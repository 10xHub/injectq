{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"InjectQ Documentation","text":"<p>InjectQ is a lightweight, type-friendly dependency injection library for Python focused on clarity, performance, and pragmatic integrations.</p>"},{"location":"#quick-example-recommended","title":"Quick example (recommended)","text":"<pre><code>from injectq import InjectQ, inject, singleton\n\ncontainer = InjectQ.get_instance()\n\n@singleton\nclass UserService:\n    def __init__(self, message: str):\n        self.message = message\n\n    def greet(self) -&gt; str:\n        return f\"Service says: {self.message}\"\n\n@inject\ndef main(service: UserService) -&gt; None:\n    print(service.greet())\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"#features-at-a-glance","title":"Features at a glance","text":"<ul> <li>Simple dict-like API and binding methods</li> <li>Decorator- and type-based injection (<code>@inject</code>, <code>Inject[T]</code>)</li> <li>Factories: dict-like factories, <code>call_factory()</code>, and \ud83c\udd95 hybrid <code>invoke()</code> / <code>ainvoke()</code> for parameterized factories</li> <li>Scopes and lifetimes: <code>@singleton</code>, <code>@transient</code>, <code>@scoped(\"request\")</code>, async scope contexts</li> <li>Modules and providers: <code>Module</code>, <code>SimpleModule</code>, <code>ProviderModule</code>, <code>@provider</code></li> <li>Integrations: FastAPI (<code>InjectFastAPI</code>) and Taskiq (<code>InjectTaskiq</code>) as optional extras</li> <li>Async-first APIs: <code>aget()</code>, <code>acall_factory()</code>, <code>ainvoke()</code></li> <li>Thread-safe by default with minimal overhead</li> <li>Diagnostics &amp; visualization: dependency graph and visualizer</li> <li>Testing utilities: <code>override_dependency</code>, <code>test_container</code>, <code>InjectQ.test_mode()</code></li> <li>Benchmarks: comprehensive reports and quick guide</li> </ul>"},{"location":"#core-patterns","title":"Core patterns","text":""},{"location":"#dict-like-interface","title":"Dict-like interface","text":"<pre><code>from injectq import InjectQ\n\ncontainer = InjectQ.get_instance()\ncontainer[str] = \"config_value\"\ncontainer[Database] = Database()\n</code></pre>"},{"location":"#functionclass-injection","title":"Function/class injection","text":"<pre><code>@inject\ndef process(service: UserService):\n    ...\n</code></pre>"},{"location":"#factory-with-parameters-hybrid","title":"Factory with parameters (hybrid)","text":"<p>Combine dependency injection with manual arguments when a factory needs both DI-managed dependencies and runtime parameters:</p> <pre><code># Factory needs both DI and custom args\ndef create_service(db: Database, cache: Cache, user_id: str):\n    return UserService(db, cache, user_id)\n\ncontainer.bind_factory(\"user_service\", create_service)\n\n# Auto-inject db and cache, provide user_id manually\nservice = container.invoke(\"user_service\", user_id=\"user123\")\n\n# Async version\nservice = await container.ainvoke(\"async_service\", batch_size=100)\n\n# You can also access and call the raw factory directly\nfactory = container.get_factory(\"user_service\")\nservice2 = factory(user_id=\"user456\")\n</code></pre>"},{"location":"#scopes-and-lifetimes","title":"Scopes and lifetimes","text":"<pre><code>from injectq import InjectQ, singleton, transient, scoped\n\ncontainer = InjectQ.get_instance()\n\n@singleton\nclass Database: ...  # One instance app-wide\n\n@transient\nclass Validator: ...  # New instance every resolution\n\n@scoped(\"request\")\nclass RequestContext: ...  # One per request scope\n\n# Working with scopes\nasync with container.scope(\"request\"):\n    ctx1 = container.get(RequestContext)\n    ctx2 = container.get(RequestContext)\n    assert ctx1 is ctx2\n\ncontainer.clear_scope(\"request\")\n</code></pre>"},{"location":"#fastapi-integration-example","title":"FastAPI integration (example)","text":"<pre><code>from typing import Annotated\nfrom fastapi import FastAPI\nfrom injectq import InjectQ, singleton\nfrom injectq.integrations.fastapi import setup_fastapi, InjectFastAPI\n\napp = FastAPI()\ncontainer = InjectQ.get_instance()\nsetup_fastapi(container, app)\n\n@singleton\nclass UserService:\n    def get_user(self, user_id: int) -&gt; dict:\n        return {\"id\": user_id}\n\n@app.get(\"/users/{user_id}\")\nasync def get_user(\n    user_id: int,\n    user_service: Annotated[UserService, InjectFastAPI(UserService)],\n):\n    return user_service.get_user(user_id)\n</code></pre>"},{"location":"#taskiq-integration-example","title":"Taskiq integration (example)","text":"<pre><code>from typing import Annotated\nfrom injectq import InjectQ\nfrom injectq.integrations.taskiq import setup_taskiq, InjectTaskiq\n\ncontainer = InjectQ.get_instance()\nsetup_taskiq(container, broker)\n\n@broker.task()\nasync def save_data(\n    data: dict,\n    service: Annotated[RankingService, InjectTaskiq(RankingService)],\n):\n    await service.save(data)\n</code></pre>"},{"location":"#modules-and-providers","title":"Modules and providers","text":"<pre><code>from injectq import InjectQ\nfrom injectq.modules import Module, SimpleModule, ProviderModule, provider\n\nclass AppModule(Module):\n    def configure(self, binder):\n        binder.bind(Config, Config())\n        binder.bind(Database, Database)\n\nclass Services(SimpleModule):\n    def __init__(self):\n        super().__init__()\n        self.bind(UserService, UserService)\n\nclass Providers(ProviderModule):\n    @provider\n    def make_notifier(self, db: Database, cfg: Config) -&gt; Notifier:\n        return Notifier(db, cfg)\n\ncontainer = InjectQ(modules=[AppModule(), Services(), Providers()])\n</code></pre>"},{"location":"#testing-utilities","title":"Testing utilities","text":"<pre><code>from injectq import InjectQ\nfrom injectq.testing import override_dependency, test_container\n\ncontainer = InjectQ.get_instance()\n\n# Temporarily override a dependency\nwith override_dependency(Database, MockDatabase()):\n    service = container.get(UserService)\n\n# Isolated test container\nwith test_container() as test_cont:\n    test_cont.bind(Database, MockDatabase)\n    ...\n</code></pre>"},{"location":"#documentation-sections","title":"Documentation sections","text":"<ul> <li>Getting started (installation &amp; quick-start)</li> <li>Injection patterns (dict-style, decorator, Inject[T])</li> <li>Scopes and lifecycle (singleton, transient, request)</li> <li>Modules and providers</li> <li>Integrations (FastAPI, Taskiq)</li> <li>Testing utilities and examples</li> <li>Performance benchmarks - Comprehensive benchmark reports and quick guide</li> <li>API reference and migration guides</li> </ul>"},{"location":"#performance","title":"Performance","text":"<p>InjectQ is designed for production use with excellent performance characteristics:</p> <ul> <li>\u26a1 Ultra-fast operations: Basic operations execute in 270-780 nanoseconds</li> <li>\ud83d\ude80 Efficient resolution: Dependency resolution in ~1 microsecond</li> <li>\ud83d\udcca Excellent scalability: Handles 1,000+ operations with sub-millisecond performance</li> <li>\ud83d\udd12 Thread-safe: Concurrent access with minimal overhead</li> <li>\ud83c\udf10 Production-ready: Web request simulation (10 services) in 142 microseconds</li> </ul> <p>See the Benchmark Report for detailed performance analysis and the Quick Guide for running benchmarks yourself. A raw, full report is also available in <code>reports/BENCHMARK_REPORT.md</code>.</p>"},{"location":"#contributing-license","title":"Contributing &amp; License","text":"<p>See <code>CONTRIBUTING.md</code> and <code>LICENSE</code> for contribution rules and licensing.</p> <p>Note: This repository maintains a test coverage floor of 73% enforced by CI and pytest configuration.</p>"},{"location":"benchmark-guide/","title":"InjectQ Performance Benchmarks - Quick Guide","text":""},{"location":"benchmark-guide/#running-benchmarks","title":"\ud83d\ude80 Running Benchmarks","text":""},{"location":"benchmark-guide/#basic-benchmark-run","title":"Basic Benchmark Run","text":"<pre><code>pytest tests/test_benchmarks.py --benchmark-only\n</code></pre>"},{"location":"benchmark-guide/#verbose-output-with-statistics","title":"Verbose Output with Statistics","text":"<pre><code>pytest tests/test_benchmarks.py --benchmark-only --benchmark-verbose\n</code></pre>"},{"location":"benchmark-guide/#save-results-for-historical-tracking","title":"Save Results for Historical Tracking","text":"<pre><code>pytest tests/test_benchmarks.py --benchmark-only --benchmark-autosave\n</code></pre>"},{"location":"benchmark-guide/#compare-two-benchmark-runs","title":"Compare Two Benchmark Runs","text":"<pre><code># Run first benchmark\npytest tests/test_benchmarks.py --benchmark-only --benchmark-autosave --benchmark-name=baseline\n\n# Make changes to code...\n\n# Run second benchmark\npytest tests/test_benchmarks.py --benchmark-only --benchmark-autosave --benchmark-name=optimized\n\n# Compare results\npytest-benchmark compare baseline optimized\n</code></pre>"},{"location":"benchmark-guide/#run-specific-benchmark","title":"Run Specific Benchmark","text":"<pre><code>pytest tests/test_benchmarks.py::test_benchmark_container_creation --benchmark-only\n</code></pre>"},{"location":"benchmark-guide/#run-regular-tests-skip-benchmarks","title":"Run Regular Tests (Skip Benchmarks)","text":"<pre><code>pytest tests/test_benchmarks.py  # Runs without detailed timing\n</code></pre>"},{"location":"benchmark-guide/#performance-summary-tldr","title":"\ud83d\udcca Performance Summary (TL;DR)","text":"Category Performance Use Case Basic Operations 270-780 ns Container lookups, bindings Dependency Resolution 1-2 \u03bcs Service instantiation Factory Functions 3-6 \u03bcs Lazy initialization Load (100 services) 779 \u03bcs Bulk registration Load (1000 gets) 739 \u03bcs High-frequency access Web Request (10 svcs) 142 \u03bcs Typical API request Thread-Safe Ops 24 \u03bcs Concurrent access <p>Verdict: \u2705 Production-ready for high-performance applications</p>"},{"location":"benchmark-guide/#benchmark-categories","title":"\ud83c\udfaf Benchmark Categories","text":""},{"location":"benchmark-guide/#1-basic-container-operations","title":"1. Basic Container Operations","text":"<ul> <li><code>test_benchmark_container_creation</code> - Creating new containers</li> <li><code>test_benchmark_bind_simple_class</code> - Binding classes</li> <li><code>test_benchmark_bind_instance</code> - Binding instances</li> <li><code>test_benchmark_bind_factory</code> - Binding factories</li> <li><code>test_benchmark_container_clear</code> - Clearing container</li> <li><code>test_benchmark_has_service</code> - Checking service existence</li> <li><code>test_benchmark_container_getitem</code> - Accessing via <code>container[Type]</code></li> </ul>"},{"location":"benchmark-guide/#2-service-retrieval","title":"2. Service Retrieval","text":"<ul> <li><code>test_benchmark_get_simple_service</code> - Basic service retrieval</li> <li><code>test_benchmark_get_singleton</code> - Singleton scope retrieval</li> <li><code>test_benchmark_get_transient</code> - Transient scope retrieval</li> </ul>"},{"location":"benchmark-guide/#3-dependency-resolution","title":"3. Dependency Resolution","text":"<ul> <li><code>test_benchmark_resolve_simple_dependency</code> - Single dependency</li> <li><code>test_benchmark_resolve_nested_dependencies</code> - 3-level nesting</li> <li><code>test_benchmark_resolve_multiple_dependencies</code> - 3 dependencies</li> <li><code>test_benchmark_resolve_deep_dependency_tree</code> - 5-level tree</li> </ul>"},{"location":"benchmark-guide/#4-factory-functions","title":"4. Factory Functions","text":"<ul> <li><code>test_benchmark_factory_simple</code> - Simple factory</li> <li><code>test_benchmark_factory_with_dependency</code> - Factory with deps</li> </ul>"},{"location":"benchmark-guide/#5-scope-performance","title":"5. Scope Performance","text":"<ul> <li><code>test_benchmark_singleton_scope_cached</code> - Cached singleton</li> <li><code>test_benchmark_transient_scope_creation</code> - New instance creation</li> <li><code>test_benchmark_request_scope</code> - Request-scoped services</li> </ul>"},{"location":"benchmark-guide/#6-load-testing","title":"6. Load Testing","text":"<ul> <li><code>test_benchmark_load_many_services</code> - 100 service registrations</li> <li><code>test_benchmark_load_repeated_gets</code> - 1,000 get operations</li> <li><code>test_benchmark_load_transient_creation</code> - 1,000 transient instances</li> <li><code>test_benchmark_load_complex_graph</code> - Complex dependency graph</li> </ul>"},{"location":"benchmark-guide/#7-thread-safety","title":"7. Thread Safety","text":"<ul> <li><code>test_benchmark_thread_safe_container</code> - Thread-safe operations</li> <li><code>test_benchmark_concurrent_gets</code> - 10 threads \u00d7 100 operations</li> </ul>"},{"location":"benchmark-guide/#8-real-world-scenarios","title":"8. Real-World Scenarios","text":"<ul> <li><code>test_benchmark_web_request_simulation</code> - Web request with 10 services</li> <li><code>test_benchmark_api_service_stack</code> - 4-layer API stack</li> <li><code>test_benchmark_override_context</code> - Context override patterns</li> </ul>"},{"location":"benchmark-guide/#9-stress-tests","title":"9. Stress Tests","text":"<ul> <li><code>test_benchmark_stress_sequential_binds</code> - 500 sequential binds</li> <li><code>test_benchmark_stress_resolution_mix</code> - 100 mixed operations</li> </ul>"},{"location":"benchmark-guide/#key-performance-metrics","title":"\ud83d\udcc8 Key Performance Metrics","text":""},{"location":"benchmark-guide/#ultra-fast-1-s","title":"Ultra-Fast (&lt; 1 \u03bcs)","text":"<pre><code>has_service:        272 ns   \u26a1 3.67M ops/sec\nbind_factory:       271 ns   \u26a1 3.68M ops/sec\nbind_instance:      784 ns   \u26a1 1.28M ops/sec\n</code></pre>"},{"location":"benchmark-guide/#fast-1-10-s","title":"Fast (1-10 \u03bcs)","text":"<pre><code>get_singleton:      1.02 \u03bcs  \u26a1 976K ops/sec\nresolve_simple:     1.05 \u03bcs  \u26a1 955K ops/sec\nresolve_nested:     1.01 \u03bcs  \u26a1 990K ops/sec\napi_service_stack:  1.06 \u03bcs  \u26a1 944K ops/sec\n</code></pre>"},{"location":"benchmark-guide/#moderate-10-100-s","title":"Moderate (10-100 \u03bcs)","text":"<pre><code>container_creation: 24.3 \u03bcs  \u26a1 41.2K ops/sec\nthread_safe_ops:    24.7 \u03bcs  \u26a1 40.5K ops/sec\n</code></pre>"},{"location":"benchmark-guide/#load-operations-100-s","title":"Load Operations (100+ \u03bcs)","text":"<pre><code>web_request (10):    142 \u03bcs  \u26a1 7,037 ops/sec\n100 services:        779 \u03bcs  \u26a1 1,283 ops/sec\n1000 gets:           739 \u03bcs  \u26a1 1,352 ops/sec\n1000 transients:    24.8 ms  \u26a1 40 ops/sec\n</code></pre>"},{"location":"benchmark-guide/#understanding-the-results","title":"\ud83d\udd2c Understanding the Results","text":""},{"location":"benchmark-guide/#time-units","title":"Time Units","text":"<ul> <li>ns (nanosecond) = 0.000001 milliseconds</li> <li>\u03bcs (microsecond) = 0.001 milliseconds  </li> <li>ms (millisecond) = 0.001 seconds</li> </ul>"},{"location":"benchmark-guide/#operations-per-second-ops","title":"Operations Per Second (OPS)","text":"<ul> <li>Higher is better</li> <li>Calculated as <code>1 / mean_time</code></li> <li>Shows throughput capacity</li> </ul>"},{"location":"benchmark-guide/#outliers","title":"Outliers","text":"<ul> <li>1.5 IQR: Moderate outliers (expected)</li> <li>1 StdDev: Significant outliers (investigate if many)</li> </ul>"},{"location":"benchmark-guide/#comparison-operators","title":"Comparison Operators","text":"<ul> <li>(1.0) = Baseline (fastest test)</li> <li>(2.5) = 2.5\u00d7 slower than baseline</li> <li>(&gt;1000.0) = More than 1000\u00d7 slower</li> </ul>"},{"location":"benchmark-guide/#performance-tips","title":"\ud83d\udca1 Performance Tips","text":""},{"location":"benchmark-guide/#do","title":"\u2705 DO","text":"<ul> <li>Use singleton scope for shared services (1 \u03bcs cached)</li> <li>Use factory bindings for lazy init (271 ns)</li> <li>Batch service registrations at startup (779 \u03bcs for 100)</li> <li>Check with has_service before complex ops (272 ns)</li> </ul>"},{"location":"benchmark-guide/#consider","title":"\u26a0\ufe0f CONSIDER","text":"<ul> <li>Transient scope adds overhead (4.7 \u03bcs vs 1 \u03bcs)</li> <li>Thread-safe container is 24\u00d7 slower (still fast at 24.7 \u03bcs)</li> <li>Deep dependency trees perform well (1 \u03bcs for 5 levels)</li> </ul>"},{"location":"benchmark-guide/#avoid","title":"\u274c AVOID","text":"<ul> <li>Creating containers in hot paths (24.3 \u03bcs each)</li> <li>Overusing transient scope for shared services</li> <li>Unnecessary thread-safe containers (use only when needed)</li> </ul>"},{"location":"benchmark-guide/#visualizing-results","title":"\ud83c\udfa8 Visualizing Results","text":""},{"location":"benchmark-guide/#generate-histogram-requires-optional-dependency","title":"Generate Histogram (requires optional dependency)","text":"<pre><code>pip install pytest-benchmark[histogram]\npytest tests/test_benchmarks.py --benchmark-only --benchmark-histogram\n</code></pre>"},{"location":"benchmark-guide/#compare-runs-with-charts","title":"Compare Runs with Charts","text":"<pre><code>pytest-benchmark compare 0001 0002 --histogram\n</code></pre>"},{"location":"benchmark-guide/#view-saved-results","title":"View Saved Results","text":"<pre><code>ls -la .benchmarks/Darwin-CPython-3.13-64bit/\ncat .benchmarks/Darwin-CPython-3.13-64bit/0001_*.json | jq\n</code></pre>"},{"location":"benchmark-guide/#output-files","title":"\ud83d\udcc1 Output Files","text":""},{"location":"benchmark-guide/#benchmark-data","title":"Benchmark Data","text":"<ul> <li>Location: <code>.benchmarks/Darwin-CPython-3.13-64bit/</code></li> <li>Format: JSON with full statistics</li> <li>Naming: <code>XXXX_&lt;commit_hash&gt;_&lt;timestamp&gt;.json</code></li> </ul>"},{"location":"benchmark-guide/#reports","title":"Reports","text":"<ul> <li>BENCHMARK_REPORT.md - Comprehensive analysis</li> <li>BENCHMARK_QUICK_GUIDE.md - This file</li> <li>benchmark_results.json - Latest run results</li> </ul>"},{"location":"benchmark-guide/#testing-your-changes","title":"\ud83e\uddea Testing Your Changes","text":""},{"location":"benchmark-guide/#before-optimization","title":"Before Optimization","text":"<pre><code>pytest tests/test_benchmarks.py --benchmark-only --benchmark-autosave --benchmark-name=before\n</code></pre>"},{"location":"benchmark-guide/#after-optimization","title":"After Optimization","text":"<pre><code>pytest tests/test_benchmarks.py --benchmark-only --benchmark-autosave --benchmark-name=after\n</code></pre>"},{"location":"benchmark-guide/#compare-results","title":"Compare Results","text":"<pre><code>pytest-benchmark compare before after\n</code></pre> <p>Look for: - \u2705 Green = Faster (good!) - \u274c Red = Slower (regression) - Percentage change = Performance delta</p>"},{"location":"benchmark-guide/#cicd-integration","title":"\ud83c\udfaf CI/CD Integration","text":""},{"location":"benchmark-guide/#fail-on-regression","title":"Fail on Regression","text":"<pre><code>pytest tests/test_benchmarks.py --benchmark-only --benchmark-compare=0001 --benchmark-compare-fail=mean:10%\n</code></pre>"},{"location":"benchmark-guide/#save-baseline","title":"Save Baseline","text":"<pre><code>pytest tests/test_benchmarks.py --benchmark-only --benchmark-autosave --benchmark-save=baseline\n</code></pre>"},{"location":"benchmark-guide/#check-against-baseline","title":"Check Against Baseline","text":"<pre><code>pytest tests/test_benchmarks.py --benchmark-only --benchmark-compare=baseline\n</code></pre>"},{"location":"benchmark-guide/#troubleshooting","title":"\ud83d\udc1b Troubleshooting","text":""},{"location":"benchmark-guide/#benchmark-takes-too-long","title":"Benchmark Takes Too Long","text":"<pre><code># Reduce max time per benchmark\npytest tests/test_benchmarks.py --benchmark-only --benchmark-max-time=0.1\n</code></pre>"},{"location":"benchmark-guide/#high-variance-in-results","title":"High Variance in Results","text":"<pre><code># Increase rounds for stability\npytest tests/test_benchmarks.py --benchmark-only --benchmark-min-rounds=100\n</code></pre>"},{"location":"benchmark-guide/#skip-slow-benchmarks","title":"Skip Slow Benchmarks","text":"<pre><code># Skip load tests\npytest tests/test_benchmarks.py --benchmark-only -k \"not load\"\n</code></pre>"},{"location":"benchmark-guide/#resources","title":"\ud83d\udcda Resources","text":"<ul> <li>Full Report: See <code>BENCHMARK_REPORT.md</code></li> <li>Test Code: <code>tests/test_benchmarks.py</code></li> <li>pytest-benchmark docs: https://pytest-benchmark.readthedocs.io/</li> <li>InjectQ docs: See <code>docs/</code> directory</li> </ul> <p>Quick Stats: 30 benchmarks | ~56s runtime | All passing \u2705</p>"},{"location":"benchmark-report/","title":"InjectQ Performance Benchmark Report","text":"<p>Generated: October 28, 2024 Python Version: 3.13.5 Platform: macOS (Darwin) Benchmark Tool: pytest-benchmark 5.1.0</p>"},{"location":"benchmark-report/#executive-summary","title":"Executive Summary","text":"<p>This report presents comprehensive performance benchmarks for the InjectQ dependency injection library, covering basic operations, dependency resolution, factory functions, scoping mechanisms, load testing, thread safety, and real-world scenarios.</p>"},{"location":"benchmark-report/#key-findings","title":"Key Findings","text":"<p>\u2705 Ultra-Fast Core Operations: Basic container operations (bind, get, has) execute in ~270-780 nanoseconds \u2705 Efficient Dependency Resolution: Simple to complex dependency graphs resolve in 1-25 microseconds \u2705 Excellent Scalability: Handles 1,000+ service instances efficiently \u2705 Thread-Safe: Concurrent operations maintain performance with minimal overhead \u2705 Production-Ready: Real-world scenarios (web requests, API stacks) perform exceptionally well</p>"},{"location":"benchmark-report/#performance-categories","title":"Performance Categories","text":""},{"location":"benchmark-report/#1-ultra-fast-operations-1-microsecond","title":"1. Ultra-Fast Operations (&lt; 1 microsecond)","text":"<p>These operations execute in nanoseconds, making them virtually zero-overhead:</p> Operation Mean Time Operations/Second Description <code>has_service</code> 272.2 ns 3.67 million Check if service is registered <code>bind_factory</code> 271.4 ns 3.68 million Register a factory function <code>bind_instance</code> 784.2 ns 1.28 million Register a singleton instance <p>Analysis: Container lookups and basic registrations are nearly instant, with negligible overhead. Perfect for high-frequency operations.</p>"},{"location":"benchmark-report/#2-fast-operations-1-10-microseconds","title":"2. Fast Operations (1-10 microseconds)","text":"<p>Core container operations that execute in microseconds:</p> Operation Mean Time Operations/Second Description <code>bind_simple_class</code> 924.1 ns 1.08 million Register a class binding <code>get_simple_service</code> 1.02 \u03bcs 977k Retrieve a simple service <code>get_singleton</code> 1.02 \u03bcs 976k Retrieve cached singleton <code>resolve_simple_dependency</code> 1.05 \u03bcs 955k Resolve single dependency <code>singleton_scope_cached</code> 1.02 \u03bcs 976k Get cached singleton scope <code>api_service_stack</code> 1.06 \u03bcs 944k Resolve API service stack <code>resolve_deep_dependency_tree</code> 1.01 \u03bcs 990k Resolve deep (5-level) tree <code>resolve_multiple_dependencies</code> 1.00 \u03bcs 1.00 million Resolve service with 3 deps <code>resolve_nested_dependencies</code> 1.01 \u03bcs 990k Resolve nested (3-level) deps <code>container_getitem</code> 1.29 \u03bcs 773k Access via <code>container[Type]</code> <p>Analysis: Dependency resolution is extremely efficient. Even deep dependency trees resolve in ~1 microsecond, demonstrating excellent optimization.</p>"},{"location":"benchmark-report/#3-moderate-operations-10-100-microseconds","title":"3. Moderate Operations (10-100 microseconds)","text":"<p>Operations with slightly more complexity:</p> Operation Mean Time Operations/Second Description <code>container_clear</code> 2.60 \u03bcs 385k Clear container state <code>request_scope</code> 2.85 \u03bcs 351k Request scope resolution <code>factory_simple</code> 3.71 \u03bcs 270k Simple factory invocation <code>override_context</code> 4.16 \u03bcs 240k Override context resolution <code>transient_scope_creation</code> 4.71 \u03bcs 212k Create transient instance <code>factory_with_dependency</code> 6.22 \u03bcs 161k Factory with dependencies <code>thread_safe_container</code> 24.7 \u03bcs 40.5k Thread-safe container ops <code>container_creation</code> 24.3 \u03bcs 41.2k Create new container <code>get_transient</code> 27.2 \u03bcs 36.8k Get transient instance <p>Analysis: Factory invocations and transient scope creations involve actual object instantiation, explaining the slightly higher times. Still exceptionally fast for production use.</p>"},{"location":"benchmark-report/#4-load-testing-100-operations","title":"4. Load Testing (100+ operations)","text":"<p>Performance under load conditions:</p> Test Mean Time Operations/Second Load Size <code>web_request_simulation</code> 142.1 \u03bcs 7,037 10 services per request <code>load_complex_graph</code> 178.6 \u03bcs 5,598 Complex dependency graph <code>load_many_services</code> 779.3 \u03bcs 1,283 100 services <code>load_repeated_gets</code> 739.5 \u03bcs 1,352 1,000 get operations <code>concurrent_gets</code> 884.4 \u03bcs 1,131 10 threads, 100 ops each <code>stress_resolution_mix</code> 849.0 \u03bcs 1,178 100 mixed operations <code>stress_sequential_binds</code> 1.96 ms 509 500 sequential binds <code>load_transient_creation</code> 24.8 ms 40 1,000 transient instances <p>Analysis:  - \u2705 Can handle 1,000 get operations in under 1 millisecond - \u2705 Web request simulation (realistic scenario) completes in 142 microseconds - \u2705 Creating 100 services takes only 779 microseconds - \u26a0\ufe0f Creating 1,000 transient instances takes 24.8ms (expected, each requires object instantiation)</p>"},{"location":"benchmark-report/#detailed-performance-analysis","title":"Detailed Performance Analysis","text":""},{"location":"benchmark-report/#container-lifecycle","title":"Container Lifecycle","text":"<pre><code>Container Creation:    24.3 \u03bcs  (41,192 ops/sec)\nContainer Clear:        2.6 \u03bcs  (384,784 ops/sec)\nContainer GetItem:      1.3 \u03bcs  (772,729 ops/sec)\n</code></pre> <p>Insight: Container creation is very fast. Clearing is even faster, making it ideal for test isolation.</p>"},{"location":"benchmark-report/#binding-performance","title":"Binding Performance","text":"<pre><code>Bind Instance:     784 ns  (1.28M ops/sec)\nBind Class:        924 ns  (1.08M ops/sec)\nBind Factory:      271 ns  (3.68M ops/sec)\n</code></pre> <p>Insight: Factory bindings are fastest (just storing function references), while instance bindings are still sub-microsecond.</p>"},{"location":"benchmark-report/#retrieval-performance","title":"Retrieval Performance","text":"<pre><code>Has Service:       272 ns  (3.67M ops/sec)\nGet Singleton:    1.02 \u03bcs  (976K ops/sec)\nGet Transient:    27.2 \u03bcs  (36.8K ops/sec)\nGet Simple:       1.02 \u03bcs  (977K ops/sec)\n</code></pre> <p>Insight: Singleton retrieval benefits from caching. Transient creation is slower due to instantiation overhead.</p>"},{"location":"benchmark-report/#dependency-resolution","title":"Dependency Resolution","text":"<pre><code>Simple (1 dep):        1.05 \u03bcs  (955K ops/sec)\nNested (3 levels):     1.01 \u03bcs  (990K ops/sec)\nMultiple (3 deps):     1.00 \u03bcs  (1.00M ops/sec)\nDeep Tree (5 levels):  1.01 \u03bcs  (990K ops/sec)\n</code></pre> <p>Insight: Resolution time is remarkably consistent regardless of dependency complexity. Excellent graph traversal optimization.</p>"},{"location":"benchmark-report/#scope-performance-comparison","title":"Scope Performance Comparison","text":"Scope Type Mean Time Operations/Second Notes Singleton (cached) 1.02 \u03bcs 976K Fastest - retrieves from cache Transient 4.71 \u03bcs 212K Creates new instance each time Request 2.85 \u03bcs 351K Scoped to request context <p>Insight: Singleton scope offers best performance for shared services. Transient scope is still very fast for most use cases.</p>"},{"location":"benchmark-report/#thread-safety","title":"Thread Safety","text":"<pre><code>Single-threaded:       1.02 \u03bcs  (976K ops/sec)\nThread-safe:          24.7 \u03bcs  (40.5K ops/sec)\nConcurrent (10x100): 884.4 \u03bcs  (1,131 ops/sec)\n</code></pre> <p>Insight: Thread-safe container adds ~24x overhead for locking, but still delivers 40,500+ operations/second. Concurrent access from 10 threads maintains excellent throughput.</p>"},{"location":"benchmark-report/#real-world-scenarios","title":"Real-World Scenarios","text":""},{"location":"benchmark-report/#web-request-simulation-10-services","title":"Web Request Simulation (10 services)","text":"<p><pre><code>Mean:     142.1 \u03bcs\nMin:      93.5 \u03bcs\nMax:      8.5 ms\nOps/sec:  7,037\n</code></pre> Analysis: Typical web request resolving 10 services completes in 142 microseconds. Even worst case (8.5ms) is negligible.</p>"},{"location":"benchmark-report/#api-service-stack-4-layers","title":"API Service Stack (4 layers)","text":"<p><pre><code>Mean:     1.06 \u03bcs\nOps/sec:  944,257\n</code></pre> Analysis: Resolving a 4-layer API stack (controller \u2192 service \u2192 repository \u2192 cache) takes just 1 microsecond.</p>"},{"location":"benchmark-report/#load-testing-results","title":"Load Testing Results","text":""},{"location":"benchmark-report/#scenario-1-high-volume-service-registration-100-services","title":"Scenario 1: High-Volume Service Registration (100 services)","text":"<ul> <li>Time: 779 microseconds</li> <li>Throughput: 1,283 operations/second</li> <li>Result: \u2705 Excellent performance for dynamic service registration</li> </ul>"},{"location":"benchmark-report/#scenario-2-repeated-access-pattern-1000-gets","title":"Scenario 2: Repeated Access Pattern (1,000 gets)","text":"<ul> <li>Time: 739 microseconds</li> <li>Per-operation: 739 nanoseconds</li> <li>Result: \u2705 Sub-microsecond average per operation under heavy load</li> </ul>"},{"location":"benchmark-report/#scenario-3-concurrent-access-10-threads-100-operations","title":"Scenario 3: Concurrent Access (10 threads \u00d7 100 operations)","text":"<ul> <li>Time: 884 microseconds</li> <li>Result: \u2705 Handles 1,000 concurrent operations in under 1 millisecond</li> </ul>"},{"location":"benchmark-report/#scenario-4-stress-test-mixed-operations-100-operations","title":"Scenario 4: Stress Test - Mixed Operations (100 operations)","text":"<ul> <li>Time: 849 microseconds</li> <li>Mix: Bind + resolve + clear</li> <li>Result: \u2705 Consistent performance under mixed workload</li> </ul>"},{"location":"benchmark-report/#scenario-5-extreme-load-sequential-binds-500-binds","title":"Scenario 5: Extreme Load - Sequential Binds (500 binds)","text":"<ul> <li>Time: 1.96 milliseconds</li> <li>Per-bind: 3.92 microseconds</li> <li>Result: \u2705 Linear scaling maintained</li> </ul>"},{"location":"benchmark-report/#scenario-6-mass-instantiation-1000-transient-objects","title":"Scenario 6: Mass Instantiation (1,000 transient objects)","text":"<ul> <li>Time: 24.8 milliseconds</li> <li>Per-object: 24.8 microseconds</li> <li>Result: \u2705 Reasonable for bulk object creation</li> </ul>"},{"location":"benchmark-report/#performance-recommendations","title":"Performance Recommendations","text":""},{"location":"benchmark-report/#best-practices","title":"\u2705 Best Practices","text":"<ol> <li>Use Singleton Scope for Shared Services</li> <li>1.02 \u03bcs retrieval time (cached)</li> <li> <p>Ideal for database connections, API clients, configuration</p> </li> <li> <p>Leverage Factory Functions</p> </li> <li>271 ns binding time</li> <li> <p>Perfect for lazy initialization patterns</p> </li> <li> <p>Batch Service Registration</p> </li> <li>100 services in 779 \u03bcs</li> <li> <p>Register all services at startup for optimal performance</p> </li> <li> <p>Cache Container Lookups</p> </li> <li><code>has_service</code> check is only 272 ns</li> <li> <p>Use early checks to avoid unnecessary resolution</p> </li> <li> <p>Use Request Scope for Web Applications</p> </li> <li>2.85 \u03bcs resolution</li> <li>Balance between singleton and transient</li> </ol>"},{"location":"benchmark-report/#performance-considerations","title":"\u26a0\ufe0f Performance Considerations","text":"<ol> <li>Minimize Transient Scope Overuse</li> <li>4.71 \u03bcs per creation (vs 1.02 \u03bcs for singleton)</li> <li> <p>Use only when instance isolation is required</p> </li> <li> <p>Thread-Safe Container Overhead</p> </li> <li>24x slower than single-threaded (still fast at 24.7 \u03bcs)</li> <li> <p>Use only when concurrent access is needed</p> </li> <li> <p>Deep Dependency Trees</p> </li> <li>Still fast at 1.01 \u03bcs for 5-level trees</li> <li>No significant performance penalty</li> </ol>"},{"location":"benchmark-report/#comparison-with-manual-di","title":"Comparison with Manual DI","text":"<pre><code># Manual DI\ntime_per_instantiation = ~50-100 ns (raw Python)\n\n# InjectQ DI\ntime_per_resolution = ~1,000 ns (1 \u03bcs)\n\n# Overhead = ~10x raw instantiation\n# Trade-off: Automatic dependency management, scoping, lifecycle\n</code></pre> <p>Verdict: The 10x overhead is negligible (&lt; 1 microsecond) and provides massive developer productivity gains through automatic dependency injection, scope management, and cleaner code architecture.</p>"},{"location":"benchmark-report/#benchmarking-methodology","title":"Benchmarking Methodology","text":""},{"location":"benchmark-report/#test-environment","title":"Test Environment","text":"<ul> <li>CPU: Apple Silicon (M-series)</li> <li>Python: 3.13.5</li> <li>Timer: <code>time.perf_counter</code> (41 ns precision)</li> <li>Warm-up: Enabled (100,000 iterations)</li> <li>Min Rounds: 5</li> <li>Max Time: 1 second per benchmark</li> </ul>"},{"location":"benchmark-report/#statistical-metrics","title":"Statistical Metrics","text":"<ul> <li>Min/Max: Range of execution times</li> <li>Mean: Average execution time</li> <li>Median: 50<sup>th</sup> percentile</li> <li>IQR: Interquartile range (25<sup>th</sup>-75<sup>th</sup> percentile)</li> <li>StdDev: Standard deviation</li> <li>Outliers: Values &gt; 1.5 IQR from quartiles</li> </ul>"},{"location":"benchmark-report/#benchmark-categories","title":"Benchmark Categories","text":"<ol> <li>Basic Operations: Container creation, binding, retrieval</li> <li>Dependency Resolution: Simple to complex dependency graphs</li> <li>Factory Functions: Simple and parameterized factories</li> <li>Scope Management: Singleton, transient, request scopes</li> <li>Load Testing: 100-1,000 operation batches</li> <li>Thread Safety: Concurrent access patterns</li> <li>Real-World Scenarios: Web requests, API stacks</li> <li>Stress Testing: Sequential binds, mixed operations</li> </ol>"},{"location":"benchmark-report/#conclusion","title":"Conclusion","text":"<p>InjectQ demonstrates exceptional performance across all tested scenarios:</p> <p>\u2705 Sub-microsecond operations for core functionality \u2705 Linear scaling under load (1,000+ operations) \u2705 Thread-safe with acceptable overhead \u2705 Production-ready for high-performance applications \u2705 Negligible overhead compared to manual dependency injection  </p> <p>The library is suitable for:</p> <ul> <li>High-traffic web applications (sub-millisecond request handling)</li> <li>Microservices (efficient service resolution)</li> <li>Real-time systems (predictable sub-microsecond latency)</li> <li>CLI applications (instant startup)</li> <li>Testing frameworks (fast container creation/cleanup)</li> </ul>"},{"location":"benchmark-report/#appendix-raw-benchmark-data","title":"Appendix: Raw Benchmark Data","text":"<p>All benchmark data is saved in: - JSON: <code>.benchmarks/Darwin-CPython-3.13-64bit/</code> - Compare: Use <code>pytest-benchmark compare</code> for historical tracking</p>"},{"location":"benchmark-report/#running-benchmarks-yourself","title":"Running Benchmarks Yourself","text":"<pre><code># Run all benchmarks\npytest tests/test_benchmarks.py --benchmark-only\n\n# Run with verbose output\npytest tests/test_benchmarks.py --benchmark-only --benchmark-verbose\n\n# Save results for comparison\npytest tests/test_benchmarks.py --benchmark-only --benchmark-autosave\n\n# Compare with previous runs\npytest-benchmark compare 0001 0002\n</code></pre>"},{"location":"benchmark-report/#generating-html-reports","title":"Generating HTML Reports","text":"<pre><code># Install optional dependencies\npip install pytest-benchmark[histogram]\n\n# Generate histogram\npytest tests/test_benchmarks.py --benchmark-only --benchmark-histogram\n\n# Generate comparison charts\npytest-benchmark compare --histogram\n</code></pre> <p>Report Version: 1.0 Benchmark Suite: test_benchmarks.py (30 tests) Total Runtime: ~56 seconds Test Status: \u2705 All 30 benchmarks passed</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to InjectQ are documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#040-unreleased","title":"[0.4.0] - Unreleased","text":"<p>\ud83c\udfaf Focus: Enhanced factory methods, improved type safety, and better async support.</p>"},{"location":"changelog/#added","title":"Added","text":""},{"location":"changelog/#factory-enhancements","title":"Factory Enhancements","text":"<ul> <li>Hybrid factory methods: <code>invoke()</code> and <code>ainvoke()</code> combine dependency injection with manual arguments   <pre><code># Inject dependencies, provide custom args\nservice = container.invoke(UserService, user_id=123)\nresult = await container.ainvoke(AsyncService, data=\"custom\")\n</code></pre></li> <li>Async factory methods: <code>aget_factory()</code> and <code>acall_factory()</code> for async operations</li> <li>Smart parameter resolution: by name first, then by type (non-primitives only)</li> </ul>"},{"location":"changelog/#registration-control","title":"Registration Control","text":"<ul> <li>Auto-registration: <code>allow_concrete=True</code> (default) automatically registers concrete types   <pre><code>container.bind_instance(Animal, dog)  # Both Animal and Dog are now resolvable\n</code></pre></li> <li>Override control: <code>allow_override=True</code> (default) controls registration overwrites</li> <li>New <code>AlreadyRegisteredError</code> exception for conflict detection</li> <li>Enhanced <code>bind()</code>, <code>bind_instance()</code>, and <code>bind_factory()</code> methods</li> </ul>"},{"location":"changelog/#framework-tools","title":"Framework &amp; Tools","text":"<ul> <li>Comprehensive documentation with MkDocs</li> <li>Plugin system for extensibility</li> <li>Advanced middleware support</li> <li>Resource management utilities</li> <li>Performance profiling tools</li> <li>Diagnostic and validation utilities</li> <li>Migration guides from other DI libraries</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Breaking: All binding methods now accept <code>allow_concrete</code> parameter</li> <li>Improved subclass injection - both base and concrete types are resolvable</li> <li>Enhanced type safety and mypy compliance</li> <li>Better error messages with detailed debugging info</li> <li>Optimized dependency graph resolution</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Subclass injection issues with concrete type resolution</li> <li>Various stability improvements</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>Complete API reference</li> <li>Framework integration guides (FastAPI, Taskiq)</li> <li>Testing best practices</li> <li>Performance optimization guide</li> <li>Migration guides</li> </ul>"},{"location":"changelog/#033-2024-12-15","title":"[0.3.3] - 2024-12-15","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Async scope support with <code>async with container.scope()</code></li> <li>Enhanced testing utilities</li> <li>Performance benchmarks</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Memory leaks in scoped services</li> <li>Thread safety issues in async contexts</li> </ul>"},{"location":"changelog/#030-2024-11-01","title":"[0.3.0] - 2024-11-01","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Custom scope support</li> <li>Module system with <code>@provider</code> decorator</li> <li>FastAPI integration with <code>InjectFastAPI</code></li> <li>Taskiq integration with <code>InjectTaskiq</code></li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Improved container API</li> <li>Better error messages</li> </ul>"},{"location":"changelog/#020-2024-09-15","title":"[0.2.0] - 2024-09-15","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Scoped services with <code>@scoped</code> decorator</li> <li>Resource management with <code>@resource</code></li> <li>Testing utilities: <code>test_container()</code>, <code>override_dependency()</code></li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Enhanced type resolution</li> <li>Performance improvements</li> </ul>"},{"location":"changelog/#010-2024-01-15","title":"[0.1.0] - 2024-01-15","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Initial stable release</li> <li>Core dependency injection with <code>InjectQ</code> container</li> <li>Service scopes: <code>@singleton</code>, <code>@transient</code></li> <li><code>@inject</code> decorator for automatic injection</li> <li>Dict-like container interface</li> <li>Type safety with mypy support</li> <li>Thread-safe operations</li> <li>Basic testing utilities</li> </ul>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Automatic dependency resolution</li> <li>Circular dependency detection</li> <li>Lifecycle hooks</li> <li>Comprehensive documentation</li> </ul>"},{"location":"changelog/#release-notes","title":"Release Notes","text":""},{"location":"changelog/#version-040-upcoming","title":"Version 0.4.0 (Upcoming)","text":"<p>InjectQ 0.4.0 introduces powerful factory enhancements and improved control over service registration.</p>"},{"location":"changelog/#key-highlights","title":"\ud83d\ude80 Key Highlights","text":"<p>Hybrid Factories: Combine DI with manual arguments <pre><code># Auto-inject Database, provide custom user_id\nservice = container.invoke(UserService, user_id=123)\n</code></pre></p> <p>Async Support: Full async factory operations <pre><code>result = await container.ainvoke(AsyncService, data=\"custom\")\n</code></pre></p> <p>Smart Registration: Automatic concrete type registration <pre><code>container.bind_instance(Animal, dog)\n# Both Animal and Dog are now available\n</code></pre></p> <p>Better Control: Prevent accidental overwrites <pre><code>container = InjectQ(allow_override=False)\ncontainer.bind(Service, impl1)\ncontainer.bind(Service, impl2)  # Raises AlreadyRegisteredError\n</code></pre></p>"},{"location":"changelog/#whats-included","title":"\ud83d\udce6 What's Included","text":"<ul> <li>23 new tests for factory methods (all passing)</li> <li>Comprehensive documentation updates</li> <li>Performance optimizations</li> <li>Enhanced error messages</li> <li>Migration guides from other DI libraries</li> </ul>"},{"location":"changelog/#breaking-changes","title":"\u26a0\ufe0f Breaking Changes","text":"<ul> <li>All binding methods now accept <code>allow_concrete</code> parameter (default: <code>True</code>)</li> <li>InjectQ constructor now accepts <code>allow_override</code> parameter (default: <code>True</code>)</li> </ul>"},{"location":"changelog/#documentation_1","title":"\ud83d\udcda Documentation","text":"<ul> <li>Complete API reference at docs.injectq.dev</li> <li>Factory Methods Guide</li> <li>Migration Guide</li> <li>Testing Guide</li> </ul>"},{"location":"changelog/#upgrade-guide","title":"Upgrade Guide","text":""},{"location":"changelog/#from-03x-to-040","title":"From 0.3.x to 0.4.0","text":"<p>No changes required for most users. The new features are backward compatible.</p> <p>Optional upgrades: <pre><code># Use hybrid factories for cleaner code\n# Before:\nservice = UserService(db=container[Database], user_id=123)\n\n# After:\nservice = container.invoke(UserService, user_id=123)\n</code></pre></p> <p>If you need strict registration: <pre><code># Prevent accidental overwrites\ncontainer = InjectQ(allow_override=False)\n</code></pre></p>"},{"location":"changelog/#contributing","title":"Contributing","text":"<p>We welcome contributions! See CONTRIBUTING.md for details.</p>"},{"location":"changelog/#reporting-issues","title":"Reporting Issues","text":"<ul> <li>Bug Reports: GitHub Issues</li> <li>Feature Requests: GitHub Discussions</li> </ul>"},{"location":"changelog/#development","title":"Development","text":"<pre><code># Clone repository\ngit clone https://github.com/Iamsdt/injectq.git\ncd injectq\n\n# Install dependencies\npip install -e \".[dev]\"\n\n# Run tests\npytest\n\n# Run type checking\nmypy injectq\n</code></pre>"},{"location":"changelog/#support","title":"Support","text":"<ul> <li>\ud83d\udcd6 Documentation: iamsdt.github.io/injectq</li> <li>\ud83d\udcac Discussions: GitHub Discussions</li> <li>\ud83d\udc1b Issues: GitHub Issues</li> <li>\ud83d\udca1 Examples: examples/</li> </ul>"},{"location":"changelog/#license","title":"License","text":"<p>MIT License - see LICENSE for details.</p>"},{"location":"changelog/#acknowledgments","title":"Acknowledgments","text":"<p>Thanks to all contributors who helped make InjectQ better: - Core development team - Community contributors - Beta testers and early adopters - Documentation reviewers</p> <p>Special thanks to everyone who provided feedback and feature requests!</p>"},{"location":"contributing/","title":"Contributing to InjectQ","text":"<p>Thank you for your interest in contributing to InjectQ! This document provides guidelines and information for contributors.</p>"},{"location":"contributing/#how-to-contribute","title":"\ud83e\udd1d How to Contribute","text":"<p>There are many ways to contribute to InjectQ:</p> <ul> <li>Bug Reports: Report bugs and issues</li> <li>Feature Requests: Suggest new features and improvements</li> <li>Documentation: Improve documentation and examples</li> <li>Code: Submit bug fixes and new features</li> <li>Testing: Add tests and improve test coverage</li> <li>Reviews: Review pull requests and provide feedback</li> </ul>"},{"location":"contributing/#reporting-issues","title":"\ud83d\udc1b Reporting Issues","text":"<p>When reporting issues, please include:</p> <ol> <li>Clear Description: Describe the issue clearly</li> <li>Reproduction Steps: Provide minimal code to reproduce the issue</li> <li>Expected Behavior: What you expected to happen</li> <li>Actual Behavior: What actually happened</li> <li>Environment: Python version, InjectQ version, OS, etc.</li> </ol>"},{"location":"contributing/#issue-template","title":"Issue Template","text":"<pre><code>## Description\nBrief description of the issue\n\n## Reproduction\n```python\n# Minimal code to reproduce the issue\n</code></pre>"},{"location":"contributing/#expected-behavior","title":"Expected Behavior","text":"<p>What should happen</p>"},{"location":"contributing/#actual-behavior","title":"Actual Behavior","text":"<p>What actually happens</p>"},{"location":"contributing/#environment","title":"Environment","text":"<ul> <li>Python version: </li> <li>InjectQ version: </li> <li>Operating System:  <pre><code>## \ud83d\ude80 Setting Up Development Environment\n\n### Prerequisites\n\n- Python 3.8 or higher\n- uv (recommended) or pip\n- Git\n\n### Setup Steps\n\n1. **Fork and Clone**\n   ```bash\n   git clone https://github.com/yourusername/injectq.git\n   cd injectq\n   ```\n\n2. **Install Dependencies**\n   ```bash\n   # Using uv (recommended)\n   uv sync --dev\n\n   # Or using pip\n   pip install -e .[dev]\n   ```\n\n3. **Install Pre-commit Hooks**\n   ```bash\n   pre-commit install\n   ```\n\n4. **Run Tests**\n   ```bash\n   # Run all tests\n   pytest\n\n   # Run with coverage\n   pytest --cov=injectq\n\n   # Run specific test file\n   pytest tests/test_container.py\n   ```\n\n5. **Run Linting**\n   ```bash\n   # Run all checks\n   ruff check .\n\n   # Auto-fix issues\n   ruff check . --fix\n\n   # Format code\n   ruff format .\n   ```\n\n## \ud83c\udfd7\ufe0f Development Workflow\n\n### Branch Strategy\n\n- `main`: Stable release branch\n- `develop`: Development branch\n- `feature/*`: Feature branches\n- `bugfix/*`: Bug fix branches\n- `hotfix/*`: Critical hotfix branches\n\n### Workflow Steps\n\n1. **Create Feature Branch**\n   ```bash\n   git checkout -b feature/your-feature-name\n   ```\n\n2. **Make Changes**\n   - Write code following our style guidelines\n   - Add tests for new functionality\n   - Update documentation if needed\n\n3. **Run Tests**\n   ```bash\n   pytest\n   ruff check .\n   mypy injectq\n   ```\n\n4. **Commit Changes**\n   ```bash\n   git add .\n   git commit -m \"feat: add your feature description\"\n   ```\n\n5. **Push and Create PR**\n   ```bash\n   git push origin feature/your-feature-name\n   ```\n\n## \ud83d\udcdd Code Style Guidelines\n\n### Python Code Style\n\nWe use [Ruff](https://docs.astral.sh/ruff/) for linting and formatting:\n\n- **Line Length**: 88 characters\n- **Import Sorting**: isort-compatible\n- **Formatting**: Black-compatible\n- **Type Hints**: Required for all public APIs\n\n### Docstring Style\n\nWe use Google-style docstrings:\n\n```python\ndef example_function(param1: str, param2: int) -&gt; bool:\n    \"\"\"Example function with proper docstring.\n\n    Args:\n        param1: Description of param1\n        param2: Description of param2\n\n    Returns:\n        Description of return value\n\n    Raises:\n        ValueError: When param1 is empty\n\n    Example:\n        &gt;&gt;&gt; example_function(\"test\", 42)\n        True\n    \"\"\"\n    if not param1:\n        raise ValueError(\"param1 cannot be empty\")\n    return len(param1) == param2\n</code></pre></li> </ul>"},{"location":"contributing/#commit-message-format","title":"Commit Message Format","text":"<p>We follow Conventional Commits:</p> <pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n</code></pre> <p>Types: - <code>feat</code>: New feature - <code>fix</code>: Bug fix - <code>docs</code>: Documentation changes - <code>style</code>: Code style changes - <code>refactor</code>: Code refactoring - <code>test</code>: Adding or fixing tests - <code>chore</code>: Maintenance tasks</p> <p>Examples: <pre><code>feat: add async dependency resolution\nfix(container): resolve circular dependency issue\ndocs: update getting started guide\ntest: add tests for scoped services\n</code></pre></p>"},{"location":"contributing/#testing-guidelines","title":"\ud83e\uddea Testing Guidelines","text":""},{"location":"contributing/#test-structure","title":"Test Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 test_container.py          # Container functionality\n\u251c\u2500\u2500 test_scopes.py            # Scoping tests\n\u251c\u2500\u2500 test_modules.py           # Module system tests\n\u251c\u2500\u2500 test_integrations/        # Framework integrations\n\u2502   \u251c\u2500\u2500 test_fastapi.py\n\u2502   \u2514\u2500\u2500 test_taskiq.py\n\u2514\u2500\u2500 fixtures/                 # Test fixtures\n    \u2514\u2500\u2500 conftest.py\n</code></pre>"},{"location":"contributing/#writing-tests","title":"Writing Tests","text":"<ol> <li>Test Files: Match source file names with <code>test_</code> prefix</li> <li>Test Classes: Group related tests in classes</li> <li>Test Methods: Use descriptive names starting with <code>test_</code></li> <li>Fixtures: Use pytest fixtures for setup/teardown</li> <li>Mocking: Use unittest.mock or pytest-mock</li> </ol> <p>Example test:</p> <pre><code>import pytest\nfrom injectq import InjectQ, inject\n\nclass TestContainer:\n    def test_simple_registration(self):\n        \"\"\"Test simple service registration.\"\"\"\n        container = InjectQ()\n        container[str] = \"test\"\n\n        assert container[str] == \"test\"\n\n    def test_dependency_injection(self):\n        \"\"\"Test automatic dependency injection.\"\"\"\n        container = InjectQ()\n        container[str] = \"hello\"\n\n        @inject\n        def func(message: str) -&gt; str:\n            return f\"Got: {message}\"\n\n        result = func()\n        assert result == \"Got: hello\"\n\n    @pytest.mark.asyncio\n    async def test_async_injection(self):\n        \"\"\"Test async dependency injection.\"\"\"\n        container = InjectQ()\n        container[str] = \"async\"\n\n        @inject\n        async def async_func(message: str) -&gt; str:\n            return f\"Async: {message}\"\n\n        result = await async_func()\n        assert result == \"Async: async\"\n</code></pre>"},{"location":"contributing/#test-coverage","title":"Test Coverage","text":"<ul> <li>Minimum Coverage: 95%</li> <li>Missing Coverage: Should be documented</li> <li>Test Types: Unit, integration, and end-to-end tests</li> </ul>"},{"location":"contributing/#documentation-guidelines","title":"\ud83d\udcda Documentation Guidelines","text":""},{"location":"contributing/#documentation-structure","title":"Documentation Structure","text":"<p>Documentation is written in Markdown and built with MkDocs:</p> <pre><code>docs/\n\u251c\u2500\u2500 index.md                  # Home page\n\u251c\u2500\u2500 getting-started/          # Installation and quick start\n\u251c\u2500\u2500 core-concepts/           # Fundamental concepts\n\u251c\u2500\u2500 injection-patterns/      # Different injection styles\n\u251c\u2500\u2500 scopes/                  # Service lifetimes\n\u251c\u2500\u2500 modules/                 # Module system\n\u251c\u2500\u2500 integrations/            # Framework integrations\n\u251c\u2500\u2500 testing/                 # Testing utilities\n\u251c\u2500\u2500 advanced/                # Advanced features\n\u251c\u2500\u2500 examples/                # Examples and patterns\n\u251c\u2500\u2500 best-practices/          # Best practices\n\u251c\u2500\u2500 api-reference/           # API documentation\n\u2514\u2500\u2500 migration/               # Migration guides\n</code></pre>"},{"location":"contributing/#writing-documentation","title":"Writing Documentation","text":"<ol> <li>Tutorial Style: Documentation should be tutorial-oriented</li> <li>Code Examples: Include working code examples</li> <li>Clear Headings: Use descriptive headings and subheadings</li> <li>Cross-references: Link to related sections</li> <li>Up-to-date: Keep examples current with latest API</li> </ol>"},{"location":"contributing/#building-documentation","title":"Building Documentation","text":"<pre><code># Install documentation dependencies\npip install -e .[docs]\n\n# Serve documentation locally\nmkdocs serve\n\n# Build documentation\nmkdocs build\n</code></pre>"},{"location":"contributing/#pull-request-process","title":"\ud83d\udd04 Pull Request Process","text":""},{"location":"contributing/#before-submitting","title":"Before Submitting","text":"<ol> <li>Tests Pass: All tests must pass</li> <li>Linting Clean: No linting errors</li> <li>Coverage: Maintain or improve test coverage</li> <li>Documentation: Update docs if needed</li> <li>Changelog: Add entry to changelog</li> </ol>"},{"location":"contributing/#pr-requirements","title":"PR Requirements","text":"<ul> <li>Clear Title: Descriptive title following commit convention</li> <li>Description: Explain what the PR does and why</li> <li>Issue Reference: Link to related issues</li> <li>Testing: Describe how the change was tested</li> <li>Breaking Changes: Clearly mark breaking changes</li> </ul>"},{"location":"contributing/#pr-template","title":"PR Template","text":"<pre><code>## Description\nBrief description of the changes\n\n## Changes\n- List of changes\n- Another change\n\n## Testing\nHow the changes were tested\n\n## Checklist\n- [ ] Tests pass\n- [ ] Linting clean\n- [ ] Documentation updated\n- [ ] Changelog updated\n- [ ] Breaking changes noted\n</code></pre>"},{"location":"contributing/#review-process","title":"Review Process","text":"<ol> <li>Automated Checks: CI must pass</li> <li>Code Review: At least one maintainer review</li> <li>Discussion: Address feedback and questions</li> <li>Approval: Maintainer approval required</li> <li>Merge: Squash and merge to main</li> </ol>"},{"location":"contributing/#release-process","title":"\ud83c\udff7\ufe0f Release Process","text":""},{"location":"contributing/#version-numbering","title":"Version Numbering","text":"<p>We follow Semantic Versioning:</p> <ul> <li>MAJOR: Breaking changes</li> <li>MINOR: New features (backward compatible)</li> <li>PATCH: Bug fixes (backward compatible)</li> </ul>"},{"location":"contributing/#release-steps","title":"Release Steps","text":"<ol> <li>Update Version: Update version in <code>pyproject.toml</code></li> <li>Update Changelog: Add release notes</li> <li>Create Release: Tag and create GitHub release</li> <li>Publish: Publish to PyPI</li> <li>Documentation: Update documentation</li> </ol>"},{"location":"contributing/#code-review-guidelines","title":"\ud83d\udccb Code Review Guidelines","text":""},{"location":"contributing/#for-contributors","title":"For Contributors","text":"<ul> <li>Self Review: Review your own code before submitting</li> <li>Small PRs: Keep changes focused and small</li> <li>Context: Provide context and explanation</li> <li>Responsive: Respond to feedback promptly</li> </ul>"},{"location":"contributing/#for-reviewers","title":"For Reviewers","text":"<ul> <li>Be Kind: Provide constructive feedback</li> <li>Be Thorough: Check code, tests, and documentation</li> <li>Be Timely: Review PRs in reasonable time</li> <li>Be Clear: Explain suggestions and concerns</li> </ul>"},{"location":"contributing/#getting-help","title":"\ud83c\udd98 Getting Help","text":"<ul> <li>GitHub Issues: Ask questions in issues</li> <li>Discussions: Use GitHub Discussions for general questions</li> <li>Documentation: Check documentation first</li> <li>Examples: Look at example code</li> </ul>"},{"location":"contributing/#recognition","title":"\ud83c\udf89 Recognition","text":"<p>Contributors are recognized in:</p> <ul> <li>Changelog: Major contributions noted</li> <li>Documentation: Contributors acknowledged</li> <li>Releases: Contributions highlighted</li> </ul> <p>Thank you for contributing to InjectQ! \ud83d\ude80</p>"},{"location":"api-reference/","title":"API Reference","text":"<p>Quick reference for InjectQ's essential API.</p>"},{"location":"api-reference/#quick-start","title":"Quick Start","text":"<p>See the Quick Reference Guide for common API patterns and code examples.</p>"},{"location":"api-reference/#main-topics-covered","title":"Main Topics Covered","text":"<ul> <li>Container creation and configuration</li> <li>Binding services (dict interface and bind methods)</li> <li>Decorators (@inject, @singleton, @transient, @scoped, @resource)</li> <li>Module system and providers</li> <li>Testing utilities (test_container, override_dependency)</li> <li>Exception handling</li> <li>Scope management</li> <li>Type-safe injection</li> </ul>"},{"location":"api-reference/#for-detailed-implementation","title":"For Detailed Implementation","text":"<p>For implementation details beyond the quick reference, refer to:</p> <ul> <li>Injection Patterns - Different ways to inject dependencies</li> <li>Scopes - Service lifetime management</li> <li>Modules - Organizing dependencies</li> <li>Testing - Testing your dependency-injected code</li> </ul>"},{"location":"api-reference/quick-reference/","title":"API Quick Reference","text":"<p>Essential InjectQ API reference for common tasks.</p>"},{"location":"api-reference/quick-reference/#container-creation","title":"Container Creation","text":"<pre><code>from injectq import InjectQ\n\n# Get the global singleton (preferred)\ncontainer = InjectQ.get_instance()\n\n# Create a new instance\ncontainer = InjectQ()\n\n# Create with specific options\ncontainer = InjectQ(\n    modules=[MyModule()],      # Pre-install modules\n    use_async_scopes=True,     # Enable async support\n    thread_safe=True,          # Thread-safe container\n    allow_override=True        # Allow re-binding\n)\n</code></pre>"},{"location":"api-reference/quick-reference/#binding-services","title":"Binding Services","text":""},{"location":"api-reference/quick-reference/#dict-like-interface-recommended","title":"Dict-like Interface (Recommended)","text":"<pre><code># Bind a simple value\ncontainer[str] = \"database_url\"\ncontainer[int] = 5432\n\n# Bind a class for automatic instantiation\ncontainer[UserService] = UserService\n\n# Bind an instance\ncontainer[Database] = Database(url=\"postgresql://...\")\n\n# Bind with string keys\ncontainer[\"config\"] = app_config\ncontainer[\"cache\"] = RedisCache()\n</code></pre>"},{"location":"api-reference/quick-reference/#bind-method","title":"Bind Method","text":"<pre><code># Bind class to implementation (same as dict interface)\ncontainer.bind(UserService, UserService)\n\n# Bind with allow_none for nullable dependencies\ncontainer.bind(OptionalService, None, allow_none=True)\n</code></pre>"},{"location":"api-reference/quick-reference/#bind-factory-method","title":"Bind Factory Method","text":"<pre><code># Bind a DI factory (factory receives injected dependencies)\ndef create_database(url: str) -&gt; Database:\n    return Database(url)\n\ncontainer.bind_factory(Database, create_database)\n\n# Bind a parameterized factory\ndef create_pool(db_name: str, max_conn: int = 10):\n    return ConnectionPool(db_name, max_conn)\n\ncontainer.bind_factory(\"pool\", create_pool)\n</code></pre>"},{"location":"api-reference/quick-reference/#retrieving-services","title":"Retrieving Services","text":"<pre><code># Using dict interface (recommended)\nservice = container[UserService]\nconfig = container[str]\n\n# Using get method (legacy)\nservice = container.get(UserService)\n</code></pre>"},{"location":"api-reference/quick-reference/#retrieving-factories","title":"Retrieving Factories","text":"<pre><code># Get a factory function\nfactory = container.get_factory(\"my_factory\")\ninstance = factory()  # Call with no args\n\n# Call a parameterized factory\nresult = container.call_factory(\"my_factory\", arg1, arg2, kwarg=value)\n\n# Get factory and call with args\nfactory = container.get_factory(\"pool\")\npool = factory(\"users_db\", max_conn=20)\n\n# \ud83c\udd95 Hybrid: Provide some args, inject the rest\nresult = container.invoke(\"my_factory\", custom_arg=\"value\")\n# Parameters not provided will be auto-injected from container\n\n# \ud83c\udd95 Async factory methods\nfactory = await container.aget_factory(\"async_factory\")\nresult = await container.acall_factory(\"async_factory\", arg1, arg2)\nresult = await container.ainvoke(\"async_factory\", custom_arg=\"value\")\n</code></pre>"},{"location":"api-reference/quick-reference/#decorators","title":"Decorators","text":""},{"location":"api-reference/quick-reference/#inject-automatic-dependency-injection","title":"@inject - Automatic Dependency Injection","text":"<pre><code>from injectq import inject\n\n@inject\ndef process_data(service: UserService, config: str):\n    # service and config automatically injected from container\n    return service.process()\n\n# Call without arguments\nresult = process_data()\n</code></pre>"},{"location":"api-reference/quick-reference/#singleton-shared-instance","title":"@singleton - Shared Instance","text":"<pre><code>from injectq import singleton\n\n@singleton\nclass Database:\n    def __init__(self, url: str):\n        self.url = url\n\n# Same instance for entire app\ndb1 = container[Database]\ndb2 = container[Database]\nassert db1 is db2  # True\n</code></pre>"},{"location":"api-reference/quick-reference/#transient-new-instance-each-time","title":"@transient - New Instance Each Time","text":"<pre><code>from injectq import transient\n\n@transient\nclass RequestHandler:\n    pass\n\n# Different instance each time\nh1 = container[RequestHandler]\nh2 = container[RequestHandler]\nassert h1 is not h2  # True\n</code></pre>"},{"location":"api-reference/quick-reference/#scoped-request-scoped-instances","title":"@scoped - Request-scoped Instances","text":"<pre><code>from injectq import scoped\n\n@scoped\nclass RequestContext:\n    pass\n\n# Same within scope, different across scopes\n# Used primarily in web frameworks\n</code></pre>"},{"location":"api-reference/quick-reference/#resource-lifecycle-management","title":"@resource - Lifecycle Management","text":"<pre><code>from injectq import resource\n\n@resource\nclass DatabaseConnection:\n    async def initialize(self):\n        # Called when service is created\n        self.connection = await connect()\n\n    async def cleanup(self):\n        # Called when service is destroyed\n        await self.connection.close()\n</code></pre>"},{"location":"api-reference/quick-reference/#modules","title":"Modules","text":""},{"location":"api-reference/quick-reference/#define-a-module","title":"Define a Module","text":"<pre><code>from injectq import Module, provider\n\nclass DatabaseModule(Module):\n    def configure(self, binder):\n        # Bind services\n        binder.bind(Database, PostgreSQLDatabase)\n        binder.bind(str, \"postgresql://localhost/db\")\n\nclass ServiceModule(Module):\n    @provider\n    def provide_user_service(self, db: Database) -&gt; UserService:\n        return UserService(db)\n\n# Or use SimpleModule for quick setup\nfrom injectq import SimpleModule\n\nmodule = SimpleModule([\n    (Database, PostgreSQLDatabase),\n    (str, \"postgresql://localhost/db\"),\n])\n</code></pre>"},{"location":"api-reference/quick-reference/#install-modules","title":"Install Modules","text":"<pre><code># Install on creation\ncontainer = InjectQ(modules=[DatabaseModule(), ServiceModule()])\n\n# Or install later\ncontainer.install_module(DatabaseModule())\ncontainer.install_module(ServiceModule())\n</code></pre>"},{"location":"api-reference/quick-reference/#testing","title":"Testing","text":""},{"location":"api-reference/quick-reference/#test_container-isolated-testing","title":"test_container - Isolated Testing","text":"<pre><code>from injectq.testing import test_container\n\ndef test_user_service():\n    with test_container() as container:\n        # Bind test doubles\n        container[Database] = MockDatabase()\n        container[UserService] = UserService\n\n        # Test\n        service = container[UserService]\n        assert service is not None\n</code></pre>"},{"location":"api-reference/quick-reference/#override_dependency-temporary-override","title":"override_dependency - Temporary Override","text":"<pre><code>from injectq.testing import override_dependency\n\ndef test_with_override():\n    container = InjectQ.get_instance()\n    mock_service = MockUserService()\n\n    with override_dependency(UserService, mock_service):\n        service = container[UserService]\n        # service is mocked here\n        assert isinstance(service, MockUserService)\n\n    # Service is restored after block\n</code></pre>"},{"location":"api-reference/quick-reference/#mock_factory-mock-factory-functions","title":"mock_factory - Mock Factory Functions","text":"<pre><code>from injectq.testing import mock_factory\n\ndef test_factory():\n    with test_container() as container:\n        container.bind_factory(\n            \"request_id\",\n            mock_factory(lambda: \"mock-123\")\n        )\n\n        request_id = container[\"request_id\"]\n        assert request_id == \"mock-123\"\n</code></pre>"},{"location":"api-reference/quick-reference/#pytest_container_fixture-pytest-integration","title":"pytest_container_fixture - Pytest Integration","text":"<pre><code>from injectq.testing import pytest_container_fixture\nimport pytest\n\n@pytest.fixture\ndef container():\n    from injectq.testing import test_container\n    with test_container() as c:\n        yield c\n\ndef test_service(container):\n    container[UserService] = UserService\n    service = container[UserService]\n    assert service is not None\n</code></pre>"},{"location":"api-reference/quick-reference/#exceptions","title":"Exceptions","text":"<pre><code>from injectq import (\n    InjectQError,           # Base exception\n    DependencyNotFoundError, # Service not registered\n    BindingError,           # Invalid binding\n    CircularDependencyError, # Circular dependencies detected\n    InjectionError,         # Injection failed\n    ScopeError,            # Scope-related issue\n)\n\ntry:\n    service = container[NonExistentService]\nexcept DependencyNotFoundError:\n    print(\"Service not found\")\n</code></pre>"},{"location":"api-reference/quick-reference/#scopes","title":"Scopes","text":"<pre><code>from injectq import Scope, ScopeType\n\n# Scope types\nScopeType.SINGLETON   # Single instance for app\nScopeType.TRANSIENT   # New instance each time\nScopeType.SCOPED      # One per request/scope\n\n# Getting scope information\nscope_manager = container._scope_manager\ncurrent_scope = scope_manager.get_scope(\"request\")\n</code></pre>"},{"location":"api-reference/quick-reference/#providers","title":"Providers","text":"<pre><code>from injectq import provider\n\nclass MyModule(Module):\n    @provider\n    def provide_database(self, url: str) -&gt; Database:\n        \"\"\"Provider method - dependency on str automatically resolved.\"\"\"\n        return Database(url)\n\n    @provider\n    def provide_service(self, db: Database) -&gt; UserService:\n        \"\"\"Provider methods can depend on other provided services.\"\"\"\n        return UserService(db)\n</code></pre>"},{"location":"api-reference/quick-reference/#type-safety","title":"Type Safety","text":"<pre><code>from injectq import Inject\nfrom typing import Protocol\n\n# Use protocols for type safety\nclass IUserService(Protocol):\n    def get_user(self, id: int) -&gt; User: ...\n\n# Type-hint injection\n@inject\ndef process(service: IUserService):\n    # Full type checking\n    user = service.get_user(1)  # IDE knows return type\n    return user\n</code></pre>"},{"location":"api-reference/quick-reference/#context-management","title":"Context Management","text":"<pre><code>from injectq import ContainerContext\n\n# Create a context\nwith ContainerContext.create(container):\n    # InjectQ.get_instance() returns this container\n    service = InjectQ.get_instance()\n    assert service is container\n\n# Outside context, InjectQ.get_instance() returns global singleton\n</code></pre>"},{"location":"api-reference/quick-reference/#common-patterns","title":"Common Patterns","text":""},{"location":"api-reference/quick-reference/#factory-pattern","title":"Factory Pattern","text":"<p>InjectQ supports both regular factories (with DI) and parameterized factories (with custom arguments).</p>"},{"location":"api-reference/quick-reference/#regular-factory-dependency-injection","title":"Regular Factory (Dependency Injection)","text":"<pre><code># Factory that uses dependency injection\ndef create_database(config: str) -&gt; Database:\n    \"\"\"Factory with DI - config is injected from container.\"\"\"\n    return Database(config)\n\n# Bind the factory\ncontainer.bind_factory(Database, create_database)\n\n# Use it - factory is called automatically\ndb = container[Database]\n</code></pre>"},{"location":"api-reference/quick-reference/#parameterized-factory","title":"Parameterized Factory","text":"<pre><code># Factory that accepts parameters\ndef create_cache(host: str, port: int = 6379):\n    \"\"\"Factory with parameters - arguments provided at call time.\"\"\"\n    return RedisCache(host, port)\n\n# Bind the parameterized factory\ncontainer.bind_factory(\"cache\", create_cache)\n\n# Method 1: Get factory and call\nfactory = container.get_factory(\"cache\")\ncache = factory(\"localhost\", port=6380)\n\n# Method 2: Use call_factory shorthand (recommended)\ncache = container.call_factory(\"cache\", \"localhost\", port=6380)\n\n# Method 3: Chain the calls\ncache = container.get_factory(\"cache\")(\"localhost\", 6380)\n</code></pre>"},{"location":"api-reference/quick-reference/#factory-with-multiple-parameters","title":"Factory with Multiple Parameters","text":"<pre><code>def create_connection_pool(\n    db_name: str,\n    host: str = \"localhost\",\n    port: int = 5432,\n    max_conn: int = 10\n) -&gt; ConnectionPool:\n    \"\"\"Factory with multiple parameters.\"\"\"\n    return ConnectionPool(db_name, host=host, port=port, max_conn=max_conn)\n\ncontainer.bind_factory(\"db_pool\", create_connection_pool)\n\n# Call with positional and keyword arguments\nusers_pool = container.call_factory(\"db_pool\", \"users_db\", port=5433, max_conn=20)\n</code></pre>"},{"location":"api-reference/quick-reference/#combining-di-and-parameterized-factories","title":"Combining DI and Parameterized Factories","text":"<pre><code>def get_cached_user(user_id: int):\n    \"\"\"Uses DI for dependencies, accepts parameters.\"\"\"\n    db = container[Database]  # DI works here\n    cache = container[Cache]   # DI works here\n    return cache.get(f\"user:{user_id}\") or db.get_user(user_id)\n\ncontainer.bind_factory(\"get_user\", get_cached_user)\n\n# Call with parameter\nuser = container.call_factory(\"get_user\", 123)\n</code></pre>"},{"location":"api-reference/quick-reference/#hybrid-factory-invocation-invoke","title":"\ud83c\udd95 Hybrid Factory Invocation (invoke)","text":"<p>The <code>invoke()</code> method combines DI and manual arguments in one call:</p> <pre><code># Factory with mixed dependencies\ndef create_user_service(db: Database, cache: Cache, user_id: str):\n    \"\"\"Factory needs both injected deps and manual args.\"\"\"\n    return UserService(db, cache, user_id)\n\ncontainer.bind_factory(\"user_service\", create_user_service)\n\n# Before invoke() - manual and verbose\ndb = container[Database]\ncache = container[Cache]\nfactory = container.get_factory(\"user_service\")\nservice = factory(db, cache, \"user123\")  # 4 lines\n\n# With invoke() - clean and automatic\nservice = container.invoke(\"user_service\", user_id=\"user123\")  # 1 line\n# db and cache are auto-injected, user_id is provided\n</code></pre> <p>How invoke() Works:</p> <ol> <li>Parameters you provide (args/kwargs) are used directly</li> <li>Missing parameters are injected by name (string keys) first</li> <li>Then by type annotation (for non-primitive types)</li> <li>Default values are used if parameter not provided or injected</li> <li>Raises error if required parameter cannot be resolved</li> </ol> <p>Example with String Keys:</p> <pre><code>container.bind(\"api_key\", \"secret-123\")\ncontainer.bind(\"api_url\", \"https://api.example.com\")\n\ndef create_client(api_key: str, api_url: str, timeout: int):\n    return HTTPClient(api_key, api_url, timeout)\n\ncontainer.bind_factory(\"client\", create_client)\n\n# api_key and api_url injected by name, timeout provided\nclient = container.invoke(\"client\", timeout=30)\n</code></pre> <p>Async Version:</p> <pre><code>async def create_async_service(db: Database, batch_size: int):\n    \"\"\"Async factory with mixed dependencies.\"\"\"\n    await asyncio.sleep(0.1)  # async work\n    return AsyncService(db, batch_size)\n\ncontainer.bind_factory(\"async_service\", create_async_service)\n\n# Use ainvoke for async factories\nservice = await container.ainvoke(\"async_service\", batch_size=100)\n# db is auto-injected\n</code></pre> <p>When to Use invoke():</p> <ul> <li>\u2705 Factory needs some DI dependencies and some runtime arguments</li> <li>\u2705 You want cleaner code without manual dependency resolution</li> <li>\u2705 You want to mix injected config with user-provided values</li> <li>\u274c All parameters are in container (use <code>get()</code> instead)</li> <li>\u274c All parameters are manual (use <code>call_factory()</code> instead)</li> </ul>"},{"location":"api-reference/quick-reference/#configuration-pattern","title":"Configuration Pattern","text":"<pre><code># Bind configuration\ncontainer[\"db_url\"] = os.getenv(\"DATABASE_URL\")\ncontainer[\"api_key\"] = os.getenv(\"API_KEY\")\ncontainer[\"debug\"] = os.getenv(\"DEBUG\") == \"true\"\n\n# Use with provider\nclass ServiceModule(Module):\n    @provider\n    def provide_service(\n        self,\n        db_url: str,\n        api_key: str,\n        debug: bool\n    ) -&gt; MyService:\n        return MyService(db_url, api_key, debug)\n</code></pre>"},{"location":"api-reference/quick-reference/#conditional-binding","title":"Conditional Binding","text":"<pre><code>if environment == \"production\":\n    container[Database] = PostgreSQLDatabase()\n    container[Cache] = RedisCache()\nelif environment == \"test\":\n    container[Database] = InMemoryDatabase()\n    container[Cache] = MemoryCache()\nelse:\n    container[Database] = SQLiteDatabase()\n    container[Cache] = MemoryCache()\n</code></pre>"},{"location":"api-reference/quick-reference/#advanced-features","title":"Advanced Features","text":""},{"location":"api-reference/quick-reference/#resource-management","title":"Resource Management","text":"<pre><code>@resource\nclass ConnectionPool:\n    async def initialize(self):\n        self.pool = await create_pool()\n\n    async def cleanup(self):\n        await self.pool.close()\n\n# With async context\nasync with container:\n    pool = container[ConnectionPool]\n    # Resources auto-initialized\n    # Auto-cleanup on exit\n</code></pre>"},{"location":"api-reference/quick-reference/#circular-dependency-detection","title":"Circular Dependency Detection","text":"<pre><code>from injectq import CircularDependencyError\n\ntry:\n    service = container[ServiceA]  # May raise if circular deps\nexcept CircularDependencyError as e:\n    print(f\"Circular dependency: {e}\")\n</code></pre>"},{"location":"api-reference/quick-reference/#diagnostics","title":"Diagnostics","text":"<pre><code>from injectq.diagnostics import (\n    DependencyProfiler,\n    DependencyValidator,\n    DependencyVisualizer,\n)\n\n# Validate dependencies\nvalidator = DependencyValidator(container)\nissues = validator.validate()\n\n# Profile dependency resolution\nprofiler = DependencyProfiler()\n# ... use container ...\nstats = profiler.get_stats()\n\n# Visualize dependency graph\nvisualizer = DependencyVisualizer(container)\ngraph = visualizer.visualize()\n</code></pre>"},{"location":"api-reference/quick-reference/#summary","title":"Summary","text":"<p>Most Common API: <pre><code>from injectq import InjectQ, inject, singleton, transient, resource\nfrom injectq.testing import test_container, override_dependency\n\n# Get container\ncontainer = InjectQ.get_instance()\n\n# Bind\ncontainer[Service] = ServiceImpl\ncontainer[\"key\"] = value\n\n# Retrieve\nservice = container[Service]\n\n# Decorator injection\n@inject\ndef my_function(service: Service):\n    pass\n\n# Testing\nwith test_container() as test_container:\n    test_container[Service] = MockService\n</code></pre></p> <p>For more details, see the full documentation sections on injection patterns, scopes, and testing.</p>"},{"location":"core-concepts/container-pattern/","title":"The Container Pattern","text":"<p>The Container Pattern is the heart of dependency injection frameworks. This guide explains how containers work, their benefits, and how InjectQ implements them.</p>"},{"location":"core-concepts/container-pattern/#what-is-a-container","title":"\ud83c\udfd7\ufe0f What is a Container?","text":"<p>A Dependency Injection Container (or DI Container) is an object that:</p> <ol> <li>Knows about all your services and their dependencies</li> <li>Creates service instances when needed</li> <li>Injects dependencies automatically</li> <li>Manages service lifetimes (scopes)</li> </ol>"},{"location":"core-concepts/container-pattern/#container-responsibilities","title":"\ud83d\udce6 Container Responsibilities","text":""},{"location":"core-concepts/container-pattern/#1-service-registration","title":"1. Service Registration","text":"<p>The container needs to know what services exist and how to create them:</p> <pre><code>from injectq import InjectQ, singleton\n\ncontainer = InjectQ.get_instance()\n\n# Option 1: Use decorators (recommended)\n@singleton\nclass Database:\n    pass\n\n@singleton\nclass Cache:\n    pass\n\n@singleton\nclass UserService:\n    pass\n\n# Option 2: Manual binding\ncontainer.bind(Database, Database)\ncontainer.bind(Cache, Cache)\ncontainer.bind(UserService, UserService)\n</code></pre>"},{"location":"core-concepts/container-pattern/#2-dependency-resolution","title":"2. Dependency Resolution","text":"<p>When a service is requested, the container:</p> <ol> <li>Looks up the service registration</li> <li>Analyzes the service's dependencies</li> <li>Recursively resolves all dependencies</li> <li>Creates the service instance</li> <li>Returns the fully configured instance</li> </ol> <pre><code>from injectq import inject, singleton\n\n@singleton\nclass Database:\n    pass\n\n@singleton\nclass Cache:\n    pass\n\n@singleton\nclass UserService:\n    @inject\n    def __init__(self, db: Database, cache: Cache):\n        self.db = db\n        self.cache = cache\n\n# Container resolves this automatically\n@inject\ndef process_data(service: UserService):\n    # Container creates:\n    # 1. Database instance\n    # 2. Cache instance\n    # 3. UserService instance with Database and Cache injected\n    pass\n</code></pre>"},{"location":"core-concepts/container-pattern/#3-lifetime-management","title":"3. Lifetime Management","text":"<p>The container manages when services are created and destroyed:</p> <pre><code># Singleton - one instance for entire app\n@singleton\nclass Database:\n    pass\n\n# Transient - new instance every time\n@transient\nclass RequestHandler:\n    pass\n</code></pre>"},{"location":"core-concepts/container-pattern/#how-injectqs-container-works","title":"\ud83d\udd27 How InjectQ's Container Works","text":""},{"location":"core-concepts/container-pattern/#core-components","title":"Core Components","text":"<p>InjectQ's container consists of several key components:</p> <pre><code>class InjectQ:\n    def __init__(self):\n        self._registry = ServiceRegistry()        # Service registrations\n        self._resolver = DependencyResolver()     # Dependency resolution\n        self._scope_manager = ScopeManager()      # Lifetime management\n</code></pre>"},{"location":"core-concepts/container-pattern/#service-registry","title":"Service Registry","text":"<p>The registry stores information about all registered services:</p> <pre><code># Internal registry structure\n{\n    Database: {\n        \"implementation\": PostgreSQLDatabase,\n        \"scope\": \"singleton\",\n        \"factory\": None\n    },\n    UserService: {\n        \"implementation\": UserService,\n        \"scope\": \"singleton\",\n        \"factory\": None\n    }\n}\n</code></pre>"},{"location":"core-concepts/container-pattern/#dependency-resolver","title":"Dependency Resolver","text":"<p>The resolver analyzes dependencies and builds the dependency graph:</p> <pre><code># For UserService(Database, Cache)\n# Resolver determines:\n# UserService depends on Database and Cache\n# Database depends on DatabaseConfig\n# Cache depends on CacheConfig\n</code></pre>"},{"location":"core-concepts/container-pattern/#scope-manager","title":"Scope Manager","text":"<p>The scope manager controls service lifetimes:</p> <pre><code># Different scopes for different lifetimes\ninjectq.bind(RequestContext, scope=ScopeType.REQUEST)  # Per request\ninjectq.bind(TempData, scope=ScopeType.TRANSIENT)      # Always new\ninjectq.bind(AppConfig, scope=ScopeType.SINGLETON)     # One for app\n</code></pre>"},{"location":"core-concepts/container-pattern/#container-patterns","title":"\ud83c\udfaf Container Patterns","text":""},{"location":"core-concepts/container-pattern/#1-singleton-container-default","title":"1. Singleton Container (Default)","text":"<p>One global container for the entire application (recommended pattern):</p> <pre><code>from injectq import InjectQ, inject, singleton\n\n# Get the global container instance\ncontainer = InjectQ.get_instance()\n\n# Register services using decorators or manual binding\n@singleton\nclass Database:\n    pass\n\n@singleton\nclass UserService:\n    @inject\n    def __init__(self, db: Database):\n        self.db = db\n\n# Use anywhere in the app\n@inject\ndef handler(service: UserService):\n    pass\n</code></pre> <p>Pros: - Simple to use - Services available everywhere - Easy to set up - Decorators auto-register</p> <p>Cons: - Global state - Harder to test in isolation - Can lead to tight coupling</p>"},{"location":"core-concepts/container-pattern/#2-composed-containers","title":"2. Composed Containers","text":"<p>Multiple containers for different contexts:</p> <pre><code>from injectq import InjectQ, Module, singleton\n\n@singleton\nclass Database:\n    pass\n\nclass WebModule(Module):\n    def configure(self, binder):\n        binder.bind(\"web_config\", {\"port\": 8080})\n\nclass ApiModule(Module):\n    def configure(self, binder):\n        binder.bind(\"api_config\", {\"version\": \"v1\"})\n\n# Base container with common services\nbase_container = InjectQ()\nbase_container.bind(Database, Database)\n\n# Web-specific container\nweb_container = InjectQ(modules=[WebModule()])\nweb_container.bind(Database, Database)\n\n# API-specific container\napi_container = InjectQ(modules=[ApiModule()])\napi_container.bind(Database, Database)\n</code></pre>"},{"location":"core-concepts/container-pattern/#3-scoped-containers","title":"3. Scoped Containers","text":"<p>Containers that create child scopes:</p> <pre><code># Main container\ncontainer = InjectQ()\n\n# Create a request scope\nasync with container.scope(\"request\"):\n    # Services in this scope are isolated\n    request_service = container.get(RequestService)\n</code></pre>"},{"location":"core-concepts/container-pattern/#container-configuration-patterns","title":"\ud83d\udccb Container Configuration Patterns","text":""},{"location":"core-concepts/container-pattern/#1-dict-like-configuration","title":"1. Dict-like Configuration","text":"<p>Simple key-value bindings:</p> <pre><code>from injectq import InjectQ\n\ncontainer = InjectQ.get_instance()\n\n# Simple values\ncontainer[\"db_url\"] = \"postgresql://localhost/db\"\ncontainer[\"port\"] = 8080\ncontainer[\"debug\"] = True\n\n# Complex objects\nclass AppConfig:\n    def __init__(self, host: str, port: int):\n        self.host = host\n        self.port = port\n\ncontainer[\"config\"] = AppConfig(host=\"localhost\", port=8080)\n</code></pre>"},{"location":"core-concepts/container-pattern/#2-type-based-configuration","title":"2. Type-based Configuration","text":"<p>Bind types to implementations:</p> <pre><code>from injectq import InjectQ, singleton\nfrom abc import ABC, abstractmethod\n\n# Define interface\nclass Database(ABC):\n    @abstractmethod\n    def query(self, sql: str):\n        pass\n\n# Implementation\n@singleton\nclass PostgreSQLDatabase(Database):\n    def query(self, sql: str):\n        return f\"PostgreSQL: {sql}\"\n\ncontainer = InjectQ.get_instance()\n\n# Bind interface to implementation\ncontainer.bind(Database, PostgreSQLDatabase)\n</code></pre>"},{"location":"core-concepts/container-pattern/#3-factory-based-configuration","title":"3. Factory-based Configuration","text":"<p>Use factories for complex creation logic. InjectQ supports both DI-based factories (no parameters) and parameterized factories (with arguments).</p>"},{"location":"core-concepts/container-pattern/#regular-factory-dependency-injection","title":"Regular Factory (Dependency Injection)","text":"<p>Create factories that are resolved automatically using DI:</p> <pre><code>from injectq import InjectQ, inject, singleton\n\ncontainer = InjectQ.get_instance()\n\n@singleton\nclass DatabaseConfig:\n    def __init__(self):\n        self.driver = \"postgres\"\n\nclass Database:\n    def __init__(self, config: DatabaseConfig):\n        self.config = config\n\n# Factory with DI - dependencies are injected\n@inject\ndef create_database(config: DatabaseConfig) -&gt; Database:\n    \"\"\"Factory with DI - dependencies are injected.\"\"\"\n    if config.driver == \"postgres\":\n        return Database(config)\n    else:\n        return Database(config)\n\n# Bind the factory - DatabaseConfig is automatically injected\ncontainer.bind_factory(Database, create_database)\n\n# Get the instance - factory is called automatically\ndb = container[Database]\n</code></pre>"},{"location":"core-concepts/container-pattern/#parameterized-factory","title":"Parameterized Factory","text":"<p>Create factories that accept arguments:</p> <pre><code># Factory that accepts parameters\ndef create_connection_pool(db_name: str, max_conn: int = 10):\n    \"\"\"Factory with parameters - no DI needed.\"\"\"\n    return ConnectionPool(db_name, max_conn=max_conn)\n\n# Bind the parameterized factory\ncontainer.bind_factory(\"db_pool\", create_connection_pool)\n\n# Method 1: Get the factory function and call it\nfactory = container.get_factory(\"db_pool\")\nusers_pool = factory(\"users_db\", max_conn=20)\n\n# Method 2: Use call_factory shorthand\norders_pool = container.call_factory(\"db_pool\", \"orders_db\", max_conn=15)\n\n# Method 3: Chain the calls\nlogs_pool = container.get_factory(\"db_pool\")(\"logs_db\")\n</code></pre>"},{"location":"core-concepts/container-pattern/#combining-di-and-parameterized-factories","title":"Combining DI and Parameterized Factories","text":"<p>Mix both patterns in the same container:</p> <pre><code>from injectq import InjectQ, singleton, inject\n\ncontainer = InjectQ.get_instance()\n\n@singleton\nclass LogConfig:\n    def __init__(self):\n        self.level = \"INFO\"\n\nclass Logger:\n    def __init__(self, config: LogConfig):\n        self.config = config\n\n@singleton\nclass Database:\n    pass\n\n# DI factory\n@inject\ndef create_logger(config: LogConfig) -&gt; Logger:\n    \"\"\"Factory with DI - dependencies injected.\"\"\"\n    return Logger(config)\n\n# Parameterized factory\ndef get_user_from_db(user_id: int):\n    \"\"\"Factory with parameters - custom arguments.\"\"\"\n    db = container[Database]  # Can still use DI\n    return {\"user_id\": user_id, \"db\": db}\n\n# Bind both\ncontainer.bind_factory(Logger, create_logger)        # DI factory\ncontainer.bind_factory(\"get_user\", get_user_from_db) # Parameterized\n\n# Use both\nlogger = container[Logger]                    # No args needed\nuser = container.call_factory(\"get_user\", 42) # Pass args\n</code></pre>"},{"location":"core-concepts/container-pattern/#hybrid-factories-with-invoke","title":"\ud83c\udd95 Hybrid Factories with invoke()","text":"<p>The new <code>invoke()</code> method combines DI with manual arguments automatically:</p> <pre><code>from injectq import InjectQ, singleton, inject\n\ncontainer = InjectQ.get_instance()\n\n@singleton\nclass Database:\n    pass\n\n@singleton\nclass Cache:\n    pass\n\nclass UserService:\n    def __init__(self, db: Database, cache: Cache, user_id: str):\n        self.db = db\n        self.cache = cache\n        self.user_id = user_id\n\n# Factory that needs BOTH DI dependencies and manual arguments\ndef create_user_service(db: Database, cache: Cache, user_id: str) -&gt; UserService:\n    \"\"\"Hybrid factory - some deps injected, some provided manually.\"\"\"\n    return UserService(db, cache, user_id)\n\ncontainer.bind_factory(\"user_service\", create_user_service)\n\n# \u274c Old way - verbose manual resolution\ndb = container[Database]\ncache = container[Cache]\nservice = container.call_factory(\"user_service\", db, cache, \"user123\")\n\n# \u2705 New way - automatic DI + manual args\nservice = container.invoke(\"user_service\", user_id=\"user123\")\n# Database and Cache are auto-injected, only provide user_id!\n\n# Also works with async\nasync def async_factory(db: Database, batch_size: int) -&gt; dict:\n    return {\"db\": db, \"batch_size\": batch_size}\n\ncontainer.bind_factory(\"async_service\", async_factory)\nresult = await container.ainvoke(\"async_service\", batch_size=100)\n</code></pre> <p>When to use invoke(): - Factory needs some dependencies from DI + some runtime arguments - You want cleaner code without manual resolution - Mix configuration from container with user input</p> <p>Learn more in Factory Methods.</p>"},{"location":"core-concepts/container-pattern/#real-world-example-multiple-database-connections","title":"Real-World Example: Multiple Database Connections","text":"<pre><code>from injectq import InjectQ\n\ncontainer = InjectQ.get_instance()\n\nclass DatabasePool:\n    \"\"\"Connection pool for a database.\"\"\"\n    def __init__(self, db_name: str, max_connections: int = 10):\n        self.db_name = db_name\n        self.max_connections = max_connections\n        self.connections = []\n\n# Create a parameterized factory\ndef create_db_pool(db_name: str, max_conn: int = 10) -&gt; DatabasePool:\n    return DatabasePool(db_name, max_conn=max_conn)\n\n# Bind the factory\ncontainer.bind_factory(\"db_pool\", create_db_pool)\n\n# Create multiple pools with different parameters\nusers_db = container.call_factory(\"db_pool\", \"users_db\", max_conn=20)\norders_db = container.call_factory(\"db_pool\", \"orders_db\", max_conn=15)\nlogs_db = container.call_factory(\"db_pool\", \"logs_db\")  # Uses default max_conn=10\n\n# Each pool is independent\nassert users_db is not orders_db\nassert users_db.db_name == \"users_db\"\nassert orders_db.max_connections == 15\n</code></pre>"},{"location":"core-concepts/container-pattern/#4-module-based-configuration","title":"4. Module-based Configuration","text":"<p>Organize configuration with modules:</p> <pre><code>from injectq import Module, InjectQ, singleton\nfrom abc import ABC, abstractmethod\n\n# Define interface\nclass Database(ABC):\n    @abstractmethod\n    def query(self, sql: str):\n        pass\n\n# Implementation\n@singleton\nclass PostgreSQLDatabase(Database):\n    def query(self, sql: str):\n        return f\"PostgreSQL: {sql}\"\n\n@singleton\nclass DatabaseConfig:\n    def __init__(self):\n        self.connection_string = \"postgresql://localhost/db\"\n\n@singleton\nclass UserService:\n    pass\n\n@singleton  \nclass OrderService:\n    pass\n\nclass DatabaseModule(Module):\n    def configure(self, binder):\n        binder.bind(Database, PostgreSQLDatabase)\n        binder.bind(DatabaseConfig, DatabaseConfig)\n\nclass ServiceModule(Module):\n    def configure(self, binder):\n        binder.bind(UserService, UserService)\n        binder.bind(OrderService, OrderService)\n\n# Compose modules\ncontainer = InjectQ(modules=[DatabaseModule(), ServiceModule()])\n</code></pre>"},{"location":"core-concepts/container-pattern/#container-lifecycle","title":"\ud83d\udd04 Container Lifecycle","text":""},{"location":"core-concepts/container-pattern/#1-registration-phase","title":"1. Registration Phase","text":"<p>Set up all service bindings:</p> <pre><code>from injectq import InjectQ, singleton\n\ncontainer = InjectQ()\n\n# Register all services using decorators\n@singleton\nclass Database:\n    pass\n\n@singleton\nclass Cache:\n    pass\n\n@singleton\nclass UserService:\n    pass\n\n# Or manual binding\ncontainer.bind(Database, Database)\ncontainer.bind(Cache, Cache)\ncontainer.bind(UserService, UserService)\n\n# Validate configuration (optional but recommended)\ncontainer.validate()\n</code></pre>"},{"location":"core-concepts/container-pattern/#2-resolution-phase","title":"2. Resolution Phase","text":"<p>Resolve services as needed:</p> <pre><code># First resolution - creates instances\nuser_service = container.get(UserService)\n\n# Subsequent resolutions - returns cached instances (for singletons)\nanother_service = container.get(UserService)\nassert user_service is another_service  # True for singletons\n</code></pre>"},{"location":"core-concepts/container-pattern/#3-cleanup-phase","title":"3. Cleanup Phase","text":"<p>Clean up resources when the application shuts down:</p> <pre><code>from injectq import InjectQ\n\ncontainer = InjectQ()\n\n# Manual cleanup\ncontainer.clear()\n\n# Or use context manager\nwith container.context():\n    # Use container\n    pass\n# Automatic cleanup when exiting context\n</code></pre>"},{"location":"core-concepts/container-pattern/#advanced-container-features","title":"\ud83d\ude80 Advanced Container Features","text":""},{"location":"core-concepts/container-pattern/#1-lazy-resolution","title":"1. Lazy Resolution","text":"<p>Services are created only when first accessed:</p> <pre><code>from injectq import InjectQ, singleton\n\ncontainer = InjectQ.get_instance()\n\n@singleton\nclass ExpensiveService:\n    def __init__(self):\n        print(\"ExpensiveService initialized\")\n\n# Service not created yet\nprint(\"Container ready\")\n\n# Service created here\nservice = container[ExpensiveService]  # Prints: ExpensiveService initialized\n</code></pre>"},{"location":"core-concepts/container-pattern/#2-circular-dependency-detection","title":"2. Circular Dependency Detection","text":"<p>Container detects and prevents circular dependencies:</p> <pre><code>from injectq import InjectQ, inject, singleton\n\n@singleton\nclass A:\n    @inject\n    def __init__(self, b: \"B\"):\n        self.b = b\n\n@singleton\nclass B:\n    @inject\n    def __init__(self, a: A):  # Circular dependency!\n        self.a = a\n\ncontainer = InjectQ.get_instance()\n\n# This will raise CircularDependencyError when trying to resolve\ntry:\n    container.validate()\nexcept Exception as e:\n    print(f\"Circular dependency detected: {e}\")\n</code></pre>"},{"location":"core-concepts/container-pattern/#3-conditional-registration","title":"3. Conditional Registration","text":"<p>Register services based on conditions:</p> <pre><code>from injectq import InjectQ, singleton\nfrom abc import ABC, abstractmethod\n\nclass Database(ABC):\n    @abstractmethod\n    def query(self, sql: str):\n        pass\n\n@singleton\nclass PostgreSQLDatabase(Database):\n    def query(self, sql: str):\n        return f\"PostgreSQL: {sql}\"\n\n@singleton\nclass SQLiteDatabase(Database):\n    def query(self, sql: str):\n        return f\"SQLite: {sql}\"\n\ncontainer = InjectQ.get_instance()\nenvironment = \"production\"  # or \"development\"\n\nif environment == \"production\":\n    container.bind(Database, PostgreSQLDatabase)\nelse:\n    container.bind(Database, SQLiteDatabase)\n</code></pre>"},{"location":"core-concepts/container-pattern/#testing-with-containers","title":"\ud83e\uddea Testing with Containers","text":""},{"location":"core-concepts/container-pattern/#1-test-containers","title":"1. Test Containers","text":"<p>Create isolated containers for testing:</p> <pre><code>from injectq.testing import test_container\nfrom injectq import singleton, inject\nfrom abc import ABC, abstractmethod\n\nclass Database(ABC):\n    @abstractmethod\n    def get_user(self, user_id: int):\n        pass\n\nclass MockDatabase(Database):\n    def get_user(self, user_id: int):\n        return {\"id\": user_id, \"name\": \"Mock User\"}\n\n@singleton\nclass UserService:\n    @inject\n    def __init__(self, db: Database):\n        self.db = db\n\n    def get_user(self, user_id: int):\n        return self.db.get_user(user_id)\n\ndef test_user_service():\n    with test_container() as container:\n        # Set up test dependencies\n        container.bind(Database, MockDatabase)\n        container.bind(UserService, UserService)\n\n        # Test the service\n        service = container[UserService]\n        result = service.get_user(1)\n        assert result is not None\n        assert result[\"name\"] == \"Mock User\"\n</code></pre>"},{"location":"core-concepts/container-pattern/#2-dependency-overrides","title":"2. Dependency Overrides","text":"<p>Temporarily override dependencies:</p> <pre><code>from injectq.testing import override_dependency\nfrom injectq import InjectQ, singleton, inject\nfrom abc import ABC, abstractmethod\n\nclass Database(ABC):\n    @abstractmethod\n    def get_user(self, user_id: int):\n        pass\n\n@singleton\nclass RealDatabase(Database):\n    def get_user(self, user_id: int):\n        return {\"id\": user_id, \"name\": \"Real User\"}\n\nclass MockDatabase(Database):\n    def get_user(self, user_id: int):\n        return {\"id\": user_id, \"name\": \"Mock User\"}\n\n@singleton\nclass UserService:\n    @inject\n    def __init__(self, db: Database):\n        self.db = db\n\n    def get_user(self, user_id: int):\n        return self.db.get_user(user_id)\n\ndef test_with_override():\n    container = InjectQ.get_instance()\n    mock_db = MockDatabase()\n\n    with override_dependency(Database, mock_db):\n        service = container[UserService]\n        # service now uses mock_db\n        result = service.get_user(1)\n        assert result[\"name\"] == \"Mock User\"\n</code></pre>"},{"location":"core-concepts/container-pattern/#performance-considerations","title":"\ud83d\udcca Performance Considerations","text":""},{"location":"core-concepts/container-pattern/#1-compilation","title":"1. Compilation","text":"<p>Pre-compile dependency graphs for better performance:</p> <pre><code># Compile for production\ncontainer.compile()\n\n# Now resolutions are faster\nservice = container.get(UserService)  # Optimized resolution\n</code></pre>"},{"location":"core-concepts/container-pattern/#2-caching","title":"2. Caching","text":"<p>Container caches resolved instances based on scope:</p> <pre><code>from injectq import InjectQ, singleton\n\n@singleton\nclass Database:\n    pass\n\ncontainer = InjectQ.get_instance()\n\n# Singleton services are cached\ndb1 = container[Database]\ndb2 = container[Database]\nassert db1 is db2  # Same instance\n</code></pre>"},{"location":"core-concepts/container-pattern/#3-lazy-loading","title":"3. Lazy Loading","text":"<p>Services are created only when needed:</p> <pre><code>from injectq import InjectQ, singleton\n\n@singleton\nclass HeavyService:\n    def __init__(self):\n        print(\"HeavyService initialized\")\n\ncontainer = InjectQ.get_instance()\n\n# No instances created yet\nprint(\"Container ready\")\n\n# Instance created here\nservice = container[HeavyService]  # Prints: HeavyService initialized\n</code></pre>"},{"location":"core-concepts/container-pattern/#container-benefits","title":"\ud83c\udf89 Container Benefits","text":""},{"location":"core-concepts/container-pattern/#1-automatic-dependency-resolution","title":"1. Automatic Dependency Resolution","text":"<p>No manual wiring of dependencies:</p> <pre><code>from injectq import inject, singleton\n\n# \u274c Manual (error-prone)\nclass DatabaseConfig:\n    pass\n\nclass Database:\n    def __init__(self, config: DatabaseConfig):\n        self.config = config\n\nclass Cache:\n    pass\n\nclass Logger:\n    pass\n\nclass UserService:\n    def __init__(self, db: Database, cache: Cache, logger: Logger):\n        self.db = db\n        self.cache = cache\n        self.logger = logger\n\ndef create_service():\n    config = DatabaseConfig()\n    db = Database(config)\n    cache = Cache()\n    logger = Logger()\n    return UserService(db, cache, logger)\n\n# \u2705 Container (automatic)\n@singleton\nclass DatabaseConfig:\n    pass\n\n@singleton\nclass Database:\n    @inject\n    def __init__(self, config: DatabaseConfig):\n        self.config = config\n\n@singleton\nclass Cache:\n    pass\n\n@singleton\nclass Logger:\n    pass\n\n@singleton\nclass UserService:\n    @inject\n    def __init__(self, db: Database, cache: Cache, logger: Logger):\n        self.db = db\n        self.cache = cache\n        self.logger = logger\n\n@inject\ndef use_service(service: UserService):\n    pass\n</code></pre>"},{"location":"core-concepts/container-pattern/#2-centralized-configuration","title":"2. Centralized Configuration","text":"<p>All service configuration in one place:</p> <pre><code>from injectq import InjectQ, Module, singleton\nfrom abc import ABC, abstractmethod\n\n# Define services\nclass Database(ABC):\n    @abstractmethod\n    def query(self, sql: str):\n        pass\n\n@singleton\nclass PostgreSQLDatabase(Database):\n    def query(self, sql: str):\n        return f\"PostgreSQL: {sql}\"\n\n@singleton\nclass RedisCache:\n    pass\n\n# Option 1: Module-based configuration\nclass AppModule(Module):\n    def configure(self, binder):\n        binder.bind(Database, PostgreSQLDatabase)\n        binder.bind(RedisCache, RedisCache)\n\ncontainer = InjectQ(modules=[AppModule()])\n\n# Option 2: Direct configuration\ncontainer = InjectQ.get_instance()\ncontainer.bind(Database, PostgreSQLDatabase)\ncontainer.bind(RedisCache, RedisCache)\n</code></pre>"},{"location":"core-concepts/container-pattern/#3-lifetime-management_1","title":"3. Lifetime Management","text":"<p>Automatic management of service lifetimes:</p> <pre><code># Container handles creation and cleanup\n@singleton\nclass Database:\n    def __init__(self):\n        # Set up connection\n\n    def close(self):\n        # Cleanup connection\n</code></pre>"},{"location":"core-concepts/container-pattern/#4-testability","title":"4. Testability","text":"<p>Easy to replace dependencies for testing:</p> <pre><code>from injectq import InjectQ, singleton\nfrom injectq.testing import override_dependency\nfrom abc import ABC, abstractmethod\n\n# Production\nclass Database(ABC):\n    @abstractmethod\n    def query(self, sql: str):\n        pass\n\n@singleton\nclass PostgreSQLDatabase(Database):\n    def query(self, sql: str):\n        return f\"PostgreSQL: {sql}\"\n\ncontainer = InjectQ.get_instance()\ncontainer.bind(Database, PostgreSQLDatabase)\n\n# Testing\nclass MockDatabase(Database):\n    def query(self, sql: str):\n        return \"Mock result\"\n\nwith override_dependency(Database, MockDatabase()):\n    # Test with mock\n    pass\n</code></pre>"},{"location":"core-concepts/container-pattern/#common-container-mistakes","title":"\ud83d\udea8 Common Container Mistakes","text":""},{"location":"core-concepts/container-pattern/#1-over-using-the-global-container","title":"1. Over-using the Global Container","text":"<pre><code>from injectq import InjectQ, inject, singleton\n\n# \u274c Global container everywhere - hidden dependency\n@singleton\nclass MyClass:\n    def __init__(self):\n        container = InjectQ.get_instance()\n        self.service = container[UserService]  # Hidden dependency\n\n# \u2705 Explicit dependency injection\n@singleton\nclass MyClass:\n    @inject\n    def __init__(self, service: UserService):\n        self.service = service  # Clear dependency\n</code></pre>"},{"location":"core-concepts/container-pattern/#2-ignoring-scopes","title":"2. Ignoring Scopes","text":"<pre><code># \u274c Wrong scope usage\n@singleton\nclass RequestData:  # Should be scoped or transient\n    pass\n</code></pre>"},{"location":"core-concepts/container-pattern/#3-circular-dependencies","title":"3. Circular Dependencies","text":"<pre><code>from injectq import singleton, inject\n\n# \u274c Circular dependency\n@singleton\nclass A:\n    @inject\n    def __init__(self, b: \"B\"):\n        self.b = b\n\n@singleton\nclass B:\n    @inject\n    def __init__(self, a: A):\n        self.a = a\n\n# \u2705 Break the cycle with a factory or interface\n@singleton\nclass A:\n    def set_b(self, b: \"B\"):\n        self.b = b\n\n@singleton\nclass B:\n    @inject\n    def __init__(self, a: A):\n        self.a = a\n        a.set_b(self)\n</code></pre>"},{"location":"core-concepts/container-pattern/#best-practices","title":"\ud83c\udfc6 Best Practices","text":""},{"location":"core-concepts/container-pattern/#1-use-modules-for-organization","title":"1. Use Modules for Organization","text":"<pre><code>from injectq import Module, InjectQ, singleton\nfrom abc import ABC, abstractmethod\n\n# Define interfaces and implementations\nclass Database(ABC):\n    @abstractmethod\n    def query(self, sql: str):\n        pass\n\n@singleton\nclass PostgreSQLDatabase(Database):\n    def query(self, sql: str):\n        return f\"PostgreSQL: {sql}\"\n\n# \u2705 Organize with modules\nclass DatabaseModule(Module):\n    def configure(self, binder):\n        binder.bind(Database, PostgreSQLDatabase)\n\ncontainer = InjectQ(modules=[DatabaseModule()])\n</code></pre>"},{"location":"core-concepts/container-pattern/#2-validate-early","title":"2. Validate Early","text":"<pre><code>from injectq import InjectQ\n\n# \u2705 Validate configuration\ncontainer = InjectQ()\n# ... register services ...\ncontainer.validate()  # Check for errors early\n</code></pre>"},{"location":"core-concepts/container-pattern/#3-use-appropriate-scopes","title":"3. Use Appropriate Scopes","text":"<pre><code># \u2705 Correct scope usage\n@singleton\nclass Database:  # Shared across app\n    pass\n\n@scoped(\"request\")\nclass RequestContext:  # Per request\n    pass\n\n@transient\nclass CommandHandler:  # New each time\n    pass\n</code></pre>"},{"location":"core-concepts/container-pattern/#4-handle-cleanup","title":"4. Handle Cleanup","text":"<pre><code># \u2705 Proper cleanup\n@resource\ndef database_connection():\n    conn = create_connection()\n    try:\n        yield conn\n    finally:\n        conn.close()\n</code></pre>"},{"location":"core-concepts/container-pattern/#summary","title":"\ud83c\udfaf Summary","text":"<p>The Container Pattern provides:</p> <ul> <li>Automatic dependency resolution - No manual wiring</li> <li>Centralized configuration - All setup in one place</li> <li>Lifetime management - Automatic creation/cleanup</li> <li>Testability - Easy dependency replacement</li> <li>Performance - Caching and optimization</li> <li>Maintainability - Clear separation of concerns</li> </ul> <p>InjectQ's container is designed to be: - Simple - Easy to get started - Powerful - Advanced features when needed - Fast - Optimized for performance - Testable - Built-in testing support</p> <p>Ready to explore service lifetimes?</p>"},{"location":"core-concepts/service-lifetimes/","title":"Service Lifetimes","text":"<p>Service lifetimes (also called scopes) control how long service instances live and when they are created. This guide explains the different lifetime options in InjectQ and when to use each one.</p>"},{"location":"core-concepts/service-lifetimes/#what-are-service-lifetimes","title":"\ud83c\udfaf What are Service Lifetimes?","text":"<p>Service lifetimes determine:</p> <ol> <li>When a service instance is created</li> <li>How long it lives</li> <li>When it gets cleaned up</li> <li>Whether instances are shared or unique</li> </ol>"},{"location":"core-concepts/service-lifetimes/#available-lifetimes","title":"\ud83d\udd04 Available Lifetimes","text":"<p>InjectQ provides several built-in lifetimes:</p>"},{"location":"core-concepts/service-lifetimes/#1-singleton-default","title":"1. Singleton (Default)","text":"<p>One instance for the entire application lifetime.</p> <pre><code>from injectq import InjectQ, singleton\n\n# Explicit singleton\n@singleton\nclass Database:\n    def __init__(self):\n        self.connection_id = id(self)\n        print(f\"Database created: {self.connection_id}\")\n\n# Or bind with scope\ncontainer = InjectQ()\ncontainer.bind(Database, Database, scope=\"singleton\")\n\n# Usage\ndb1 = container.get(Database)\ndb2 = container.get(Database)\nprint(f\"Same instance? {db1 is db2}\")  # True\n</code></pre> <p>When to use: - Database connections - Configuration objects - Caching services - Logging services - Any expensive resource that can be shared</p> <p>Pros: - Memory efficient (one instance) - Fast (no creation overhead) - Thread-safe sharing</p> <p>Cons: - Cannot store request-specific data - Harder to test in isolation</p>"},{"location":"core-concepts/service-lifetimes/#2-transient","title":"2. Transient","text":"<p>New instance every time the service is requested.</p> <pre><code>from injectq import transient\n\n@transient\nclass RequestProcessor:\n    def __init__(self):\n        self.instance_id = id(self)\n        print(f\"Processor created: {self.instance_id}\")\n\n# Usage\nproc1 = container.get(RequestProcessor)\nproc2 = container.get(RequestProcessor)\nprint(f\"Different instances? {proc1 is not proc2}\")  # True\n</code></pre> <p>When to use: - Request handlers - Command processors - Validators - Any service that needs to be stateless</p> <p>Pros: - Clean state for each use - Easy to test - No shared state issues</p> <p>Cons: - Memory overhead (many instances) - Creation overhead - Cannot cache data between calls</p>"},{"location":"core-concepts/service-lifetimes/#3-scoped","title":"3. Scoped","text":"<p>One instance per scope (request, session, etc.).</p> <pre><code>from injectq import InjectQ, scoped\n\n@scoped(\"request\")\nclass RequestContext:\n    def __init__(self):\n        self.request_id = id(self)\n        self.user_id = None\n        self.start_time = time.time()\n\n# Usage\ncontainer = InjectQ()\n\nasync with container.scope(\"request\"):\n    ctx1 = container.get(RequestContext)\n    # Do work...\n    ctx1.user_id = 123\n\n    # Same instance in same scope\n    ctx2 = container.get(RequestContext)\n    print(f\"Same context? {ctx1 is ctx2}\")  # True\n    print(f\"User ID: {ctx2.user_id}\")  # 123\n\n# New scope = new instance\nasync with container.scope(\"request\"):\n    ctx3 = container.get(RequestContext)\n    print(f\"New context? {ctx1 is not ctx3}\")  # True\n</code></pre> <p>When to use: - Request context data - User session data - Transaction contexts - Per-operation state</p> <p>Pros: - Shared within logical unit - Automatic cleanup - Request-scoped caching</p> <p>Cons: - More complex to manage - Requires scope management</p>"},{"location":"core-concepts/service-lifetimes/#built-in-scopes","title":"\ud83c\udfd7\ufe0f Built-in Scopes","text":"<p>InjectQ provides several built-in scopes:</p>"},{"location":"core-concepts/service-lifetimes/#singleton-scope","title":"Singleton Scope","text":"<p>Lives for the entire application lifetime:</p> <pre><code>from injectq import ScopeType\n\ncontainer.bind(AppConfig, scope=ScopeType.SINGLETON)\ncontainer.bind(Database, scope=ScopeType.SINGLETON)\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#request-scope","title":"Request Scope","text":"<p>Lives for the duration of a request:</p> <pre><code>container.bind(RequestContext, scope=Scope.REQUEST)\ncontainer.bind(UserSession, scope=Scope.REQUEST)\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#action-scope","title":"Action Scope","text":"<p>Lives for the duration of an action/method:</p> <pre><code>container.bind(ActionContext, scope=Scope.ACTION)\ncontainer.bind(ValidationContext, scope=Scope.ACTION)\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#transient-scope","title":"Transient Scope","text":"<p>Always creates new instances (same as <code>@transient</code>):</p> <pre><code>container.bind(CommandHandler, scope=Scope.TRANSIENT)\ncontainer.bind(Validator, scope=Scope.TRANSIENT)\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#custom-scopes","title":"\ud83c\udfa8 Custom Scopes","text":"<p>You can create custom scopes for specific needs:</p> <pre><code>from injectq import Scope, ScopeManager\n\nclass TaskScope(Scope):\n    \"\"\"Scope that lives for the duration of a background task.\"\"\"\n\n    def __init__(self):\n        self.task_id = None\n        self.start_time = None\n\n    def enter(self):\n        \"\"\"Called when entering the scope.\"\"\"\n        self.task_id = f\"task_{uuid.uuid4().hex[:8]}\"\n        self.start_time = time.time()\n        print(f\"Starting task: {self.task_id}\")\n\n    def exit(self):\n        \"\"\"Called when exiting the scope.\"\"\"\n        duration = time.time() - self.start_time\n        print(f\"Task {self.task_id} completed in {duration:.2f}s\")\n\n# Register custom scope\nscope_manager = container._scope_manager\nscope_manager.register_scope(\"task\", TaskScope())\n\n# Use custom scope\n@scoped(\"task\")\nclass TaskProcessor:\n    def __init__(self):\n        self.task_id = None\n\n    def set_task_id(self, task_id: str):\n        self.task_id = task_id\n\n# Usage\nasync with container.scope(\"task\"):\n    processor = container.get(TaskProcessor)\n    processor.set_task_id(\"process_data\")\n    # Do task work...\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#lifetime-examples","title":"\ud83d\udd04 Lifetime Examples","text":""},{"location":"core-concepts/service-lifetimes/#example-1-web-application","title":"Example 1: Web Application","text":"<pre><code>from injectq import InjectQ, singleton, scoped, transient\n\ncontainer = InjectQ()\n\n# Application-wide services\n@singleton\nclass Database:\n    pass\n\n@singleton\nclass Cache:\n    pass\n\n# Request-scoped services\n@scoped(\"request\")\nclass RequestContext:\n    def __init__(self):\n        self.user_id = None\n        self.request_id = str(uuid.uuid4())\n\n@scoped(\"request\")\nclass UserSession:\n    def __init__(self, context: RequestContext):\n        self.context = context\n        self.user_data = {}\n\n# Transient services\n@transient\nclass EmailSender:\n    def send(self, to: str, subject: str, body: str):\n        print(f\"Sending email to {to}: {subject}\")\n\n# Usage in request handler\n@inject\nasync def handle_request(\n    db: Database,\n    cache: Cache,\n    context: RequestContext,\n    session: UserSession,\n    email_sender: EmailSender\n):\n    # db and cache are shared across all requests\n    # context and session are unique to this request\n    # email_sender is new for this handler\n\n    context.user_id = 123\n    session.user_data[\"last_login\"] = datetime.now()\n\n    # Each call gets a new email_sender\n    email_sender.send(\"user@example.com\", \"Welcome\", \"Hello!\")\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#example-2-background-job-processing","title":"Example 2: Background Job Processing","text":"<pre><code>@singleton\nclass JobQueue:\n    pass\n\n@scoped(\"job\")\nclass JobContext:\n    def __init__(self):\n        self.job_id = None\n        self.start_time = time.time()\n        self.progress = 0\n\n@transient\nclass FileProcessor:\n    def process(self, file_path: str) -&gt; dict:\n        # Process file and return results\n        return {\"processed\": True, \"file\": file_path}\n\n@inject\nasync def process_job(\n    queue: JobQueue,\n    context: JobContext,\n    processor: FileProcessor\n):\n    # queue is shared\n    # context is per-job\n    # processor is new each time\n\n    files = [\"file1.txt\", \"file2.txt\", \"file3.txt\"]\n\n    for file_path in files:\n        # Each iteration gets a new processor\n        result = processor.process(file_path)\n        context.progress += 1\n        print(f\"Processed {file_path}: {result}\")\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#performance-considerations","title":"\u26a1 Performance Considerations","text":""},{"location":"core-concepts/service-lifetimes/#memory-usage","title":"Memory Usage","text":"<pre><code># Singleton - Low memory usage\n@singleton\nclass HeavyService:\n    def __init__(self):\n        self.data = {}  # Large data structure\n\n# Transient - High memory usage\n@transient\nclass LightService:\n    def __init__(self):\n        self.temp_data = []  # Small data structure\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#creation-overhead","title":"Creation Overhead","text":"<pre><code># Singleton - Created once\n@singleton\nclass ExpensiveService:\n    def __init__(self):\n        time.sleep(1)  # Expensive initialization\n\n# Transient - Created every time\n@transient\nclass CheapService:\n    def __init__(self):\n        pass  # Cheap initialization\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#thread-safety","title":"Thread Safety","text":"<pre><code># Singleton - Must be thread-safe\n@singleton\nclass SharedCache:\n    def __init__(self):\n        self._data = {}\n        self._lock = threading.Lock()\n\n    def get(self, key):\n        with self._lock:\n            return self._data.get(key)\n\n    def set(self, key, value):\n        with self._lock:\n            self._data[key] = value\n\n# Transient - No thread safety concerns\n@transient\nclass RequestHandler:\n    def __init__(self):\n        self.request_data = {}\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#testing-different-lifetimes","title":"\ud83e\uddea Testing Different Lifetimes","text":""},{"location":"core-concepts/service-lifetimes/#testing-singletons","title":"Testing Singletons","text":"<pre><code>def test_singleton_behavior():\n    with test_container() as container:\n        container.bind(Database, MockDatabase)\n\n        # Should be same instance\n        db1 = container.get(Database)\n        db2 = container.get(Database)\n        assert db1 is db2\n\n        # Test the singleton\n        db1.connect()\n        assert db2.is_connected()\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#testing-scoped-services","title":"Testing Scoped Services","text":"<pre><code>def test_scoped_behavior():\n    with test_container() as container:\n        container.bind(RequestContext, RequestContext, scope=\"request\")\n\n        # Outside scope - should fail\n        with pytest.raises(DependencyNotFoundError):\n            container.get(RequestContext)\n\n        # Inside scope\n        with container.scope(\"request\"):\n            ctx1 = container.get(RequestContext)\n            ctx2 = container.get(RequestContext)\n            assert ctx1 is ctx2\n\n        # New scope - new instance\n        with container.scope(\"request\"):\n            ctx3 = container.get(RequestContext)\n            assert ctx1 is not ctx3\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#testing-transients","title":"Testing Transients","text":"<pre><code>def test_transient_behavior():\n    with test_container() as container:\n        container.bind(Processor, Processor, scope=\"transient\")\n\n        proc1 = container.get(Processor)\n        proc2 = container.get(Processor)\n\n        # Should be different instances\n        assert proc1 is not proc2\n        assert proc1.instance_id != proc2.instance_id\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#common-lifetime-mistakes","title":"\ud83d\udea8 Common Lifetime Mistakes","text":""},{"location":"core-concepts/service-lifetimes/#1-wrong-scope-for-shared-data","title":"1. Wrong Scope for Shared Data","text":"<pre><code># \u274c Wrong - request data in singleton\n@singleton\nclass UserContext:\n    def __init__(self):\n        self.user_id = None  # Will be shared across requests!\n\n# \u2705 Correct - request-scoped\n@scoped(\"request\")\nclass UserContext:\n    def __init__(self):\n        self.user_id = None  # Unique per request\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#2-expensive-operations-in-transient","title":"2. Expensive Operations in Transient","text":"<pre><code># \u274c Wrong - expensive operation in transient\n@transient\nclass DatabaseConnection:\n    def __init__(self):\n        self.connection = create_expensive_connection()  # Called every time!\n\n# \u2705 Correct - singleton for expensive resources\n@singleton\nclass DatabaseConnection:\n    def __init__(self):\n        self.connection = create_expensive_connection()  # Called once\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#3-state-in-singletons","title":"3. State in Singletons","text":"<pre><code># \u274c Wrong - mutable state in singleton\n@singleton\nclass Cache:\n    def __init__(self):\n        self._data = {}  # Shared mutable state\n\n    def set_user_data(self, user_id, data):\n        self._data[user_id] = data  # Race conditions!\n\n# \u2705 Correct - thread-safe or scoped\n@singleton\nclass Cache:\n    def __init__(self):\n        self._data = {}\n        self._lock = threading.Lock()\n\n    def set_user_data(self, user_id, data):\n        with self._lock:\n            self._data[user_id] = data\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#best-practices","title":"\ud83c\udfc6 Best Practices","text":""},{"location":"core-concepts/service-lifetimes/#1-choose-the-right-lifetime","title":"1. Choose the Right Lifetime","text":"<pre><code># Singleton for shared resources\n@singleton\nclass DatabaseConnection:\n    pass\n\n# Scoped for request-specific data\n@scoped(\"request\")\nclass RequestContext:\n    pass\n\n# Transient for stateless operations\n@transient\nclass EmailValidator:\n    pass\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#2-consider-thread-safety","title":"2. Consider Thread Safety","text":"<pre><code># Make singletons thread-safe\n@singleton\nclass SharedService:\n    def __init__(self):\n        self._lock = threading.Lock()\n\n    def do_work(self):\n        with self._lock:\n            # Thread-safe operations\n            pass\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#3-use-appropriate-scopes","title":"3. Use Appropriate Scopes","text":"<pre><code># Web application scopes\ncontainer.bind(UserSession, scope=Scope.REQUEST)\ncontainer.bind(Transaction, scope=Scope.REQUEST)\n\n# Background job scopes\ncontainer.bind(JobContext, scope=\"job\")\ncontainer.bind(TaskProgress, scope=\"job\")\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#4-handle-cleanup","title":"4. Handle Cleanup","text":"<pre><code># Use resource management for cleanup\n@resource\ndef database_connection():\n    conn = create_connection()\n    try:\n        yield conn\n    finally:\n        conn.close()\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#5-test-lifetime-behavior","title":"5. Test Lifetime Behavior","text":"<pre><code>def test_lifetimes():\n    # Test singleton behavior\n    # Test scoped behavior\n    # Test transient behavior\n    pass\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#summary","title":"\ud83c\udfaf Summary","text":"<p>Service lifetimes control:</p> <ul> <li>Singleton: One instance for the entire application</li> <li>Transient: New instance every time</li> <li>Scoped: One instance per scope (request, session, etc.)</li> <li>Custom: User-defined scopes for specific needs</li> </ul> <p>Choose the right lifetime based on:</p> <ul> <li>Sharing needs: Shared vs. isolated state</li> <li>Performance: Creation overhead vs. memory usage</li> <li>Thread safety: Concurrent access patterns</li> <li>Testing: Isolation requirements</li> </ul> <p>Key principles:</p> <ul> <li>Use singleton for expensive shared resources</li> <li>Use scoped for request/session specific data</li> <li>Use transient for stateless operations</li> <li>Always consider thread safety for singletons</li> <li>Test your lifetime choices</li> </ul> <p>Ready to explore type safety in InjectQ?</p>"},{"location":"core-concepts/type-safety/","title":"Type Safety","text":"<p>InjectQ is designed with type safety as a first-class concern. This guide explains how InjectQ leverages Python's type hints to catch errors early and provide better IDE support.</p>"},{"location":"core-concepts/type-safety/#what-is-type-safety","title":"\ud83c\udfaf What is Type Safety?","text":"<p>Type safety means catching type-related errors before your code runs, not during runtime.</p>"},{"location":"core-concepts/type-safety/#without-type-safety","title":"Without Type Safety","text":"<pre><code># \u274c Runtime errors possible\ndef process_user(user_data):\n    return user_data[\"name\"]  # What if user_data is None?\n\nuser = None\nresult = process_user(user)  # Runtime error!\n</code></pre>"},{"location":"core-concepts/type-safety/#with-type-safety","title":"With Type Safety","text":"<pre><code># \u2705 Type checker catches the error\nfrom typing import Optional\n\ndef process_user(user_data: Optional[dict]) -&gt; str:\n    if user_data is None:\n        return \"Unknown User\"\n    return user_data.get(\"name\", \"Unknown\")\n\nuser: Optional[dict] = None\nresult = process_user(user)  # \u2705 Safe\n</code></pre>"},{"location":"core-concepts/type-safety/#injectqs-type-safety-features","title":"\ud83d\udd27 InjectQ's Type Safety Features","text":""},{"location":"core-concepts/type-safety/#1-type-hints-support","title":"1. Type Hints Support","text":"<p>InjectQ automatically resolves dependencies based on type hints:</p> <pre><code>from injectq import inject, singleton\n\n@singleton\nclass Database:\n    def query(self, sql: str) -&gt; list:\n        return []\n\n@singleton\nclass UserService:\n    @inject\n    def __init__(self, db: Database):\n        self.db = db\n\n    def get_users(self) -&gt; list:\n        return self.db.query(\"SELECT * FROM users\")\n\n# Type-safe injection\n@inject\ndef process_users(service: UserService) -&gt; None:\n    users = service.get_users()  # Type: list\n    print(f\"Found {len(users)} users\")\n</code></pre>"},{"location":"core-concepts/type-safety/#2-protocol-support","title":"2. Protocol Support","text":"<p>Use protocols (interfaces) for flexible, type-safe design:</p> <pre><code>from typing import Protocol\nfrom injectq import inject, singleton\n\nclass DatabaseProtocol(Protocol):\n    def query(self, sql: str) -&gt; list:\n        ...\n\n@singleton\nclass PostgreSQLDatabase:\n    def query(self, sql: str) -&gt; list:\n        return []\n\n@singleton\nclass UserService:\n    @inject\n    def __init__(self, db: DatabaseProtocol):\n        self.db = db\n\n    def get_users(self) -&gt; list:\n        return self.db.query(\"SELECT * FROM users\")\n</code></pre>"},{"location":"core-concepts/type-safety/#early-error-detection","title":"\ud83d\udee1\ufe0f Early Error Detection","text":"<p>InjectQ catches errors during startup, not at runtime:</p>"},{"location":"core-concepts/type-safety/#missing-dependencies","title":"Missing Dependencies","text":"<pre><code>from injectq import InjectQ, singleton, inject\nfrom injectq.utils import DependencyNotFoundError\n\n@singleton\nclass Database:\n    pass\n\n@singleton\nclass UserService:\n    @inject\n    def __init__(self, db: Database, cache: \"Cache\"):  # Cache not registered\n        self.db = db\n        self.cache = cache\n\ncontainer = InjectQ.get_instance()\n\n# This will raise an error during validation\ntry:\n    container.validate()\nexcept DependencyNotFoundError as e:\n    print(f\"Missing dependency: {e}\")\n</code></pre>"},{"location":"core-concepts/type-safety/#circular-dependencies","title":"Circular Dependencies","text":"<pre><code>from injectq import singleton, inject\n\n@singleton\nclass A:\n    @inject\n    def __init__(self, b: \"B\"):\n        self.b = b\n\n@singleton\nclass B:\n    @inject\n    def __init__(self, a: A):  # \u274c Circular!\n        self.a = a\n\n# Detected during validation\ncontainer.validate()  # Raises CircularDependencyError\n</code></pre>"},{"location":"core-concepts/type-safety/#mypy-integration","title":"\ud83d\udd0d MyPy Integration","text":"<p>InjectQ works with mypy and other type checkers:</p> <pre><code>from typing import Optional\nfrom injectq import inject, singleton\n\n@singleton\nclass Database:\n    def query(self, sql: str) -&gt; list[dict]:\n        return []\n\n@singleton\nclass UserService:\n    @inject\n    def __init__(self, db: Database) -&gt; None:\n        self.db = db\n\n    def get_user(self, user_id: int) -&gt; Optional[dict]:\n        results = self.db.query(f\"SELECT * FROM users WHERE id = {user_id}\")\n        return results[0] if results else None\n\n# MyPy will check types automatically\n@inject\ndef process(service: UserService) -&gt; None:\n    user = service.get_user(1)\n    if user:\n        print(user[\"name\"])  # Type checker knows user is dict\n</code></pre>"},{"location":"core-concepts/type-safety/#testing-with-type-safety","title":"\ud83e\uddea Testing with Type Safety","text":"<p>Use type-safe mocks for testing:</p> <pre><code>from typing import Protocol\nfrom injectq.testing import test_container\nfrom injectq import inject, singleton\n\nclass DatabaseProtocol(Protocol):\n    def query(self, sql: str) -&gt; list[dict]:\n        ...\n\nclass MockDatabase:\n    def query(self, sql: str) -&gt; list[dict]:\n        return [{\"id\": 1, \"name\": \"Test User\"}]\n\n@singleton\nclass UserService:\n    @inject\n    def __init__(self, db: DatabaseProtocol):\n        self.db = db\n\ndef test_user_service():\n    with test_container() as container:\n        container.bind(DatabaseProtocol, MockDatabase)\n        container.bind(UserService, UserService)\n\n        service = container[UserService]\n        users = service.get_users()  # Type: list[dict]\n        assert len(users) == 1\n</code></pre>"},{"location":"core-concepts/type-safety/#common-mistakes","title":"\ud83d\udea8 Common Mistakes","text":""},{"location":"core-concepts/type-safety/#1-missing-type-hints","title":"1. Missing Type Hints","text":"<pre><code># \u274c Bad - no type hints\nclass UserService:\n    def __init__(self, repository):\n        self.repository = repository\n\n    def get_user(self, user_id):\n        return self.repository.get_by_id(user_id)\n\n# \u2705 Good - with type hints\nfrom typing import Optional\n\nclass UserService:\n    def __init__(self, repository: DatabaseProtocol):\n        self.repository = repository\n\n    def get_user(self, user_id: int) -&gt; Optional[dict]:\n        return self.repository.get_by_id(user_id)\n</code></pre>"},{"location":"core-concepts/type-safety/#2-not-handling-optional","title":"2. Not Handling Optional","text":"<pre><code>from typing import Optional\n\n# \u274c Bad - user could be None\n@inject\ndef process_user(service: UserService, user_id: int) -&gt; str:\n    user = service.get_user(user_id)  # Returns Optional[dict]\n    return user[\"name\"]  # Crash if None!\n\n# \u2705 Good - handle None\n@inject\ndef process_user(service: UserService, user_id: int) -&gt; str:\n    user = service.get_user(user_id)\n    return user[\"name\"] if user else \"Unknown\"\n</code></pre>"},{"location":"core-concepts/type-safety/#best-practices","title":"\ud83c\udfc6 Best Practices","text":""},{"location":"core-concepts/type-safety/#1-always-use-type-hints","title":"1. Always Use Type Hints","text":"<pre><code>from injectq import inject, singleton\n\n# \u2705 All parameters and returns have types\n@singleton\nclass UserService:\n    @inject\n    def __init__(self, db: Database) -&gt; None:\n        self.db = db\n\n    def get_user(self, user_id: int) -&gt; Optional[dict]:\n        return self.db.query_one(f\"SELECT * FROM users WHERE id = {user_id}\")\n</code></pre>"},{"location":"core-concepts/type-safety/#2-use-protocols-for-interfaces","title":"2. Use Protocols for Interfaces","text":"<pre><code>from typing import Protocol\n\n# \u2705 Define clear interfaces\nclass CacheProtocol(Protocol):\n    def get(self, key: str) -&gt; Optional[str]:\n        ...\n\n    def set(self, key: str, value: str) -&gt; None:\n        ...\n\n# Implementation can be swapped easily\n@singleton\nclass RedisCache:\n    def get(self, key: str) -&gt; Optional[str]:\n        return None\n\n    def set(self, key: str, value: str) -&gt; None:\n        pass\n</code></pre>"},{"location":"core-concepts/type-safety/#3-validate-early","title":"3. Validate Early","text":"<pre><code>from injectq import InjectQ\n\n# \u2705 Validate at startup\ncontainer = InjectQ.get_instance()\n\ntry:\n    container.validate()\n    print(\"\u2705 Container is valid\")\nexcept Exception as e:\n    print(f\"\u274c Configuration error: {e}\")\n    exit(1)\n</code></pre>"},{"location":"core-concepts/type-safety/#summary","title":"\ud83c\udfaf Summary","text":"<p>InjectQ's type safety provides:</p> <ul> <li>Type hints everywhere - Full Python typing support</li> <li>Protocol support - Interface-based design</li> <li>Early error detection - Catch issues at startup, not runtime</li> <li>IDE support - Autocomplete and inline errors</li> <li>MyPy compatibility - Works with static type checkers</li> </ul> <p>Key takeaways:</p> <p>\u2705 Always add type hints to your classes and functions \u2705 Use protocols for flexible, testable interfaces \u2705 Handle <code>Optional</code> types properly \u2705 Validate your container configuration at startup \u2705 Let type checkers catch errors before running code</p> <p>Ready to explore injection patterns?</p>"},{"location":"core-concepts/what-is-di/","title":"What is Dependency Injection?","text":"<p>Dependency Injection (DI) is a design pattern that helps you write more maintainable, testable, and flexible code. This guide explains what DI is, why it's useful, and how InjectQ implements it.</p>"},{"location":"core-concepts/what-is-di/#what-is-dependency-injection_1","title":"\ud83c\udfaf What is Dependency Injection?","text":"<p>Dependency Injection is a technique where objects receive their dependencies from an external source rather than creating them internally.</p>"},{"location":"core-concepts/what-is-di/#without-dependency-injection","title":"Without Dependency Injection","text":"<pre><code>class UserService:\n    def __init__(self):\n        # Service creates its own dependencies\n        self.db = Database()  # \u274c Tight coupling\n        self.cache = Cache()  # \u274c Hard to test\n\n    def get_user(self, user_id):\n        return self.db.query(f\"SELECT * FROM users WHERE id = {user_id}\")\n</code></pre> <p>Problems: - Hard to test (can't mock dependencies) - Hard to change implementations - Tight coupling between classes - Difficult to reuse in different contexts</p>"},{"location":"core-concepts/what-is-di/#with-dependency-injection","title":"With Dependency Injection","text":"<pre><code>class UserService:\n    def __init__(self, db: Database, cache: Cache):\n        # Dependencies are injected\n        self.db = db\n        self.cache = cache\n\n# Somewhere else (composition root)\ndb = Database()\ncache = Cache()\nuser_service = UserService(db, cache)  # \u2705 Loose coupling\n</code></pre> <p>Benefits: - Easy to test (can inject mocks) - Easy to change implementations - Loose coupling between classes - Highly reusable components</p>"},{"location":"core-concepts/what-is-di/#the-dependency-injection-container","title":"\ud83c\udfd7\ufe0f The Dependency Injection Container","text":"<p>A DI Container is a framework that automatically manages dependency resolution and injection.</p>"},{"location":"core-concepts/what-is-di/#manual-dependency-resolution","title":"Manual Dependency Resolution","text":"<pre><code># Without a container - manual wiring\ndef create_user_service():\n    config = DatabaseConfig(\"postgresql://...\")\n    db = Database(config)\n    cache = RedisCache(\"redis://...\")\n    logger = Logger(\"user_service\")\n    return UserService(db, cache, logger)\n\n# Usage\nservice = create_user_service()\n</code></pre> <p>Problems: - Repetitive boilerplate code - Error-prone manual wiring - Hard to maintain as dependencies grow</p>"},{"location":"core-concepts/what-is-di/#with-a-di-container","title":"With a DI Container","text":"<pre><code>from injectq import injectq, inject\n\n# Container automatically wires dependencies\ncontainer = injectq\n\n# Bind implementations\ncontainer.bind(DatabaseConfig, DatabaseConfig)\ncontainer.bind(Database, Database)\ncontainer.bind(Cache, RedisCache)\n\n# Usage - automatic resolution\n@inject\ndef process_user(service: UserService):\n    # All dependencies automatically injected\n    pass\n\nprocess_user()  # No manual wiring needed!\n</code></pre>"},{"location":"core-concepts/what-is-di/#types-of-dependency-injection","title":"\ud83c\udfad Types of Dependency Injection","text":""},{"location":"core-concepts/what-is-di/#1-constructor-injection-recommended","title":"1. Constructor Injection (Recommended)","text":"<p>Dependencies are passed through the constructor:</p> <pre><code>class UserService:\n    def __init__(self, db: Database, cache: Cache):\n        self.db = db\n        self.cache = cache\n</code></pre> <p>Pros: - Dependencies are explicit and clear - Immutable after construction - Easy to test - Fail fast if dependencies are missing</p>"},{"location":"core-concepts/what-is-di/#2-property-injection","title":"2. Property Injection","text":"<p>Dependencies are set via properties:</p> <pre><code>class UserService:\n    def __init__(self):\n        self._db = None\n        self._cache = None\n\n    @property\n    def db(self):\n        return self._db\n\n    @db.setter\n    def db(self, value):\n        self._db = value\n</code></pre> <p>Pros: - Can change dependencies at runtime - Optional dependencies possible</p> <p>Cons: - Dependencies not guaranteed to be set - Harder to test - Less explicit</p>"},{"location":"core-concepts/what-is-di/#3-method-injection","title":"3. Method Injection","text":"<p>Dependencies are passed to specific methods:</p> <pre><code>class UserService:\n    def process_user(self, user_id: int, db: Database):\n        # db is injected only for this method\n        pass\n</code></pre> <p>Pros: - Fine-grained control - Dependencies only where needed</p> <p>Cons: - Verbose - Easy to forget to pass dependencies</p>"},{"location":"core-concepts/what-is-di/#inversion-of-control-ioc","title":"\ud83d\udd04 Inversion of Control (IoC)","text":"<p>Inversion of Control is the principle behind DI. Instead of your code controlling dependency creation, the container controls it.</p>"},{"location":"core-concepts/what-is-di/#traditional-control-flow","title":"Traditional Control Flow","text":"<pre><code>Your Code \u2192 Creates Database \u2192 Creates Cache \u2192 Creates Service\n</code></pre>"},{"location":"core-concepts/what-is-di/#inverted-control-flow","title":"Inverted Control Flow","text":"<pre><code>Container \u2192 Creates Database \u2192 Creates Cache \u2192 Injects into Service \u2192 Your Code\n</code></pre>"},{"location":"core-concepts/what-is-di/#benefits-of-dependency-injection","title":"\ud83c\udfaf Benefits of Dependency Injection","text":""},{"location":"core-concepts/what-is-di/#1-testability","title":"1. Testability","text":"<pre><code>def test_user_service():\n    # Easy to inject mocks\n    mock_db = MockDatabase()\n    mock_cache = MockCache()\n\n    service = UserService(mock_db, mock_cache)\n\n    # Test the service in isolation\n    result = service.get_user(1)\n    assert result is not None\n</code></pre>"},{"location":"core-concepts/what-is-di/#2-flexibility","title":"2. Flexibility","text":"<pre><code># Easy to swap implementations\nif environment == \"production\":\n    container.bind(Database, PostgreSQLDatabase)\nelif environment == \"testing\":\n    container.bind(Database, InMemoryDatabase)\nelse:\n    container.bind(Database, SQLiteDatabase)\n</code></pre>"},{"location":"core-concepts/what-is-di/#3-maintainability","title":"3. Maintainability","text":"<pre><code># Adding a new dependency is easy\nclass UserService:\n    def __init__(self, db: Database, cache: Cache, logger: Logger):\n        self.db = db\n        self.cache = cache\n        self.logger = logger  # New dependency\n</code></pre>"},{"location":"core-concepts/what-is-di/#4-separation-of-concerns","title":"4. Separation of Concerns","text":"<p>Each class focuses on its single responsibility:</p> <pre><code>class UserService:      # Business logic\nclass Database:         # Data persistence\nclass Cache:           # Caching\nclass Logger:          # Logging\n</code></pre>"},{"location":"core-concepts/what-is-di/#5-reusability","title":"5. Reusability","text":"<p>Components can be reused in different contexts:</p> <pre><code># Same UserService can be used in:\n# - Web API\n# - Background worker\n# - CLI tool\n# - Tests\n</code></pre>"},{"location":"core-concepts/what-is-di/#common-anti-patterns","title":"\ud83d\udea8 Common Anti-Patterns","text":""},{"location":"core-concepts/what-is-di/#1-service-locator","title":"1. Service Locator","text":"<pre><code>class UserService:\n    def __init__(self):\n        self.db = ServiceLocator.get(Database)  # \u274c Hidden dependency\n</code></pre> <p>Problems: - Dependencies not explicit - Harder to test - Tightly coupled to locator</p>"},{"location":"core-concepts/what-is-di/#2-factory-overload","title":"2. Factory Overload","text":"<pre><code>class UserServiceFactory:\n    def create(self):\n        db = DatabaseFactory.create()\n        cache = CacheFactory.create()\n        return UserService(db, cache)  # \u274c Manual wiring everywhere\n</code></pre> <p>Problems: - Boilerplate code - Error-prone - Hard to maintain</p>"},{"location":"core-concepts/what-is-di/#3-circular-dependencies","title":"3. Circular Dependencies","text":"<pre><code>class A:\n    def __init__(self, b: B):\n        self.b = b\n\nclass B:\n    def __init__(self, a: A):  # \u274c Circular dependency\n        self.a = a\n</code></pre> <p>Problems: - Impossible to resolve - Indicates poor design</p>"},{"location":"core-concepts/what-is-di/#best-practices","title":"\ud83c\udfc6 Best Practices","text":""},{"location":"core-concepts/what-is-di/#1-use-constructor-injection","title":"1. Use Constructor Injection","text":"<pre><code># \u2705 Good\nclass UserService:\n    def __init__(self, db: Database, cache: Cache):\n        self.db = db\n        self.cache = cache\n</code></pre>"},{"location":"core-concepts/what-is-di/#2-depend-on-abstractions","title":"2. Depend on Abstractions","text":"<pre><code># \u2705 Good - depend on interface/protocol\nclass UserService:\n    def __init__(self, repository: IUserRepository):\n        self.repository = repository\n</code></pre>"},{"location":"core-concepts/what-is-di/#3-single-responsibility","title":"3. Single Responsibility","text":"<pre><code># \u2705 Good - one reason to change\nclass UserService:\n    def __init__(self, repository: IUserRepository):\n        self.repository = repository\n\n    def get_user(self, id: int):\n        return self.repository.get_by_id(id)\n</code></pre>"},{"location":"core-concepts/what-is-di/#4-explicit-dependencies","title":"4. Explicit Dependencies","text":"<pre><code># \u2705 Good - all dependencies visible\n@inject\ndef process_order(\n    order_service: OrderService,\n    payment_service: PaymentService,\n    notification_service: NotificationService\n):\n    pass\n</code></pre>"},{"location":"core-concepts/what-is-di/#summary","title":"\ud83c\udf89 Summary","text":"<p>Dependency Injection is a powerful pattern that:</p> <ul> <li>Improves testability by allowing easy mocking</li> <li>Increases flexibility by enabling easy implementation swaps</li> <li>Enhances maintainability by reducing coupling</li> <li>Promotes reusability by creating focused components</li> <li>Enables better architecture through clear separation of concerns</li> </ul> <p>InjectQ makes DI easy by providing: - Multiple injection patterns (<code>@inject</code>, dict-like, manual) - Automatic dependency resolution - Powerful scoping mechanisms - Framework integrations - Testing utilities</p> <p>Ready to dive deeper? Check out the container pattern next!</p>"},{"location":"getting-started/first-app/","title":"Your First App","text":"<p>Let's build a complete application with InjectQ! We'll create a simple user management system that demonstrates real-world patterns.</p>"},{"location":"getting-started/first-app/#application-overview","title":"\ud83c\udfaf Application Overview","text":"<p>We'll build a user management API with:</p> <ul> <li>User repository for data access</li> <li>User service for business logic</li> <li>Configuration management</li> <li>Dependency injection throughout</li> <li>Proper error handling</li> </ul>"},{"location":"getting-started/first-app/#project-structure","title":"\ud83d\udcc1 Project Structure","text":"<pre><code>my_injectq_app/\n\u251c\u2500\u2500 main.py              # Application entry point\n\u251c\u2500\u2500 config.py            # Configuration classes\n\u251c\u2500\u2500 database.py          # Database layer\n\u251c\u2500\u2500 repository.py        # Data access layer\n\u251c\u2500\u2500 service.py           # Business logic layer\n\u2514\u2500\u2500 models.py            # Data models\n</code></pre>"},{"location":"getting-started/first-app/#step-1-define-data-models","title":"\ud83c\udfd7\ufe0f Step 1: Define Data Models","text":"<pre><code># models.py\nfrom dataclasses import dataclass\nfrom typing import Optional\nfrom datetime import datetime\n\n@dataclass\nclass User:\n    id: Optional[int]\n    username: str\n    email: str\n    created_at: datetime\n    is_active: bool = True\n\n@dataclass\nclass CreateUserRequest:\n    username: str\n    email: str\n\n@dataclass\nclass UpdateUserRequest:\n    username: Optional[str] = None\n    email: Optional[str] = None\n    is_active: Optional[bool] = None\n</code></pre>"},{"location":"getting-started/first-app/#step-2-configuration","title":"\u2699\ufe0f Step 2: Configuration","text":"<pre><code># config.py\nfrom injectq import singleton\n\n@singleton\nclass DatabaseConfig:\n    def __init__(self):\n        self.host = \"localhost\"\n        self.port = 5432\n        self.database = \"userdb\"\n        self.user = \"postgres\"\n        self.password = \"password\"\n\n    @property\n    def connection_string(self) -&gt; str:\n        return f\"postgresql://{self.user}:{self.password}@{self.host}:{self.port}/{self.database}\"\n\n@singleton\nclass AppConfig:\n    def __init__(self):\n        self.app_name = \"User Management API\"\n        self.version = \"1.0.0\"\n        self.debug = True\n</code></pre>"},{"location":"getting-started/first-app/#step-3-database-layer","title":"\ud83d\uddc4\ufe0f Step 3: Database Layer","text":"<pre><code># database.py\nfrom typing import List, Optional\nfrom injectq import singleton\nimport asyncio\n\nfrom .config import DatabaseConfig\nfrom .models import User\n\n@singleton\nclass Database:\n    def __init__(self, config: DatabaseConfig):\n        self.config = config\n        self._users = {}  # In-memory storage for demo\n        self._next_id = 1\n        print(f\"Database initialized with config: {config.connection_string}\")\n\n    async def create_user(self, user: User) -&gt; User:\n        \"\"\"Create a new user.\"\"\"\n        user.id = self._next_id\n        self._users[user.id] = user\n        self._next_id += 1\n        return user\n\n    async def get_user(self, user_id: int) -&gt; Optional[User]:\n        \"\"\"Get user by ID.\"\"\"\n        return self._users.get(user_id)\n\n    async def get_user_by_username(self, username: str) -&gt; Optional[User]:\n        \"\"\"Get user by username.\"\"\"\n        for user in self._users.values():\n            if user.username == username:\n                return user\n        return None\n\n    async def get_all_users(self) -&gt; List[User]:\n        \"\"\"Get all users.\"\"\"\n        return list(self._users.values())\n\n    async def update_user(self, user_id: int, updates: dict) -&gt; Optional[User]:\n        \"\"\"Update user.\"\"\"\n        user = self._users.get(user_id)\n        if not user:\n            return None\n\n        for key, value in updates.items():\n            if hasattr(user, key):\n                setattr(user, key, value)\n\n        return user\n\n    async def delete_user(self, user_id: int) -&gt; bool:\n        \"\"\"Delete user.\"\"\"\n        if user_id in self._users:\n            del self._users[user_id]\n            return True\n        return False\n</code></pre>"},{"location":"getting-started/first-app/#step-4-repository-layer","title":"\ud83d\udcca Step 4: Repository Layer","text":"<pre><code># repository.py\nfrom typing import List, Optional\nfrom injectq import singleton\n\nfrom .database import Database\nfrom .models import User, CreateUserRequest, UpdateUserRequest\n\n@singleton\nclass UserRepository:\n    def __init__(self, db: Database):\n        self.db = db\n\n    async def create(self, request: CreateUserRequest) -&gt; User:\n        \"\"\"Create a new user.\"\"\"\n        from datetime import datetime\n        user = User(\n            id=None,\n            username=request.username,\n            email=request.email,\n            created_at=datetime.now(),\n            is_active=True\n        )\n        return await self.db.create_user(user)\n\n    async def get_by_id(self, user_id: int) -&gt; Optional[User]:\n        \"\"\"Get user by ID.\"\"\"\n        return await self.db.get_user(user_id)\n\n    async def get_by_username(self, username: str) -&gt; Optional[User]:\n        \"\"\"Get user by username.\"\"\"\n        return await self.db.get_user_by_username(username)\n\n    async def get_all(self) -&gt; List[User]:\n        \"\"\"Get all users.\"\"\"\n        return await self.db.get_all_users()\n\n    async def update(self, user_id: int, request: UpdateUserRequest) -&gt; Optional[User]:\n        \"\"\"Update user.\"\"\"\n        updates = {}\n        if request.username is not None:\n            updates[\"username\"] = request.username\n        if request.email is not None:\n            updates[\"email\"] = request.email\n        if request.is_active is not None:\n            updates[\"is_active\"] = request.is_active\n\n        return await self.db.update_user(user_id, updates)\n\n    async def delete(self, user_id: int) -&gt; bool:\n        \"\"\"Delete user.\"\"\"\n        return await self.db.delete_user(user_id)\n</code></pre>"},{"location":"getting-started/first-app/#step-5-service-layer","title":"\ud83d\udd27 Step 5: Service Layer","text":"<pre><code># service.py\nfrom typing import List, Optional\nfrom injectq import singleton\n\nfrom .repository import UserRepository\nfrom .models import User, CreateUserRequest, UpdateUserRequest\n\n@singleton\nclass UserService:\n    def __init__(self, repo: UserRepository):\n        self.repo = repo\n\n    async def create_user(self, request: CreateUserRequest) -&gt; User:\n        \"\"\"Create a new user with validation.\"\"\"\n        # Check if username already exists\n        existing = await self.repo.get_by_username(request.username)\n        if existing:\n            raise ValueError(f\"Username '{request.username}' already exists\")\n\n        # Check if email already exists\n        # In a real app, you'd check this too\n        return await self.repo.create(request)\n\n    async def get_user(self, user_id: int) -&gt; Optional[User]:\n        \"\"\"Get user by ID.\"\"\"\n        return await self.repo.get_by_id(user_id)\n\n    async def get_user_by_username(self, username: str) -&gt; Optional[User]:\n        \"\"\"Get user by username.\"\"\"\n        return await self.repo.get_by_username(username)\n\n    async def get_all_users(self) -&gt; List[User]:\n        \"\"\"Get all users.\"\"\"\n        return await self.repo.get_all()\n\n    async def update_user(self, user_id: int, request: UpdateUserRequest) -&gt; Optional[User]:\n        \"\"\"Update user with validation.\"\"\"\n        # Check if user exists\n        existing = await self.repo.get_by_id(user_id)\n        if not existing:\n            return None\n\n        # Check username uniqueness if being updated\n        if request.username and request.username != existing.username:\n            duplicate = await self.repo.get_by_username(request.username)\n            if duplicate:\n                raise ValueError(f\"Username '{request.username}' already exists\")\n\n        return await self.repo.update(user_id, request)\n\n    async def delete_user(self, user_id: int) -&gt; bool:\n        \"\"\"Delete user.\"\"\"\n        return await self.repo.delete(user_id)\n\n    async def deactivate_user(self, user_id: int) -&gt; Optional[User]:\n        \"\"\"Deactivate user.\"\"\"\n        return await self.update_user(user_id, UpdateUserRequest(is_active=False))\n\n    async def activate_user(self, user_id: int) -&gt; Optional[User]:\n        \"\"\"Activate user.\"\"\"\n        return await self.update_user(user_id, UpdateUserRequest(is_active=True))\n</code></pre>"},{"location":"getting-started/first-app/#step-6-application-entry-point","title":"\ud83d\ude80 Step 6: Application Entry Point","text":"<pre><code># main.py\nimport asyncio\nfrom injectq import InjectQ, inject\n\nfrom .config import DatabaseConfig, AppConfig\nfrom .database import Database\nfrom .repository import UserRepository\nfrom .service import UserService\nfrom .models import CreateUserRequest, UpdateUserRequest\n\nasync def setup_container() -&gt; None:\n    \"\"\"Set up the dependency injection container using the public convenience container.\"\"\"\n    from injectq import InjectQ\n\n    # use the global convenience container directly\n    container = InjectQ.get_instance()\n\n    # Bind configurations\n    container[DatabaseConfig] = DatabaseConfig\n    container[AppConfig] = AppConfig\n\n    # Bind services (automatically resolved)\n    container[Database] = Database\n    container[UserRepository] = UserRepository\n    container[UserService] = UserService\n\n\n@inject\nasync def demo_user_operations(service: UserService, config: AppConfig):\n    \"\"\"Demonstrate user operations.\"\"\"\n    print(f\"\ud83d\ude80 {config.app_name} v{config.version}\")\n    print(\"=\" * 50)\n\n    # Create users\n    print(\"\\n\ud83d\udcdd Creating users...\")\n    user1 = await service.create_user(CreateUserRequest(\n        username=\"john_doe\",\n        email=\"john@example.com\"\n    ))\n    print(f\"Created user: {user1.username} (ID: {user1.id})\")\n\n    user2 = await service.create_user(CreateUserRequest(\n        username=\"jane_smith\",\n        email=\"jane@example.com\"\n    ))\n    print(f\"Created user: {user2.username} (ID: {user2.id})\")\n\n    # Get user\n    print(\"\\n\ud83d\udd0d Getting user...\")\n    retrieved = await service.get_user(user1.id)\n    if retrieved:\n        print(f\"Retrieved user: {retrieved.username}\")\n\n    # Update user\n    print(\"\\n\u270f\ufe0f  Updating user...\")\n    updated = await service.update_user(user1.id, UpdateUserRequest(\n        email=\"john.doe@example.com\"\n    ))\n    if updated:\n        print(f\"Updated user email: {updated.email}\")\n\n    # List all users\n    print(\"\\n\ud83d\udccb All users:\")\n    users = await service.get_all_users()\n    for user in users:\n        status = \"Active\" if user.is_active else \"Inactive\"\n        print(f\"  - {user.username} ({user.email}) - {status}\")\n\n    # Deactivate user\n    print(\"\\n\ud83d\udeab Deactivating user...\")\n    deactivated = await service.deactivate_user(user2.id)\n    if deactivated:\n        print(f\"Deactivated user: {deactivated.username}\")\n\n    # List users again\n    print(\"\\n\ud83d\udccb Users after deactivation:\")\n    users = await service.get_all_users()\n    for user in users:\n        status = \"Active\" if user.is_active else \"Inactive\"\n        print(f\"  - {user.username} ({user.email}) - {status}\")\n\nasync def main():\n    \"\"\"Main application entry point.\"\"\"\n    # Set up container\n    await setup_container()\n\n    # Run demo\n    await demo_user_operations()\n\n    print(\"\\n\u2705 Demo completed successfully!\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"getting-started/first-app/#step-7-running-the-application","title":"\ud83c\udfaf Step 7: Running the Application","text":"<p>Create the files above and run:</p> <pre><code>python main.py\n</code></pre> <p>You should see output like:</p> <pre><code>\ud83d\ude80 User Management API v1.0.0\n==================================================\n\n\ud83d\udcdd Creating users...\nDatabase initialized with config: postgresql://postgres:password@localhost:5432/userdb\nCreated user: john_doe (ID: 1)\nCreated user: jane_smith (ID: 2)\n\n\ud83d\udd0d Getting user...\nRetrieved user: john_doe\n\n\u270f\ufe0f  Updating user...\nUpdated user email: john.doe@example.com\n\n\ud83d\udccb All users:\n  - john_doe (john.doe@example.com) - Active\n  - jane_smith (jane@example.com) - Active\n\n\ud83d\udeab Deactivating user...\nDeactivated user: jane_smith\n\n\ud83d\udccb Users after deactivation:\n  - john_doe (john.doe@example.com) - Active\n  - jane_smith (jane@example.com) - Inactive\n\n\u2705 Demo completed successfully!\n</code></pre>"},{"location":"getting-started/first-app/#step-8-adding-error-handling","title":"\ud83d\udd27 Step 8: Adding Error Handling","text":"<p>Let's enhance our application with proper error handling:</p> <pre><code># Add to service.py\nclass UserServiceError(Exception):\n    \"\"\"Base exception for user service errors.\"\"\"\n    pass\n\nclass UserNotFoundError(UserServiceError):\n    \"\"\"Raised when a user is not found.\"\"\"\n    pass\n\nclass UserAlreadyExistsError(UserServiceError):\n    \"\"\"Raised when trying to create a user that already exists.\"\"\"\n    pass\n\n# Update UserService methods\nasync def get_user(self, user_id: int) -&gt; User:\n    \"\"\"Get user by ID.\"\"\"\n    user = await self.repo.get_by_id(user_id)\n    if not user:\n        raise UserNotFoundError(f\"User with ID {user_id} not found\")\n    return user\n\nasync def create_user(self, request: CreateUserRequest) -&gt; User:\n    \"\"\"Create a new user with validation.\"\"\"\n    # Check if username already exists\n    existing = await self.repo.get_by_username(request.username)\n    if existing:\n        raise UserAlreadyExistsError(f\"Username '{request.username}' already exists\")\n\n    return await self.repo.create(request)\n</code></pre>"},{"location":"getting-started/first-app/#step-9-adding-tests","title":"\ud83e\uddea Step 9: Adding Tests","text":"<pre><code># tests/test_user_service.py\nimport pytest\nfrom injectq.testing import test_container\n\nfrom ..service import UserService\nfrom ..models import CreateUserRequest\n\nclass MockRepository:\n    def __init__(self):\n        self.users = {}\n\n    async def create(self, request):\n        # Mock implementation\n        from ..models import User\n        from datetime import datetime\n        user = User(\n            id=len(self.users) + 1,\n            username=request.username,\n            email=request.email,\n            created_at=datetime.now()\n        )\n        self.users[user.id] = user\n        return user\n\n    async def get_by_id(self, user_id):\n        return self.users.get(user_id)\n\n@pytest.mark.asyncio\nasync def test_create_user():\n    with test_container() as container:\n        # Bind mock repository\n        mock_repo = MockRepository()\n        container[UserRepository] = mock_repo\n\n        # Bind service\n        container[UserService] = UserService\n\n        service = container[UserService]\n\n        # Test user creation\n        request = CreateUserRequest(username=\"test\", email=\"test@example.com\")\n        user = await service.create_user(request)\n\n        assert user.username == \"test\"\n        assert user.email == \"test@example.com\"\n\n@pytest.mark.asyncio\nasync def test_get_user_not_found():\n    with test_container() as container:\n        mock_repo = MockRepository()\n        container[UserRepository] = mock_repo\n        container[UserService] = UserService\n\n        service = container[UserService]\n\n        # Should raise error for non-existent user\n        from ..service import UserNotFoundError\n        with pytest.raises(UserNotFoundError):\n            await service.get_user(999)\n</code></pre>"},{"location":"getting-started/first-app/#whats-next","title":"\ud83d\ude80 What's Next?","text":"<p>Congratulations! You've built a complete application with InjectQ. Here are some next steps:</p> <ol> <li>FastAPI Integration: Turn this into a REST API</li> <li>Taskiq Integration: Add background job processing</li> <li>Testing Patterns: Write comprehensive tests</li> <li>Modules &amp; Organization: Organize larger applications</li> </ol>"},{"location":"getting-started/first-app/#key-takeaways","title":"\ud83d\udca1 Key Takeaways","text":"<ul> <li>Separation of Concerns: Each layer has a single responsibility</li> <li>Dependency Injection: Clean, testable, and maintainable code</li> <li>Type Safety: Full type hints throughout</li> <li>Async Support: Modern Python async/await patterns</li> <li>Error Handling: Proper exception handling and validation</li> <li>Testing: Easy to test with dependency overrides</li> </ul> <p>Your InjectQ journey has just begun! \ud83c\udf89</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide helps you install InjectQ and verify a minimal setup.</p>"},{"location":"getting-started/installation/#basic-installation","title":"Basic installation","text":"<pre><code>pip install injectq\n</code></pre>"},{"location":"getting-started/installation/#optional-integrations-install-only-what-you-need","title":"Optional integrations (install only what you need)","text":"<ul> <li>FastAPI integration: <code>pip install injectq[fastapi]</code></li> <li>Taskiq integration: <code>pip install injectq[taskiq]</code></li> <li>Developer extras (mypy, pytest, black, ...): <code>pip install injectq[dev]</code></li> </ul> <p>Example combined install:</p> <pre><code>pip install \"injectq[fastapi,taskiq]\"\n</code></pre>"},{"location":"getting-started/installation/#supported-python-versions","title":"Supported Python versions","text":"<p>InjectQ supports Python 3.10 and above. Using 3.11+ is recommended for best runtime performance.</p>"},{"location":"getting-started/installation/#quick-verification","title":"Quick verification","text":"<p>After installation, verify the library behaves as expected. Use <code>InjectQ.get_instance()</code> (recommended):</p> <pre><code>from injectq import InjectQ\n\ncontainer = InjectQ.get_instance()\nprint(f\"InjectQ available: {container is not None}\")\n\nclass A:\n    pass\n\n# Bind a simple instance\ncontainer[A] = A()\n\nassert container[A] is not None\nassert container.get(A) is container[A]\nassert container.try_get(A, None) is container[A]\n\nprint(\"InjectQ appears to be working\")\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development installation","text":"<p>To work on the repository locally:</p> <pre><code>git clone https://github.com/Iamsdt/injectq.git\ncd injectq\npip install -e .[dev]\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next steps","text":"<p>Now explore the Quick Start to get started with InjectQ!</p> <p>````</p>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Get up and running with InjectQ in minutes!</p>"},{"location":"getting-started/quick-start/#hello-world-example","title":"\ud83c\udfaf Hello World Example","text":"<p>The simplest way to start:</p> <pre><code>from injectq import inject, singleton\n\n# 1. Define and auto-register a service\n@singleton\nclass UserService:\n    def greet(self) -&gt; str:\n        return \"Hello from InjectQ!\"\n\n# 2. Use dependency injection\n@inject\ndef main(service: UserService) -&gt; None:\n    print(service.greet())\n\n# 3. Run\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Note: The <code>@singleton</code> decorator automatically registers the class with the global container. No manual registration needed!</p>"},{"location":"getting-started/quick-start/#building-your-first-service","title":"\ud83c\udfd7\ufe0f Building Your First Service","text":"<p>Create a simple application with dependencies:</p> <pre><code>from injectq import inject, singleton\n\n# Define your services with auto-registration\n@singleton\nclass Database:\n    def __init__(self):\n        print(\"Database initialized\")\n        self.connected = True\n\n    def query(self, sql: str) -&gt; str:\n        return f\"Result of: {sql}\"\n\n@singleton\nclass UserService:\n    @inject\n    def __init__(self, db: Database):\n        self.db = db\n\n    def get_users(self) -&gt; str:\n        return self.db.query(\"SELECT * FROM users\")\n\n# Use the service\n@inject\ndef show_users(service: UserService) -&gt; None:\n    print(service.get_users())\n\nif __name__ == \"__main__\":\n    show_users()  # Prints: Result of: SELECT * FROM users\n</code></pre> <p>Note: Both <code>Database</code> and <code>UserService</code> are automatically registered. The <code>@inject</code> on <code>__init__</code> enables automatic dependency injection of <code>Database</code> into <code>UserService</code>.</p>"},{"location":"getting-started/quick-start/#three-ways-to-inject","title":"\ud83c\udfa8 Three Ways to Inject","text":""},{"location":"getting-started/quick-start/#1-decorator-method-recommended","title":"1. Decorator Method (Recommended)","text":"<pre><code>from injectq import inject, singleton\n\n@singleton\nclass UserService:\n    def do_something(self):\n        return \"Done!\"\n\n@inject\ndef my_function(service: UserService) -&gt; None:\n    # UserService is automatically injected\n    print(service.do_something())\n\n# Call without arguments\nmy_function()\n</code></pre>"},{"location":"getting-started/quick-start/#2-dict-like-interface","title":"2. Dict-like Interface","text":"<pre><code>from injectq import InjectQ\n\ncontainer = InjectQ.get_instance()\n\n# Register\ncontainer[\"config\"] = \"prod\"\ncontainer[Database] = Database()\n\n# Retrieve\nconfig = container[\"config\"]\ndb = container[Database]\n</code></pre>"},{"location":"getting-started/quick-start/#3-manual-resolution","title":"3. Manual Resolution","text":"<pre><code>from injectq import InjectQ\n\ncontainer = InjectQ.get_instance()\n\n# Get service when needed\nservice = container.get(UserService)\n# or\nservice = container[UserService]\n</code></pre>"},{"location":"getting-started/quick-start/#understanding-scopes","title":"\ud83d\udd04 Understanding Scopes","text":"<p>Control how many instances of a service are created:</p> <pre><code>from injectq import InjectQ, singleton, transient\n\n@singleton  # Same instance everywhere\nclass Logger:\n    def __init__(self):\n        self.id = id(self)\n\n@singleton  # Logger is injected as singleton\nclass RequestHandler:\n    @inject\n    def __init__(self, logger: Logger):\n        self.logger = logger\n\ncontainer = InjectQ.get_instance()\n\n# Singleton behavior\nlogger1 = container[Logger]\nlogger2 = container[Logger]\nassert logger1 is logger2  # True - same instance\n\n# RequestHandler is also singleton, but you can make it transient:\n@transient  # New instance each time\nclass TransientHandler:\n    @inject\n    def __init__(self, logger: Logger):\n        self.logger = logger\n\nhandler1 = container[TransientHandler]\nhandler2 = container[TransientHandler]\nassert handler1 is not handler2  # True - different instances\nassert handler1.logger is handler2.logger  # True - same singleton logger\n</code></pre> <p>Key points: - <code>@singleton</code> \u2014 One instance for the entire application - <code>@transient</code> \u2014 New instance every time you resolve - <code>@scoped(\"request\")</code> \u2014 One instance per scope context</p>"},{"location":"getting-started/quick-start/#organizing-with-modules","title":"\ud83d\udce6 Organizing with Modules","text":"<p>For larger applications, use modules:</p> <pre><code>from injectq import Module, InjectQ, singleton\n\n@singleton\nclass Database:\n    pass\n\n@singleton\nclass UserService:\n    pass\n\n@singleton  \nclass AdminService:\n    pass\n\nclass DatabaseModule(Module):\n    def configure(self, binder):\n        binder.bind(Database, Database)\n        binder.bind(str, \"postgresql://localhost/db\")\n\nclass ServiceModule(Module):\n    def configure(self, binder):\n        binder.bind(UserService, UserService)\n        binder.bind(AdminService, AdminService)\n\n# Create container with modules\ncontainer = InjectQ(modules=[\n    DatabaseModule(),\n    ServiceModule()\n])\n\n# Services are automatically available\n@inject\ndef main(user_service: UserService):\n    print(\"App started!\")\n\nmain()\n</code></pre> <p>Modules help you: - Organize related bindings - Separate concerns - Make configuration reusable</p>"},{"location":"getting-started/quick-start/#working-with-factories","title":"\ud83c\udfed Working with Factories","text":"<p>InjectQ provides flexible factory methods for advanced scenarios:</p>"},{"location":"getting-started/quick-start/#basic-factory","title":"Basic Factory","text":"<pre><code>from injectq import InjectQ, inject, singleton\n\ncontainer = InjectQ.get_instance()\ncontainer[\"db_url\"] = \"postgresql://localhost/db\"\n\n@singleton\nclass Database:\n    def __init__(self, url: str):\n        self.url = url\n\n# Factory with DI\n@inject\ndef create_database(db_url: str) -&gt; Database:\n    return Database(db_url)\n\ncontainer.bind_factory(Database, create_database)\n\n# Factory called automatically with injected dependencies\ndb = container[Database]\nprint(db.url)  # postgresql://localhost/db\n</code></pre>"},{"location":"getting-started/quick-start/#parameterized-factory","title":"Parameterized Factory","text":"<pre><code>from injectq import InjectQ\n\ncontainer = InjectQ.get_instance()\n\nclass RedisCache:\n    def __init__(self, namespace: str, ttl: int):\n        self.namespace = namespace\n        self.ttl = ttl\n\n# Factory that accepts arguments\ndef create_cache(namespace: str, ttl: int = 3600) -&gt; RedisCache:\n    return RedisCache(namespace, ttl)\n\ncontainer.bind_factory(\"cache\", create_cache)\n\n# Call with custom arguments\nuser_cache = container.call_factory(\"cache\", \"users\", ttl=7200)\nsession_cache = container.call_factory(\"cache\", \"sessions\")\n</code></pre>"},{"location":"getting-started/quick-start/#hybrid-factory-best-of-both-worlds","title":"\ud83c\udd95 Hybrid Factory (Best of Both Worlds!)","text":"<p>The new <code>invoke()</code> method combines DI with manual arguments:</p> <pre><code>from injectq import InjectQ, singleton, inject\n\ncontainer = InjectQ.get_instance()\n\n@singleton\nclass Database:\n    pass\n\n@singleton\nclass Cache:\n    pass\n\nclass UserService:\n    def __init__(self, db: Database, cache: Cache, user_id: str):\n        self.db = db\n        self.cache = cache\n        self.user_id = user_id\n\n# Factory needs both injected deps and manual args\ndef create_user_service(db: Database, cache: Cache, user_id: str) -&gt; UserService:\n    return UserService(db, cache, user_id)\n\ncontainer.bind_factory(\"user_service\", create_user_service)\n\n# \u274c Old way - verbose\ndb = container[Database]\ncache = container[Cache]\nservice = container.call_factory(\"user_service\", db, cache, \"user123\")\n\n# \u2705 New way - clean and automatic!\nservice = container.invoke(\"user_service\", user_id=\"user123\")\n# db and cache are auto-injected, only provide user_id\n\n# Async version\nasync def async_factory(db: Database, batch_size: int) -&gt; dict:\n    return {\"db\": db, \"batch_size\": batch_size}\n\ncontainer.bind_factory(\"async_service\", async_factory)\nresult = await container.ainvoke(\"async_service\", batch_size=100)\n</code></pre> <p>When to use invoke(): - \u2705 Factory needs some DI dependencies + some runtime arguments - \u2705 You want cleaner code without manual resolution - \u2705 Mix config from container with user input</p> <p>Learn more in Factory Methods.</p>"},{"location":"getting-started/quick-start/#testing-with-injectq","title":"\ud83e\uddea Testing with InjectQ","text":"<p>Use the built-in testing utilities:</p> <pre><code>from injectq.testing import test_container, override_dependency\nfrom injectq import inject, singleton, InjectQ\n\n@singleton\nclass Database:\n    def get_user(self, user_id: int):\n        return {\"id\": user_id, \"name\": \"Real User\"}\n\n@singleton\nclass UserService:\n    @inject\n    def __init__(self, db: Database):\n        self.db = db\n\n    def get_user(self, user_id: int):\n        return self.db.get_user(user_id)\n\n# Test with isolated container\ndef test_user_service():\n    \"\"\"Test with isolated container.\"\"\"\n    with test_container() as container:\n        # Create mock database\n        class MockDatabase:\n            def get_user(self, user_id: int):\n                return {\"id\": user_id, \"name\": \"Mock User\"}\n\n        # Register mock dependencies\n        container[Database] = MockDatabase()\n        container[UserService] = UserService\n\n        # Test your code\n        service = container[UserService]\n        result = service.get_user(1)\n        assert result[\"name\"] == \"Mock User\"\n\n# Alternative: Override existing binding\ndef test_with_override():\n    \"\"\"Test by overriding a dependency.\"\"\"\n    class MockDatabase:\n        def get_user(self, user_id: int):\n            return {\"id\": user_id, \"name\": \"Override User\"}\n\n    with override_dependency(Database, MockDatabase()):\n        service = InjectQ.get_instance().get(UserService)\n        result = service.get_user(1)\n        assert result[\"name\"] == \"Override User\"\n</code></pre> <p>Testing patterns: - <code>test_container()</code> \u2014 Isolated container for each test - <code>override_dependency()</code> \u2014 Temporarily replace a service - <code>InjectQ.test_mode()</code> \u2014 Context manager for test instances</p>"},{"location":"getting-started/quick-start/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ol> <li>Explore Core Concepts \u2014 Understand DI principles</li> <li>Master Scopes \u2014 Learn service lifetimes</li> <li>Inject Patterns \u2014 Different injection styles</li> <li>FastAPI Integration \u2014 Use with FastAPI</li> </ol>"},{"location":"getting-started/quick-start/#quick-tips","title":"\ud83d\udca1 Quick Tips","text":"<ul> <li>Use <code>@inject</code> decorator for automatic dependency resolution</li> <li>Use <code>@singleton</code> for services shared across the app</li> <li>Use <code>@transient</code> for fresh instances each time</li> <li>Use <code>test_container()</code> for unit testing</li> <li>Use <code>Module</code> for organizing complex apps</li> <li>\ud83c\udd95 Use <code>invoke()</code> when you need both DI and manual arguments in factories</li> </ul> <p>Happy coding! \ud83c\udf89 ````</p>"},{"location":"injection-patterns/dict-interface/","title":"Dict-like Interface","text":"<p>The dict-like interface is the simplest way to register and retrieve services. Use <code>InjectQ.get_instance()</code> to get the container.</p>"},{"location":"injection-patterns/dict-interface/#basic-usage","title":"Basic Usage","text":"<pre><code>from injectq import InjectQ\n\ncontainer = InjectQ.get_instance()\n\n# Register simple values\ncontainer[str] = \"Hello, InjectQ!\"\ncontainer[int] = 42\ncontainer[\"database_url\"] = \"postgresql://localhost/db\"\n\n# Retrieve services\nmessage = container[str]\nnumber = container[int]\ndb_url = container[\"database_url\"]\n```## Class Registration\n\nRegister classes for automatic instantiation:\n\n```python\nfrom injectq import InjectQ\n\ncontainer = InjectQ.get_instance()\n\nclass DatabaseConfig:\n    def __init__(self):\n        self.host = \"localhost\"\n        self.port = 5432\n\nclass Database:\n    def __init__(self, config: DatabaseConfig):\n        self.config = config\n\nclass UserRepository:\n    def __init__(self, db: Database):\n        self.db = db\n\n# Register classes\ncontainer[DatabaseConfig] = DatabaseConfig\ncontainer[Database] = Database\ncontainer[UserRepository] = UserRepository\n\n# Automatic dependency resolution\nrepo = container[UserRepository]\n</code></pre>"},{"location":"injection-patterns/dict-interface/#key-operations","title":"Key operations","text":""},{"location":"injection-patterns/dict-interface/#setting-values","title":"Setting values","text":"<pre><code>from injectq import InjectQ\n\ncontainer = InjectQ.get_instance()\n\n# Simple values\ncontainer[str] = \"configuration\"\ncontainer[int] = 12345\ncontainer[bool] = True\n\n# Complex objects\ncontainer[\"config\"] = AppConfig(host=\"prod\", debug=False)\n\n# Classes (for automatic instantiation)\ncontainer[Database] = Database\ncontainer[UserService] = UserService\n\n# Instances (pre-created objects)\ncontainer[\"cache\"] = RedisCache(host=\"localhost\")\n</code></pre>"},{"location":"injection-patterns/dict-interface/#getting-values","title":"Getting values","text":"<pre><code># Simple retrieval\nconfig = container[str]\nnumber = container[int]\n\n# With type hints (better IDE support)\nconfig: str = container[str]\nservice: UserService = container[UserService]\n</code></pre>"},{"location":"injection-patterns/dict-interface/#checking-existence","title":"Checking existence","text":"<pre><code># Check if a service is registered\nif str in container:\n    config = container[str]\n\nif \"database\" in container:\n    db = container[\"database\"]\n</code></pre>"},{"location":"injection-patterns/dict-interface/#removing-services","title":"Removing services","text":"<pre><code># Remove a service\ndel container[str]\ndel container[Database]\n\n# Check removal\nassert str not in container\nassert Database not in container\n</code></pre>"},{"location":"injection-patterns/dict-interface/#testing-with-dict-interface","title":"Testing with Dict Interface","text":"<p>Use the testing utilities to create test containers:</p> <pre><code>from injectq.testing import test_container\n\ndef test_user_service():\n    with test_container() as container:\n        container[Database] = MockDatabase()\n        container[UserService] = UserService\n\n        service = container[UserService]\n        result = service.get_user(1)\n        assert result is not None\n</code></pre>"},{"location":"injection-patterns/dict-interface/#when-to-use-dict-interface","title":"\u2696\ufe0f When to Use Dict Interface","text":"<p>Good for: - Simple applications with few services - Configuration values (strings, numbers, settings) - Prototyping and learning DI - Quick setup projects</p> <p>Not ideal for: - Large applications with many dependencies - Complex interdependent services - Advanced scoping requirements - Large teams needing explicit contracts</p>"},{"location":"injection-patterns/dict-interface/#summary","title":"\ud83c\udfaf Summary","text":"<p>The dict-like interface is: - Simple \u2014 Easy to understand and use - Flexible \u2014 Store any type of value or service - Fast \u2014 Quick setup for small projects</p> <p>Ready to explore the @inject decorator?</p>"},{"location":"injection-patterns/dict-interface/#when-to-use-dict-interface_1","title":"\u2696\ufe0f When to Use Dict Interface","text":""},{"location":"injection-patterns/dict-interface/#good-for","title":"\u2705 Good For","text":"<ul> <li>Simple applications - Quick setup without complex configuration</li> <li>Configuration values - Storing strings, numbers, settings</li> <li>Prototyping - Fast iteration and testing</li> <li>Small projects - When you don't need advanced features</li> <li>Learning DI - Easiest way to understand the concepts</li> </ul>"},{"location":"injection-patterns/dict-interface/#not-ideal-for","title":"\u274c Not Ideal For","text":"<ul> <li>Large applications - Can become messy with many services</li> <li>Complex dependencies - Hard to manage intricate dependency graphs</li> <li>Type safety - Less type-safe than other approaches</li> <li>Advanced scoping - Limited lifetime management</li> <li>Team development - Less explicit about dependencies</li> </ul>"},{"location":"injection-patterns/dict-interface/#migration-path","title":"\ud83d\udd04 Migration Path","text":"<p>You can start with the dict interface and migrate to more advanced patterns:</p> <pre><code># Phase 1: Simple dict interface\ncontainer = InjectQ()\ncontainer[Database] = Database\ncontainer[UserService] = UserService\n\n# Phase 2: Add modules for organization\nclass DatabaseModule(Module):\n    def configure(self, binder):\n        binder.bind(Database, Database)\n\ncontainer = InjectQ([DatabaseModule()])\n\n# Phase 3: Add type safety with protocols\nclass IDatabase(Protocol):\n    def connect(self) -&gt; None: ...\n\ncontainer.bind(IDatabase, PostgreSQLDatabase)\n</code></pre>"},{"location":"injection-patterns/dict-interface/#best-practices","title":"\ud83c\udfc6 Best Practices","text":""},{"location":"injection-patterns/dict-interface/#1-use-descriptive-keys","title":"1. Use Descriptive Keys","text":"<pre><code># \u2705 Good - descriptive keys\ncontainer[\"database_url\"] = \"postgresql://...\"\ncontainer[\"redis_host\"] = \"localhost\"\ncontainer[\"api_timeout\"] = 30\n\n# \u274c Avoid - unclear keys\ncontainer[\"url\"] = \"postgresql://...\"\ncontainer[\"host\"] = \"localhost\"\ncontainer[\"num\"] = 30\n</code></pre>"},{"location":"injection-patterns/dict-interface/#2-group-related-configuration","title":"2. Group Related Configuration","text":"<pre><code># \u2705 Good - grouped configuration\ncontainer[\"database\"] = {\n    \"host\": \"localhost\",\n    \"port\": 5432,\n    \"name\": \"myapp\"\n}\ncontainer[\"cache\"] = {\n    \"host\": \"redis\",\n    \"ttl\": 3600\n}\n\n# \u274c Avoid - scattered configuration\ncontainer[\"db_host\"] = \"localhost\"\ncontainer[\"db_port\"] = 5432\ncontainer[\"cache_host\"] = \"redis\"\n</code></pre>"},{"location":"injection-patterns/dict-interface/#3-use-factories-for-dynamic-values","title":"3. Use Factories for Dynamic Values","text":"<pre><code># \u2705 Good - factories for dynamic values\ncontainer[\"request_id\"] = lambda: str(uuid.uuid4())\ncontainer[\"timestamp\"] = lambda: datetime.now()\n\n# \u274c Avoid - static values that should be dynamic\ncontainer[\"request_id\"] = \"static-id\"  # Same for all requests\n</code></pre>"},{"location":"injection-patterns/dict-interface/#4-document-your-services","title":"4. Document Your Services","text":"<pre><code># \u2705 Good - documented services\ncontainer[\"database\"] = PostgreSQLDatabase()  # Main application database\ncontainer[\"cache\"] = RedisCache()            # Redis cache for performance\ncontainer[\"logger\"] = StructuredLogger()     # JSON structured logging\n</code></pre>"},{"location":"injection-patterns/dict-interface/#summary_1","title":"\ud83c\udfaf Summary","text":"<p>The dict-like interface is:</p> <ul> <li>Simple - Easy to understand and use</li> <li>Flexible - Store any type of value or service</li> <li>Fast - Quick setup for small projects</li> <li>Intuitive - Familiar dictionary-like API</li> </ul> <p>Key features: - Store simple values, objects, classes, or factories - Automatic dependency resolution for registered classes - Easy testing with dependency overrides - Seamless integration with other InjectQ features</p> <p>When to use: - Learning dependency injection - Small to medium applications - Prototyping and experimentation - Simple configuration management</p> <p>Ready to explore the @inject decorator?</p>"},{"location":"injection-patterns/factory-methods/","title":"Factory Methods","text":"<p>InjectQ provides powerful factory methods for creating services with different patterns. This guide covers all factory-related APIs.</p>"},{"location":"injection-patterns/factory-methods/#overview","title":"Overview","text":"<p>InjectQ supports three factory patterns:</p> <ol> <li>DI Factories - Factory with dependency injection (no manual args)</li> <li>Parameterized Factories - Factory with manual arguments (no DI)</li> <li>Hybrid Factories - Factory with both DI and manual arguments (\ud83c\udd95)</li> </ol>"},{"location":"injection-patterns/factory-methods/#di-factories","title":"DI Factories","text":"<p>Regular factories where all dependencies are automatically injected.</p>"},{"location":"injection-patterns/factory-methods/#basic-usage","title":"Basic Usage","text":"<pre><code>from injectq import InjectQ\n\ncontainer = InjectQ()\ncontainer.bind(\"db_url\", \"postgresql://localhost/mydb\")\n\n# Factory with DI - parameter is injected\ndef create_database(db_url: str):\n    return Database(db_url)\n\ncontainer.bind_factory(Database, create_database)\n\n# Get instance - factory called automatically with injected deps\ndb = container[Database]\n# or\ndb = container.get(Database)\n</code></pre>"},{"location":"injection-patterns/factory-methods/#with-multiple-dependencies","title":"With Multiple Dependencies","text":"<pre><code>container.bind(Database, Database)\ncontainer.bind(Cache, Cache)\n\ndef create_user_service(db: Database, cache: Cache):\n    \"\"\"All dependencies auto-injected.\"\"\"\n    return UserService(db, cache)\n\ncontainer.bind_factory(UserService, create_user_service)\n\n# All dependencies resolved automatically\nservice = container[UserService]\n</code></pre>"},{"location":"injection-patterns/factory-methods/#async-di-factories","title":"Async DI Factories","text":"<pre><code>async def create_async_database(db_url: str):\n    \"\"\"Async factory with DI.\"\"\"\n    await asyncio.sleep(0.1)  # async initialization\n    return await Database.create(db_url)\n\ncontainer.bind_factory(\"async_db\", create_async_database)\n\n# Use async get\ndb = await container.aget(\"async_db\")\n</code></pre>"},{"location":"injection-patterns/factory-methods/#parameterized-factories","title":"Parameterized Factories","text":"<p>Factories that accept custom arguments at call time.</p>"},{"location":"injection-patterns/factory-methods/#basic-usage_1","title":"Basic Usage","text":"<pre><code># Factory with parameters\ndef create_connection_pool(db_name: str, max_conn: int = 10):\n    \"\"\"Factory accepts runtime arguments.\"\"\"\n    return ConnectionPool(db_name, max_conn)\n\ncontainer.bind_factory(\"db_pool\", create_connection_pool)\n</code></pre>"},{"location":"injection-patterns/factory-methods/#calling-parameterized-factories","title":"Calling Parameterized Factories","text":"<p>There are three ways to call parameterized factories:</p>"},{"location":"injection-patterns/factory-methods/#method-1-get_factory-manual-call","title":"Method 1: get_factory() + manual call","text":"<pre><code>factory = container.get_factory(\"db_pool\")\npool = factory(\"users_db\", max_conn=20)\n</code></pre>"},{"location":"injection-patterns/factory-methods/#method-2-call_factory-recommended","title":"Method 2: call_factory() - Recommended","text":"<pre><code># Shorthand: get and call in one step\npool = container.call_factory(\"db_pool\", \"users_db\", max_conn=20)\n</code></pre>"},{"location":"injection-patterns/factory-methods/#method-3-chain-calls","title":"Method 3: Chain calls","text":"<pre><code># Inline chaining\npool = container.get_factory(\"db_pool\")(\"users_db\", max_conn=20)\n</code></pre>"},{"location":"injection-patterns/factory-methods/#async-parameterized-factories","title":"Async Parameterized Factories","text":"<pre><code>async def create_async_pool(db_name: str, max_conn: int = 10):\n    \"\"\"Async factory with parameters.\"\"\"\n    await asyncio.sleep(0.1)\n    return await AsyncPool.create(db_name, max_conn)\n\ncontainer.bind_factory(\"async_pool\", create_async_pool)\n\n# Method 1: aget_factory()\nfactory = await container.aget_factory(\"async_pool\")\npool = await factory(\"users_db\", max_conn=20)\n\n# Method 2: acall_factory() - Recommended\npool = await container.acall_factory(\"async_pool\", \"users_db\", max_conn=20)\n</code></pre>"},{"location":"injection-patterns/factory-methods/#use-cases-for-parameterized-factories","title":"Use Cases for Parameterized Factories","text":"<p>Perfect for: - Creating multiple instances with different configurations - Runtime-dependent object creation - Factory functions that don't need DI</p> <pre><code># Example: Creating multiple caches\ndef create_cache(namespace: str, ttl: int = 3600):\n    return RedisCache(namespace=namespace, ttl=ttl)\n\ncontainer.bind_factory(\"cache\", create_cache)\n\n# Create different caches\nuser_cache = container.call_factory(\"cache\", \"users\", ttl=7200)\nsession_cache = container.call_factory(\"cache\", \"sessions\", ttl=1800)\nproduct_cache = container.call_factory(\"cache\", \"products\")  # default ttl\n</code></pre>"},{"location":"injection-patterns/factory-methods/#hybrid-factories-invoke","title":"\ud83c\udd95 Hybrid Factories (invoke)","text":"<p>The most powerful pattern - combines DI with manual arguments.</p>"},{"location":"injection-patterns/factory-methods/#introduction","title":"Introduction","text":"<p>The <code>invoke()</code> method is perfect when you need: - Some dependencies from the container (config, services) - Some arguments provided at runtime (user input, dynamic values)</p>"},{"location":"injection-patterns/factory-methods/#basic-usage_2","title":"Basic Usage","text":"<pre><code>container.bind(Database, Database)\ncontainer.bind(Cache, Cache)\n\n# Factory with BOTH injected deps and manual args\ndef create_user_service(db: Database, cache: Cache, user_id: str):\n    \"\"\"\n    db and cache will be injected\n    user_id must be provided at call time\n    \"\"\"\n    return UserService(db, cache, user_id)\n\ncontainer.bind_factory(\"user_service\", create_user_service)\n\n# \u274c Old way - verbose\ndb = container[Database]\ncache = container[Cache]\nfactory = container.get_factory(\"user_service\")\nservice = factory(db, cache, \"user123\")\n\n# \u2705 New way - clean and automatic\nservice = container.invoke(\"user_service\", user_id=\"user123\")\n</code></pre>"},{"location":"injection-patterns/factory-methods/#how-invoke-resolves-parameters","title":"How invoke() Resolves Parameters","text":"<p>The resolution strategy follows this order:</p> <ol> <li>Provided Arguments - Use args/kwargs you provide</li> <li>String Key Injection - Inject by parameter name (if registered)</li> <li>Type Annotation Injection - Inject by type (non-primitives only)</li> <li>Default Values - Use parameter defaults</li> <li>Error - Raise DependencyNotFoundError if required param unresolved</li> </ol> <pre><code>container.bind(\"api_key\", \"secret-123\")\ncontainer.bind(\"api_url\", \"https://api.example.com\")\ncontainer.bind(RateLimiter, RateLimiter)\n\ndef create_api_client(\n    api_key: str,           # Injected by name (step 2)\n    api_url: str,           # Injected by name (step 2)\n    rate_limiter: RateLimiter,  # Injected by type (step 3)\n    timeout: int = 30,      # Uses default (step 4)\n    retry_count: int = 3    # Uses default (step 4)\n):\n    return APIClient(api_key, api_url, rate_limiter, timeout, retry_count)\n\ncontainer.bind_factory(\"client\", create_api_client)\n\n# Only provide values that need to be dynamic\nclient = container.invoke(\"client\", timeout=60)\n# api_key, api_url, rate_limiter auto-injected\n# retry_count uses default (3)\n</code></pre>"},{"location":"injection-patterns/factory-methods/#invoke-with-all-defaults","title":"invoke() with All Defaults","text":"<pre><code>def create_config(env: str = \"dev\", debug: bool = False, port: int = 8000):\n    return Config(env, debug, port)\n\ncontainer.bind_factory(\"config\", create_config)\n\n# Use all defaults\nconfig = container.invoke(\"config\")\n# Result: Config(env=\"dev\", debug=False, port=8000)\n\n# Override some\nconfig = container.invoke(\"config\", env=\"prod\", port=80)\n# Result: Config(env=\"prod\", debug=False, port=80)\n</code></pre>"},{"location":"injection-patterns/factory-methods/#primitive-types-and-invoke","title":"Primitive Types and invoke()","text":"<p>To avoid ambiguous injections, <code>invoke()</code> doesn't auto-inject primitive types (<code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code>) by type annotation. It only injects them by parameter name.</p> <pre><code>container.bind(\"db_host\", \"localhost\")\ncontainer.bind(\"db_port\", 5432)\n\ndef create_pool(db_host: str, db_port: int, db_name: str, max_conn: int = 10):\n    return ConnectionPool(db_host, db_port, db_name, max_conn)\n\ncontainer.bind_factory(\"pool\", create_pool)\n\n# db_host and db_port injected by NAME\n# db_name provided manually\n# max_conn uses default\npool = container.invoke(\"pool\", db_name=\"users_db\")\n</code></pre> <p>Why this design?</p> <p>Without this restriction, if you have multiple <code>int</code> or <code>str</code> bindings, InjectQ wouldn't know which one to inject. By requiring name-based injection for primitives, the behavior is explicit and predictable.</p>"},{"location":"injection-patterns/factory-methods/#async-invoke","title":"Async invoke()","text":"<pre><code>container.bind(Database, Database)\ncontainer.bind(Logger, Logger)\n\nasync def create_processor(db: Database, logger: Logger, batch_size: int):\n    \"\"\"Async factory with mixed dependencies.\"\"\"\n    await asyncio.sleep(0.1)\n    logger.log(f\"Creating processor with batch_size={batch_size}\")\n    return AsyncProcessor(db, batch_size)\n\ncontainer.bind_factory(\"processor\", create_processor)\n\n# Use ainvoke\nprocessor = await container.ainvoke(\"processor\", batch_size=100)\n</code></pre>"},{"location":"injection-patterns/factory-methods/#real-world-example-connection-pools","title":"Real-World Example: Connection Pools","text":"<pre><code># Register shared config\ncontainer.bind(\"db_host\", \"localhost\")\ncontainer.bind(\"db_port\", 5432)\ncontainer.bind(\"max_connections\", 10)\ncontainer.bind(\"timeout\", 30)\n\n# Factory that uses config + custom args\ndef create_connection_pool(\n    db_name: str,                    # Must provide\n    db_host: str,                    # Injected by name\n    db_port: int,                    # Injected by name\n    max_connections: int,            # Injected by name\n    timeout: int                     # Injected by name\n):\n    return ConnectionPool(db_name, db_host, db_port, max_connections, timeout)\n\ncontainer.bind_factory(\"db_pool\", create_connection_pool)\n\n# Create different pools - only specify what changes\nusers_pool = container.invoke(\"db_pool\", db_name=\"users_db\")\norders_pool = container.invoke(\"db_pool\", db_name=\"orders_db\", max_connections=20)\nlogs_pool = container.invoke(\"db_pool\", db_name=\"logs_db\", timeout=10)\n\n# Each pool inherits shared config but can override\n</code></pre>"},{"location":"injection-patterns/factory-methods/#best-practices-for-invoke","title":"Best Practices for invoke()","text":""},{"location":"injection-patterns/factory-methods/#do","title":"\u2705 Do","text":"<pre><code># Use keyword arguments for clarity\nservice = container.invoke(\"service\", user_id=\"123\", action=\"create\")\n\n# Mix config from container with runtime values\nresult = container.invoke(\"processor\", input_file=user_uploaded_file)\n\n# Leverage defaults for optional parameters\nclient = container.invoke(\"client\")  # uses all defaults\n</code></pre>"},{"location":"injection-patterns/factory-methods/#dont","title":"\u274c Don't","text":"<pre><code># Avoid positional args - can be ambiguous\nservice = container.invoke(\"service\", \"123\", \"create\")  # unclear\n\n# Don't use invoke() when all params are in container\nservice = container.invoke(\"service\")  # use get() instead\n\n# Don't use invoke() when no params are injected\nresult = container.invoke(\"factory\", arg1, arg2)  # use call_factory()\n</code></pre>"},{"location":"injection-patterns/factory-methods/#comparison-table","title":"Comparison Table","text":"Method DI Manual Args Use Case <code>get()</code> \u2705 \u274c All params in container <code>call_factory()</code> \u274c \u2705 All params manual <code>get_factory()</code> \u274c \u2705 Advanced control <code>invoke()</code> \ud83c\udd95 \u2705 \u2705 Mix both <code>aget()</code> \u2705 \u274c Async all params in container <code>acall_factory()</code> \ud83c\udd95 \u274c \u2705 Async all params manual <code>aget_factory()</code> \ud83c\udd95 \u274c \u2705 Async advanced control <code>ainvoke()</code> \ud83c\udd95 \u2705 \u2705 Async mix both"},{"location":"injection-patterns/factory-methods/#summary","title":"Summary","text":""},{"location":"injection-patterns/factory-methods/#when-to-use-each-method","title":"When to Use Each Method","text":"<p>Use <code>get()</code> or <code>aget()</code> when: - All dependencies are registered in the container - You want full dependency injection - Factory has no runtime arguments</p> <p>Use <code>call_factory()</code> or <code>acall_factory()</code> when: - All arguments are provided at call time - No dependency injection needed - Creating multiple instances with different args</p> <p>Use <code>invoke()</code> or <code>ainvoke()</code> when: \ud83c\udd95 - You need BOTH injected dependencies AND manual arguments - Some params come from config/container - Some params come from user input/runtime - You want cleaner code than manual resolution</p>"},{"location":"injection-patterns/factory-methods/#code-examples-summary","title":"Code Examples Summary","text":"<pre><code># DI Factory\ncontainer.bind_factory(Service, create_service)\nservice = container.get(Service)\n\n# Parameterized Factory\ncontainer.bind_factory(\"pool\", create_pool)\npool = container.call_factory(\"pool\", \"db_name\", max_conn=20)\n\n# Hybrid Factory (\ud83c\udd95)\ncontainer.bind_factory(\"user_service\", create_user_service)\nservice = container.invoke(\"user_service\", user_id=\"123\")\n\n# Async versions\nservice = await container.aget(Service)\npool = await container.acall_factory(\"pool\", \"db_name\", max_conn=20)\nservice = await container.ainvoke(\"user_service\", user_id=\"123\")\n</code></pre>"},{"location":"injection-patterns/factory-methods/#see-also","title":"See Also","text":"<ul> <li>Inject Decorator - Automatic function parameter injection</li> <li>Dict Interface - Container dict-like interface</li> <li>Testing Patterns - Testing with factories</li> </ul>"},{"location":"injection-patterns/inject-decorator/","title":"@inject Decorator","text":"<p>The <code>@inject</code> decorator is InjectQ's most powerful and recommended way to inject dependencies. It automatically resolves and injects dependencies based on type hints, making your code clean and declarative.</p>"},{"location":"injection-patterns/inject-decorator/#basic-usage","title":"\ud83c\udfaf Basic Usage","text":"<p>The <code>@inject</code> decorator eliminates manual dependency management:</p> <pre><code>from injectq import InjectQ, inject\n\ncontainer = InjectQ.get_instance()\n\n# Set up container\ncontainer[Database] = Database\ncontainer[UserService] = UserService\n\n# Use @inject decorator\n@inject\ndef process_user(service: UserService, db: Database) -&gt; None:\n    # Dependencies automatically injected\n    user = service.get_user(1)\n    db.save(user)\n\n# Call without parameters - dependencies injected automatically\nprocess_user()\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#how-it-works","title":"\ud83c\udfd7\ufe0f How It Works","text":""},{"location":"injection-patterns/inject-decorator/#automatic-resolution","title":"Automatic Resolution","text":"<p>The <code>@inject</code> decorator analyzes function signatures and resolves dependencies:</p> <pre><code>@inject\ndef create_report(\n    user_service: UserService,\n    analytics: AnalyticsService,\n    cache: Cache,\n    config: AppConfig\n) -&gt; Report:\n    # InjectQ automatically:\n    # 1. Gets UserService from container\n    # 2. Gets AnalyticsService from container\n    # 3. Gets Cache from container\n    # 4. Gets AppConfig from container\n    # 5. Calls the function with all dependencies\n    pass\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#type-based-resolution","title":"Type-Based Resolution","text":"<p>Dependencies are resolved based on type hints:</p> <pre><code>from injectq import InjectQ\n\ncontainer = InjectQ.get_instance()\n\nclass IUserRepository(Protocol):\n    def get_by_id(self, id: int) -&gt; Optional[User]: ...\n\nclass UserRepository:\n    def get_by_id(self, id: int) -&gt; Optional[User]:\n        # Implementation\n        pass\n\n# Register implementation\ncontainer.bind(IUserRepository, UserRepository)\n\n@inject\ndef get_user(repo: IUserRepository) -&gt; Optional[User]:\n    # InjectQ finds UserRepository for IUserRepository\n    return repo.get_by_id(1)\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#advanced-patterns","title":"\ud83c\udfa8 Advanced Patterns","text":""},{"location":"injection-patterns/inject-decorator/#async-functions","title":"Async Functions","text":"<p>Works seamlessly with async functions:</p> <pre><code>@inject\nasync def process_user_async(service: UserService, user_id: int) -&gt; User:\n    # All dependencies injected\n    user = await service.get_user_async(user_id)\n    return user\n\n# Usage\nresult = await process_user_async(user_id=123)\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#class-methods","title":"Class Methods","text":"<p>Can be used on class methods:</p> <pre><code>class UserController:\n    @inject\n    def get_user(self, service: UserService, user_id: int) -&gt; User:\n        # 'self' is not injected, other parameters are\n        return service.get_user(user_id)\n\n    @classmethod\n    @inject\n    def create_user(cls, service: UserService, data: dict) -&gt; User:\n        # 'cls' is not injected\n        return service.create_user(data)\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#static-methods","title":"Static Methods","text":"<p>Works with static methods:</p> <pre><code>class UserUtils:\n    @staticmethod\n    @inject\n    def validate_user(service: UserService, user_id: int) -&gt; bool:\n        user = service.get_user(user_id)\n        return user is not None and user.is_active\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#nested-injection","title":"Nested Injection","text":"<p>Dependencies can have their own dependencies:</p> <pre><code>class Database:\n    def __init__(self, config: DatabaseConfig):\n        self.config = config\n\nclass UserRepository:\n    def __init__(self, db: Database):\n        self.db = db\n\nclass UserService:\n    def __init__(self, repo: UserRepository):\n        self.repo = repo\n\n# Register only the top-level service\ncontainer[UserService] = UserService\n\n@inject\ndef use_service(service: UserService) -&gt; None:\n    # InjectQ automatically creates:\n    # 1. DatabaseConfig\n    # 2. Database (with DatabaseConfig)\n    # 3. UserRepository (with Database)\n    # 4. UserService (with UserRepository)\n    pass\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#integration-patterns","title":"\ud83d\udd27 Integration Patterns","text":""},{"location":"injection-patterns/inject-decorator/#with-classes","title":"With Classes","text":"<p>Use <code>@inject</code> on <code>__init__</code> methods:</p> <pre><code>class UserController:\n    @inject\n    def __init__(self, service: UserService, logger: Logger):\n        self.service = service\n        self.logger = logger\n\n    def get_user(self, user_id: int) -&gt; User:\n        self.logger.info(f\"Getting user {user_id}\")\n        return self.service.get_user(user_id)\n\n# Usage\ncontroller = UserController()  # Dependencies automatically injected\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#with-context-managers","title":"With Context Managers","text":"<pre><code>class DatabaseTransaction:\n    @inject\n    def __init__(self, db: Database):\n        self.db = db\n\n    def __enter__(self):\n        self.db.begin_transaction()\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type:\n            self.db.rollback()\n        else:\n            self.db.commit()\n\n@inject\ndef process_with_transaction(service: UserService) -&gt; None:\n    with DatabaseTransaction() as tx:\n        # Transaction automatically injected\n        service.update_user(1, {\"name\": \"New Name\"})\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#testing-with-inject","title":"\ud83e\uddea Testing with @inject","text":"<p>Test your injected functions easily:</p> <pre><code>from injectq.testing import test_container\nfrom injectq import inject\n\ndef test_user_service():\n    with test_container() as container:\n        # Set up test dependencies\n        container[UserService] = MockUserService\n        container[Database] = MockDatabase\n\n        # Test the function\n        @inject\n        def get_user(service: UserService) -&gt; User:\n            return service.get_user(1)\n\n        result = get_user()\n        assert result is not None\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#error-handling","title":"\ud83d\udea8 Error Handling","text":""},{"location":"injection-patterns/inject-decorator/#missing-dependencies","title":"Missing Dependencies","text":"<pre><code>@inject\ndef process_data(service: UserService) -&gt; None:\n    pass\n\n# If UserService is not registered\ntry:\n    process_data()\nexcept DependencyNotFoundError as e:\n    print(f\"Missing dependency: {e}\")\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#circular-dependencies","title":"Circular Dependencies","text":"<pre><code>class A:\n    def __init__(self, b: B):\n        self.b = b\n\nclass B:\n    def __init__(self, a: A):  # Circular!\n        self.a = a\n\ncontainer.bind(A, A)\ncontainer.bind(B, B)\n\n@inject\ndef use_a(a: A) -&gt; None:\n    pass\n\n# Will raise CircularDependencyError\nuse_a()\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#best-practices","title":"\ud83c\udfc6 Best Practices","text":""},{"location":"injection-patterns/inject-decorator/#1-use-type-hints","title":"1. Use Type Hints","text":"<pre><code># \u2705 Good - explicit type hints\n@inject\ndef process_user(service: UserService, user_id: int) -&gt; User:\n    pass\n\n# \u274c Avoid - missing type hints\n@inject\ndef process_user(service, user_id):\n    pass\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#2-prefer-protocols","title":"2. Prefer Protocols","text":"<pre><code># \u2705 Good - depend on abstractions\nclass IUserService(Protocol):\n    def get_user(self, id: int) -&gt; User: ...\n\n@inject\ndef process_user(service: IUserService) -&gt; None:\n    pass\n\n# \u274c Avoid - depend on concrete classes\n@inject\ndef process_user(service: UserService) -&gt; None:\n    pass\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#3-keep-functions-focused","title":"3. Keep Functions Focused","text":"<pre><code># \u2705 Good - single responsibility\n@inject\ndef create_user(service: UserService, data: CreateUserRequest) -&gt; User:\n    return service.create_user(data)\n\n@inject\ndef send_welcome_email(email_service: EmailService, user: User) -&gt; None:\n    email_service.send_welcome(user)\n\n# \u274c Avoid - multiple responsibilities\n@inject\ndef create_user_and_send_email(\n    user_service: UserService,\n    email_service: EmailService,\n    data: CreateUserRequest\n) -&gt; User:\n    user = user_service.create_user(data)\n    email_service.send_welcome(user)  # Multiple concerns\n    return user\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#4-handle-optional-dependencies","title":"4. Handle Optional Dependencies","text":"<pre><code># \u2705 Good - optional dependencies\n@inject\ndef log_request(logger: Optional[Logger], request: Request) -&gt; None:\n    if logger:\n        logger.info(f\"Request: {request.path}\")\n\n# \u2705 Good - default values\n@inject\ndef process_data(cache: Optional[Cache] = None) -&gt; None:\n    if cache:\n        # Use cache\n        pass\n    else:\n        # Cache not available\n        pass\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#5-use-descriptive-names","title":"5. Use Descriptive Names","text":"<pre><code># \u2705 Good - descriptive parameter names\n@inject\ndef authenticate_user(\n    auth_service: AuthenticationService,\n    user_credentials: UserCredentials\n) -&gt; AuthResult:\n    pass\n\n# \u274c Avoid - unclear names\n@inject\ndef auth(s: AuthenticationService, c: UserCredentials) -&gt; AuthResult:\n    pass\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#comparison-with-other-patterns","title":"\ud83d\udd04 Comparison with Other Patterns","text":""},{"location":"injection-patterns/inject-decorator/#inject-vs-dict-interface","title":"@inject vs Dict Interface","text":"<pre><code># Dict interface - manual resolution\ndef process_user(user_id: int) -&gt; User:\n    service = container[UserService]\n    return service.get_user(user_id)\n\n# @inject - automatic resolution\n@inject\ndef process_user(service: UserService, user_id: int) -&gt; User:\n    return service.get_user(user_id)\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#when-to-use-inject","title":"\ud83c\udfaf When to Use @inject","text":""},{"location":"injection-patterns/inject-decorator/#ideal-for","title":"\u2705 Ideal For","text":"<ul> <li>Most applications - Recommended default approach</li> <li>Complex dependency graphs - Automatic resolution</li> <li>Type safety - Full mypy support</li> <li>Clean code - Declarative dependency specification</li> <li>Testing - Easy to mock and override</li> </ul>"},{"location":"injection-patterns/inject-decorator/#considerations","title":"\u26a0\ufe0f Considerations","text":"<ul> <li>Performance - Slight overhead for resolution (can be optimized)</li> <li>Debugging - Dependencies not visible in function calls</li> <li>Learning curve - Need to understand type hints</li> </ul>"},{"location":"injection-patterns/inject-decorator/#summary","title":"\ud83c\udf89 Summary","text":"<p>The <code>@inject</code> decorator provides:</p> <ul> <li>Automatic dependency resolution - No manual wiring</li> <li>Type-based injection - Uses type hints for resolution</li> <li>Clean syntax - Declarative and readable</li> <li>Full type safety - Works with mypy and IDEs</li> <li>Async support - Works with async functions</li> <li>Testing friendly - Easy to override dependencies</li> </ul> <p>Key benefits: - Eliminates boilerplate dependency management - Makes dependencies explicit through type hints - Enables easy testing with dependency overrides - Works seamlessly with all InjectQ features - Provides excellent IDE support and autocomplete</p> <p>Ready to explore the Inject() function?</p>"},{"location":"integrations/fastapi/","title":"FastAPI Integration","text":"<p>InjectQ provides seamless dependency injection for FastAPI using modern, high-performance patterns with ContextVars for per-request container propagation.</p>"},{"location":"integrations/fastapi/#installation","title":"Installation","text":"<pre><code>pip install injectq[fastapi]\n</code></pre>"},{"location":"integrations/fastapi/#quick-start","title":"Quick Start","text":"<pre><code>from typing import Annotated\nfrom fastapi import FastAPI\nfrom injectq import InjectQ, singleton\nfrom injectq.integrations.fastapi import InjectFastAPI, setup_fastapi\n\n# Define your services\n@singleton\nclass UserService:\n    def get_user(self, user_id: int) -&gt; dict:\n        return {\"id\": user_id, \"name\": \"John Doe\"}\n\n# Setup\napp = FastAPI()\ncontainer = InjectQ.get_instance()\nsetup_fastapi(container, app)\n\n# Define routes with dependency injection\n@app.get(\"/users/{user_id}\")\ndef get_user(\n    user_id: int,\n    service: Annotated[UserService, InjectFastAPI(UserService)]\n):\n    return service.get_user(user_id)\n</code></pre>"},{"location":"integrations/fastapi/#how-it-works","title":"How It Works","text":"<p>The FastAPI integration uses:</p> <ul> <li>ContextVar-based middleware (<code>InjectQRequestMiddleware</code>) that sets the active container per request</li> <li>Zero overhead context propagation - O(1) ContextVar operations</li> <li>InjectFastAPI as a FastAPI Depends marker for type-safe, async-safe dependency resolution</li> </ul>"},{"location":"integrations/fastapi/#core-api","title":"Core API","text":""},{"location":"integrations/fastapi/#setup_fastapicontainer-app","title":"<code>setup_fastapi(container, app)</code>","text":"<p>Registers the InjectQ integration with your FastAPI application. This adds middleware to propagate the container via ContextVars.</p> <pre><code>from injectq import InjectQ\nfrom injectq.integrations.fastapi import setup_fastapi\nfrom fastapi import FastAPI\n\napp = FastAPI()\ncontainer = InjectQ.get_instance()\n\n# Register integration - must be called before defining routes\nsetup_fastapi(container, app)\n</code></pre>"},{"location":"integrations/fastapi/#injectfastapiservicetype","title":"<code>InjectFastAPI[ServiceType]</code>","text":"<p>Type-safe dependency marker for FastAPI routes. Use with <code>Annotated</code> for clean type hints.</p> <pre><code>from typing import Annotated\nfrom injectq.integrations.fastapi import InjectFastAPI\n\n@app.get(\"/users/{user_id}\")\ndef get_user(\n    user_id: int,\n    service: Annotated[UserService, InjectFastAPI(UserService)]\n):\n    return service.get_user(user_id)\n</code></pre>"},{"location":"integrations/fastapi/#injectqrequestmiddleware","title":"<code>InjectQRequestMiddleware</code>","text":"<p>The lightweight middleware that handles context propagation. Automatically added by <code>setup_fastapi()</code>.</p> <pre><code>from injectq.integrations.fastapi import InjectQRequestMiddleware\n\n# Already added by setup_fastapi(), but you can manually add it:\napp.add_middleware(InjectQRequestMiddleware, container=container)\n</code></pre>"},{"location":"integrations/fastapi/#basic-example","title":"Basic Example","text":"<p>Complete working example matching <code>examples/api.py</code>:</p> <pre><code>from typing import Annotated\nfrom fastapi import FastAPI, HTTPException\nfrom injectq import InjectQ, inject, singleton\nfrom injectq.integrations.fastapi import InjectFastAPI, setup_fastapi\n\n# Define services\n@singleton\nclass UserRepo:\n    def __init__(self) -&gt; None:\n        self.users = {}\n\n    def add_user(self, user_id: str, user_data: dict) -&gt; None:\n        self.users[user_id] = user_data\n\n    def get_user(self, user_id: str) -&gt; dict | None:\n        return self.users.get(user_id)\n\n    def delete_user(self, user_id: str) -&gt; None:\n        if user_id in self.users:\n            del self.users[user_id]\n\n@singleton\nclass UserService:\n    @inject\n    def __init__(self, user_repo: UserRepo) -&gt; None:\n        self.user_repo = user_repo\n\n    def create_user(self, user_id: str, user_data: dict) -&gt; None:\n        self.user_repo.add_user(user_id, user_data)\n\n    def retrieve_user(self, user_id: str) -&gt; dict | None:\n        return self.user_repo.get_user(user_id)\n\n    def remove_user(self, user_id: str) -&gt; None:\n        self.user_repo.delete_user(user_id)\n\n# Setup FastAPI and InjectQ\napp = FastAPI()\ncontainer = InjectQ.get_instance()\nsetup_fastapi(container, app)\n\n# Routes with dependency injection\n@app.post(\"/users/{user_id}\")\ndef create_user(\n    user_id: str,\n    user_service: Annotated[UserService, InjectFastAPI(UserService)],\n) -&gt; dict:\n    user_service.create_user(user_id, {\"name\": \"John Doe\"})\n    return {\"message\": \"User created successfully\"}\n\n@app.get(\"/users/{user_id}\")\ndef get_user(\n    user_id: str,\n    user_service: Annotated[UserService, InjectFastAPI(UserService)],\n) -&gt; dict:\n    user = user_service.retrieve_user(user_id)\n    if user:\n        return user\n    raise HTTPException(status_code=404, detail=\"User not found\")\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"127.0.0.1\", port=8000)\n</code></pre>"},{"location":"integrations/fastapi/#using-with-modules","title":"Using with Modules","text":"<p>Organize FastAPI services with modules:</p> <pre><code>from typing import Annotated\nfrom injectq import Module, InjectQ\nfrom injectq.integrations.fastapi import InjectFastAPI, setup_fastapi\nfrom fastapi import FastAPI\n\n# Define modules\nclass DatabaseModule(Module):\n    def configure(self, binder):\n        binder.bind(Database, Database())\n\nclass ServiceModule(Module):\n    def configure(self, binder):\n        binder.bind(UserService, UserService())\n\n# Setup\napp = FastAPI()\ncontainer = InjectQ(modules=[\n    DatabaseModule(),\n    ServiceModule()\n])\n\nsetup_fastapi(container, app)\n\n# Routes use services from modules\n@app.get(\"/users\")\ndef get_users(service: Annotated[UserService, InjectFastAPI(UserService)]) -&gt; list:\n    return service.get_users()\n\n@app.post(\"/users\")\ndef create_user(\n    name: str,\n    service: Annotated[UserService, InjectFastAPI(UserService)]\n) -&gt; dict:\n    return service.create_user(name)\n</code></pre>"},{"location":"integrations/fastapi/#common-patterns","title":"Common Patterns","text":""},{"location":"integrations/fastapi/#request-scoped-services","title":"Request-Scoped Services","text":"<pre><code>from typing import Annotated\nfrom uuid import uuid4\nfrom injectq import scoped\n\n@scoped\nclass RequestContext:\n    def __init__(self):\n        self.request_id = str(uuid4())\n        self.user_id = None\n\n@app.get(\"/items/{item_id}\")\ndef get_item(\n    item_id: int,\n    context: Annotated[RequestContext, InjectFastAPI(RequestContext)]\n):\n    print(f\"[{context.request_id}] Fetching item {item_id}\")\n    return {\"id\": item_id, \"request_id\": context.request_id}\n</code></pre>"},{"location":"integrations/fastapi/#dependency-chains","title":"Dependency Chains","text":"<pre><code>from typing import Annotated\nfrom injectq import singleton, inject\n\n@singleton\nclass EmailService:\n    def send_email(self, to: str, subject: str) -&gt; bool:\n        print(f\"Email sent to {to}: {subject}\")\n        return True\n\n@singleton\nclass UserNotificationService:\n    @inject\n    def __init__(self, email: EmailService) -&gt; None:\n        self.email = email\n\n    def notify_user(self, user_id: int, message: str) -&gt; bool:\n        return self.email.send_email(f\"user{user_id}@example.com\", message)\n\n@app.post(\"/notify/{user_id}\")\ndef notify(\n    user_id: int,\n    message: str,\n    notifier: Annotated[UserNotificationService, InjectFastAPI(UserNotificationService)]\n) -&gt; dict:\n    success = notifier.notify_user(user_id, message)\n    return {\"sent\": success}\n</code></pre>"},{"location":"integrations/fastapi/#multiple-dependency-injection","title":"Multiple Dependency Injection","text":"<pre><code>from typing import Annotated\nfrom injectq import singleton\n\n@singleton\nclass AuthService:\n    def verify_token(self, token: str) -&gt; bool:\n        return token == \"valid_token\"\n\n@singleton\nclass DataService:\n    def get_data(self) -&gt; dict:\n        return {\"data\": \"value\"}\n\n@app.get(\"/secure-data\")\ndef get_secure_data(\n    auth: Annotated[AuthService, InjectFastAPI(AuthService)],\n    data: Annotated[DataService, InjectFastAPI(DataService)]\n) -&gt; dict:\n    if not auth.verify_token(\"valid_token\"):\n        raise HTTPException(status_code=401, detail=\"Unauthorized\")\n    return data.get_data()\n</code></pre>"},{"location":"integrations/fastapi/#testing","title":"Testing","text":"<p>Test FastAPI routes with mocked dependencies:</p> <pre><code>from typing import Annotated\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom fastapi import FastAPI\nfrom injectq import InjectQ\nfrom injectq.integrations.fastapi import InjectFastAPI, setup_fastapi\n\nclass MockUserService:\n    def get_users(self):\n        return [{\"id\": 1, \"name\": \"Test User\"}]\n\n    def create_user(self, name: str):\n        return {\"name\": name}\n\n@pytest.fixture\ndef test_app():\n    \"\"\"Create test app with mocked services\"\"\"\n    app = FastAPI()\n    container = InjectQ()\n    container[UserService] = MockUserService()\n\n    setup_fastapi(container, app)\n\n    # Define routes\n    @app.get(\"/users\")\n    def get_users(service: Annotated[UserService, InjectFastAPI(UserService)]):\n        return service.get_users()\n\n    @app.post(\"/users\")\n    def create_user(\n        name: str,\n        service: Annotated[UserService, InjectFastAPI(UserService)]\n    ):\n        return service.create_user(name)\n\n    return app\n\ndef test_get_users(test_app):\n    client = TestClient(test_app)\n    response = client.get(\"/users\")\n\n    assert response.status_code == 200\n    assert len(response.json()) == 1\n    assert response.json()[0][\"name\"] == \"Test User\"\n\ndef test_create_user(test_app):\n    client = TestClient(test_app)\n    response = client.post(\"/users?name=Alice\")\n\n    assert response.status_code == 200\n    assert response.json()[\"name\"] == \"Alice\"\n</code></pre>"},{"location":"integrations/fastapi/#best-practices","title":"Best Practices","text":""},{"location":"integrations/fastapi/#good-patterns","title":"\u2705 Good Patterns","text":"<p>1. Use singleton for shared resources <pre><code>@singleton\nclass DatabasePool:\n    def __init__(self):\n        self.pool = create_connection_pool()\n\n@singleton\nclass CacheService:\n    def __init__(self):\n        self.cache = {}\n</code></pre></p> <p>2. Use scoped for request-specific data <pre><code>@scoped\nclass RequestContext:\n    def __init__(self):\n        from uuid import uuid4\n        self.request_id = str(uuid4())\n</code></pre></p> <p>3. Always use Annotated with InjectFastAPI <pre><code># \u2705 Good - clear, type-safe\n@app.get(\"/items\")\ndef get_items(\n    service: Annotated[ItemService, InjectFastAPI(ItemService)]\n):\n    return service.get_items()\n</code></pre></p>"},{"location":"integrations/fastapi/#bad-patterns","title":"\u274c Bad Patterns","text":"<p>1. Don't access container directly in routes <pre><code># \u274c Bad - manual resolution\n@app.get(\"/items/{item_id}\")\ndef get_item(item_id: int):\n    service = container.get(ItemService)\n    return service.get_item(item_id)\n\n# \u2705 Good - let FastAPI inject\n@app.get(\"/items/{item_id}\")\ndef get_item(\n    item_id: int,\n    service: Annotated[ItemService, InjectFastAPI(ItemService)]\n):\n    return service.get_item(item_id)\n</code></pre></p> <p>2. Don't use singleton for request-specific data <pre><code># \u274c Bad - shared across requests!\n@singleton\nclass UserContext:\n    def __init__(self):\n        self.user_id = None\n\n# \u2705 Good - isolated per request\n@scoped\nclass UserContext:\n    def __init__(self):\n        self.user_id = None\n</code></pre></p> <p>3. Don't forget to call setup_fastapi() first <pre><code># \u274c Bad - forgot middleware\napp = FastAPI()\ncontainer = InjectQ.get_instance()\n\n@app.get(\"/users\")\ndef get_users(service: Annotated[UserService, InjectFastAPI(UserService)]):\n    pass  # This will fail - no middleware!\n\n# \u2705 Good - setup first\napp = FastAPI()\ncontainer = InjectQ.get_instance()\nsetup_fastapi(container, app)  # Must be called first\n\n@app.get(\"/users\")\ndef get_users(service: Annotated[UserService, InjectFastAPI(UserService)]):\n    pass  # Now it works!\n</code></pre></p>"},{"location":"integrations/fastapi/#performance-notes","title":"Performance Notes","text":"<p>The FastAPI integration uses ContextVars for per-request container propagation:</p> <ul> <li>O(1) overhead - ContextVar set/reset is constant time</li> <li>No async complications - ContextVars handle async context propagation automatically</li> <li>No per-request initialization - Middleware just sets the container reference</li> <li>Suitable for high-throughput APIs - Tested with thousands of requests per second</li> </ul>"},{"location":"integrations/fastapi/#summary","title":"Summary","text":"<p>FastAPI integration provides:</p> <ul> <li>Simple setup - Just <code>setup_fastapi(container, app)</code> before defining routes</li> <li>Type-safe injection - Use <code>Annotated[ServiceType, InjectFastAPI(ServiceType)]</code> in route parameters</li> <li>Request isolation - Each request gets its own scoped container context via ContextVars</li> <li>Zero global state - No singleton container pollution</li> <li>High performance - O(1) ContextVar operations, async-safe</li> <li>Easy testing - Mock dependencies by rebinding in test container</li> </ul> <p>Key components: - <code>setup_fastapi(container, app)</code> - Register integration (call first!) - <code>InjectFastAPI[ServiceType]</code> - Inject dependencies with Annotated - <code>InjectQRequestMiddleware</code> - Automatic middleware for context propagation</p> <p>Best practices: - Use <code>Annotated[ServiceType, InjectFastAPI(ServiceType)]</code> for type safety - Call <code>setup_fastapi()</code> before defining any routes - Use singleton for shared resources - Use scoped for request-specific data - Test with mocked dependencies - Organize services with modules</p> <p>Ready to explore Taskiq integration?</p>"},{"location":"integrations/taskiq/","title":"Taskiq Integration","text":"<p>InjectQ provides seamless dependency injection for Taskiq background tasks using a lightweight, context-based approach.</p>"},{"location":"integrations/taskiq/#installation","title":"Installation","text":"<pre><code>pip install injectq[taskiq]\n</code></pre>"},{"location":"integrations/taskiq/#quick-start","title":"Quick Start","text":"<pre><code>from typing import Annotated\nfrom taskiq import InMemoryBroker, Context, TaskiqDepends\nfrom injectq import InjectQ, singleton\nfrom injectq.integrations.taskiq import setup_taskiq, InjectTaskiq\n\n# Define your services\n@singleton\nclass EmailService:\n    def send_email(self, to: str, subject: str) -&gt; None:\n        print(f\"Sending email to {to}: {subject}\")\n\n# Setup\ncontainer = InjectQ.get_instance()\nbroker = InMemoryBroker()\nsetup_taskiq(container, broker)\n\n# Define tasks with dependency injection\n@broker.task\nasync def send_welcome_email(\n    user_email: str,\n    service: Annotated[EmailService, InjectTaskiq(EmailService)]\n):\n    service.send_email(user_email, \"Welcome!\")\n\n# Schedule task\nawait broker(send_welcome_email)(user_email=\"user@example.com\")\n</code></pre>"},{"location":"integrations/taskiq/#how-it-works","title":"How It Works","text":"<p>The Taskiq integration uses: 1. State-based container attachment - The container is stored in <code>broker.state</code> 2. TaskiqDepends for dependency resolution 3. InjectTaskiq as a Taskiq dependency marker for type-safe injection</p>"},{"location":"integrations/taskiq/#core-api","title":"Core API","text":""},{"location":"integrations/taskiq/#setup_taskiqcontainer-broker","title":"<code>setup_taskiq(container, broker)</code>","text":"<p>Registers the InjectQ integration with your Taskiq broker. This attaches the container to the broker's state for task-level access.</p> <pre><code>from injectq import InjectQ\nfrom injectq.integrations.taskiq import setup_taskiq\nfrom taskiq import InMemoryBroker\n\ncontainer = InjectQ.get_instance()\nbroker = InMemoryBroker()\n\n# Register integration - attaches container to broker.state\nsetup_taskiq(container, broker)\n</code></pre>"},{"location":"integrations/taskiq/#injecttaskiqservicetype","title":"<code>InjectTaskiq[ServiceType]</code>","text":"<p>Type-safe dependency marker for Taskiq tasks. Use with <code>Annotated</code> for clean type hints.</p> <pre><code>from typing import Annotated\nfrom injectq.integrations.taskiq import InjectTaskiq\n\n# In task definition\n@broker.task\nasync def process_data(\n    data: dict,\n    service: Annotated[DataService, InjectTaskiq(DataService)]\n):\n    return service.process(data)\n</code></pre>"},{"location":"integrations/taskiq/#injecttaskservicetype-alias","title":"<code>InjectTask[ServiceType]</code> (Alias)","text":"<p>Backwards compatibility alias for <code>InjectTaskiq</code>.</p> <pre><code>from typing import Annotated\nfrom injectq.integrations.taskiq import InjectTask\n\n# Works the same as InjectTaskiq\n@broker.task\nasync def process(\n    data: dict,\n    service: Annotated[DataService, InjectTask(DataService)]\n):\n    return service.process(data)\n</code></pre>"},{"location":"integrations/taskiq/#basic-example","title":"Basic Example","text":"<p>Complete working example with Taskiq:</p> <pre><code>from typing import Annotated\nfrom taskiq import InMemoryBroker, Context, TaskiqDepends\nfrom injectq import InjectQ, singleton, inject\nfrom injectq.integrations.taskiq import InjectTaskiq, setup_taskiq\n\n# Define services\n@singleton\nclass Database:\n    def __init__(self):\n        print(\"Database initialized\")\n        self.data = {\"orders\": []}\n\n    def get_orders(self):\n        return self.data[\"orders\"]\n\n    def save_order(self, order: dict):\n        self.data[\"orders\"].append(order)\n\n@singleton\nclass EmailService:\n    def send_email(self, to: str, subject: str, body: str):\n        print(f\"Email to {to}: {subject}\")\n\n@singleton\nclass OrderService:\n    @inject\n    def __init__(self, db: Database, email: EmailService):\n        self.db = db\n        self.email = email\n\n    def process_order(self, order_id: int):\n        order = {\"id\": order_id, \"status\": \"processing\"}\n        self.db.save_order(order)\n        self.email.send_email(\"admin@example.com\", f\"Order {order_id}\", \"New order\")\n        return order\n\n# Setup\ncontainer = InjectQ.get_instance()\nbroker = InMemoryBroker()\nsetup_taskiq(container, broker)\n\n# Define tasks\n@broker.task\nasync def process_new_order(\n    order_id: int,\n    service: Annotated[OrderService, InjectTaskiq(OrderService)]\n):\n    \"\"\"Process a new order\"\"\"\n    return service.process_order(order_id)\n\n@broker.task\nasync def send_notification(\n    user_email: str,\n    service: Annotated[EmailService, InjectTaskiq(EmailService)]\n):\n    \"\"\"Send notification email\"\"\"\n    service.send_email(user_email, \"Notification\", \"Your order is ready!\")\n\n# Schedule tasks\nasync def main():\n    await broker(process_new_order)(order_id=123)\n    await broker(send_notification)(user_email=\"user@example.com\")\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())\n</code></pre>"},{"location":"integrations/taskiq/#using-with-modules","title":"Using with Modules","text":"<p>Organize task services with modules:</p> <pre><code>from typing import Annotated\nfrom injectq import Module, InjectQ\nfrom injectq.integrations.taskiq import InjectTaskiq, setup_taskiq\nfrom taskiq import InMemoryBroker\n\n# Define modules\nclass DatabaseModule(Module):\n    def configure(self, binder):\n        binder.bind(Database, Database())\n\nclass ServiceModule(Module):\n    def configure(self, binder):\n        binder.bind(EmailService, EmailService())\n        binder.bind(OrderService, OrderService())\n\n# Setup\ncontainer = InjectQ(modules=[\n    DatabaseModule(),\n    ServiceModule()\n])\n\nbroker = InMemoryBroker()\nsetup_taskiq(container, broker)\n\n# Tasks use services from modules\n@broker.task\nasync def process_order(\n    order_id: int,\n    service: Annotated[OrderService, InjectTaskiq(OrderService)]\n):\n    return service.process_order(order_id)\n\n@broker.task\nasync def send_email(\n    to: str,\n    service: Annotated[EmailService, InjectTaskiq(EmailService)]\n):\n    service.send_email(to, \"Update\", \"Your order status changed\")\n</code></pre>"},{"location":"integrations/taskiq/#common-patterns","title":"Common Patterns","text":""},{"location":"integrations/taskiq/#dependency-chains","title":"Dependency Chains","text":"<pre><code>from typing import Annotated\nfrom injectq import singleton, inject\n\n@singleton\nclass Logger:\n    def log(self, msg: str):\n        print(f\"[LOG] {msg}\")\n\n@singleton\nclass ProcessingService:\n    @inject\n    def __init__(self, logger: Logger):\n        self.logger = logger\n\n    def process(self, data: dict):\n        self.logger.log(f\"Processing {len(data)} items\")\n        return {\"status\": \"done\", \"items\": len(data)}\n\n@broker.task\nasync def batch_process(\n    data: dict,\n    service: Annotated[ProcessingService, InjectTaskiq(ProcessingService)]\n):\n    return service.process(data)\n</code></pre>"},{"location":"integrations/taskiq/#scoped-services","title":"Scoped Services","text":"<pre><code>from typing import Annotated\nfrom uuid import uuid4\nfrom injectq import scoped\n\n@scoped\nclass TaskContext:\n    def __init__(self):\n        self.task_id = str(uuid4())\n        self.start_time = __import__(\"time\").time()\n\n    def get_duration(self):\n        return __import__(\"time\").time() - self.start_time\n\n@broker.task\nasync def long_running_task(\n    data: dict,\n    ctx: Annotated[TaskContext, InjectTaskiq(TaskContext)],\n    processor: Annotated[DataProcessor, InjectTaskiq(DataProcessor)]\n):\n    result = processor.process(data)\n    print(f\"Task {ctx.task_id} completed in {ctx.get_duration():.2f}s\")\n    return result\n</code></pre>"},{"location":"integrations/taskiq/#error-handling","title":"Error Handling","text":"<pre><code>from typing import Annotated\n\n@broker.task(max_retries=3)\nasync def retry_task(\n    item_id: int,\n    service: Annotated[ProcessingService, InjectTaskiq(ProcessingService)]\n):\n    \"\"\"Task with retry logic\"\"\"\n    try:\n        return service.process_item(item_id)\n    except ProcessingError as e:\n        # Taskiq handles retries\n        raise\n</code></pre>"},{"location":"integrations/taskiq/#testing","title":"Testing","text":"<p>Test tasks with mocked dependencies:</p> <pre><code>import pytest\nfrom typing import Annotated\nfrom injectq import InjectQ\nfrom injectq.integrations.taskiq import InjectTaskiq, setup_taskiq\nfrom taskiq import InMemoryBroker\n\nclass MockEmailService:\n    def __init__(self):\n        self.sent_emails = []\n\n    def send_email(self, to: str, subject: str, body: str):\n        self.sent_emails.append({\"to\": to, \"subject\": subject})\n        return True\n\n@pytest.fixture\ndef test_broker():\n    \"\"\"Create test broker with mocked services\"\"\"\n    broker = InMemoryBroker()\n    container = InjectQ()\n\n    # Use mocks instead of real services\n    container[EmailService] = MockEmailService\n\n    setup_taskiq(container, broker)\n    return broker\n\n@pytest.mark.asyncio\nasync def test_send_email(test_broker):\n    @test_broker.task\n    async def send_welcome(\n        email: str,\n        service: Annotated[EmailService, InjectTaskiq(EmailService)]\n    ):\n        service.send_email(email, \"Welcome\", \"Welcome to our app!\")\n\n    await test_broker(send_welcome)(email=\"test@example.com\")\n\n    # Verify email was \"sent\"\n    service = test_broker.state.injectq_container[EmailService]\n    assert len(service.sent_emails) == 1\n    assert service.sent_emails[0][\"to\"] == \"test@example.com\"\n</code></pre>"},{"location":"integrations/taskiq/#best-practices","title":"Best Practices","text":""},{"location":"integrations/taskiq/#good-patterns","title":"\u2705 Good Patterns","text":"<p>1. Use singleton for shared resources <pre><code>@singleton\nclass DatabaseConnection:\n    pass\n\n@singleton\nclass CacheService:\n    pass\n</code></pre></p> <p>2. Use dependency injection in all tasks <pre><code>@broker.task\nasync def my_task(\n    service: Annotated[MyService, InjectTaskiq(MyService)]\n):\n    return service.do_something()\n</code></pre></p> <p>3. Use scoped for task-specific data <pre><code>@scoped\nclass TaskContext:\n    def __init__(self):\n        from uuid import uuid4\n        self.task_id = str(uuid4())\n</code></pre></p>"},{"location":"integrations/taskiq/#bad-patterns","title":"\u274c Bad Patterns","text":"<p>1. Don't access container directly <pre><code># \u274c Bad\n@broker.task\nasync def my_task():\n    service = container.get(MyService)\n    return service.do_something()\n\n# \u2705 Good\n@broker.task\nasync def my_task(\n    service: Annotated[MyService, InjectTaskiq(MyService)]\n):\n    return service.do_something()\n</code></pre></p> <p>2. Don't use singleton for task-specific data <pre><code># \u274c Bad - shared across tasks!\n@singleton\nclass TaskContext:\n    def __init__(self):\n        self.data = {}\n\n# \u2705 Good - isolated per task\n@scoped\nclass TaskContext:\n    def __init__(self):\n        self.data = {}\n</code></pre></p>"},{"location":"integrations/taskiq/#summary","title":"Summary","text":"<p>Taskiq integration provides:</p> <ul> <li>Simple setup - Just <code>setup_taskiq(container, broker)</code> once at startup</li> <li>Type-safe injection - Use <code>Annotated[ServiceType, InjectTaskiq(ServiceType)]</code> in tasks</li> <li>Task isolation - Each task gets its own container context via Taskiq's dependency system</li> <li>Zero global state - No singleton container pollution</li> <li>Easy testing - Mock dependencies by rebinding in test container</li> </ul> <p>Key components:</p> <ul> <li><code>setup_taskiq(container, broker)</code> - Register integration</li> <li><code>InjectTaskiq[ServiceType]</code> or <code>InjectTask[ServiceType]</code> - Inject dependencies in tasks</li> <li>Singleton, scoped, and transient scopes all supported</li> </ul> <p>Best practices:</p> <ul> <li>Use dependency injection in all tasks</li> <li>Use singleton for shared resources</li> <li>Use scoped for task-specific data</li> <li>Test with mocked dependencies</li> <li>Organize services with modules</li> </ul>"},{"location":"modules/overview/","title":"Modules &amp; Providers","text":"<p>Organize your dependency injection configuration into reusable, composable units.</p>"},{"location":"modules/overview/#what-are-modules","title":"What are Modules?","text":"<p>Modules are containers for related bindings that group services together.</p> <pre><code>from injectq import InjectQ\nfrom injectq.modules import Module\n\nclass DatabaseModule(Module):\n    def configure(self, binder):\n        binder.bind(Database, PostgresDatabase)\n        binder.bind(UserRepository, UserRepositoryImpl)\n\ncontainer = InjectQ.get_instance()\ncontainer.install_module(DatabaseModule())\n\n# Services are now available\nrepo = container[UserRepository]\n</code></pre>"},{"location":"modules/overview/#module-types","title":"Module Types","text":""},{"location":"modules/overview/#1-simple-module","title":"1. Simple Module","text":"<p>Basic module for straightforward bindings:</p> <pre><code>from injectq.modules import SimpleModule\n\nmodule = SimpleModule() \\\n    .bind(Database, PostgresDatabase) \\\n    .bind(Cache, RedisCache) \\\n    .bind_instance(\"api_key\", \"secret-123\")\n\ncontainer.install_module(module)\n</code></pre>"},{"location":"modules/overview/#2-configuration-module","title":"2. Configuration Module","text":"<p>Bind configuration values:</p> <pre><code>from injectq.modules import ConfigurationModule\n\nconfig = {\n    \"db_host\": \"localhost\",\n    \"db_port\": 5432,\n    \"api_key\": \"secret-key\"\n}\n\ncontainer.install_module(ConfigurationModule(config))\n\n# Access configuration\nhost = container[\"db_host\"]\nport = container[\"db_port\"]\n</code></pre>"},{"location":"modules/overview/#3-provider-module","title":"3. Provider Module","text":"<p>Most powerful - use <code>@provider</code> methods for complex initialization:</p> <pre><code>from injectq.modules import ProviderModule, provider\n\nclass AppModule(ProviderModule):\n    @provider\n    def provide_database_config(\n        self, db_host: str, db_port: int, db_name: str\n    ) -&gt; DatabaseConfig:\n        \"\"\"Provider parameters are auto-injected\"\"\"\n        return DatabaseConfig(\n            host=db_host,\n            port=db_port,\n            database=db_name\n        )\n\n    @provider\n    def provide_database(self, config: DatabaseConfig) -&gt; Database:\n        \"\"\"Compose dependencies with initialization logic\"\"\"\n        db = Database(config)\n        db.connect()  # Custom initialization\n        return db\n\n# Bind config values\ncontainer.bind_instance(\"db_host\", \"localhost\")\ncontainer.bind_instance(\"db_port\", 5432)\ncontainer.bind_instance(\"db_name\", \"myapp\")\n\n# Install module\ncontainer.install_module(AppModule())\n\n# Get fully initialized database\ndb = container[Database]\n</code></pre>"},{"location":"modules/overview/#provider-pattern-recommended","title":"Provider Pattern (Recommended)","text":"<p>The @provider pattern is the most powerful way to create complex dependencies.</p>"},{"location":"modules/overview/#basic-provider","title":"Basic Provider","text":"<pre><code>class ServiceModule(ProviderModule):\n    @provider\n    def provide_logger(self, app_name: str, log_level: str) -&gt; Logger:\n        \"\"\"Return type annotation determines what this provides\"\"\"\n        return Logger(name=app_name, level=log_level)\n\n# Bind parameters\ncontainer.bind_instance(\"app_name\", \"MyApp\")\ncontainer.bind_instance(\"log_level\", \"INFO\")\n\n# Install and use\ncontainer.install_module(ServiceModule())\nlogger = container[Logger]\n</code></pre>"},{"location":"modules/overview/#provider-with-dependencies","title":"Provider with Dependencies","text":"<pre><code>class UserModule(ProviderModule):\n    @provider\n    def provide_user_service(\n        self, database: Database, cache: Cache, logger: Logger\n    ) -&gt; UserService:\n        \"\"\"Dependencies are auto-injected\"\"\"\n        return UserService(db=database, cache=cache, logger=logger)\n</code></pre>"},{"location":"modules/overview/#provider-with-initialization","title":"Provider with Initialization","text":"<pre><code>class DatabaseModule(ProviderModule):\n    @provider\n    def provide_database(self, config: DatabaseConfig) -&gt; Database:\n        \"\"\"Perform complex initialization\"\"\"\n        db = Database(config)\n        db.connect()\n        db.setup_tables()\n        db.run_migrations()\n        return db\n</code></pre>"},{"location":"modules/overview/#environment-specific-providers","title":"Environment-Specific Providers","text":"<pre><code>class EnvironmentModule(ProviderModule):\n    def __init__(self, environment: str):\n        self.environment = environment\n\n    @provider\n    def provide_database_config(self) -&gt; DatabaseConfig:\n        \"\"\"Use module state for environment-specific logic\"\"\"\n        if self.environment == \"production\":\n            return DatabaseConfig(\n                host=\"prod-db.example.com\",\n                port=5432,\n                ssl=True\n            )\n        else:  # development\n            return DatabaseConfig(\n                host=\"localhost\",\n                port=5432,\n                ssl=False\n            )\n\n# Usage\ncontainer.install_module(EnvironmentModule(\"production\"))\n</code></pre>"},{"location":"modules/overview/#complete-example","title":"Complete Example","text":"<pre><code>from injectq import InjectQ\nfrom injectq.modules import ProviderModule, provider\n\n# Domain models\nclass DatabaseConfig:\n    def __init__(self, host: str, port: int):\n        self.host = host\n        self.port = port\n\nclass Database:\n    def __init__(self, config: DatabaseConfig):\n        self.config = config\n        self.connected = False\n\n    def connect(self):\n        self.connected = True\n        print(f\"Connected to {self.config.host}\")\n\nclass UserService:\n    def __init__(self, db: Database, logger: Logger):\n        self.db = db\n        self.logger = logger\n\n# Provider module\nclass ApplicationModule(ProviderModule):\n    @provider\n    def provide_database_config(\n        self, db_host: str, db_port: int\n    ) -&gt; DatabaseConfig:\n        return DatabaseConfig(host=db_host, port=db_port)\n\n    @provider\n    def provide_database(self, config: DatabaseConfig) -&gt; Database:\n        db = Database(config)\n        db.connect()  # Initialize\n        return db\n\n    @provider\n    def provide_logger(self, log_level: str) -&gt; Logger:\n        return Logger(level=log_level)\n\n    @provider\n    def provide_user_service(\n        self, db: Database, logger: Logger\n    ) -&gt; UserService:\n        return UserService(db=db, logger=logger)\n\n# Setup\ncontainer = InjectQ.get_instance()\n\n# Bind configuration\ncontainer.bind_instance(\"db_host\", \"localhost\")\ncontainer.bind_instance(\"db_port\", 5432)\ncontainer.bind_instance(\"log_level\", \"INFO\")\n\n# Install module\ncontainer.install_module(ApplicationModule())\n\n# Use services\nuser_service = container[UserService]\n# Database is connected, logger is configured\n</code></pre>"},{"location":"modules/overview/#module-patterns","title":"Module Patterns","text":""},{"location":"modules/overview/#domain-modules","title":"Domain Modules","text":"<pre><code>class UserModule(ProviderModule):\n    @provider\n    def provide_user_repository(self, db: Database) -&gt; UserRepository:\n        return UserRepository(db)\n\n    @provider\n    def provide_user_service(self, repo: UserRepository) -&gt; UserService:\n        return UserService(repo)\n\nclass OrderModule(ProviderModule):\n    @provider\n    def provide_order_repository(self, db: Database) -&gt; OrderRepository:\n        return OrderRepository(db)\n\n    @provider\n    def provide_order_service(self, repo: OrderRepository) -&gt; OrderService:\n        return OrderService(repo)\n</code></pre>"},{"location":"modules/overview/#infrastructure-module","title":"Infrastructure Module","text":"<pre><code>class InfrastructureModule(ProviderModule):\n    @provider\n    def provide_database(self, db_url: str) -&gt; Database:\n        return Database(db_url)\n\n    @provider\n    def provide_cache(self, redis_url: str) -&gt; Cache:\n        return RedisCache(redis_url)\n\n    @provider\n    def provide_queue(self, queue_url: str) -&gt; Queue:\n        return MessageQueue(queue_url)\n</code></pre>"},{"location":"modules/overview/#testing-modules","title":"Testing Modules","text":"<pre><code>class TestModule(ProviderModule):\n    @provider\n    def provide_database(self) -&gt; Database:\n        return InMemoryDatabase()\n\n    @provider\n    def provide_cache(self) -&gt; Cache:\n        return MockCache()\n\n# Test setup\ndef test_user_service():\n    container = InjectQ.get_instance()\n    container.install_module(TestModule())\n\n    service = container[UserService]\n    # Uses mocked dependencies\n</code></pre>"},{"location":"modules/overview/#best-practices","title":"Best Practices","text":""},{"location":"modules/overview/#use-providers-for-complex-setup","title":"\u2705 Use Providers for Complex Setup","text":"<pre><code>@provider\ndef provide_database(self, config: DatabaseConfig) -&gt; Database:\n    db = Database(config)\n    db.connect()\n    db.run_migrations()\n    return db\n</code></pre>"},{"location":"modules/overview/#one-module-per-domain","title":"\u2705 One Module Per Domain","text":"<pre><code>class UserModule(ProviderModule): pass\nclass OrderModule(ProviderModule): pass\nclass PaymentModule(ProviderModule): pass\n</code></pre>"},{"location":"modules/overview/#environment-specific-modules","title":"\u2705 Environment-Specific Modules","text":"<pre><code>class ProductionModule(ProviderModule):\n    def __init__(self):\n        self.environment = \"production\"\n\n    @provider\n    def provide_config(self) -&gt; Config:\n        return Config(ssl=True, debug=False)\n</code></pre>"},{"location":"modules/overview/#type-annotations-required","title":"\u2705 Type Annotations Required","text":"<pre><code>@provider\ndef provide_database(self, config: DatabaseConfig) -&gt; Database:\n    \"\"\"Return type annotation is required\"\"\"\n    return Database(config)\n</code></pre>"},{"location":"modules/overview/#avoid-god-modules","title":"\u274c Avoid God Modules","text":"<pre><code># \u274c Bad - everything in one module\nclass EverythingModule(ProviderModule):\n    # 50+ providers...\n\n# \u2705 Good - focused modules\nclass DatabaseModule(ProviderModule): pass\nclass CacheModule(ProviderModule): pass\nclass EmailModule(ProviderModule): pass\n</code></pre>"},{"location":"modules/overview/#summary","title":"Summary","text":"<ul> <li>Simple Module: Fluent API for basic bindings</li> <li>Configuration Module: Bind config dictionaries</li> <li>Provider Module: Most powerful - complex initialization</li> </ul> <p>Provider Pattern Benefits: - Auto-inject dependencies into provider methods - Custom initialization logic - Environment-specific configuration - Clean, organized code</p> <p>Key Points: - Use <code>@provider</code> decorator on methods - Return type annotation determines what's provided - Parameters are auto-injected from container - Great for multi-step initialization</p> <p>Next: FastAPI Integration | Testing</p>"},{"location":"scopes/scoped-services/","title":"Scoped Services","text":"<p>One instance per scope context. Same instance within a scope, different instances across scopes.</p>"},{"location":"scopes/scoped-services/#what-are-scoped-services","title":"What are Scoped Services?","text":"<p>Scoped services create one instance per scope. All requests within the same scope get the same instance.</p> <pre><code>from injectq import InjectQ, scoped\n\ncontainer = InjectQ.get_instance()\n\n@scoped(\"request\")\nclass RequestContext:\n    def __init__(self):\n        self.request_id = str(uuid.uuid4())\n        print(f\"Context created: {self.request_id}\")\n\n# Within same scope - same instance\nwith container.scope(\"request\"):\n    ctx1 = container[RequestContext]\n    ctx2 = container[RequestContext]\n    print(ctx1 is ctx2)  # True\n\n# Different scopes - different instances\nwith container.scope(\"request\"):\n    ctx_a = container[RequestContext]\n\nwith container.scope(\"request\"):\n    ctx_b = container[RequestContext]\n\nprint(ctx_a is not ctx_b)  # True\n</code></pre>"},{"location":"scopes/scoped-services/#when-to-use","title":"When to Use","text":"<p>\u2705 Use for: - Web request data - Database transactions - User sessions - Request-scoped cache - Per-operation context</p> <p>\u274c Avoid for: - Global config (use singleton) - Stateless operations (use transient) - Cross-request data (use singleton)</p>"},{"location":"scopes/scoped-services/#examples","title":"Examples","text":""},{"location":"scopes/scoped-services/#good-use-cases","title":"Good Use Cases","text":"<pre><code>@scoped(\"request\")\nclass UserSession:\n    \"\"\"Per-user session data\"\"\"\n    def __init__(self):\n        self.user_id = None\n        self.permissions = []\n\n@scoped(\"request\")\nclass DatabaseTransaction:\n    \"\"\"Per-request transaction\"\"\"\n    def __init__(self, db: Database):\n        self.db = db\n        self.transaction = db.begin_transaction()\n\n    def commit(self):\n        self.transaction.commit()\n\n@scoped(\"request\")\nclass RequestCache:\n    \"\"\"Cache per request\"\"\"\n    def __init__(self):\n        self.data = {}\n</code></pre>"},{"location":"scopes/scoped-services/#bad-use-cases","title":"Bad Use Cases","text":"<pre><code>@scoped(\"request\")\nclass AppConfig:\n    \"\"\"\u274c Bad - config should be global\"\"\"\n    pass\n\n@scoped(\"request\")\nclass EmailValidator:\n    \"\"\"\u274c Bad - validation is stateless\"\"\"\n    pass\n</code></pre>"},{"location":"scopes/scoped-services/#usage-patterns","title":"Usage Patterns","text":""},{"location":"scopes/scoped-services/#web-request-scope","title":"Web Request Scope","text":"<pre><code>from fastapi import FastAPI\nfrom injectq.integrations.fastapi import InjectFastAPI\n\napp = FastAPI()\ninject_fastapi = InjectFastAPI(app)\n\n@scoped(\"request\")\nclass ShoppingCart:\n    def __init__(self):\n        self.items = []\n\n    def add_item(self, item: dict):\n        self.items.append(item)\n\n@app.post(\"/cart/add\")\ndef add_to_cart(\n    item: dict,\n    cart: Annotated[ShoppingCart, Depends()]\n):\n    cart.add_item(item)\n    return {\"items\": len(cart.items)}\n\n# Each HTTP request gets its own cart instance\n</code></pre>"},{"location":"scopes/scoped-services/#manual-scope-management","title":"Manual Scope Management","text":"<pre><code>@scoped(\"request\")\nclass RequestContext:\n    def __init__(self):\n        self.request_id = str(uuid.uuid4())\n\n# Sync scope\nwith container.scope(\"request\"):\n    ctx = container[RequestContext]\n    # ... use context\n\n# Async scope\nasync with container.scope(\"request\"):\n    ctx = await container.aget(RequestContext)\n    # ... use context\n</code></pre>"},{"location":"scopes/scoped-services/#nested-scopes","title":"Nested Scopes","text":"<pre><code>@scoped(\"request\")\nclass RequestData:\n    pass\n\n@scoped(\"transaction\")\nclass TransactionData:\n    pass\n\n# Nested scopes\nwith container.scope(\"request\"):\n    req_data = container[RequestData]\n\n    with container.scope(\"transaction\"):\n        tx_data = container[TransactionData]\n        # Both available here\n\n    # tx_data cleaned up, req_data still available\n\n# req_data cleaned up\n</code></pre>"},{"location":"scopes/scoped-services/#working-with-scopes","title":"Working with Scopes","text":""},{"location":"scopes/scoped-services/#creating-named-scopes","title":"Creating Named Scopes","text":"<pre><code># Define scope names\n@scoped(\"request\")\nclass RequestService:\n    pass\n\n@scoped(\"session\")\nclass SessionService:\n    pass\n\n@scoped(\"transaction\")\nclass TransactionService:\n    pass\n\n# Use appropriate scopes\nwith container.scope(\"request\"):\n    req_svc = container[RequestService]\n\nwith container.scope(\"session\"):\n    sess_svc = container[SessionService]\n</code></pre>"},{"location":"scopes/scoped-services/#clearing-scopes","title":"Clearing Scopes","text":"<pre><code># Clear specific scope\ncontainer.clear_scope(\"request\")\n\n# Clear all scopes\ncontainer.clear_all_scopes()\n</code></pre>"},{"location":"scopes/scoped-services/#scope-lifecycle","title":"Scope Lifecycle","text":"<pre><code>@scoped(\"request\")\nclass Service:\n    def __init__(self):\n        print(\"Service created\")\n\n    def __del__(self):\n        print(\"Service destroyed\")\n\n# Lifecycle\nwith container.scope(\"request\"):\n    svc = container[Service]  # \"Service created\"\n    # ... use service\n# \"Service destroyed\" when scope exits\n</code></pre>"},{"location":"scopes/scoped-services/#fastapi-integration","title":"FastAPI Integration","text":"<pre><code>from fastapi import FastAPI, Depends\nfrom typing import Annotated\nfrom injectq import scoped\nfrom injectq.integrations.fastapi import InjectFastAPI\n\napp = FastAPI()\ninject_fastapi = InjectFastAPI(app)\n\n@scoped(\"request\")\nclass UserContext:\n    def __init__(self):\n        self.user_id = None\n\n@app.get(\"/user/{user_id}\")\ndef get_user(\n    user_id: int,\n    ctx: Annotated[UserContext, Depends()]\n):\n    ctx.user_id = user_id\n    return {\"user_id\": ctx.user_id}\n\n# InjectFastAPI automatically manages request scope\n</code></pre>"},{"location":"scopes/scoped-services/#async-support","title":"Async Support","text":"<pre><code>@scoped(\"request\")\nclass AsyncService:\n    async def process(self):\n        await asyncio.sleep(0.1)\n        return \"processed\"\n\n# Async scope context\nasync with container.scope(\"request\"):\n    service = await container.aget(AsyncService)\n    result = await service.process()\n</code></pre>"},{"location":"scopes/scoped-services/#common-mistakes","title":"Common Mistakes","text":""},{"location":"scopes/scoped-services/#using-scoped-without-scope-context","title":"\u274c Using Scoped Without Scope Context","text":"<pre><code>@scoped(\"request\")\nclass Service:\n    pass\n\n# \u274c No scope context\nservice = container[Service]  # Error or unexpected behavior\n</code></pre>"},{"location":"scopes/scoped-services/#always-use-scope-context","title":"\u2705 Always Use Scope Context","text":"<pre><code>@scoped(\"request\")\nclass Service:\n    pass\n\n# \u2705 Within scope\nwith container.scope(\"request\"):\n    service = container[Service]  # Works correctly\n</code></pre>"},{"location":"scopes/scoped-services/#mixing-scope-names","title":"\u274c Mixing Scope Names","text":"<pre><code>@scoped(\"request\")\nclass Service:\n    pass\n\n# \u274c Wrong scope name\nwith container.scope(\"session\"):\n    service = container[Service]  # May not work as expected\n</code></pre>"},{"location":"scopes/scoped-services/#match-scope-names","title":"\u2705 Match Scope Names","text":"<pre><code>@scoped(\"request\")\nclass Service:\n    pass\n\n# \u2705 Correct scope name\nwith container.scope(\"request\"):\n    service = container[Service]  # Works correctly\n</code></pre>"},{"location":"scopes/scoped-services/#testing-scoped-services","title":"Testing Scoped Services","text":"<pre><code>from injectq.testing import test_container\n\ndef test_scoped_service():\n    with test_container() as container:\n        @scoped(\"request\")\n        class Service:\n            def __init__(self):\n                self.value = 0\n\n        # Test same instance within scope\n        with container.scope(\"request\"):\n            svc1 = container[Service]\n            svc2 = container[Service]\n            assert svc1 is svc2\n\n        # Test different instances across scopes\n        with container.scope(\"request\"):\n            svc3 = container[Service]\n\n        with container.scope(\"request\"):\n            svc4 = container[Service]\n\n        assert svc3 is not svc4\n</code></pre>"},{"location":"scopes/scoped-services/#summary","title":"Summary","text":"<ul> <li>One instance per scope context</li> <li>Same instance within a scope</li> <li>Different instances across scopes</li> <li>Automatic cleanup when scope exits</li> </ul> <p>Use for: Request data, transactions, sessions Avoid for: Global config, stateless operations</p> <p>Key patterns: - Use <code>with container.scope(\"name\"):</code> for sync - Use <code>async with container.scope(\"name\"):</code> for async - Match scope names between decorator and context - Always use within scope context</p> <p>Next: Singleton Scope | Transient Scope</p>"},{"location":"scopes/singleton-scope/","title":"Singleton Scope","text":"<p>One instance shared across the entire application. Created once, reused everywhere.</p>"},{"location":"scopes/singleton-scope/#what-is-singleton","title":"What is Singleton?","text":"<p>Singleton creates one instance for the entire application lifetime. Same instance is returned for all requests.</p> <pre><code>from injectq import InjectQ, singleton\n\ncontainer = InjectQ.get_instance()\n\n@singleton\nclass Database:\n    def __init__(self):\n        print(\"Database created\")\n\n# First access creates instance\ndb1 = container[Database]  # \"Database created\"\n\n# Subsequent accesses return same instance\ndb2 = container[Database]  # No output\nprint(db1 is db2)  # True\n</code></pre>"},{"location":"scopes/singleton-scope/#when-to-use","title":"When to Use","text":"<p>\u2705 Use for: - Database connections - Configuration objects - Caches - Loggers - Expensive resources</p> <p>\u274c Avoid for: - Request-specific data - User sessions - Temporary state</p>"},{"location":"scopes/singleton-scope/#examples","title":"Examples","text":""},{"location":"scopes/singleton-scope/#good-use-cases","title":"Good Use Cases","text":"<pre><code>@singleton\nclass DatabaseConnection:\n    \"\"\"Shared connection pool\"\"\"\n    def __init__(self):\n        self.pool = create_connection_pool()\n\n@singleton\nclass AppConfig:\n    \"\"\"Application settings\"\"\"\n    def __init__(self):\n        self.database_url = os.getenv(\"DATABASE_URL\")\n\n@singleton\nclass RedisCache:\n    \"\"\"Shared cache\"\"\"\n    def __init__(self):\n        self.client = redis.Redis()\n</code></pre>"},{"location":"scopes/singleton-scope/#bad-use-cases","title":"Bad Use Cases","text":"<pre><code>@singleton\nclass UserSession:\n    \"\"\"\u274c Bad - user data gets mixed up\"\"\"\n    def __init__(self):\n        self.user_id = None\n\n@singleton\nclass RequestContext:\n    \"\"\"\u274c Bad - request data gets overwritten\"\"\"\n    def __init__(self):\n        self.request_id = None\n</code></pre>"},{"location":"scopes/singleton-scope/#usage","title":"Usage","text":""},{"location":"scopes/singleton-scope/#using-the-decorator","title":"Using the Decorator","text":"<pre><code>from injectq import singleton\n\n@singleton\nclass Database:\n    pass\n\n# Automatically registered\ndb = container[Database]\n</code></pre>"},{"location":"scopes/singleton-scope/#with-dependencies","title":"With Dependencies","text":"<pre><code>@singleton\nclass Database:\n    pass\n\n@singleton\nclass UserRepository:\n    def __init__(self, db: Database):\n        self.db = db\n\n@singleton\nclass UserService:\n    def __init__(self, repo: UserRepository):\n        self.repo = repo\n\n# All dependencies are singletons\nservice = container[UserService]\n</code></pre>"},{"location":"scopes/singleton-scope/#thread-safety","title":"Thread Safety","text":"<p>Singletons must be thread-safe for concurrent access:</p> <pre><code>@singleton\nclass ThreadSafeCache:\n    def __init__(self):\n        self._data = {}\n        self._lock = threading.Lock()\n\n    def get(self, key: str):\n        with self._lock:\n            return self._data.get(key)\n\n    def set(self, key: str, value):\n        with self._lock:\n            self._data[key] = value\n</code></pre>"},{"location":"scopes/singleton-scope/#common-mistakes","title":"Common Mistakes","text":""},{"location":"scopes/singleton-scope/#storing-request-data","title":"\u274c Storing Request Data","text":"<pre><code>@singleton\nclass UserContext:\n    def __init__(self):\n        self.user_id = None  # Shared across requests!\n\n    def set_user(self, user_id):\n        self.user_id = user_id  # Overwrites for all users\n</code></pre>"},{"location":"scopes/singleton-scope/#use-scoped-instead","title":"\u2705 Use Scoped Instead","text":"<pre><code>@scoped(\"request\")\nclass UserContext:\n    def __init__(self):\n        self.user_id = None  # Isolated per request\n</code></pre>"},{"location":"scopes/singleton-scope/#not-thread-safe","title":"\u274c Not Thread-Safe","text":"<pre><code>@singleton\nclass Counter:\n    def __init__(self):\n        self.count = 0\n\n    def increment(self):\n        self.count += 1  # Race condition!\n</code></pre>"},{"location":"scopes/singleton-scope/#use-locking","title":"\u2705 Use Locking","text":"<pre><code>@singleton\nclass Counter:\n    def __init__(self):\n        self.count = 0\n        self._lock = threading.Lock()\n\n    def increment(self):\n        with self._lock:\n            self.count += 1\n</code></pre>"},{"location":"scopes/singleton-scope/#summary","title":"Summary","text":"<ul> <li>One instance per application</li> <li>Created once, reused everywhere</li> <li>Lazy initialization - created when first requested</li> <li>Thread safety required for concurrent access</li> </ul> <p>Use for: Databases, config, caches, expensive resources Avoid for: Request data, user sessions, temporary state</p> <p>Next: Transient Scope | Scoped Services</p>"},{"location":"scopes/transient-scope/","title":"Transient Scope","text":"<p>A new instance is created every time the service is requested. Perfect for stateless operations.</p>"},{"location":"scopes/transient-scope/#what-is-transient","title":"What is Transient?","text":"<p>Transient creates a fresh instance for each request. No shared state between uses.</p> <pre><code>from injectq import InjectQ, transient\n\ncontainer = InjectQ.get_instance()\n\n@transient\nclass RequestHandler:\n    def __init__(self):\n        self.instance_id = id(self)\n        print(f\"Handler created: {self.instance_id}\")\n\n# Each access creates new instance\nhandler1 = container[RequestHandler]  # \"Handler created: 140...\"\nhandler2 = container[RequestHandler]  # \"Handler created: 140...\" (different ID)\nprint(handler1 is handler2)  # False\n</code></pre>"},{"location":"scopes/transient-scope/#when-to-use","title":"When to Use","text":"<p>\u2705 Use for: - Request handlers - Validators - Command processors - Stateless services - Data processors</p> <p>\u274c Avoid for: - Database connections (expensive) - Caches (should be shared) - Expensive resources</p>"},{"location":"scopes/transient-scope/#examples","title":"Examples","text":""},{"location":"scopes/transient-scope/#good-use-cases","title":"Good Use Cases","text":"<pre><code>@transient\nclass EmailValidator:\n    \"\"\"Stateless validation\"\"\"\n    def validate(self, email: str) -&gt; bool:\n        return \"@\" in email\n\n@transient\nclass DataProcessor:\n    \"\"\"Process data without storing state\"\"\"\n    def process(self, data: dict) -&gt; dict:\n        return {\"processed\": True, **data}\n\n@transient\nclass PasswordHasher:\n    \"\"\"Stateless hashing\"\"\"\n    def hash(self, password: str) -&gt; str:\n        return bcrypt.hashpw(password.encode(), bcrypt.gensalt())\n</code></pre>"},{"location":"scopes/transient-scope/#bad-use-cases","title":"Bad Use Cases","text":"<pre><code>@transient\nclass DatabaseConnection:\n    \"\"\"\u274c Bad - expensive to create\"\"\"\n    def __init__(self):\n        self.conn = create_connection()  # Repeated!\n\n@transient\nclass SharedCache:\n    \"\"\"\u274c Bad - cache should be shared\"\"\"\n    def __init__(self):\n        self.data = {}  # Lost on each creation\n</code></pre>"},{"location":"scopes/transient-scope/#usage","title":"Usage","text":""},{"location":"scopes/transient-scope/#using-the-decorator","title":"Using the Decorator","text":"<pre><code>from injectq import transient\n\n@transient\nclass EmailSender:\n    def __init__(self, config: SMTPConfig):\n        self.config = config\n\n    def send(self, to: str, subject: str, body: str):\n        print(f\"Sending email to {to}\")\n\n# Each request gets new instance\nsender1 = container[EmailSender]\nsender2 = container[EmailSender]\nprint(sender1 is not sender2)  # True\n</code></pre>"},{"location":"scopes/transient-scope/#command-pattern","title":"Command Pattern","text":"<pre><code>@transient\nclass CreateUserCommand:\n    def __init__(self, user_repo: UserRepository):\n        self.repo = user_repo\n\n    def execute(self, user_data: dict) -&gt; User:\n        user = User(**user_data)\n        return self.repo.save(user)\n\n# Each command is isolated\ncommand = container[CreateUserCommand]\nuser = command.execute({\"name\": \"Alice\"})\n</code></pre>"},{"location":"scopes/transient-scope/#common-mistakes","title":"Common Mistakes","text":""},{"location":"scopes/transient-scope/#expensive-initialization","title":"\u274c Expensive Initialization","text":"<pre><code>@transient\nclass Processor:\n    def __init__(self):\n        self.schema = load_database_schema()  # Repeated!\n</code></pre>"},{"location":"scopes/transient-scope/#use-singleton-dependencies","title":"\u2705 Use Singleton Dependencies","text":"<pre><code>@singleton\nclass DatabaseSchema:\n    def __init__(self):\n        self.schema = load_database_schema()  # Once\n\n@transient\nclass Processor:\n    def __init__(self, schema: DatabaseSchema):\n        self.schema = schema  # Reuse\n</code></pre>"},{"location":"scopes/transient-scope/#shared-class-variables","title":"\u274c Shared Class Variables","text":"<pre><code>@transient\nclass Counter:\n    count = 0  # \u274c Shared across instances!\n\n    def increment(self):\n        self.count += 1\n</code></pre>"},{"location":"scopes/transient-scope/#use-instance-variables","title":"\u2705 Use Instance Variables","text":"<pre><code>@transient\nclass Counter:\n    def __init__(self):\n        self.count = 0  # \u2705 Unique per instance\n\n    def increment(self):\n        self.count += 1\n</code></pre>"},{"location":"scopes/transient-scope/#transient-vs-singleton","title":"Transient vs Singleton","text":"Aspect Transient Singleton Instances New each time One instance Memory Higher usage Lower usage Thread Safety Automatic Needs locking State Isolated Shared Creation Cost Every request Once"},{"location":"scopes/transient-scope/#summary","title":"Summary","text":"<ul> <li>New instance per request</li> <li>Complete isolation between uses</li> <li>Automatically thread-safe (no sharing)</li> <li>Keep initialization cheap - avoid expensive operations</li> </ul> <p>Use for: Handlers, validators, commands, stateless services Avoid for: Databases, caches, expensive resources</p> <p>Next: Scoped Services | Singleton Scope</p>"},{"location":"scopes/understanding-scopes/","title":"Understanding Scopes","text":"<p>Scopes control how long service instances live and when they're created.</p>"},{"location":"scopes/understanding-scopes/#what-are-scopes","title":"What are Scopes?","text":"<p>A scope defines the lifecycle of a service: - When it's created - How long it lives - Whether instances are shared</p>"},{"location":"scopes/understanding-scopes/#built-in-scopes","title":"Built-in Scopes","text":""},{"location":"scopes/understanding-scopes/#singleton-one-instance-forever","title":"Singleton - One Instance Forever","text":"<pre><code>from injectq import singleton, InjectQ\n\n@singleton\nclass Database:\n    def __init__(self):\n        print(\"Database created\")\n\ncontainer = InjectQ.get_instance()\n\n# Created once, reused everywhere\ndb1 = container[Database]\ndb2 = container[Database]\nassert db1 is db2  # True\n</code></pre> <p>Use for: Database connections, configuration, caches, loggers</p>"},{"location":"scopes/understanding-scopes/#transient-new-instance-every-time","title":"Transient - New Instance Every Time","text":"<pre><code>from injectq import transient\nimport uuid\n\n@transient\nclass RequestHandler:\n    def __init__(self):\n        self.id = uuid.uuid4()\n\n# New instance each time\nhandler1 = container[RequestHandler]\nhandler2 = container[RequestHandler]\nassert handler1 is not handler2  # True\n</code></pre> <p>Use for: Request handlers, validators, temporary objects</p>"},{"location":"scopes/understanding-scopes/#scoped-one-instance-per-scope","title":"Scoped - One Instance Per Scope","text":"<pre><code>from injectq import scoped\n\n@scoped(\"request\")\nclass UserSession:\n    def __init__(self):\n        self.user_id = None\n\n# One instance within a scope\nasync with container.scope(\"request\"):\n    session1 = container[UserSession]\n    session2 = container[UserSession]\n    assert session1 is session2  # True\n\n# New scope = new instance\nasync with container.scope(\"request\"):\n    session3 = container[UserSession]\n    assert session1 is not session3  # True\n</code></pre> <p>Use for: Request context, user sessions, transaction data</p>"},{"location":"scopes/understanding-scopes/#choosing-the-right-scope","title":"Choosing the Right Scope","text":"Scope When to Use Examples Singleton Shared across app Database, Config, Cache Transient Stateless operations Validators, Handlers Scoped Per-request state Session, Context"},{"location":"scopes/understanding-scopes/#working-with-scopes","title":"Working with Scopes","text":""},{"location":"scopes/understanding-scopes/#creating-scopes","title":"Creating Scopes","text":"<pre><code>from injectq import InjectQ\n\ncontainer = InjectQ.get_instance()\n\n# Sync scope\nwith container.scope(\"request\"):\n    service = container[RequestService]\n\n# Async scope\nasync with container.scope(\"request\"):\n    service = await container.aget(AsyncService)\n</code></pre>"},{"location":"scopes/understanding-scopes/#clearing-scopes","title":"Clearing Scopes","text":"<pre><code># Clear specific scope\ncontainer.clear_scope(\"request\")\n\n# Clear all scopes\ncontainer.clear_all_scopes()\n</code></pre>"},{"location":"scopes/understanding-scopes/#common-mistakes","title":"Common Mistakes","text":""},{"location":"scopes/understanding-scopes/#wrong-singleton-with-request-data","title":"\u274c Wrong: Singleton with Request Data","text":"<pre><code>@singleton\nclass UserContext:\n    def __init__(self):\n        self.user_id = None  # Shared across all requests!\n</code></pre>"},{"location":"scopes/understanding-scopes/#right-scoped-for-request-data","title":"\u2705 Right: Scoped for Request Data","text":"<pre><code>@scoped(\"request\")\nclass UserContext:\n    def __init__(self):\n        self.user_id = None  # Isolated per request\n</code></pre>"},{"location":"scopes/understanding-scopes/#wrong-transient-for-expensive-resources","title":"\u274c Wrong: Transient for Expensive Resources","text":"<pre><code>@transient\nclass DatabaseConnection:\n    def __init__(self):\n        self.conn = create_connection()  # Created every time!\n</code></pre>"},{"location":"scopes/understanding-scopes/#right-singleton-for-expensive-resources","title":"\u2705 Right: Singleton for Expensive Resources","text":"<pre><code>@singleton\nclass DatabaseConnection:\n    def __init__(self):\n        self.conn = create_connection()  # Created once\n</code></pre>"},{"location":"scopes/understanding-scopes/#summary","title":"Summary","text":"<ul> <li>Singleton \u2192 One instance app-wide (databases, config)</li> <li>Transient \u2192 New instance each time (validators, handlers)</li> <li>Scoped \u2192 One instance per scope (request context, sessions)</li> </ul> <p>Choose based on: - Data sharing needs - Resource costs - Thread safety requirements</p> <p>Next: Singleton Scope | Transient Scope | Scoped Services</p>"},{"location":"testing/overview/","title":"Testing","text":"<p>InjectQ provides utilities to test dependency-injected code with proper isolation and mocking.</p>"},{"location":"testing/overview/#overview","title":"\ud83c\udfaf Overview","text":"<p>InjectQ's testing utilities help you:</p> <ul> <li>Isolate dependencies - Test services without their real implementations</li> <li>Mock services - Simulate external services easily</li> <li>Override bindings - Temporarily replace implementations for testing</li> <li>Verify behavior - Ensure services work as expected</li> </ul>"},{"location":"testing/overview/#testing-documentation","title":"\ud83d\udcc1 Testing Documentation","text":"<p>This section covers:</p> <ul> <li>Testing Patterns - How to test with InjectQ</li> </ul>"},{"location":"testing/overview/#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"testing/overview/#basic-test-setup","title":"Basic Test Setup","text":"<pre><code>from injectq.testing import test_container\n\ndef test_user_service():\n    \"\"\"Test UserService with mocked dependencies.\"\"\"\n    with test_container() as container:\n        # Bind dependencies\n        container[Database] = MockDatabase()\n        container[UserService] = UserService\n\n        # Get service from container\n        service = container[UserService]\n\n        # Test the service\n        user = service.get_user(1)\n        assert user is not None\n</code></pre>"},{"location":"testing/overview/#override-dependencies","title":"Override Dependencies","text":"<pre><code>from injectq.testing import override_dependency\n\ndef test_with_override():\n    \"\"\"Temporarily override a dependency.\"\"\"\n    from injectq import InjectQ\n\n    container = InjectQ.get_instance()\n    mock_service = MockUserService()\n\n    with override_dependency(UserService, mock_service):\n        service = container[UserService]\n        result = service.get_user(1)\n\n        assert isinstance(service, MockUserService)\n</code></pre>"},{"location":"testing/overview/#testing-patterns","title":"\ud83e\uddea Testing Patterns","text":""},{"location":"testing/overview/#unit-testing","title":"Unit Testing","text":"<pre><code>from injectq.testing import test_container\n\ndef test_service_with_mocks():\n    \"\"\"Test service with mocked external dependencies.\"\"\"\n    with test_container() as container:\n        # Mock external services\n        container[EmailService] = MockEmailService()\n        container[Database] = MockDatabase()\n\n        # Real internal service\n        container[UserService] = UserService\n\n        # Test\n        service = container[UserService]\n        result = service.register_user(\"test@example.com\")\n\n        assert result.email == \"test@example.com\"\n</code></pre>"},{"location":"testing/overview/#error-handling","title":"Error Handling","text":"<pre><code>import pytest\nfrom injectq.testing import test_container\n\ndef test_error_handling():\n    \"\"\"Test that services handle errors correctly.\"\"\"\n    with test_container() as container:\n        container[UserService] = UserService\n        container[UserRepository] = MockUserRepository()\n\n        service = container[UserService]\n\n        with pytest.raises(UserNotFoundError):\n            service.get_user(999)\n</code></pre>"},{"location":"testing/overview/#best-practices","title":"\ud83c\udfc6 Best Practices","text":""},{"location":"testing/overview/#do","title":"\u2705 DO","text":"<ul> <li>Use test_container() for isolated tests</li> <li>Mock external dependencies only (APIs, databases, email)</li> <li>Keep tests focused - one behavior per test</li> <li>Use mocks with tracking - verify calls were made</li> </ul> <pre><code># \u2705 Good\nwith test_container() as container:\n    mock_db = MockDatabase()\n    container[Database] = mock_db\n    container[UserService] = UserService\n\n    service = container[UserService]\n    service.create_user(\"test@example.com\")\n\n    assert mock_db.save_called\n</code></pre>"},{"location":"testing/overview/#dont","title":"\u274c DON'T","text":"<ul> <li>Don't use global container in tests without override_dependency</li> <li>Don't over-mock - only mock external services</li> <li>Don't test private methods</li> <li>Don't share state between tests</li> </ul> <pre><code># \u274c Bad - affects other tests\ncontainer = InjectQ.get_instance()\ncontainer[Database] = mock_db  # Persists across tests\n</code></pre>"},{"location":"testing/overview/#testing-utilities","title":"\ud83d\udcda Testing Utilities","text":"<pre><code>from injectq.testing import (\n    test_container,            # Create isolated containers\n    override_dependency,       # Temporarily override a service\n    mock_factory,             # Mock factory functions\n    pytest_container_fixture, # Pytest fixture\n)\n</code></pre>"},{"location":"testing/overview/#summary","title":"\ud83c\udfaf Summary","text":"<p>Effective testing with InjectQ:</p> <ul> <li>Use <code>test_container()</code> for test isolation</li> <li>Use <code>override_dependency()</code> for temporary overrides</li> <li>Mock external dependencies, use real internal services</li> <li>Keep tests focused and independent</li> <li>Verify behavior, not implementation</li> </ul> <p>Ready for more? Check out testing patterns!</p>"},{"location":"testing/testing-patterns/","title":"Testing Patterns","text":"<p>Testing is critical for dependency-injected code. InjectQ provides utilities to isolate dependencies, mock services, and verify behavior.</p>"},{"location":"testing/testing-patterns/#core-testing-utilities","title":"Core Testing Utilities","text":"<pre><code>from injectq.testing import (\n    test_container,           # Create isolated test containers\n    override_dependency,      # Temporarily override a binding\n    mock_factory,            # Create mock factory functions\n    pytest_container_fixture, # Pytest fixture for test containers\n)\n</code></pre>"},{"location":"testing/testing-patterns/#basic-testing-pattern","title":"Basic Testing Pattern","text":""},{"location":"testing/testing-patterns/#using-test_container","title":"Using test_container()","text":"<pre><code>from injectq import InjectQ, inject\nfrom injectq.testing import test_container\n\n# Create an isolated container for each test\ndef test_user_service():\n    with test_container() as container:\n        # Bind dependencies\n        container[str] = \"test-database-url\"\n        container[UserService] = UserService\n\n        # Get service - automatically resolves dependencies\n        service = container[UserService]\n\n        # Test the service\n        result = service.get_user(1)\n        assert result is not None\n</code></pre>"},{"location":"testing/testing-patterns/#using-override_dependency","title":"Using override_dependency()","text":"<pre><code>from injectq import InjectQ\nfrom injectq.testing import override_dependency\n\ndef test_with_mocked_dependency():\n    container = InjectQ.get_instance()\n\n    # Temporarily replace a service with a mock\n    mock_db = MockDatabase()\n\n    with override_dependency(Database, mock_db):\n        service = container[UserService]\n        result = service.get_user(1)\n\n        # Verify mock was used\n        assert mock_db.query_called is True\n</code></pre>"},{"location":"testing/testing-patterns/#unit-testing","title":"Unit Testing","text":"<p>Test services in isolation by mocking their dependencies:</p> <pre><code>from injectq.testing import test_container\n\ndef test_user_service_create_user():\n    \"\"\"Test UserService.create_user() with mock database.\"\"\"\n    with test_container() as container:\n        # Create mock repository\n        mock_repo = MockUserRepository()\n\n        # Bind mock into container\n        container[UserRepository] = mock_repo\n        container[UserService] = UserService\n\n        # Get service and test\n        service = container[UserService]\n        user = service.create_user(\"john@example.com\")\n\n        # Verify behavior\n        assert user.email == \"john@example.com\"\n        assert mock_repo.save_called is True\n</code></pre>"},{"location":"testing/testing-patterns/#mock-implementation-example","title":"Mock Implementation Example","text":"<pre><code>class MockUserRepository:\n    \"\"\"Mock repository for testing.\"\"\"\n\n    def __init__(self):\n        self.users = {}\n        self.save_called = False\n        self.get_called = False\n\n    def save(self, user):\n        self.save_called = True\n        self.users[user.id] = user\n        return user\n\n    def get_by_id(self, user_id):\n        self.get_called = True\n        return self.users.get(user_id)\n\n    def get_by_email(self, email):\n        for user in self.users.values():\n            if user.email == email:\n                return user\n        return None\n</code></pre>"},{"location":"testing/testing-patterns/#mock-factory-pattern","title":"Mock Factory Pattern","text":"<p>Use <code>mock_factory</code> for factory-based dependencies:</p> <pre><code>from injectq.testing import mock_factory\n\ndef test_with_factory():\n    \"\"\"Test using mock factories.\"\"\"\n    with test_container() as container:\n        # Bind a mock factory\n        container.bind_factory(\n            \"connection_id\",\n            mock_factory(lambda: \"mock-connection-123\")\n        )\n\n        # Service gets mocked value\n        service = container[ServiceUsingConnectionId]\n        result = service.do_work()\n\n        assert result is not None\n</code></pre>"},{"location":"testing/testing-patterns/#testing-parameterized-factories","title":"Testing Parameterized Factories","text":"<p>Test factories that accept arguments:</p> <pre><code>from injectq.testing import test_container\n\ndef test_parameterized_factory():\n    \"\"\"Test parameterized factory with different arguments.\"\"\"\n    with test_container() as container:\n        # Bind a parameterized factory\n        def create_pool(db_name: str, max_conn: int = 10):\n            return ConnectionPool(db_name, max_conn=max_conn)\n\n        container.bind_factory(\"pool\", create_pool)\n\n        # Test with different parameters\n        users_pool = container.call_factory(\"pool\", \"users_db\", max_conn=20)\n        orders_pool = container.call_factory(\"pool\", \"orders_db\", max_conn=15)\n\n        # Verify each has correct parameters\n        assert users_pool.db_name == \"users_db\"\n        assert users_pool.max_connections == 20\n\n        assert orders_pool.db_name == \"orders_db\"\n        assert orders_pool.max_connections == 15\n\n        # Verify they are different instances\n        assert users_pool is not orders_pool\n\ndef test_factory_with_mock_dependencies():\n    \"\"\"Test parameterized factory that uses DI.\"\"\"\n    with test_container() as container:\n        # Mock a dependency\n        mock_db = MockDatabase()\n        container[Database] = mock_db\n\n        # Parameterized factory that uses DI\n        def get_user(user_id: int):\n            db = container[Database]\n            return db.get_user(user_id)\n\n        container.bind_factory(\"get_user\", get_user)\n\n        # Mock the database response\n        mock_db.users = {1: {\"id\": 1, \"name\": \"Alice\"}}\n\n        # Test with parameter\n        user = container.call_factory(\"get_user\", 1)\n        assert user[\"name\"] == \"Alice\"\n</code></pre>"},{"location":"testing/testing-patterns/#pytest-integration","title":"Pytest Integration","text":"<p>Use pytest fixtures for convenient test setup:</p> <pre><code>import pytest\nfrom injectq.testing import pytest_container_fixture\n\n# Create a pytest fixture\ncontainer = pytest_container_fixture()\n\ndef test_with_fixture(container):\n    \"\"\"Test using pytest fixture.\"\"\"\n    # container is a fresh InjectQ instance for each test\n    container[UserService] = UserService\n    container[str] = \"test-config\"\n\n    service = container[UserService]\n    assert service is not None\n\n\n# Or create a custom fixture\n@pytest.fixture\ndef test_app_container():\n    from injectq.testing import test_container\n    with test_container() as container:\n        # Setup common test bindings\n        container[str] = \"test-database-url\"\n        yield container\n\ndef test_with_custom_fixture(test_app_container):\n    test_app_container[UserService] = UserService\n    service = test_app_container[UserService]\n    assert service is not None\n</code></pre>"},{"location":"testing/testing-patterns/#testing-scopes","title":"Testing Scopes","text":"<p>Test scoped services:</p> <pre><code>from injectq import singleton, scoped, transient\n\ndef test_singleton_scope():\n    \"\"\"Verify singleton scope creates one instance.\"\"\"\n    with test_container() as container:\n        @singleton\n        class SingletonService:\n            pass\n\n        container[SingletonService] = SingletonService\n\n        # Same instance every time\n        instance1 = container[SingletonService]\n        instance2 = container[SingletonService]\n\n        assert instance1 is instance2\n\ndef test_transient_scope():\n    \"\"\"Verify transient scope creates new instances.\"\"\"\n    with test_container() as container:\n        @transient\n        class TransientService:\n            pass\n\n        container[TransientService] = TransientService\n\n        # Different instance every time\n        instance1 = container[TransientService]\n        instance2 = container[TransientService]\n\n        assert instance1 is not instance2\n</code></pre>"},{"location":"testing/testing-patterns/#testing-with-real-vs-mock-dependencies","title":"Testing with Real vs Mock Dependencies","text":"<pre><code>def test_mixed_real_and_mocked():\n    \"\"\"Use real services where possible, mock only external dependencies.\"\"\"\n    with test_container() as container:\n        # Real internal services\n        container[UserService] = UserService\n        container[UserValidator] = UserValidator\n\n        # Mock external services\n        container[EmailService] = MockEmailService()\n        container[PaymentService] = MockPaymentService()\n\n        service = container[UserService]\n        result = service.register_user(\"john@example.com\", \"password\")\n\n        # Verify result\n        assert result.email == \"john@example.com\"\n\n        # Verify external services were called correctly\n        email_service = container[EmailService]\n        assert email_service.confirmation_email_sent\n</code></pre>"},{"location":"testing/testing-patterns/#error-testing","title":"Error Testing","text":"<pre><code>import pytest\n\ndef test_error_handling():\n    \"\"\"Test service error handling.\"\"\"\n    with test_container() as container:\n        container[UserService] = UserService\n        container[UserRepository] = MockUserRepository()\n\n        service = container[UserService]\n\n        # Test that errors are raised correctly\n        with pytest.raises(UserNotFoundError):\n            service.get_user(999)\n</code></pre>"},{"location":"testing/testing-patterns/#best-practices","title":"Best Practices","text":""},{"location":"testing/testing-patterns/#do","title":"\u2705 DO","text":"<ul> <li>Use test_container() for isolated test environments</li> <li>Mock external dependencies (APIs, databases, email services)</li> <li>Keep tests focused on one behavior per test</li> <li>Use fixtures for common setup</li> <li>Name mocks clearly to distinguish from real services</li> </ul> <pre><code># \u2705 Good\ndef test_user_creation():\n    with test_container() as container:\n        mock_repo = MockUserRepository()\n        container[UserRepository] = mock_repo\n        container[UserService] = UserService\n\n        service = container[UserService]\n        user = service.create_user(\"test@example.com\")\n\n        assert mock_repo.save_called\n</code></pre>"},{"location":"testing/testing-patterns/#dont","title":"\u274c DON'T","text":"<ul> <li>Don't use the global container in tests without override_dependency</li> <li>Don't over-mock - only mock external dependencies</li> <li>Don't test private methods - test public interfaces</li> <li>Don't share state between tests</li> </ul> <pre><code># \u274c Bad\ndef test_user_creation():\n    # Uses global container - tests interfere with each other\n    container = InjectQ.get_instance()\n    service = container[UserService]\n    # ...\n</code></pre>"},{"location":"testing/testing-patterns/#common-testing-patterns","title":"Common Testing Patterns","text":""},{"location":"testing/testing-patterns/#pattern-1-verify-method-calls","title":"Pattern 1: Verify Method Calls","text":"<pre><code>class TrackingMockService:\n    def __init__(self):\n        self.call_log = []\n\n    def some_method(self, arg):\n        self.call_log.append((\"some_method\", arg))\n        return f\"result_{arg}\"\n\ndef test_service_calls_dependency():\n    with test_container() as container:\n        tracking_mock = TrackingMockService()\n        container[DependentService] = tracking_mock\n\n        service = container[MainService]\n        service.do_work(\"test\")\n\n        # Verify the dependency was called\n        assert (\"some_method\", \"test\") in tracking_mock.call_log\n</code></pre>"},{"location":"testing/testing-patterns/#pattern-2-control-return-values","title":"Pattern 2: Control Return Values","text":"<pre><code>class ConfigurableMockService:\n    def __init__(self):\n        self.return_values = {}\n\n    def set_return_value(self, method, value):\n        self.return_values[method] = value\n\n    def get_data(self):\n        return self.return_values.get(\"get_data\", None)\n\ndef test_with_specific_return_values():\n    with test_container() as container:\n        mock_service = ConfigurableMockService()\n        mock_service.set_return_value(\"get_data\", {\"id\": 1, \"name\": \"Test\"})\n\n        container[DataService] = mock_service\n        container[ConsumerService] = ConsumerService\n\n        service = container[ConsumerService]\n        result = service.process()\n\n        assert result[\"id\"] == 1\n</code></pre>"},{"location":"testing/testing-patterns/#pattern-3-temporary-override","title":"Pattern 3: Temporary Override","text":"<pre><code>def test_with_temporary_override():\n    \"\"\"Override a dependency for a specific test.\"\"\"\n    container = InjectQ.get_instance()\n\n    # Original binding\n    container[ConfigService] = RealConfigService()\n\n    real_service = container[ConfigService]\n    assert isinstance(real_service, RealConfigService)\n\n    # Temporarily override\n    mock_config = MockConfigService()\n    with override_dependency(ConfigService, mock_config):\n        service = container[ConfigService]\n        assert isinstance(service, MockConfigService)\n\n        # Do test assertions here\n\n    # Override ends - back to real service\n    service = container[ConfigService]\n    assert isinstance(service, RealConfigService)\n</code></pre>"},{"location":"testing/testing-patterns/#running-tests-with-pytest","title":"Running Tests with Pytest","text":"<pre><code># Run all tests\npytest\n\n# Run specific test file\npytest tests/test_services.py\n\n# Run with coverage\npytest --cov=src\n\n# Show coverage report\npytest --cov=src --cov-report=html\n</code></pre>"},{"location":"testing/testing-patterns/#summary","title":"Summary","text":"<p>Key testing practices with InjectQ:</p> <ul> <li>Use <code>test_container()</code> for isolated test environments</li> <li>Use <code>override_dependency()</code> for temporary service replacement</li> <li>Mock external dependencies, use real internal services</li> <li>Test behavior, not implementation details</li> <li>Keep tests fast and independent</li> <li>Use pytest fixtures for common setup</li> </ul>"}]}