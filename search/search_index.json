{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"InjectQ Documentation","text":"<p>InjectQ is a lightweight, type-friendly dependency injection library for Python focused on clarity and pragmatic integrations.</p>"},{"location":"#quick-example-recommended","title":"Quick example (recommended)","text":"<pre><code>from injectq import injectq, inject, singleton\n\ninjectq[str] = \"Hello, World!\"\n\n@singleton\nclass UserService:\n    def __init__(self, message: str):\n        self.message = message\n\n    def greet(self) -&gt; str:\n        return f\"Service says: {self.message}\"\n\n@inject\ndef main(service: UserService) -&gt; None:\n    print(service.greet())\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>Dict-like bindings and simple APIs for small projects</li> <li>Decorator and type-based injection (<code>@inject</code>, <code>Inject[T]</code>) for typed code</li> <li>Optional integrations for FastAPI and Taskiq (install extras as needed)</li> <li>Async factory support and request-scoped lifetimes</li> </ul>"},{"location":"#api-patterns","title":"API patterns","text":""},{"location":"#dict-like-interface","title":"Dict-like interface","text":"<pre><code>from injectq import injectq\ninjectq[str] = \"config_value\"\ninjectq[Database] = Database()\n</code></pre>"},{"location":"#functionclass-injection","title":"Function/class injection","text":"<pre><code>@inject\ndef process(service: UserService):\n    ...\n</code></pre>"},{"location":"#fastapi-integration-example","title":"FastAPI integration (example)","text":"<pre><code>from injectq import injectq\nfrom injectq.integrations.fastapi import setup_fastapi, InjectAPI\n\nsetup_fastapi(injectq, app)\n\n@app.get(\"/users/{user_id}\")\nasync def get_user(user_id: int, user_service: IUserService = InjectAPI[IUserService]):\n    return user_service.get_user(user_id)\n</code></pre>"},{"location":"#taskiq-integration-example","title":"Taskiq integration (example)","text":"<pre><code>from injectq import injectq\nfrom injectq.integrations.taskiq import setup_taskiq, InjectTask\n\nsetup_taskiq(injectq, broker)\n\n@broker.task()\nasync def save_data(data: dict, service: RankingService = InjectTask[RankingService]):\n    await service.save(data)\n</code></pre>"},{"location":"#documentation-sections","title":"Documentation sections","text":"<ul> <li>Getting started (installation &amp; quick-start)</li> <li>Injection patterns (dict-style, decorator, Inject[T])</li> <li>Scopes and lifecycle (singleton, transient, request)</li> <li>Modules and providers</li> <li>Integrations (FastAPI, Taskiq)</li> <li>Testing utilities and examples</li> <li>API reference and migration guides</li> </ul>"},{"location":"#contributing-license","title":"Contributing &amp; License","text":"<p>See <code>CONTRIBUTING.md</code> and <code>LICENSE</code> for contribution rules and licensing.</p> <p>Note: This repository maintains a test coverage floor of 73% enforced by CI and pytest configuration.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to InjectQ will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Auto-registration of concrete types: New <code>allow_concrete</code> parameter (default: True)    automatically registers concrete types when registering instances to base types</li> <li>Registration override control: New <code>allow_override</code> parameter (default: True)    controls whether existing service registrations can be overwritten</li> <li>Enhanced <code>bind_instance()</code> method with <code>allow_concrete</code> parameter</li> <li>Enhanced <code>bind_factory()</code> method with <code>allow_concrete</code> parameter</li> <li>Enhanced <code>bind()</code> method with <code>allow_concrete</code> parameter</li> <li>New <code>AlreadyRegisteredError</code> exception for override conflicts</li> <li>Comprehensive documentation with MkDocs</li> <li>Plugin system for extensibility</li> <li>Advanced middleware support</li> <li>Enhanced async support with context managers</li> <li>Resource management utilities</li> <li>Performance profiling tools</li> <li>Diagnostic and validation utilities</li> <li>Migration guides from other DI libraries</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Breaking: InjectQ constructor now accepts <code>allow_override</code> parameter</li> <li>Breaking: All binding methods now accept <code>allow_concrete</code> parameter</li> <li>Dict-like syntax (<code>container[Type] = instance</code>) now uses <code>allow_concrete=True</code> by default</li> <li>Improved subclass injection support - both base and concrete types can be resolved</li> <li>Improved type safety and mypy compliance</li> <li>Enhanced error messages and debugging information</li> <li>Optimized performance for large dependency graphs</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Subclass injection issues where concrete types weren't accessible after registering to base type</li> <li>Various bug fixes and stability improvements</li> </ul>"},{"location":"changelog/#010-2024-01-15","title":"[0.1.0] - 2024-01-15","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Initial release of InjectQ</li> <li>Core dependency injection functionality</li> <li>Multiple injection patterns:</li> <li>Dict-like interface</li> <li><code>@inject</code> decorator</li> <li><code>Inject()</code> function</li> <li>Service scopes:</li> <li>Singleton scope</li> <li>Transient scope</li> <li>Scoped services</li> <li>Custom scopes</li> <li>Module system for organizing dependencies</li> <li>Provider pattern for complex object creation</li> <li>Framework integrations:</li> <li>FastAPI integration</li> <li>Taskiq integration</li> <li>FastMCP integration</li> <li>Testing utilities:</li> <li>Test containers</li> <li>Mocking and overrides</li> <li>Async testing support</li> <li>Advanced features:</li> <li>Conditional registration</li> <li>Lazy loading</li> <li>Circular dependency detection</li> <li>Lifecycle hooks</li> <li>Thread safety features</li> <li>Performance optimizations</li> <li>Type safety with full mypy support</li> </ul>"},{"location":"changelog/#features","title":"Features","text":""},{"location":"changelog/#core-container","title":"Core Container","text":"<ul> <li><code>InjectQ</code> container with dict-like interface</li> <li>Automatic dependency resolution</li> <li>Type-safe service registration and retrieval</li> <li>Support for generic types and protocols</li> </ul>"},{"location":"changelog/#scoping-system","title":"Scoping System","text":"<ul> <li>Built-in scopes: singleton, transient, scoped</li> <li>Custom scope creation and management</li> <li>Scope-aware dependency resolution</li> <li>Automatic resource cleanup</li> </ul>"},{"location":"changelog/#module-system","title":"Module System","text":"<ul> <li>Modular dependency organization</li> <li>Provider pattern for complex construction</li> <li>Module composition and inheritance</li> <li>Configuration-based modules</li> </ul>"},{"location":"changelog/#injection-patterns","title":"Injection Patterns","text":"<ul> <li><code>@inject</code> decorator for automatic injection</li> <li><code>Inject()</code> function for explicit injection</li> <li>Dict-like container access</li> <li>Support for optional dependencies</li> </ul>"},{"location":"changelog/#framework-integrations","title":"Framework Integrations","text":"<ul> <li>FastAPI: <code>Injected[T]</code> dependency provider</li> <li>Taskiq: Automatic worker dependency injection</li> <li>FastMCP: Server and tool integration</li> </ul>"},{"location":"changelog/#testing-support","title":"Testing Support","text":"<ul> <li>Test-specific containers</li> <li>Service mocking and overrides</li> <li>Async testing utilities</li> <li>Integration testing helpers</li> </ul>"},{"location":"changelog/#advanced-features","title":"Advanced Features","text":"<ul> <li>Conditional service registration</li> <li>Lazy loading of expensive services</li> <li>Circular dependency detection and resolution</li> <li>Service lifecycle hooks</li> <li>Resource management with automatic cleanup</li> </ul>"},{"location":"changelog/#performance-features","title":"Performance Features","text":"<ul> <li>Compile-time dependency resolution</li> <li>Service caching and optimization</li> <li>Thread-safe operations</li> <li>Minimal runtime overhead</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>Comprehensive getting started guide</li> <li>Detailed core concepts explanation</li> <li>Extensive examples and tutorials</li> <li>Framework integration guides</li> <li>Testing strategies and best practices</li> <li>Migration guides from other libraries</li> <li>Complete API reference</li> </ul>"},{"location":"changelog/#development","title":"Development","text":"<ul> <li>Full test suite with high coverage</li> <li>Type checking with mypy</li> <li>Code quality with ruff</li> <li>Continuous integration setup</li> <li>Documentation generation with MkDocs</li> </ul>"},{"location":"changelog/#001-2023-12-01","title":"[0.0.1] - 2023-12-01","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Initial project setup</li> <li>Basic dependency injection prototype</li> <li>Core container implementation</li> <li>Simple registration and resolution</li> </ul>"},{"location":"changelog/#release-notes","title":"Release Notes","text":""},{"location":"changelog/#version-010-release-notes","title":"Version 0.1.0 Release Notes","text":"<p>InjectQ 0.1.0 is the first stable release of our modern Python dependency injection library. This release focuses on providing a simple yet powerful API that grows with your application needs.</p>"},{"location":"changelog/#key-highlights","title":"Key Highlights","text":"<p>\ud83c\udfaf Multiple API Styles: Choose the injection style that fits your needs: - Dict-like interface for simple cases - <code>@inject</code> decorator for automatic injection - <code>Inject()</code> function for explicit control</p> <p>\ud83d\udd12 Type Safety First: Full mypy compliance with early error detection and comprehensive type checking.</p> <p>\u26a1 Performance Optimized: Compile-time dependency resolution with caching for minimal runtime overhead.</p> <p>\ud83e\uddea Testing Built-in: Comprehensive testing utilities including test containers, mocking, and async support.</p> <p>\ud83d\udd17 Framework Native: Built-in integrations for FastAPI, Taskiq, and FastMCP with idiomatic patterns.</p>"},{"location":"changelog/#breaking-changes","title":"Breaking Changes","text":"<p>None - this is the first stable release.</p>"},{"location":"changelog/#migration-guide","title":"Migration Guide","text":"<p>This is the initial release, so no migration is needed. However, if you're coming from other dependency injection libraries, check out our migration guides.</p>"},{"location":"changelog/#known-issues","title":"Known Issues","text":"<ul> <li>None currently known</li> </ul>"},{"location":"changelog/#deprecations","title":"Deprecations","text":"<ul> <li>None in this release</li> </ul>"},{"location":"changelog/#acknowledgments","title":"Acknowledgments","text":"<p>Special thanks to all contributors who helped make this release possible: - Core development team - Beta testers and early adopters - Documentation reviewers - Community feedback providers</p>"},{"location":"changelog/#upcoming-features","title":"Upcoming Features","text":""},{"location":"changelog/#version-020-planned","title":"Version 0.2.0 (Planned)","text":"<ul> <li>Enhanced plugin system</li> <li>Additional framework integrations</li> <li>Performance improvements</li> <li>Extended diagnostic tools</li> </ul>"},{"location":"changelog/#version-030-planned","title":"Version 0.3.0 (Planned)","text":"<ul> <li>Configuration management improvements</li> <li>Advanced caching strategies  </li> <li>Monitoring and observability features</li> <li>Additional testing utilities</li> </ul>"},{"location":"changelog/#contributing","title":"Contributing","text":"<p>We welcome contributions! Please see our contributing guide for details on how to contribute to InjectQ.</p>"},{"location":"changelog/#support","title":"Support","text":"<ul> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> <li>Documentation: InjectQ Docs</li> </ul>"},{"location":"contributing/","title":"Contributing to InjectQ","text":"<p>Thank you for your interest in contributing to InjectQ! This document provides guidelines and information for contributors.</p>"},{"location":"contributing/#how-to-contribute","title":"\ud83e\udd1d How to Contribute","text":"<p>There are many ways to contribute to InjectQ:</p> <ul> <li>Bug Reports: Report bugs and issues</li> <li>Feature Requests: Suggest new features and improvements</li> <li>Documentation: Improve documentation and examples</li> <li>Code: Submit bug fixes and new features</li> <li>Testing: Add tests and improve test coverage</li> <li>Reviews: Review pull requests and provide feedback</li> </ul>"},{"location":"contributing/#reporting-issues","title":"\ud83d\udc1b Reporting Issues","text":"<p>When reporting issues, please include:</p> <ol> <li>Clear Description: Describe the issue clearly</li> <li>Reproduction Steps: Provide minimal code to reproduce the issue</li> <li>Expected Behavior: What you expected to happen</li> <li>Actual Behavior: What actually happened</li> <li>Environment: Python version, InjectQ version, OS, etc.</li> </ol>"},{"location":"contributing/#issue-template","title":"Issue Template","text":"<pre><code>## Description\nBrief description of the issue\n\n## Reproduction\n```python\n# Minimal code to reproduce the issue\n</code></pre>"},{"location":"contributing/#expected-behavior","title":"Expected Behavior","text":"<p>What should happen</p>"},{"location":"contributing/#actual-behavior","title":"Actual Behavior","text":"<p>What actually happens</p>"},{"location":"contributing/#environment","title":"Environment","text":"<ul> <li>Python version: </li> <li>InjectQ version: </li> <li>Operating System:  <pre><code>## \ud83d\ude80 Setting Up Development Environment\n\n### Prerequisites\n\n- Python 3.8 or higher\n- uv (recommended) or pip\n- Git\n\n### Setup Steps\n\n1. **Fork and Clone**\n   ```bash\n   git clone https://github.com/yourusername/injectq.git\n   cd injectq\n   ```\n\n2. **Install Dependencies**\n   ```bash\n   # Using uv (recommended)\n   uv sync --dev\n\n   # Or using pip\n   pip install -e .[dev]\n   ```\n\n3. **Install Pre-commit Hooks**\n   ```bash\n   pre-commit install\n   ```\n\n4. **Run Tests**\n   ```bash\n   # Run all tests\n   pytest\n\n   # Run with coverage\n   pytest --cov=injectq\n\n   # Run specific test file\n   pytest tests/test_container.py\n   ```\n\n5. **Run Linting**\n   ```bash\n   # Run all checks\n   ruff check .\n\n   # Auto-fix issues\n   ruff check . --fix\n\n   # Format code\n   ruff format .\n   ```\n\n## \ud83c\udfd7\ufe0f Development Workflow\n\n### Branch Strategy\n\n- `main`: Stable release branch\n- `develop`: Development branch\n- `feature/*`: Feature branches\n- `bugfix/*`: Bug fix branches\n- `hotfix/*`: Critical hotfix branches\n\n### Workflow Steps\n\n1. **Create Feature Branch**\n   ```bash\n   git checkout -b feature/your-feature-name\n   ```\n\n2. **Make Changes**\n   - Write code following our style guidelines\n   - Add tests for new functionality\n   - Update documentation if needed\n\n3. **Run Tests**\n   ```bash\n   pytest\n   ruff check .\n   mypy injectq\n   ```\n\n4. **Commit Changes**\n   ```bash\n   git add .\n   git commit -m \"feat: add your feature description\"\n   ```\n\n5. **Push and Create PR**\n   ```bash\n   git push origin feature/your-feature-name\n   ```\n\n## \ud83d\udcdd Code Style Guidelines\n\n### Python Code Style\n\nWe use [Ruff](https://docs.astral.sh/ruff/) for linting and formatting:\n\n- **Line Length**: 88 characters\n- **Import Sorting**: isort-compatible\n- **Formatting**: Black-compatible\n- **Type Hints**: Required for all public APIs\n\n### Docstring Style\n\nWe use Google-style docstrings:\n\n```python\ndef example_function(param1: str, param2: int) -&gt; bool:\n    \"\"\"Example function with proper docstring.\n\n    Args:\n        param1: Description of param1\n        param2: Description of param2\n\n    Returns:\n        Description of return value\n\n    Raises:\n        ValueError: When param1 is empty\n\n    Example:\n        &gt;&gt;&gt; example_function(\"test\", 42)\n        True\n    \"\"\"\n    if not param1:\n        raise ValueError(\"param1 cannot be empty\")\n    return len(param1) == param2\n</code></pre></li> </ul>"},{"location":"contributing/#commit-message-format","title":"Commit Message Format","text":"<p>We follow Conventional Commits:</p> <pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n</code></pre> <p>Types: - <code>feat</code>: New feature - <code>fix</code>: Bug fix - <code>docs</code>: Documentation changes - <code>style</code>: Code style changes - <code>refactor</code>: Code refactoring - <code>test</code>: Adding or fixing tests - <code>chore</code>: Maintenance tasks</p> <p>Examples: <pre><code>feat: add async dependency resolution\nfix(container): resolve circular dependency issue\ndocs: update getting started guide\ntest: add tests for scoped services\n</code></pre></p>"},{"location":"contributing/#testing-guidelines","title":"\ud83e\uddea Testing Guidelines","text":""},{"location":"contributing/#test-structure","title":"Test Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 test_container.py          # Container functionality\n\u251c\u2500\u2500 test_scopes.py            # Scoping tests\n\u251c\u2500\u2500 test_modules.py           # Module system tests\n\u251c\u2500\u2500 test_integrations/        # Framework integrations\n\u2502   \u251c\u2500\u2500 test_fastapi.py\n\u2502   \u2514\u2500\u2500 test_taskiq.py\n\u2514\u2500\u2500 fixtures/                 # Test fixtures\n    \u2514\u2500\u2500 conftest.py\n</code></pre>"},{"location":"contributing/#writing-tests","title":"Writing Tests","text":"<ol> <li>Test Files: Match source file names with <code>test_</code> prefix</li> <li>Test Classes: Group related tests in classes</li> <li>Test Methods: Use descriptive names starting with <code>test_</code></li> <li>Fixtures: Use pytest fixtures for setup/teardown</li> <li>Mocking: Use unittest.mock or pytest-mock</li> </ol> <p>Example test:</p> <pre><code>import pytest\nfrom injectq import InjectQ, inject\n\nclass TestContainer:\n    def test_simple_registration(self):\n        \"\"\"Test simple service registration.\"\"\"\n        container = InjectQ()\n        container[str] = \"test\"\n\n        assert container[str] == \"test\"\n\n    def test_dependency_injection(self):\n        \"\"\"Test automatic dependency injection.\"\"\"\n        container = InjectQ()\n        container[str] = \"hello\"\n\n        @inject\n        def func(message: str) -&gt; str:\n            return f\"Got: {message}\"\n\n        result = func()\n        assert result == \"Got: hello\"\n\n    @pytest.mark.asyncio\n    async def test_async_injection(self):\n        \"\"\"Test async dependency injection.\"\"\"\n        container = InjectQ()\n        container[str] = \"async\"\n\n        @inject\n        async def async_func(message: str) -&gt; str:\n            return f\"Async: {message}\"\n\n        result = await async_func()\n        assert result == \"Async: async\"\n</code></pre>"},{"location":"contributing/#test-coverage","title":"Test Coverage","text":"<ul> <li>Minimum Coverage: 95%</li> <li>Missing Coverage: Should be documented</li> <li>Test Types: Unit, integration, and end-to-end tests</li> </ul>"},{"location":"contributing/#documentation-guidelines","title":"\ud83d\udcda Documentation Guidelines","text":""},{"location":"contributing/#documentation-structure","title":"Documentation Structure","text":"<p>Documentation is written in Markdown and built with MkDocs:</p> <pre><code>docs/\n\u251c\u2500\u2500 index.md                  # Home page\n\u251c\u2500\u2500 getting-started/          # Installation and quick start\n\u251c\u2500\u2500 core-concepts/           # Fundamental concepts\n\u251c\u2500\u2500 injection-patterns/      # Different injection styles\n\u251c\u2500\u2500 scopes/                  # Service lifetimes\n\u251c\u2500\u2500 modules/                 # Module system\n\u251c\u2500\u2500 integrations/            # Framework integrations\n\u251c\u2500\u2500 testing/                 # Testing utilities\n\u251c\u2500\u2500 advanced/                # Advanced features\n\u251c\u2500\u2500 examples/                # Examples and patterns\n\u251c\u2500\u2500 best-practices/          # Best practices\n\u251c\u2500\u2500 api-reference/           # API documentation\n\u2514\u2500\u2500 migration/               # Migration guides\n</code></pre>"},{"location":"contributing/#writing-documentation","title":"Writing Documentation","text":"<ol> <li>Tutorial Style: Documentation should be tutorial-oriented</li> <li>Code Examples: Include working code examples</li> <li>Clear Headings: Use descriptive headings and subheadings</li> <li>Cross-references: Link to related sections</li> <li>Up-to-date: Keep examples current with latest API</li> </ol>"},{"location":"contributing/#building-documentation","title":"Building Documentation","text":"<pre><code># Install documentation dependencies\npip install -e .[docs]\n\n# Serve documentation locally\nmkdocs serve\n\n# Build documentation\nmkdocs build\n</code></pre>"},{"location":"contributing/#pull-request-process","title":"\ud83d\udd04 Pull Request Process","text":""},{"location":"contributing/#before-submitting","title":"Before Submitting","text":"<ol> <li>Tests Pass: All tests must pass</li> <li>Linting Clean: No linting errors</li> <li>Coverage: Maintain or improve test coverage</li> <li>Documentation: Update docs if needed</li> <li>Changelog: Add entry to changelog</li> </ol>"},{"location":"contributing/#pr-requirements","title":"PR Requirements","text":"<ul> <li>Clear Title: Descriptive title following commit convention</li> <li>Description: Explain what the PR does and why</li> <li>Issue Reference: Link to related issues</li> <li>Testing: Describe how the change was tested</li> <li>Breaking Changes: Clearly mark breaking changes</li> </ul>"},{"location":"contributing/#pr-template","title":"PR Template","text":"<pre><code>## Description\nBrief description of the changes\n\n## Changes\n- List of changes\n- Another change\n\n## Testing\nHow the changes were tested\n\n## Checklist\n- [ ] Tests pass\n- [ ] Linting clean\n- [ ] Documentation updated\n- [ ] Changelog updated\n- [ ] Breaking changes noted\n</code></pre>"},{"location":"contributing/#review-process","title":"Review Process","text":"<ol> <li>Automated Checks: CI must pass</li> <li>Code Review: At least one maintainer review</li> <li>Discussion: Address feedback and questions</li> <li>Approval: Maintainer approval required</li> <li>Merge: Squash and merge to main</li> </ol>"},{"location":"contributing/#release-process","title":"\ud83c\udff7\ufe0f Release Process","text":""},{"location":"contributing/#version-numbering","title":"Version Numbering","text":"<p>We follow Semantic Versioning:</p> <ul> <li>MAJOR: Breaking changes</li> <li>MINOR: New features (backward compatible)</li> <li>PATCH: Bug fixes (backward compatible)</li> </ul>"},{"location":"contributing/#release-steps","title":"Release Steps","text":"<ol> <li>Update Version: Update version in <code>pyproject.toml</code></li> <li>Update Changelog: Add release notes</li> <li>Create Release: Tag and create GitHub release</li> <li>Publish: Publish to PyPI</li> <li>Documentation: Update documentation</li> </ol>"},{"location":"contributing/#code-review-guidelines","title":"\ud83d\udccb Code Review Guidelines","text":""},{"location":"contributing/#for-contributors","title":"For Contributors","text":"<ul> <li>Self Review: Review your own code before submitting</li> <li>Small PRs: Keep changes focused and small</li> <li>Context: Provide context and explanation</li> <li>Responsive: Respond to feedback promptly</li> </ul>"},{"location":"contributing/#for-reviewers","title":"For Reviewers","text":"<ul> <li>Be Kind: Provide constructive feedback</li> <li>Be Thorough: Check code, tests, and documentation</li> <li>Be Timely: Review PRs in reasonable time</li> <li>Be Clear: Explain suggestions and concerns</li> </ul>"},{"location":"contributing/#getting-help","title":"\ud83c\udd98 Getting Help","text":"<ul> <li>GitHub Issues: Ask questions in issues</li> <li>Discussions: Use GitHub Discussions for general questions</li> <li>Documentation: Check documentation first</li> <li>Examples: Look at example code</li> </ul>"},{"location":"contributing/#recognition","title":"\ud83c\udf89 Recognition","text":"<p>Contributors are recognized in:</p> <ul> <li>Changelog: Major contributions noted</li> <li>Documentation: Contributors acknowledged</li> <li>Releases: Contributions highlighted</li> </ul> <p>Thank you for contributing to InjectQ! \ud83d\ude80</p>"},{"location":"advanced/async-support/","title":"Async Support","text":"<p>InjectQ provides comprehensive support for asynchronous programming patterns, enabling dependency injection in async/await applications.</p>"},{"location":"advanced/async-support/#async-service-resolution","title":"Async Service Resolution","text":""},{"location":"advanced/async-support/#basic-async-resolution","title":"Basic Async Resolution","text":"<pre><code>import asyncio\nfrom injectq import Container, inject\n\n# Async service\nclass AsyncUserService:\n    def __init__(self, repository: UserRepository):\n        self.repository = repository\n\n    async def get_user(self, user_id: int) -&gt; User:\n        # Simulate async operation\n        await asyncio.sleep(0.1)\n        return await self.repository.get_user_async(user_id)\n\n    async def create_user(self, email: str) -&gt; User:\n        await asyncio.sleep(0.1)\n        return await self.repository.create_user_async(email)\n\n# Register services\ncontainer = Container()\ncontainer.register(UserRepository, AsyncUserRepository)\ncontainer.register(AsyncUserService, AsyncUserService)\n\n# Async injection\n@inject\nasync def handle_request(user_service: AsyncUserService) -&gt; dict:\n    user = await user_service.get_user(1)\n    return {\"user\": user.email}\n\n# Usage\nasync def main():\n    result = await container.resolve(handle_request)\n    print(result)\n\nasyncio.run(main())\n</code></pre>"},{"location":"advanced/async-support/#async-context-managers","title":"Async Context Managers","text":"<pre><code>from contextlib import asynccontextmanager\nfrom typing import AsyncGenerator\n\nclass AsyncDatabaseConnection:\n    def __init__(self, connection_string: str):\n        self.connection_string = connection_string\n        self.connection = None\n\n    async def connect(self):\n        \"\"\"Establish database connection.\"\"\"\n        # Simulate async connection\n        await asyncio.sleep(0.1)\n        self.connection = f\"Connected to {self.connection_string}\"\n        print(f\"Database connected: {self.connection}\")\n\n    async def disconnect(self):\n        \"\"\"Close database connection.\"\"\"\n        if self.connection:\n            await asyncio.sleep(0.05)\n            print(f\"Database disconnected: {self.connection}\")\n            self.connection = None\n\n    async def __aenter__(self):\n        await self.connect()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        await self.disconnect()\n\n# Async scope with context manager\n@asynccontextmanager\nasync def async_request_scope(container: Container) -&gt; AsyncGenerator[Container, None]:\n    \"\"\"Create async request scope.\"\"\"\n    scope = container.create_scope()\n    try:\n        # Setup async resources\n        db_connection = scope.resolve(AsyncDatabaseConnection)\n        await db_connection.connect()\n\n        yield scope\n    finally:\n        # Cleanup async resources\n        if hasattr(scope, '_instances'):\n            for instance in scope._instances.values():\n                if hasattr(instance, '__aexit__'):\n                    await instance.__aexit__(None, None, None)\n                elif hasattr(instance, 'disconnect'):\n                    await instance.disconnect()\n\n        scope.dispose()\n\n# Usage\nasync def process_request():\n    async with async_request_scope(container) as scope:\n        user_service = scope.resolve(AsyncUserService)\n        result = await user_service.get_user(1)\n        return result\n</code></pre>"},{"location":"advanced/async-support/#async-factory-functions","title":"Async Factory Functions","text":""},{"location":"advanced/async-support/#async-service-factories","title":"Async Service Factories","text":"<pre><code>from typing import Awaitable, Callable\n\nclass AsyncServiceFactory:\n    \"\"\"Factory for creating async services.\"\"\"\n\n    def __init__(self, factory_func: Callable[..., Awaitable[Any]]):\n        self.factory_func = factory_func\n        self._cached_instance = None\n\n    async def create(self, *args, **kwargs) -&gt; Any:\n        \"\"\"Create service instance asynchronously.\"\"\"\n        return await self.factory_func(*args, **kwargs)\n\n    async def create_singleton(self, *args, **kwargs) -&gt; Any:\n        \"\"\"Create singleton instance asynchronously.\"\"\"\n        if self._cached_instance is None:\n            self._cached_instance = await self.factory_func(*args, **kwargs)\n        return self._cached_instance\n\n# Async factory function\nasync def create_email_service(config: EmailConfig) -&gt; EmailService:\n    \"\"\"Async factory for email service.\"\"\"\n    service = EmailService(config)\n\n    # Async initialization\n    await service.initialize()\n    await service.test_connection()\n\n    return service\n\n# Register async factory\nasync_factory = AsyncServiceFactory(create_email_service)\ncontainer.register(EmailService, async_factory.create_singleton)\n\n# Alternative: Direct async factory registration\ncontainer.register_async_factory(EmailService, create_email_service)\n</code></pre>"},{"location":"advanced/async-support/#async-lazy-services","title":"Async Lazy Services","text":"<pre><code>class AsyncLazyService:\n    \"\"\"Lazy-loaded async service.\"\"\"\n\n    def __init__(self, factory: Callable[[], Awaitable[Any]]):\n        self._factory = factory\n        self._instance = None\n        self._initialized = False\n        self._lock = asyncio.Lock()\n\n    async def get_instance(self) -&gt; Any:\n        \"\"\"Get or create service instance.\"\"\"\n        if not self._initialized:\n            async with self._lock:\n                if not self._initialized:\n                    self._instance = await self._factory()\n                    self._initialized = True\n\n        return self._instance\n\n    async def __call__(self, *args, **kwargs):\n        \"\"\"Make service callable.\"\"\"\n        instance = await self.get_instance()\n        if asyncio.iscoroutinefunction(instance):\n            return await instance(*args, **kwargs)\n        else:\n            return instance(*args, **kwargs)\n\n# Register lazy async service\nasync def create_heavy_service() -&gt; HeavyService:\n    \"\"\"Create expensive service asynchronously.\"\"\"\n    service = HeavyService()\n    await service.load_heavy_data()\n    return service\n\nlazy_service = AsyncLazyService(create_heavy_service)\ncontainer.register(HeavyService, lazy_service.get_instance)\n</code></pre>"},{"location":"advanced/async-support/#async-scopes","title":"Async Scopes","text":""},{"location":"advanced/async-support/#request-scoped-async-services","title":"Request-Scoped Async Services","text":"<pre><code>import asyncio\nfrom contextvars import ContextVar\nfrom typing import Dict, Any\n\n# Context variable for request scope\n_request_scope: ContextVar[Dict[str, Any]] = ContextVar('request_scope', default={})\n\nclass AsyncRequestScope:\n    \"\"\"Async request scope implementation.\"\"\"\n\n    def __init__(self, container: Container):\n        self.container = container\n        self._instances: Dict[type, Any] = {}\n        self._disposal_tasks: List[Callable[[], Awaitable[None]]] = []\n\n    async def resolve(self, service_type: type) -&gt; Any:\n        \"\"\"Resolve service in async request scope.\"\"\"\n        if service_type not in self._instances:\n            # Check if service is async\n            if self._is_async_service(service_type):\n                instance = await self._create_async_instance(service_type)\n            else:\n                instance = self.container.resolve(service_type)\n\n            self._instances[service_type] = instance\n\n            # Register disposal if needed\n            if hasattr(instance, '__aexit__'):\n                self._disposal_tasks.append(\n                    lambda: instance.__aexit__(None, None, None)\n                )\n\n        return self._instances[service_type]\n\n    async def _create_async_instance(self, service_type: type) -&gt; Any:\n        \"\"\"Create async service instance.\"\"\"\n        # Get constructor dependencies\n        dependencies = self._get_dependencies(service_type)\n        resolved_deps = {}\n\n        for name, dep_type in dependencies.items():\n            resolved_deps[name] = await self.resolve(dep_type)\n\n        # Create instance\n        instance = service_type(**resolved_deps)\n\n        # Initialize if async\n        if hasattr(instance, '__aenter__'):\n            await instance.__aenter__()\n\n        return instance\n\n    def _is_async_service(self, service_type: type) -&gt; bool:\n        \"\"\"Check if service requires async initialization.\"\"\"\n        return (\n            hasattr(service_type, '__aenter__') or\n            hasattr(service_type, 'async_init') or\n            any(asyncio.iscoroutinefunction(getattr(service_type, method, None))\n                for method in ['__init__', 'initialize'])\n        )\n\n    def _get_dependencies(self, service_type: type) -&gt; Dict[str, type]:\n        \"\"\"Get service dependencies.\"\"\"\n        import inspect\n        dependencies = {}\n\n        if hasattr(service_type, '__init__'):\n            sig = inspect.signature(service_type.__init__)\n            for param_name, param in sig.parameters.items():\n                if param_name != 'self' and param.annotation != inspect.Parameter.empty:\n                    dependencies[param_name] = param.annotation\n\n        return dependencies\n\n    async def dispose(self):\n        \"\"\"Dispose all async resources.\"\"\"\n        # Run disposal tasks\n        if self._disposal_tasks:\n            await asyncio.gather(*[task() for task in self._disposal_tasks])\n\n        # Dispose instances\n        for instance in self._instances.values():\n            if hasattr(instance, 'dispose') and asyncio.iscoroutinefunction(instance.dispose):\n                await instance.dispose()\n\n        self._instances.clear()\n        self._disposal_tasks.clear()\n\n# Async scope decorator\ndef async_request_scoped(func):\n    \"\"\"Decorator for async request-scoped functions.\"\"\"\n    async def wrapper(*args, **kwargs):\n        # Get or create request scope\n        scope_data = _request_scope.get()\n\n        if 'async_scope' not in scope_data:\n            container = kwargs.get('container') or get_current_container()\n            scope_data['async_scope'] = AsyncRequestScope(container)\n            _request_scope.set(scope_data)\n\n        scope = scope_data['async_scope']\n\n        try:\n            # Inject dependencies\n            resolved_func = await container.resolve_async(func)\n            return await resolved_func(*args, **kwargs)\n        finally:\n            # Cleanup in outermost scope\n            if len(asyncio.current_task().get_stack()) == 1:\n                await scope.dispose()\n                scope_data.pop('async_scope', None)\n\n    return wrapper\n</code></pre>"},{"location":"advanced/async-support/#async-middleware","title":"Async Middleware","text":""},{"location":"advanced/async-support/#async-dependency-middleware","title":"Async Dependency Middleware","text":"<pre><code>class AsyncDependencyMiddleware:\n    \"\"\"Middleware for async dependency injection.\"\"\"\n\n    def __init__(self, container: Container):\n        self.container = container\n\n    async def __call__(self, request, response, next_middleware):\n        \"\"\"Process request with async dependency injection.\"\"\"\n        # Create async scope for request\n        async with AsyncRequestScope(self.container) as scope:\n            # Store scope in request context\n            request.scope = scope\n\n            # Process request\n            return await next_middleware(request, response)\n\n# FastAPI async middleware\nfrom fastapi import FastAPI, Request, Response\nfrom fastapi.middleware.base import BaseHTTPMiddleware\n\nclass FastAPIAsyncDIMiddleware(BaseHTTPMiddleware):\n    \"\"\"FastAPI async dependency injection middleware.\"\"\"\n\n    def __init__(self, app: FastAPI, container: Container):\n        super().__init__(app)\n        self.container = container\n\n    async def dispatch(self, request: Request, call_next):\n        \"\"\"Process request with async DI.\"\"\"\n        async with AsyncRequestScope(self.container) as scope:\n            # Store scope in request state\n            request.state.di_scope = scope\n\n            # Process request\n            response = await call_next(request)\n            return response\n\n# Register middleware\napp = FastAPI()\napp.add_middleware(FastAPIAsyncDIMiddleware, container=container)\n\n# Async endpoint with DI\n@app.get(\"/users/{user_id}\")\nasync def get_user(user_id: int, request: Request):\n    # Get service from async scope\n    scope = request.state.di_scope\n    user_service = await scope.resolve(AsyncUserService)\n\n    user = await user_service.get_user(user_id)\n    return {\"user\": user.email}\n</code></pre>"},{"location":"advanced/async-support/#async-patterns","title":"Async Patterns","text":""},{"location":"advanced/async-support/#producer-consumer-pattern","title":"Producer-Consumer Pattern","text":"<pre><code>import asyncio\nfrom asyncio import Queue\nfrom typing import List\n\nclass AsyncEventProducer:\n    \"\"\"Async event producer service.\"\"\"\n\n    def __init__(self, event_queue: Queue):\n        self.event_queue = event_queue\n\n    async def produce_event(self, event_data: dict):\n        \"\"\"Produce an event asynchronously.\"\"\"\n        await self.event_queue.put(event_data)\n        print(f\"Produced event: {event_data}\")\n\nclass AsyncEventConsumer:\n    \"\"\"Async event consumer service.\"\"\"\n\n    def __init__(self, event_queue: Queue, processor: EventProcessor):\n        self.event_queue = event_queue\n        self.processor = processor\n        self._running = False\n\n    async def start_consuming(self):\n        \"\"\"Start consuming events.\"\"\"\n        self._running = True\n        while self._running:\n            try:\n                # Wait for event with timeout\n                event = await asyncio.wait_for(\n                    self.event_queue.get(),\n                    timeout=1.0\n                )\n\n                # Process event\n                await self.processor.process_event(event)\n                self.event_queue.task_done()\n\n            except asyncio.TimeoutError:\n                continue  # Continue waiting for events\n\n    def stop_consuming(self):\n        \"\"\"Stop consuming events.\"\"\"\n        self._running = False\n\n# Async service registration\nasync def create_event_queue() -&gt; Queue:\n    \"\"\"Create async event queue.\"\"\"\n    return Queue(maxsize=100)\n\ncontainer.register_async_factory(Queue, create_event_queue)\ncontainer.register(AsyncEventProducer, AsyncEventProducer)\ncontainer.register(AsyncEventConsumer, AsyncEventConsumer)\n\n# Usage\n@inject\nasync def run_event_system(producer: AsyncEventProducer, consumer: AsyncEventConsumer):\n    \"\"\"Run async event system.\"\"\"\n    # Start consumer\n    consumer_task = asyncio.create_task(consumer.start_consuming())\n\n    # Produce events\n    for i in range(10):\n        await producer.produce_event({\"id\": i, \"data\": f\"event_{i}\"})\n        await asyncio.sleep(0.1)\n\n    # Wait for processing to complete\n    await asyncio.sleep(1)\n    consumer.stop_consuming()\n\n    # Cancel consumer task\n    consumer_task.cancel()\n    try:\n        await consumer_task\n    except asyncio.CancelledError:\n        pass\n\n# Run the system\nasyncio.run(container.resolve(run_event_system))\n</code></pre>"},{"location":"advanced/async-support/#async-background-tasks","title":"Async Background Tasks","text":"<pre><code>class AsyncBackgroundTaskManager:\n    \"\"\"Manages async background tasks.\"\"\"\n\n    def __init__(self):\n        self._tasks: List[asyncio.Task] = []\n        self._running = True\n\n    async def start_task(self, coro):\n        \"\"\"Start a background task.\"\"\"\n        task = asyncio.create_task(coro)\n        self._tasks.append(task)\n        return task\n\n    async def stop_all_tasks(self):\n        \"\"\"Stop all background tasks.\"\"\"\n        self._running = False\n\n        # Cancel all tasks\n        for task in self._tasks:\n            task.cancel()\n\n        # Wait for cancellation\n        if self._tasks:\n            await asyncio.gather(*self._tasks, return_exceptions=True)\n\n        self._tasks.clear()\n\nclass AsyncEmailService:\n    \"\"\"Async email service with background processing.\"\"\"\n\n    def __init__(self, task_manager: AsyncBackgroundTaskManager):\n        self.task_manager = task_manager\n        self._email_queue = Queue()\n\n    async def send_email_async(self, to: str, subject: str, body: str):\n        \"\"\"Send email asynchronously in background.\"\"\"\n        email_data = {\n            \"to\": to,\n            \"subject\": subject,\n            \"body\": body\n        }\n\n        await self._email_queue.put(email_data)\n\n    async def _process_emails(self):\n        \"\"\"Background email processing.\"\"\"\n        while True:\n            try:\n                email_data = await self._email_queue.get()\n\n                # Simulate email sending\n                await asyncio.sleep(0.5)\n                print(f\"Email sent to {email_data['to']}: {email_data['subject']}\")\n\n                self._email_queue.task_done()\n\n            except asyncio.CancelledError:\n                break\n\n    async def start_background_processing(self):\n        \"\"\"Start background email processing.\"\"\"\n        await self.task_manager.start_task(self._process_emails())\n\n# Register async services\ncontainer.register(AsyncBackgroundTaskManager, AsyncBackgroundTaskManager)\ncontainer.register(AsyncEmailService, AsyncEmailService)\n\n# Auto-start background processing\n@inject\nasync def start_email_service(email_service: AsyncEmailService):\n    \"\"\"Start email service with background processing.\"\"\"\n    await email_service.start_background_processing()\n    return email_service\n\ncontainer.register_factory(AsyncEmailService, start_email_service)\n</code></pre>"},{"location":"advanced/async-support/#error-handling-in-async-context","title":"Error Handling in Async Context","text":""},{"location":"advanced/async-support/#async-exception-handling","title":"Async Exception Handling","text":"<pre><code>class AsyncExceptionHandler:\n    \"\"\"Handles exceptions in async dependency injection.\"\"\"\n\n    def __init__(self):\n        self._handlers = {}\n\n    def register_handler(self, exception_type: type, handler):\n        \"\"\"Register async exception handler.\"\"\"\n        self._handlers[exception_type] = handler\n\n    async def handle_exception(self, exception: Exception) -&gt; bool:\n        \"\"\"Handle exception asynchronously.\"\"\"\n        for exc_type, handler in self._handlers.items():\n            if isinstance(exception, exc_type):\n                if asyncio.iscoroutinefunction(handler):\n                    await handler(exception)\n                else:\n                    handler(exception)\n                return True\n\n        return False\n\n# Async error recovery\nasync def async_service_with_fallback(container: Container, service_type: type, fallback_factory):\n    \"\"\"Resolve service with async fallback.\"\"\"\n    try:\n        return await container.resolve_async(service_type)\n    except Exception as e:\n        print(f\"Service resolution failed: {e}\")\n\n        # Try fallback\n        if asyncio.iscoroutinefunction(fallback_factory):\n            return await fallback_factory()\n        else:\n            return fallback_factory()\n\n# Usage\nasync def fallback_user_service():\n    \"\"\"Fallback user service factory.\"\"\"\n    return MockUserService()\n\n@inject\nasync def get_user_with_fallback(user_id: int) -&gt; dict:\n    \"\"\"Get user with fallback service.\"\"\"\n    user_service = await async_service_with_fallback(\n        container,\n        UserService,\n        fallback_user_service\n    )\n\n    user = await user_service.get_user(user_id)\n    return {\"user\": user.email}\n</code></pre>"},{"location":"advanced/async-support/#best-practices-for-async-di","title":"Best Practices for Async DI","text":""},{"location":"advanced/async-support/#performance-optimization","title":"Performance Optimization","text":"<pre><code>class AsyncServicePool:\n    \"\"\"Pool of async service instances.\"\"\"\n\n    def __init__(self, factory_func, pool_size: int = 10):\n        self.factory_func = factory_func\n        self.pool_size = pool_size\n        self._pool = Queue(maxsize=pool_size)\n        self._initialized = False\n\n    async def initialize(self):\n        \"\"\"Initialize service pool.\"\"\"\n        if not self._initialized:\n            for _ in range(self.pool_size):\n                instance = await self.factory_func()\n                await self._pool.put(instance)\n            self._initialized = True\n\n    async def get_service(self):\n        \"\"\"Get service from pool.\"\"\"\n        if not self._initialized:\n            await self.initialize()\n\n        return await self._pool.get()\n\n    async def return_service(self, service):\n        \"\"\"Return service to pool.\"\"\"\n        await self._pool.put(service)\n\n# Connection pooling\nasync def create_db_connection():\n    \"\"\"Create database connection.\"\"\"\n    connection = DatabaseConnection()\n    await connection.connect()\n    return connection\n\ndb_pool = AsyncServicePool(create_db_connection, pool_size=5)\n\n# Use pooled services\n@inject\nasync def process_data(data: dict):\n    \"\"\"Process data with pooled database connection.\"\"\"\n    db_connection = await db_pool.get_service()\n\n    try:\n        # Use connection\n        result = await db_connection.execute_query(data['query'])\n        return result\n    finally:\n        # Return to pool\n        await db_pool.return_service(db_connection)\n</code></pre>"},{"location":"advanced/async-support/#resource-management","title":"Resource Management","text":"<pre><code>class AsyncResourceManager:\n    \"\"\"Manages async resources with proper cleanup.\"\"\"\n\n    def __init__(self):\n        self._resources: List[Any] = []\n        self._cleanup_tasks: List[Callable] = []\n\n    def register_resource(self, resource, cleanup_func=None):\n        \"\"\"Register resource for cleanup.\"\"\"\n        self._resources.append(resource)\n\n        if cleanup_func:\n            self._cleanup_tasks.append(cleanup_func)\n        elif hasattr(resource, '__aexit__'):\n            self._cleanup_tasks.append(\n                lambda: resource.__aexit__(None, None, None)\n            )\n        elif hasattr(resource, 'close') and asyncio.iscoroutinefunction(resource.close):\n            self._cleanup_tasks.append(resource.close)\n\n    async def cleanup_all(self):\n        \"\"\"Cleanup all registered resources.\"\"\"\n        cleanup_results = await asyncio.gather(\n            *[task() for task in self._cleanup_tasks],\n            return_exceptions=True\n        )\n\n        # Log any cleanup errors\n        for i, result in enumerate(cleanup_results):\n            if isinstance(result, Exception):\n                print(f\"Cleanup error for resource {i}: {result}\")\n\n        self._resources.clear()\n        self._cleanup_tasks.clear()\n\n# Register resource manager\ncontainer.register(AsyncResourceManager, AsyncResourceManager, scope=\"singleton\")\n\n# Auto-cleanup on container disposal\n@inject\nasync def setup_container_cleanup(resource_manager: AsyncResourceManager):\n    \"\"\"Setup automatic resource cleanup.\"\"\"\n\n    async def cleanup_handler():\n        await resource_manager.cleanup_all()\n\n    # Register cleanup with container\n    container.register_disposal_handler(cleanup_handler)\n</code></pre> <p>This comprehensive async support documentation covers all aspects of using InjectQ with asynchronous Python applications, from basic async service resolution to advanced patterns like connection pooling and resource management.</p>"},{"location":"advanced/circular-dependencies/","title":"Circular Dependencies","text":"<p>Circular dependencies occur when two or more services depend on each other, creating a dependency loop that can cause resolution failures or infinite loops.</p>"},{"location":"advanced/circular-dependencies/#understanding-circular-dependencies","title":"\ud83d\udd04 Understanding Circular Dependencies","text":""},{"location":"advanced/circular-dependencies/#what-are-circular-dependencies","title":"What are Circular Dependencies?","text":"<pre><code># \u274c Circular dependency example\nclass ServiceA:\n    def __init__(self, service_b: ServiceB):\n        self.service_b = service_b\n\nclass ServiceB:\n    def __init__(self, service_a: ServiceA):\n        self.service_a = service_a\n\n# This creates a circular dependency:\n# ServiceA -&gt; ServiceB -&gt; ServiceA\n</code></pre>"},{"location":"advanced/circular-dependencies/#types-of-circular-dependencies","title":"Types of Circular Dependencies","text":"<pre><code># 1. Direct circular dependency\nclass DirectCircularA:\n    def __init__(self, b: DirectCircularB):\n        self.b = b\n\nclass DirectCircularB:\n    def __init__(self, a: DirectCircularA):\n        self.a = a\n\n# 2. Indirect circular dependency\nclass IndirectCircularA:\n    def __init__(self, b: IndirectCircularB):\n        self.b = b\n\nclass IndirectCircularB:\n    def __init__(self, c: IndirectCircularC):\n        self.c = c\n\nclass IndirectCircularC:\n    def __init__(self, a: IndirectCircularA):\n        self.a = a\n\n# 3. Self-dependency (rare but possible)\nclass SelfDependency:\n    def __init__(self, self_ref):\n        self.self_ref = self_ref\n</code></pre>"},{"location":"advanced/circular-dependencies/#circular-dependency-detection","title":"\ud83d\udd0d Circular Dependency Detection","text":""},{"location":"advanced/circular-dependencies/#automatic-detection","title":"Automatic Detection","text":"<pre><code>from injectq.core.circulardeps import CircularDependencyDetector\n\n# Automatic circular dependency detection\ndetector = CircularDependencyDetector(container)\n\n# Detect circular dependencies\ncircular_deps = detector.detect_circular_dependencies()\nprint(\"Circular dependencies found:\")\nfor dep_chain in circular_deps:\n    print(f\"- {' -&gt; '.join(cls.__name__ for cls in dep_chain)}\")\n\n# Check if specific service has circular dependency\nhas_circular = detector.has_circular_dependency(SomeService)\nprint(f\"SomeService has circular dependency: {has_circular}\")\n\n# Get circular dependency chains for specific service\nchains = detector.get_circular_chains(SomeService)\nfor chain in chains:\n    print(f\"Circular chain: {' -&gt; '.join(cls.__name__ for cls in chain)}\")\n</code></pre>"},{"location":"advanced/circular-dependencies/#dependency-graph-analysis","title":"Dependency Graph Analysis","text":"<pre><code>from injectq.core.circulardeps import DependencyGraphAnalyzer\n\n# Analyze dependency graph for circular dependencies\nanalyzer = DependencyGraphAnalyzer(container)\n\n# Build dependency graph\ngraph = analyzer.build_dependency_graph()\n\n# Find all circular dependencies\ncircular_paths = analyzer.find_circular_paths()\nprint(\"Circular dependency paths:\")\nfor path in circular_paths:\n    print(f\"- {' -&gt; '.join(cls.__name__ for cls in path)}\")\n\n# Get strongly connected components\nscc = analyzer.get_strongly_connected_components()\nprint(\"Strongly connected components:\")\nfor component in scc:\n    if len(component) &gt; 1:  # Only show components with cycles\n        print(f\"- {', '.join(cls.__name__ for cls in component)}\")\n</code></pre>"},{"location":"advanced/circular-dependencies/#runtime-detection","title":"Runtime Detection","text":"<pre><code># Runtime circular dependency detection\nclass RuntimeCircularDetector:\n    \"\"\"Detect circular dependencies at runtime.\"\"\"\n\n    def __init__(self):\n        self.resolution_stack = []\n        self.visited = set()\n\n    def detect_during_resolution(self, service_type):\n        \"\"\"Detect circular dependency during service resolution.\"\"\"\n        if service_type in self.resolution_stack:\n            # Circular dependency found\n            cycle_start = self.resolution_stack.index(service_type)\n            cycle = self.resolution_stack[cycle_start:] + [service_type]\n            raise CircularDependencyError(f\"Circular dependency detected: {' -&gt; '.join(cls.__name__ for cls in cycle)}\")\n\n        if service_type in self.visited:\n            return  # Already processed\n\n        self.resolution_stack.append(service_type)\n\n        try:\n            # Get dependencies of this service\n            dependencies = self.get_dependencies(service_type)\n\n            for dep in dependencies:\n                self.detect_during_resolution(dep)\n\n            self.visited.add(service_type)\n\n        finally:\n            self.resolution_stack.pop()\n\n    def get_dependencies(self, service_type):\n        \"\"\"Get dependencies of a service type.\"\"\"\n        # This would integrate with container's dependency resolution\n        return []\n\n# Usage\ndetector = RuntimeCircularDetector()\ntry:\n    detector.detect_during_resolution(SomeService)\nexcept CircularDependencyError as e:\n    print(f\"Circular dependency: {e}\")\n</code></pre>"},{"location":"advanced/circular-dependencies/#resolving-circular-dependencies","title":"\ud83d\udee0\ufe0f Resolving Circular Dependencies","text":""},{"location":"advanced/circular-dependencies/#method-1-property-injection","title":"Method 1: Property Injection","text":"<pre><code># \u2705 Solution: Use property injection to break circular dependency\nclass PropertyInjectionA:\n    def __init__(self):\n        self.service_b = None  # Injected later\n\n    def set_service_b(self, service_b: PropertyInjectionB):\n        self.service_b = service_b\n\nclass PropertyInjectionB:\n    def __init__(self, service_a: PropertyInjectionA):\n        self.service_a = service_a\n\n# Setup with property injection\ndef setup_property_injection(container):\n    # Create instances\n    service_a = PropertyInjectionA()\n    service_b = PropertyInjectionB(service_a)\n\n    # Break circular dependency with property injection\n    service_a.set_service_b(service_b)\n\n    # Bind to container\n    container.bind(PropertyInjectionA, service_a)\n    container.bind(PropertyInjectionB, service_b)\n\n# Usage\nsetup_property_injection(container)\nservice_a = container.get(PropertyInjectionA)\nservice_b = container.get(PropertyInjectionB)\n</code></pre>"},{"location":"advanced/circular-dependencies/#method-2-interface-segregation","title":"Method 2: Interface Segregation","text":"<pre><code># \u2705 Solution: Use interfaces to break circular dependency\nfrom abc import ABC, abstractmethod\n\nclass IServiceA(ABC):\n    @abstractmethod\n    def method_a(self):\n        pass\n\nclass IServiceB(ABC):\n    @abstractmethod\n    def method_b(self):\n        pass\n\nclass InterfaceSegregationA(IServiceA):\n    def __init__(self, service_b: IServiceB):\n        self.service_b = service_b\n\n    def method_a(self):\n        return f\"A calling B: {self.service_b.method_b()}\"\n\nclass InterfaceSegregationB(IServiceB):\n    def __init__(self):\n        self.service_a = None  # Will be set later\n\n    def set_service_a(self, service_a: IServiceA):\n        self.service_a = service_a\n\n    def method_b(self):\n        if self.service_a:\n            return f\"B calling A: {self.service_a.method_a()}\"\n        return \"B: No service A available\"\n\n# Setup with interface segregation\ndef setup_interface_segregation(container):\n    # Bind interface to implementation\n    container.bind(IServiceA, InterfaceSegregationA)\n    container.bind(IServiceB, InterfaceSegregationB)\n\n    # Create instances\n    service_b = container.get(IServiceB)\n    service_a = container.get(IServiceA)\n\n    # Set the circular reference\n    service_b.set_service_a(service_a)\n\n# Usage\nsetup_interface_segregation(container)\nservice_a = container.get(IServiceA)\nresult = service_a.method_a()  # This will work without circular dependency\n</code></pre>"},{"location":"advanced/circular-dependencies/#method-3-factory-pattern","title":"Method 3: Factory Pattern","text":"<pre><code># \u2705 Solution: Use factory pattern to break circular dependency\nclass FactoryA:\n    def __init__(self, value: str):\n        self.value = value\n\n    def get_service_b(self, container):\n        \"\"\"Lazy creation of ServiceB.\"\"\"\n        return container.get(FactoryB)\n\nclass FactoryB:\n    def __init__(self, value: str):\n        self.value = value\n\n    def get_service_a(self, container):\n        \"\"\"Lazy creation of ServiceA.\"\"\"\n        return container.get(FactoryA)\n\n# Setup with factory pattern\ndef setup_factory_pattern(container):\n    container.bind(FactoryA, lambda: FactoryA(\"from_a\"))\n    container.bind(FactoryB, lambda: FactoryB(\"from_b\"))\n\n# Usage\nsetup_factory_pattern(container)\n\nservice_a = container.get(FactoryA)\nservice_b = service_a.get_service_b(container)  # Lazy resolution\nservice_a_again = service_b.get_service_a(container)  # Lazy resolution\n</code></pre>"},{"location":"advanced/circular-dependencies/#method-4-service-locator-pattern","title":"Method 4: Service Locator Pattern","text":"<pre><code># \u2705 Solution: Use service locator to break circular dependency\nclass ServiceLocator:\n    \"\"\"Simple service locator to break circular dependencies.\"\"\"\n\n    def __init__(self):\n        self.services = {}\n\n    def register(self, service_type, service_instance):\n        self.services[service_type] = service_instance\n\n    def get(self, service_type):\n        return self.services.get(service_type)\n\nclass ServiceLocatorA:\n    def __init__(self, locator: ServiceLocator):\n        self.locator = locator\n\n    def call_service_b(self):\n        service_b = self.locator.get(ServiceLocatorB)\n        return service_b.do_something()\n\nclass ServiceLocatorB:\n    def __init__(self, locator: ServiceLocator):\n        self.locator = locator\n\n    def call_service_a(self):\n        service_a = self.locator.get(ServiceLocatorA)\n        return service_a.do_something()\n\n    def do_something(self):\n        return \"ServiceB result\"\n\n# Setup with service locator\ndef setup_service_locator(container):\n    locator = ServiceLocator()\n\n    # Create services with locator\n    service_a = ServiceLocatorA(locator)\n    service_b = ServiceLocatorB(locator)\n\n    # Register services\n    locator.register(ServiceLocatorA, service_a)\n    locator.register(ServiceLocatorB, service_b)\n\n    # Bind to container\n    container.bind(ServiceLocatorA, service_a)\n    container.bind(ServiceLocatorB, service_b)\n\n# Usage\nsetup_service_locator(container)\nservice_a = container.get(ServiceLocatorA)\nresult = service_a.call_service_b()\n</code></pre>"},{"location":"advanced/circular-dependencies/#method-5-event-driven-architecture","title":"Method 5: Event-Driven Architecture","text":"<pre><code># \u2705 Solution: Use events to break circular dependency\nfrom typing import Callable\n\nclass EventBus:\n    \"\"\"Simple event bus for decoupling services.\"\"\"\n\n    def __init__(self):\n        self.listeners = {}\n\n    def subscribe(self, event_type: str, listener: Callable):\n        if event_type not in self.listeners:\n            self.listeners[event_type] = []\n        self.listeners[event_type].append(listener)\n\n    def publish(self, event_type: str, data=None):\n        if event_type in self.listeners:\n            for listener in self.listeners[event_type]:\n                listener(data)\n\nclass EventDrivenA:\n    def __init__(self, event_bus: EventBus):\n        self.event_bus = event_bus\n        self.event_bus.subscribe(\"service_b_event\", self.handle_service_b_event)\n\n    def do_something(self):\n        # Instead of calling ServiceB directly, publish an event\n        self.event_bus.publish(\"service_a_event\", {\"data\": \"from_a\"})\n        return \"ServiceA result\"\n\n    def handle_service_b_event(self, data):\n        print(f\"ServiceA received event from ServiceB: {data}\")\n\nclass EventDrivenB:\n    def __init__(self, event_bus: EventBus):\n        self.event_bus = event_bus\n        self.event_bus.subscribe(\"service_a_event\", self.handle_service_a_event)\n\n    def do_something(self):\n        # Instead of calling ServiceA directly, publish an event\n        self.event_bus.publish(\"service_b_event\", {\"data\": \"from_b\"})\n        return \"ServiceB result\"\n\n    def handle_service_a_event(self, data):\n        print(f\"ServiceB received event from ServiceA: {data}\")\n\n# Setup with event-driven architecture\ndef setup_event_driven(container):\n    event_bus = EventBus()\n\n    container.bind(EventBus, event_bus)\n    container.bind(EventDrivenA, EventDrivenA)\n    container.bind(EventDrivenB, EventDrivenB)\n\n# Usage\nsetup_event_driven(container)\nservice_a = container.get(EventDrivenA)\nservice_b = container.get(EventDrivenB)\n\nresult_a = service_a.do_something()  # Triggers event to ServiceB\nresult_b = service_b.do_something()  # Triggers event to ServiceA\n</code></pre>"},{"location":"advanced/circular-dependencies/#advanced-circular-dependency-resolution","title":"\ud83c\udfd7\ufe0f Advanced Circular Dependency Resolution","text":""},{"location":"advanced/circular-dependencies/#lazy-resolution","title":"Lazy Resolution","text":"<pre><code># Lazy resolution to break circular dependencies\nclass LazyResolver:\n    \"\"\"Lazy dependency resolver.\"\"\"\n\n    def __init__(self, container):\n        self.container = container\n        self._cache = {}\n\n    def get_lazy(self, service_type):\n        \"\"\"Get lazy resolver for service type.\"\"\"\n        if service_type not in self._cache:\n            self._cache[service_type] = LazyService(service_type, self.container)\n        return self._cache[service_type]\n\nclass LazyService:\n    \"\"\"Lazy service wrapper.\"\"\"\n\n    def __init__(self, service_type, container):\n        self.service_type = service_type\n        self.container = container\n        self._instance = None\n\n    def __call__(self):\n        \"\"\"Resolve service when called.\"\"\"\n        if self._instance is None:\n            self._instance = self.container.get(self.service_type)\n        return self._instance\n\nclass LazyA:\n    def __init__(self, lazy_resolver: LazyResolver):\n        self.lazy_b = lazy_resolver.get_lazy(LazyB)\n\n    def call_b(self):\n        service_b = self.lazy_b()  # Resolved when called\n        return service_b.do_something()\n\nclass LazyB:\n    def __init__(self, lazy_resolver: LazyResolver):\n        self.lazy_a = lazy_resolver.get_lazy(LazyA)\n\n    def call_a(self):\n        service_a = self.lazy_a()  # Resolved when called\n        return service_a.do_something()\n\n    def do_something(self):\n        return \"LazyB result\"\n\n# Setup with lazy resolution\ndef setup_lazy_resolution(container):\n    lazy_resolver = LazyResolver(container)\n\n    container.bind(LazyResolver, lazy_resolver)\n    container.bind(LazyA, LazyA)\n    container.bind(LazyB, LazyB)\n\n# Usage\nsetup_lazy_resolution(container)\nservice_a = container.get(LazyA)\nresult = service_a.call_b()  # ServiceB resolved lazily\n</code></pre>"},{"location":"advanced/circular-dependencies/#proxy-pattern","title":"Proxy Pattern","text":"<pre><code># Proxy pattern to break circular dependencies\nclass ServiceProxy:\n    \"\"\"Proxy for delayed service resolution.\"\"\"\n\n    def __init__(self, service_type, container):\n        self.service_type = service_type\n        self.container = container\n        self._real_service = None\n\n    def _get_real_service(self):\n        if self._real_service is None:\n            self._real_service = self.container.get(self.service_type)\n        return self._real_service\n\n    def __getattr__(self, name):\n        \"\"\"Delegate attribute access to real service.\"\"\"\n        return getattr(self._get_real_service(), name)\n\nclass ProxyA:\n    def __init__(self, proxy_b: ServiceProxy):\n        self.proxy_b = proxy_b\n\n    def call_b(self):\n        return self.proxy_b.do_something()\n\nclass ProxyB:\n    def __init__(self, proxy_a: ServiceProxy):\n        self.proxy_a = proxy_a\n\n    def call_a(self):\n        return self.proxy_a.call_b()\n\n    def do_something(self):\n        return \"ProxyB result\"\n\n# Setup with proxy pattern\ndef setup_proxy_pattern(container):\n    # Create proxies\n    proxy_a = ServiceProxy(ProxyA, container)\n    proxy_b = ServiceProxy(ProxyB, container)\n\n    # Bind proxies\n    container.bind(ServiceProxy, proxy_a, name=\"proxy_a\")\n    container.bind(ServiceProxy, proxy_b, name=\"proxy_b\")\n\n    # Bind real services\n    container.bind(ProxyA, lambda: ProxyA(proxy_b))\n    container.bind(ProxyB, lambda: ProxyB(proxy_a))\n\n# Usage\nsetup_proxy_pattern(container)\nservice_a = container.get(ProxyA)\nresult = service_a.call_b()  # Uses proxy to access ServiceB\n</code></pre>"},{"location":"advanced/circular-dependencies/#dependency-injection-container-features","title":"Dependency Injection Container Features","text":"<pre><code># Using InjectQ's circular dependency resolution features\nfrom injectq.core.circulardeps import CircularDependencyResolver\n\nresolver = CircularDependencyResolver(container)\n\n# Automatic circular dependency resolution\n@resolver.resolve_circular\nclass AutoResolvedA:\n    def __init__(self, b: AutoResolvedB):\n        self.b = b\n\n    def call_b(self):\n        return self.b.do_something()\n\n@resolver.resolve_circular\nclass AutoResolvedB:\n    def __init__(self, a: AutoResolvedA):\n        self.a = a\n\n    def call_a(self):\n        return self.a.call_b()\n\n    def do_something(self):\n        return \"AutoResolvedB result\"\n\n# Setup with automatic resolution\ndef setup_automatic_resolution(container):\n    container.bind(AutoResolvedA, AutoResolvedA)\n    container.bind(AutoResolvedB, AutoResolvedB)\n\n# Usage\nsetup_automatic_resolution(container)\nservice_a = container.get(AutoResolvedA)\nresult = service_a.call_b()  # Works despite circular dependency\n</code></pre>"},{"location":"advanced/circular-dependencies/#circular-dependency-analysis","title":"\ud83d\udcca Circular Dependency Analysis","text":""},{"location":"advanced/circular-dependencies/#dependency-graph-visualization","title":"Dependency Graph Visualization","text":"<pre><code>from injectq.core.circulardeps import DependencyGraphVisualizer\n\n# Visualize dependency graph\nvisualizer = DependencyGraphVisualizer(container)\n\n# Generate dependency graph\ngraph_data = visualizer.generate_graph()\n\n# Save as different formats\nvisualizer.save_as_dot(\"dependencies.dot\")\nvisualizer.save_as_png(\"dependencies.png\")\nvisualizer.save_as_svg(\"dependencies.svg\")\n\n# Highlight circular dependencies\ncircular_graph = visualizer.highlight_circular_dependencies()\nvisualizer.save_as_png(\"circular_dependencies.png\", graph=circular_graph)\n</code></pre>"},{"location":"advanced/circular-dependencies/#impact-analysis","title":"Impact Analysis","text":"<pre><code>from injectq.core.circulardeps import CircularDependencyAnalyzer\n\n# Analyze impact of circular dependencies\nanalyzer = CircularDependencyAnalyzer(container)\n\n# Analyze specific circular dependency\nimpact = analyzer.analyze_impact(SomeService)\nprint(\"Circular Dependency Impact Analysis:\")\nprint(f\"- Involved services: {impact.involved_services}\")\nprint(f\"- Resolution depth: {impact.resolution_depth}\")\nprint(f\"- Performance impact: {impact.performance_impact}\")\nprint(f\"- Maintenance complexity: {impact.maintenance_complexity}\")\n\n# Get resolution recommendations\nrecommendations = analyzer.get_recommendations(SomeService)\nprint(\"Resolution Recommendations:\")\nfor rec in recommendations:\n    print(f\"- {rec.strategy}: {rec.description}\")\n    print(f\"  Difficulty: {rec.difficulty}\")\n    print(f\"  Benefits: {rec.benefits}\")\n</code></pre>"},{"location":"advanced/circular-dependencies/#metrics-and-monitoring","title":"Metrics and Monitoring","text":"<pre><code>from injectq.core.circulardeps import CircularDependencyMonitor\n\n# Monitor circular dependencies\nmonitor = CircularDependencyMonitor(container)\n\n# Get circular dependency metrics\nmetrics = monitor.get_metrics()\nprint(\"Circular Dependency Metrics:\")\nprint(f\"- Total circular dependencies: {metrics.total_circular_deps}\")\nprint(f\"- Most complex cycle: {metrics.most_complex_cycle}\")\nprint(f\"- Average cycle length: {metrics.avg_cycle_length}\")\nprint(f\"- Resolution success rate: {metrics.resolution_success_rate}%\")\n\n# Monitor resolution attempts\nwith monitor.track_resolution(SomeService) as tracking:\n    service = container.get(SomeService)\n\nresolution_metrics = tracking.get_metrics()\nprint(\"Resolution Metrics:\")\nprint(f\"- Resolution time: {resolution_metrics.resolution_time}ms\")\nprint(f\"- Cycle detected: {resolution_metrics.cycle_detected}\")\nprint(f\"- Resolution strategy used: {resolution_metrics.strategy_used}\")\n</code></pre>"},{"location":"advanced/circular-dependencies/#best-practices","title":"\ud83c\udfaf Best Practices","text":""},{"location":"advanced/circular-dependencies/#good-practices","title":"\u2705 Good Practices","text":""},{"location":"advanced/circular-dependencies/#1-design-for-testability","title":"1. Design for Testability","text":"<pre><code># \u2705 Good: Design interfaces to avoid circular dependencies\nclass RepositoryInterface:\n    def get_data(self, id: str):\n        pass\n\nclass ServiceInterface:\n    def process_data(self, data: dict):\n        pass\n\nclass RepositoryImpl(RepositoryInterface):\n    def __init__(self, config: dict):\n        self.config = config\n\n    def get_data(self, id: str):\n        # Implementation\n        return {\"id\": id, \"data\": \"from_repository\"}\n\nclass ServiceImpl(ServiceInterface):\n    def __init__(self, repository: RepositoryInterface):\n        self.repository = repository\n\n    def process_data(self, data: dict):\n        # No circular dependency\n        repo_data = self.repository.get_data(data[\"id\"])\n        return {\"processed\": True, \"data\": repo_data}\n\n# Usage\ncontainer.bind(RepositoryInterface, RepositoryImpl)\ncontainer.bind(ServiceInterface, ServiceImpl)\n</code></pre>"},{"location":"advanced/circular-dependencies/#2-use-dependency-inversion-principle","title":"2. Use Dependency Inversion Principle","text":"<pre><code># \u2705 Good: Use dependency inversion to break circular dependencies\nfrom abc import ABC, abstractmethod\n\nclass NotificationServiceInterface(ABC):\n    @abstractmethod\n    def send_notification(self, message: str):\n        pass\n\nclass UserServiceInterface(ABC):\n    @abstractmethod\n    def get_user(self, user_id: str):\n        pass\n\nclass NotificationService(NotificationServiceInterface):\n    def __init__(self, user_service: UserServiceInterface):\n        self.user_service = user_service\n\n    def send_notification(self, message: str):\n        # Can get user information without circular dependency\n        user = self.user_service.get_user(\"current_user\")\n        print(f\"Sending notification to {user['name']}: {message}\")\n\nclass UserService(UserServiceInterface):\n    def __init__(self, notification_service: NotificationServiceInterface = None):\n        self.notification_service = notification_service\n\n    def get_user(self, user_id: str):\n        user = {\"id\": user_id, \"name\": \"John Doe\"}\n        # Optional notification (no circular dependency)\n        if self.notification_service:\n            self.notification_service.send_notification(f\"User {user_id} accessed\")\n        return user\n\n# Usage\ncontainer.bind(NotificationServiceInterface, NotificationService)\ncontainer.bind(UserServiceInterface, UserService)\n</code></pre>"},{"location":"advanced/circular-dependencies/#3-event-driven-communication","title":"3. Event-Driven Communication","text":"<pre><code># \u2705 Good: Use events for cross-service communication\nclass EventDrivenRepository:\n    def __init__(self, event_publisher):\n        self.event_publisher = event_publisher\n\n    def save_data(self, data: dict):\n        # Save data\n        saved_data = {\"id\": \"123\", **data}\n\n        # Publish event instead of calling service directly\n        self.event_publisher.publish(\"data_saved\", saved_data)\n\n        return saved_data\n\nclass EventDrivenProcessor:\n    def __init__(self, event_subscriber):\n        self.event_subscriber = event_subscriber\n        self.event_subscriber.subscribe(\"data_saved\", self.process_saved_data)\n\n    def process_saved_data(self, data):\n        # Process the saved data\n        print(f\"Processing saved data: {data}\")\n\n# Usage\nevent_bus = EventBus()\ncontainer.bind(EventBus, event_bus)\n\ncontainer.bind(EventDrivenRepository, EventDrivenRepository)\ncontainer.bind(EventDrivenProcessor, EventDrivenProcessor)\n</code></pre>"},{"location":"advanced/circular-dependencies/#bad-practices","title":"\u274c Bad Practices","text":""},{"location":"advanced/circular-dependencies/#1-tight-coupling","title":"1. Tight Coupling","text":"<pre><code># \u274c Bad: Tight coupling leads to circular dependencies\nclass TightlyCoupledA:\n    def __init__(self, b: TightlyCoupledB):\n        self.b = b\n\n    def process(self):\n        return self.b.process()\n\nclass TightlyCoupledB:\n    def __init__(self, a: TightlyCoupledA):\n        self.a = a\n\n    def process(self):\n        return self.a.process()  # Circular call\n\n# \u2705 Better: Use interfaces and proper separation\nclass ProcessingInterface:\n    def process(self):\n        pass\n\nclass DecoupledA(ProcessingInterface):\n    def __init__(self, processor: ProcessingInterface):\n        self.processor = processor\n\n    def process(self):\n        return f\"A: {self.processor.process()}\"\n\nclass DecoupledB(ProcessingInterface):\n    def __init__(self):\n        pass  # No circular dependency\n\n    def process(self):\n        return \"B processed\"\n</code></pre>"},{"location":"advanced/circular-dependencies/#2-service-locator-anti-pattern","title":"2. Service Locator Anti-Pattern","text":"<pre><code># \u274c Bad: Global service locator can hide circular dependencies\nclass GlobalServiceLocator:\n    _instance = None\n    services = {}\n\n    @classmethod\n    def get_instance(cls):\n        if cls._instance is None:\n            cls._instance = cls()\n        return cls._instance\n\n    def get_service(self, service_type):\n        return self.services.get(service_type)\n\n# \u2705 Better: Explicit dependency injection\nclass ExplicitDependenciesA:\n    def __init__(self, dependency_b):\n        self.dependency_b = dependency_b\n\nclass ExplicitDependenciesB:\n    def __init__(self, dependency_a):\n        self.dependency_a = dependency_a\n</code></pre>"},{"location":"advanced/circular-dependencies/#summary","title":"\ud83c\udfaf Summary","text":"<p>Circular dependencies create resolution challenges:</p> <ul> <li>Detection - Automatic and runtime circular dependency detection</li> <li>Resolution strategies - Property injection, interfaces, factories, service locators, events</li> <li>Advanced techniques - Lazy resolution, proxy pattern, automatic resolution</li> <li>Analysis tools - Graph visualization, impact analysis, monitoring</li> <li>Best practices - Design for testability, dependency inversion, event-driven communication</li> </ul> <p>Key features: - Comprehensive circular dependency detection - Multiple resolution strategies - Dependency graph analysis and visualization - Impact analysis and recommendations - Performance monitoring and metrics</p> <p>Best practices: - Design with interfaces to prevent circular dependencies - Use dependency inversion principle - Implement event-driven communication - Avoid tight coupling between services - Use lazy resolution when necessary - Monitor and analyze dependency graphs</p> <p>Common resolution patterns: - Property injection for breaking direct cycles - Interface segregation for loose coupling - Factory pattern for lazy instantiation - Service locator for centralized access - Event-driven architecture for decoupling - Proxy pattern for delayed resolution</p> <p>Ready to explore profiling?</p>"},{"location":"advanced/diagnostics/","title":"Diagnostics","text":"<p>Diagnostics provide comprehensive tools for debugging, monitoring, and troubleshooting dependency injection issues in your InjectQ applications.</p>"},{"location":"advanced/diagnostics/#diagnostic-tools","title":"\ud83d\udd0d Diagnostic Tools","text":""},{"location":"advanced/diagnostics/#container-inspection","title":"Container Inspection","text":"<pre><code>from injectq import InjectQ\nfrom injectq.diagnostics import ContainerInspector\n\n# Create container with diagnostics\ncontainer = InjectQ()\ninspector = ContainerInspector(container)\n\n# Inspect container state\ncontainer_info = inspector.inspect_container()\nprint(\"Container Information:\")\nprint(f\"- Total bindings: {container_info['total_bindings']}\")\nprint(f\"- Active scopes: {container_info['active_scopes']}\")\nprint(f\"- Memory usage: {container_info['memory_usage']} bytes\")\n\n# Inspect specific bindings\nbinding_info = inspector.inspect_binding(SomeService)\nprint(f\"Binding for SomeService: {binding_info}\")\n\n# List all bindings\nall_bindings = inspector.list_bindings()\nfor binding_type, binding_info in all_bindings.items():\n    print(f\"{binding_type.__name__}: {binding_info['scope']} scope\")\n</code></pre>"},{"location":"advanced/diagnostics/#dependency-graph-analysis","title":"Dependency Graph Analysis","text":"<pre><code>from injectq.diagnostics import DependencyGraphAnalyzer\n\nanalyzer = DependencyGraphAnalyzer(container)\n\n# Analyze dependency graph\ngraph_info = analyzer.analyze_graph()\nprint(\"Dependency Graph Analysis:\")\nprint(f\"- Total nodes: {graph_info['total_nodes']}\")\nprint(f\"- Total edges: {graph_info['total_edges']}\")\nprint(f\"- Circular dependencies: {graph_info['circular_dependencies']}\")\n\n# Find dependency chains\nchains = analyzer.find_dependency_chains(SomeService)\nfor chain in chains:\n    print(f\"Dependency chain: {' -&gt; '.join(cls.__name__ for cls in chain)}\")\n\n# Detect circular dependencies\ncircular_deps = analyzer.detect_circular_dependencies()\nif circular_deps:\n    print(\"Circular dependencies found:\")\n    for dep in circular_deps:\n        print(f\"- {' -&gt; '.join(cls.__name__ for cls in dep)}\")\n</code></pre>"},{"location":"advanced/diagnostics/#performance-diagnostics","title":"Performance Diagnostics","text":"<pre><code>from injectq.diagnostics import PerformanceMonitor\n\nmonitor = PerformanceMonitor(container)\n\n# Monitor resolution performance\nwith monitor.monitor_resolution():\n    service = container.get(SomeService)\n\n# Get performance report\nperformance_report = monitor.get_performance_report()\nprint(\"Performance Report:\")\nprint(f\"- Total resolutions: {performance_report['total_resolutions']}\")\nprint(f\"- Average resolution time: {performance_report['avg_resolution_time']}ms\")\nprint(f\"- Slowest resolution: {performance_report['slowest_resolution']}ms\")\n\n# Monitor memory usage\nmemory_report = monitor.get_memory_report()\nprint(\"Memory Report:\")\nprint(f\"- Peak memory usage: {memory_report['peak_memory']} bytes\")\nprint(f\"- Current memory usage: {memory_report['current_memory']} bytes\")\n</code></pre>"},{"location":"advanced/diagnostics/#debugging-tools","title":"\ud83d\udc1b Debugging Tools","text":""},{"location":"advanced/diagnostics/#resolution-tracing","title":"Resolution Tracing","text":"<pre><code>from injectq.diagnostics import ResolutionTracer\n\ntracer = ResolutionTracer(container)\n\n# Trace dependency resolution\nwith tracer.trace_resolution(SomeService) as trace:\n    service = container.get(SomeService)\n\n# Print resolution trace\nprint(\"Resolution Trace:\")\nfor step in trace.steps:\n    print(f\"  {step['step']}: {step['description']}\")\n    if 'duration' in step:\n        print(f\"    Duration: {step['duration']}ms\")\n\n# Trace with detailed output\ntracer.enable_detailed_tracing()\nwith tracer.trace_resolution(ComplexService) as trace:\n    complex_service = container.get(ComplexService)\n\ntracer.print_trace(trace)\n</code></pre>"},{"location":"advanced/diagnostics/#error-diagnostics","title":"Error Diagnostics","text":"<pre><code>from injectq.diagnostics import ErrorAnalyzer\n\nanalyzer = ErrorAnalyzer(container)\n\n# Analyze resolution errors\ntry:\n    service = container.get(SomeService)\nexcept Exception as e:\n    error_analysis = analyzer.analyze_error(e)\n    print(\"Error Analysis:\")\n    print(f\"- Error type: {error_analysis['error_type']}\")\n    print(f\"- Root cause: {error_analysis['root_cause']}\")\n    print(f\"- Suggested fixes: {error_analysis['suggested_fixes']}\")\n\n    # Print detailed error context\n    analyzer.print_error_context(error_analysis)\n</code></pre>"},{"location":"advanced/diagnostics/#scope-debugging","title":"Scope Debugging","text":"<pre><code>from injectq.diagnostics import ScopeDebugger\n\ndebugger = ScopeDebugger(container)\n\n# Debug scope issues\nscope_info = debugger.debug_scopes()\nprint(\"Scope Debug Information:\")\nfor scope_name, scope_data in scope_info.items():\n    print(f\"- {scope_name}: {scope_data['instance_count']} instances\")\n    print(f\"  Active instances: {len(scope_data['active_instances'])}\")\n\n# Check for scope leaks\nleaks = debugger.detect_scope_leaks()\nif leaks:\n    print(\"Scope leaks detected:\")\n    for leak in leaks:\n        print(f\"- {leak['scope']}: {leak['leaked_instances']} instances\")\n\n# Debug singleton scope\nsingleton_debug = debugger.debug_singleton_scope()\nprint(\"Singleton Debug:\")\nfor binding_type, info in singleton_debug.items():\n    print(f\"- {binding_type.__name__}: {info['instance_count']} instances\")\n</code></pre>"},{"location":"advanced/diagnostics/#monitoring-and-metrics","title":"\ud83d\udcca Monitoring and Metrics","text":""},{"location":"advanced/diagnostics/#container-metrics","title":"Container Metrics","text":"<pre><code>from injectq.diagnostics import ContainerMetrics\n\nmetrics = ContainerMetrics(container)\n\n# Collect metrics\ncontainer_metrics = metrics.collect_metrics()\nprint(\"Container Metrics:\")\nprint(f\"- Bindings count: {container_metrics['bindings_count']}\")\nprint(f\"- Resolutions count: {container_metrics['resolutions_count']}\")\nprint(f\"- Cache hit rate: {container_metrics['cache_hit_rate']}%\")\nprint(f\"- Memory usage: {container_metrics['memory_usage']} bytes\")\n\n# Monitor over time\nmetrics.start_monitoring(interval_seconds=60)\n\n# Later...\ntime_series_data = metrics.get_time_series_data()\nfor timestamp, data in time_series_data.items():\n    print(f\"{timestamp}: {data['resolutions_per_minute']} resolutions/min\")\n</code></pre>"},{"location":"advanced/diagnostics/#performance-profiling","title":"Performance Profiling","text":"<pre><code>from injectq.diagnostics import PerformanceProfiler\n\nprofiler = PerformanceProfiler(container)\n\n# Profile dependency resolution\nwith profiler.profile_resolution(SomeService) as profile:\n    service = container.get(SomeService)\n\n# Analyze profile\nprofile_analysis = profiler.analyze_profile(profile)\nprint(\"Profile Analysis:\")\nprint(f\"- Total time: {profile_analysis['total_time']}ms\")\nprint(f\"- Slowest dependency: {profile_analysis['slowest_dependency']}\")\nprint(f\"- Bottlenecks: {profile_analysis['bottlenecks']}\")\n\n# Profile memory usage\nmemory_profile = profiler.profile_memory_usage()\nprint(\"Memory Profile:\")\nfor binding_type, usage in memory_profile.items():\n    print(f\"- {binding_type.__name__}: {usage['memory_usage']} bytes\")\n</code></pre>"},{"location":"advanced/diagnostics/#health-checks","title":"Health Checks","text":"<pre><code>from injectq.diagnostics import HealthChecker\n\nhealth_checker = HealthChecker(container)\n\n# Perform health check\nhealth_status = await health_checker.check_health()\nprint(\"Health Status:\")\nprint(f\"- Overall health: {health_status['overall_health']}\")\nprint(f\"- Issues found: {len(health_status['issues'])}\")\n\nfor issue in health_status['issues']:\n    print(f\"- {issue['severity']}: {issue['description']}\")\n    if 'suggestion' in issue:\n        print(f\"  Suggestion: {issue['suggestion']}\")\n\n# Check specific components\nbinding_health = health_checker.check_binding_health(SomeService)\nprint(f\"Binding health for SomeService: {binding_health}\")\n\nscope_health = health_checker.check_scope_health()\nprint(f\"Scope health: {scope_health}\")\n</code></pre>"},{"location":"advanced/diagnostics/#diagnostic-commands","title":"\ud83d\udd27 Diagnostic Commands","text":""},{"location":"advanced/diagnostics/#command-line-diagnostics","title":"Command Line Diagnostics","text":"<pre><code># Inspect container state\ninjectq inspect container\n\n# Analyze dependency graph\ninjectq analyze graph --output graph.dot\n\n# Check for circular dependencies\ninjectq check circular\n\n# Monitor performance\ninjectq monitor performance --duration 60\n\n# Generate diagnostic report\ninjectq report --output diagnostics.json\n</code></pre>"},{"location":"advanced/diagnostics/#programmatic-diagnostics","title":"Programmatic Diagnostics","text":"<pre><code>from injectq.diagnostics import DiagnosticRunner\n\nrunner = DiagnosticRunner(container)\n\n# Run all diagnostics\ndiagnostic_report = runner.run_all_diagnostics()\nprint(\"Diagnostic Report:\")\nfor check_name, result in diagnostic_report.items():\n    print(f\"- {check_name}: {result['status']}\")\n    if result['status'] == 'failed':\n        print(f\"  Error: {result['error']}\")\n\n# Run specific diagnostic\ncircular_check = runner.run_diagnostic('circular_dependencies')\nif circular_check['status'] == 'failed':\n    print(\"Circular dependencies found:\")\n    for dep in circular_check['details']:\n        print(f\"- {' -&gt; '.join(cls.__name__ for cls in dep)}\")\n\n# Export diagnostics\nrunner.export_diagnostics('diagnostics_report.json')\n</code></pre>"},{"location":"advanced/diagnostics/#common-diagnostic-scenarios","title":"\ud83c\udfaf Common Diagnostic Scenarios","text":""},{"location":"advanced/diagnostics/#debugging-resolution-failures","title":"Debugging Resolution Failures","text":"<pre><code># Scenario: Service resolution fails\ntry:\n    service = container.get(SomeService)\nexcept Exception as e:\n    # Use error analyzer\n    analyzer = ErrorAnalyzer(container)\n    analysis = analyzer.analyze_error(e)\n\n    print(\"Resolution Failure Analysis:\")\n    print(f\"Error: {analysis['error']}\")\n    print(f\"Root cause: {analysis['root_cause']}\")\n\n    # Check if binding exists\n    if 'missing_binding' in analysis:\n        print(f\"Missing binding for: {analysis['missing_binding']}\")\n        print(\"Suggestion: Add binding with container.bind()\")\n\n    # Check for circular dependencies\n    if 'circular_dependency' in analysis:\n        print(\"Circular dependency detected in chain:\")\n        for cls in analysis['circular_dependency']:\n            print(f\"- {cls.__name__}\")\n\n    # Get suggested fixes\n    for fix in analysis['suggested_fixes']:\n        print(f\"Suggestion: {fix}\")\n</code></pre>"},{"location":"advanced/diagnostics/#performance-issues","title":"Performance Issues","text":"<pre><code># Scenario: Slow dependency resolution\nmonitor = PerformanceMonitor(container)\n\n# Profile the resolution\nwith monitor.monitor_resolution() as monitoring:\n    service = container.get(SomeService)\n\nperformance_data = monitoring.get_data()\n\nif performance_data['total_time'] &gt; 1000:  # More than 1 second\n    print(\"Performance issue detected!\")\n\n    # Find bottlenecks\n    for step in performance_data['steps']:\n        if step['duration'] &gt; 500:  # More than 500ms\n            print(f\"Bottleneck: {step['description']} ({step['duration']}ms)\")\n\n    # Check for optimization opportunities\n    if performance_data['cache_misses'] &gt; performance_data['cache_hits']:\n        print(\"Suggestion: Consider using singleton scope for frequently used dependencies\")\n\n    if performance_data['memory_usage'] &gt; 100 * 1024 * 1024:  # 100MB\n        print(\"Suggestion: Check for memory leaks in dependencies\")\n</code></pre>"},{"location":"advanced/diagnostics/#memory-leaks","title":"Memory Leaks","text":"<pre><code># Scenario: Suspected memory leak\nfrom injectq.diagnostics import MemoryLeakDetector\n\ndetector = MemoryLeakDetector(container)\n\n# Monitor memory usage over time\ndetector.start_monitoring()\n\n# Perform operations that might leak\nfor i in range(1000):\n    service = container.get(SomeService)\n    # Use service...\n\n# Check for leaks\nleak_report = detector.check_for_leaks()\nprint(\"Memory Leak Analysis:\")\nprint(f\"- Memory growth: {leak_report['memory_growth']} bytes\")\nprint(f\"- Potential leaks: {len(leak_report['potential_leaks'])}\")\n\nfor leak in leak_report['potential_leaks']:\n    print(f\"- {leak['type'].__name__}: {leak['instances']} instances\")\n\n# Get recommendations\nrecommendations = detector.get_recommendations()\nfor rec in recommendations:\n    print(f\"Recommendation: {rec}\")\n</code></pre>"},{"location":"advanced/diagnostics/#scope-issues","title":"Scope Issues","text":"<pre><code># Scenario: Scope-related problems\ndebugger = ScopeDebugger(container)\n\n# Check scope state\nscope_status = debugger.get_scope_status()\nprint(\"Scope Status:\")\nfor scope_name, status in scope_status.items():\n    print(f\"- {scope_name}: {status['active_instances']} active, {status['total_created']} total\")\n\n# Detect scope leaks\nleaks = debugger.detect_scope_leaks()\nif leaks:\n    print(\"Scope Leaks Detected:\")\n    for leak in leaks:\n        print(f\"- {leak['scope']}: {leak['count']} leaked instances\")\n        print(f\"  Instances: {[str(inst) for inst in leak['instances']]}\")\n\n# Check for scope conflicts\nconflicts = debugger.detect_scope_conflicts()\nif conflicts:\n    print(\"Scope Conflicts Detected:\")\n    for conflict in conflicts:\n        print(f\"- {conflict['binding']}: requested in {conflict['requested_scope']}, bound in {conflict['bound_scope']}\")\n</code></pre>"},{"location":"advanced/diagnostics/#diagnostic-best-practices","title":"\ud83d\udccb Diagnostic Best Practices","text":""},{"location":"advanced/diagnostics/#good-diagnostic-practices","title":"\u2705 Good Diagnostic Practices","text":""},{"location":"advanced/diagnostics/#1-regular-health-monitoring","title":"1. Regular Health Monitoring","text":"<pre><code>class ApplicationMonitor:\n    \"\"\"Monitor application health continuously.\"\"\"\n\n    def __init__(self, container: InjectQ):\n        self.container = container\n        self.health_checker = HealthChecker(container)\n        self.performance_monitor = PerformanceMonitor(container)\n        self.last_check = None\n\n    async def run_health_check(self):\n        \"\"\"Run comprehensive health check.\"\"\"\n        health_status = await self.health_checker.check_health()\n\n        if health_status['overall_health'] != 'healthy':\n            await self.handle_health_issues(health_status['issues'])\n\n        self.last_check = datetime.now()\n        return health_status\n\n    async def monitor_performance(self):\n        \"\"\"Monitor performance metrics.\"\"\"\n        performance_data = self.performance_monitor.get_performance_report()\n\n        # Check for performance degradation\n        if performance_data['avg_resolution_time'] &gt; 100:  # 100ms threshold\n            await self.handle_performance_issue(performance_data)\n\n        return performance_data\n\n    async def handle_health_issues(self, issues):\n        \"\"\"Handle health check failures.\"\"\"\n        for issue in issues:\n            if issue['severity'] == 'critical':\n                # Log critical issues\n                logger.critical(f\"Critical health issue: {issue['description']}\")\n                # Send alerts\n                await self.send_alert(issue)\n            elif issue['severity'] == 'warning':\n                logger.warning(f\"Health warning: {issue['description']}\")\n\n    async def send_alert(self, issue):\n        \"\"\"Send alert for critical issues.\"\"\"\n        # Implementation depends on your alerting system\n        pass\n\n# Usage\nmonitor = ApplicationMonitor(container)\n\n# Run periodic checks\nasync def monitoring_loop():\n    while True:\n        await monitor.run_health_check()\n        await monitor.monitor_performance()\n        await asyncio.sleep(300)  # Check every 5 minutes\n</code></pre>"},{"location":"advanced/diagnostics/#2-structured-logging","title":"2. Structured Logging","text":"<pre><code>import logging\nfrom injectq.diagnostics import DiagnosticLogger\n\n# Configure diagnostic logging\ndiagnostic_logger = DiagnosticLogger(container)\ndiagnostic_logger.configure_logging(level=logging.DEBUG)\n\n# Log diagnostic events\nwith diagnostic_logger.log_resolution(SomeService):\n    service = container.get(SomeService)\n\n# Log errors with context\ntry:\n    complex_service = container.get(ComplexService)\nexcept Exception as e:\n    diagnostic_logger.log_error_with_context(e, {\n        'operation': 'service_resolution',\n        'service_type': 'ComplexService',\n        'container_state': container.get_state_summary()\n    })\n\n# Custom diagnostic logging\nclass CustomDiagnosticLogger:\n    def __init__(self, container):\n        self.container = container\n        self.logger = logging.getLogger('injectq.diagnostics')\n\n    def log_resolution_start(self, service_type):\n        self.logger.info(f\"Starting resolution of {service_type.__name__}\")\n\n    def log_resolution_success(self, service_type, duration):\n        self.logger.info(f\"Successfully resolved {service_type.__name__} in {duration}ms\")\n\n    def log_resolution_failure(self, service_type, error):\n        self.logger.error(f\"Failed to resolve {service_type.__name__}: {error}\")\n\n# Usage\ncustom_logger = CustomDiagnosticLogger(container)\ncustom_logger.log_resolution_start(SomeService)\ntry:\n    service = container.get(SomeService)\n    custom_logger.log_resolution_success(SomeService, 150)\nexcept Exception as e:\n    custom_logger.log_resolution_failure(SomeService, e)\n</code></pre>"},{"location":"advanced/diagnostics/#3-diagnostic-dashboards","title":"3. Diagnostic Dashboards","text":"<pre><code>from injectq.diagnostics import DiagnosticDashboard\n\n# Create diagnostic dashboard\ndashboard = DiagnosticDashboard(container)\n\n# Generate HTML dashboard\nhtml_report = dashboard.generate_html_report()\nwith open('diagnostics_dashboard.html', 'w') as f:\n    f.write(html_report)\n\n# Generate JSON report for monitoring systems\njson_report = dashboard.generate_json_report()\nwith open('diagnostics_report.json', 'w') as f:\n    f.write(json.dumps(json_report, indent=2))\n\n# Real-time monitoring dashboard\nclass RealTimeDashboard:\n    def __init__(self, container):\n        self.container = container\n        self.metrics = ContainerMetrics(container)\n        self.last_update = None\n\n    def update_dashboard(self):\n        \"\"\"Update dashboard with latest metrics.\"\"\"\n        current_metrics = self.metrics.collect_metrics()\n\n        # Update display\n        self.display_metrics(current_metrics)\n\n        # Check for alerts\n        self.check_alerts(current_metrics)\n\n        self.last_update = datetime.now()\n\n    def display_metrics(self, metrics):\n        \"\"\"Display metrics in console or web interface.\"\"\"\n        print(\"\n=== InjectQ Diagnostic Dashboard ===\")\n        print(f\"Timestamp: {datetime.now()}\")\n        print(f\"Bindings: {metrics['bindings_count']}\")\n        print(f\"Resolutions: {metrics['resolutions_count']}\")\n        print(f\"Memory Usage: {metrics['memory_usage']} bytes\")\n        print(f\"Cache Hit Rate: {metrics['cache_hit_rate']}%\")\n        print(\"=\" * 40)\n\n    def check_alerts(self, metrics):\n        \"\"\"Check for alert conditions.\"\"\"\n        if metrics['memory_usage'] &gt; 500 * 1024 * 1024:  # 500MB\n            print(\"\u26a0\ufe0f  High memory usage detected!\")\n\n        if metrics['cache_hit_rate'] &lt; 50:\n            print(\"\u26a0\ufe0f  Low cache hit rate detected!\")\n\n# Usage\nrt_dashboard = RealTimeDashboard(container)\n\n# Update every 30 seconds\ndef monitoring_loop():\n    while True:\n        rt_dashboard.update_dashboard()\n        time.sleep(30)\n</code></pre>"},{"location":"advanced/diagnostics/#common-diagnostic-mistakes","title":"\u274c Common Diagnostic Mistakes","text":""},{"location":"advanced/diagnostics/#1-over-diagnostics","title":"1. Over-Diagnostics","text":"<pre><code># \u274c Bad: Too much diagnostic overhead\nclass OverDiagnosticContainer:\n    def __init__(self):\n        self.container = InjectQ()\n        # Too many monitors\n        self.performance_monitor = PerformanceMonitor(self.container)\n        self.memory_monitor = MemoryLeakDetector(self.container)\n        self.scope_monitor = ScopeDebugger(self.container)\n        self.health_monitor = HealthChecker(self.container)\n        # And more...\n\n    def get_service(self, service_type):\n        # Every resolution triggers all diagnostics\n        with self.performance_monitor.monitor_resolution():\n            with self.memory_monitor.monitor_memory():\n                with self.scope_monitor.debug_scope():\n                    return self.container.get(service_type)\n\n# \u2705 Good: Selective diagnostics\nclass SelectiveDiagnostics:\n    def __init__(self, enable_diagnostics=False):\n        self.container = InjectQ()\n        self.enable_diagnostics = enable_diagnostics\n\n        if enable_diagnostics:\n            self.monitor = PerformanceMonitor(self.container)\n\n    def get_service(self, service_type):\n        if self.enable_diagnostics:\n            with self.monitor.monitor_resolution():\n                return self.container.get(service_type)\n        else:\n            return self.container.get(service_type)\n</code></pre>"},{"location":"advanced/diagnostics/#2-ignoring-diagnostic-data","title":"2. Ignoring Diagnostic Data","text":"<pre><code># \u274c Bad: Collecting but not using diagnostics\nmonitor = PerformanceMonitor(container)\n\n# Collect data but never analyze it\nfor i in range(1000):\n    with monitor.monitor_resolution():\n        service = container.get(SomeService)\n\n# Data collected but never used\nperformance_data = monitor.get_performance_report()\n# Just print it and forget\nprint(performance_data)\n\n# \u2705 Good: Actionable diagnostics\nclass ActionableDiagnostics:\n    def __init__(self, container):\n        self.container = container\n        self.monitor = PerformanceMonitor(container)\n        self.baseline_performance = None\n\n    def establish_baseline(self):\n        \"\"\"Establish performance baseline.\"\"\"\n        # Run several resolutions to establish baseline\n        times = []\n        for _ in range(10):\n            with self.monitor.monitor_resolution() as m:\n                self.container.get(SomeService)\n            times.append(m.get_data()['total_time'])\n\n        self.baseline_performance = sum(times) / len(times)\n\n    def monitor_and_act(self):\n        \"\"\"Monitor and take action if needed.\"\"\"\n        with self.monitor.monitor_resolution() as m:\n            service = self.container.get(SomeService)\n\n        current_time = m.get_data()['total_time']\n\n        if current_time &gt; self.baseline_performance * 2:  # 2x slower\n            self.handle_performance_degradation(current_time)\n\n    def handle_performance_degradation(self, current_time):\n        \"\"\"Handle performance issues.\"\"\"\n        print(f\"Performance degradation detected: {current_time}ms (baseline: {self.baseline_performance}ms)\")\n\n        # Take action: clear caches, restart services, etc.\n        self.container.clear_caches()\n        print(\"Caches cleared to improve performance\")\n</code></pre>"},{"location":"advanced/diagnostics/#summary","title":"\ud83c\udfaf Summary","text":"<p>Diagnostics provide comprehensive tools for monitoring and debugging:</p> <ul> <li>Container inspection - Examine container state and bindings</li> <li>Dependency graph analysis - Find circular dependencies and optimization opportunities</li> <li>Performance monitoring - Track resolution times and memory usage</li> <li>Resolution tracing - Debug dependency resolution issues</li> <li>Error analysis - Understand and fix resolution failures</li> <li>Scope debugging - Detect scope leaks and conflicts</li> <li>Health checks - Monitor overall system health</li> </ul> <p>Key features: - Real-time monitoring and alerting - Performance profiling and optimization - Memory leak detection - Structured logging and reporting - Command-line diagnostic tools - Programmatic diagnostic APIs</p> <p>Best practices: - Regular health monitoring - Structured diagnostic logging - Actionable diagnostic data - Selective diagnostic overhead - Real-time dashboards and alerts</p> <p>Common scenarios: - Debugging resolution failures - Performance issue diagnosis - Memory leak detection - Scope problem identification - Health monitoring and alerting</p> <p>Ready to explore performance optimization?</p>"},{"location":"advanced/middleware/","title":"Middleware","text":"<p>InjectQ's middleware system allows you to intercept and modify the dependency injection process, providing powerful extension points for logging, validation, caching, and more.</p>"},{"location":"advanced/middleware/#understanding-middleware","title":"Understanding Middleware","text":""},{"location":"advanced/middleware/#middleware-concept","title":"Middleware Concept","text":"<p>Middleware in InjectQ works similarly to web framework middleware, creating a pipeline where each middleware can:</p> <ul> <li>Intercept service resolution requests</li> <li>Modify or validate dependencies</li> <li>Add cross-cutting concerns like logging or caching</li> <li>Handle errors and provide fallbacks</li> </ul> <pre><code>from abc import ABC, abstractmethod\nfrom typing import Any, Type, Callable, Optional\nimport time\nimport logging\n\nclass DIMiddleware(ABC):\n    \"\"\"Base class for dependency injection middleware.\"\"\"\n\n    @abstractmethod\n    async def process_resolution(\n        self, \n        service_type: Type,\n        next_resolver: Callable[[Type], Any]\n    ) -&gt; Any:\n        \"\"\"Process service resolution with next resolver in chain.\"\"\"\n        pass\n\n    def process_registration(\n        self,\n        service_type: Type,\n        implementation: Any,\n        next_registrar: Callable[[Type, Any], None]\n    ) -&gt; None:\n        \"\"\"Process service registration (optional).\"\"\"\n        next_registrar(service_type, implementation)\n\nclass MiddlewarePipeline:\n    \"\"\"Pipeline for executing middleware in order.\"\"\"\n\n    def __init__(self):\n        self._middleware: List[DIMiddleware] = []\n\n    def add_middleware(self, middleware: DIMiddleware):\n        \"\"\"Add middleware to pipeline.\"\"\"\n        self._middleware.append(middleware)\n\n    async def execute_resolution(self, service_type: Type, final_resolver: Callable[[Type], Any]) -&gt; Any:\n        \"\"\"Execute resolution pipeline.\"\"\"\n        if not self._middleware:\n            return final_resolver(service_type)\n\n        # Create middleware chain\n        async def create_chain(index: int):\n            if index &gt;= len(self._middleware):\n                return final_resolver\n\n            middleware = self._middleware[index]\n            next_resolver = await create_chain(index + 1)\n\n            return lambda st: middleware.process_resolution(st, next_resolver)\n\n        chain = await create_chain(0)\n        return await chain(service_type)\n</code></pre>"},{"location":"advanced/middleware/#built-in-middleware","title":"Built-in Middleware","text":""},{"location":"advanced/middleware/#logging-middleware","title":"Logging Middleware","text":"<pre><code>class LoggingMiddleware(DIMiddleware):\n    \"\"\"Middleware for logging service resolution.\"\"\"\n\n    def __init__(self, logger: Optional[logging.Logger] = None):\n        self.logger = logger or logging.getLogger(__name__)\n\n    async def process_resolution(self, service_type: Type, next_resolver: Callable) -&gt; Any:\n        \"\"\"Log service resolution.\"\"\"\n        start_time = time.time()\n        service_name = service_type.__name__\n\n        self.logger.debug(f\"Resolving service: {service_name}\")\n\n        try:\n            result = await next_resolver(service_type)\n            resolution_time = (time.time() - start_time) * 1000\n\n            self.logger.info(\n                f\"\u2705 Resolved {service_name} in {resolution_time:.2f}ms\"\n            )\n\n            return result\n\n        except Exception as e:\n            resolution_time = (time.time() - start_time) * 1000\n\n            self.logger.error(\n                f\"\u274c Failed to resolve {service_name} in {resolution_time:.2f}ms: {e}\"\n            )\n\n            raise\n\n# Usage\nlogging_middleware = LoggingMiddleware()\ncontainer.add_middleware(logging_middleware)\n\n@inject\ndef test_service(user_service: UserService):\n    return user_service.get_all_users()\n\n# Will log: \"Resolving service: UserService\" and \"\u2705 Resolved UserService in 2.34ms\"\n</code></pre>"},{"location":"advanced/middleware/#caching-middleware","title":"Caching Middleware","text":"<pre><code>from typing import Dict, Any\nimport hashlib\nimport pickle\n\nclass CachingMiddleware(DIMiddleware):\n    \"\"\"Middleware for caching service instances.\"\"\"\n\n    def __init__(self, cache_singletons: bool = True, cache_transients: bool = False):\n        self.cache_singletons = cache_singletons\n        self.cache_transients = cache_transients\n        self._cache: Dict[str, Any] = {}\n\n    async def process_resolution(self, service_type: Type, next_resolver: Callable) -&gt; Any:\n        \"\"\"Cache service resolution based on type and configuration.\"\"\"\n        # Generate cache key\n        cache_key = self._generate_cache_key(service_type)\n\n        # Check cache\n        if cache_key in self._cache:\n            cached_instance = self._cache[cache_key]\n            print(f\"\ud83d\udce6 Cache hit for {service_type.__name__}\")\n            return cached_instance\n\n        # Resolve service\n        instance = await next_resolver(service_type)\n\n        # Cache based on scope\n        should_cache = self._should_cache_service(service_type)\n\n        if should_cache:\n            self._cache[cache_key] = instance\n            print(f\"\ud83d\udcbe Cached {service_type.__name__}\")\n\n        return instance\n\n    def _generate_cache_key(self, service_type: Type) -&gt; str:\n        \"\"\"Generate cache key for service type.\"\"\"\n        return f\"{service_type.__module__}.{service_type.__name__}\"\n\n    def _should_cache_service(self, service_type: Type) -&gt; bool:\n        \"\"\"Determine if service should be cached.\"\"\"\n        # This would check service registration scope\n        # Simplified implementation\n        return self.cache_singletons  # or check actual scope\n\n    def clear_cache(self):\n        \"\"\"Clear all cached instances.\"\"\"\n        self._cache.clear()\n\n    def remove_from_cache(self, service_type: Type):\n        \"\"\"Remove specific service from cache.\"\"\"\n        cache_key = self._generate_cache_key(service_type)\n        self._cache.pop(cache_key, None)\n\n# Usage\ncaching_middleware = CachingMiddleware(cache_singletons=True)\ncontainer.add_middleware(caching_middleware)\n</code></pre>"},{"location":"advanced/middleware/#validation-middleware","title":"Validation Middleware","text":"<pre><code>import inspect\nfrom typing import get_type_hints\n\nclass ValidationMiddleware(DIMiddleware):\n    \"\"\"Middleware for validating service resolution.\"\"\"\n\n    def __init__(self, strict_mode: bool = False):\n        self.strict_mode = strict_mode\n\n    async def process_resolution(self, service_type: Type, next_resolver: Callable) -&gt; Any:\n        \"\"\"Validate service resolution.\"\"\"\n        # Pre-resolution validation\n        self._validate_service_type(service_type)\n\n        try:\n            instance = await next_resolver(service_type)\n\n            # Post-resolution validation\n            self._validate_instance(service_type, instance)\n\n            return instance\n\n        except Exception as e:\n            self._handle_resolution_error(service_type, e)\n            raise\n\n    def _validate_service_type(self, service_type: Type):\n        \"\"\"Validate service type before resolution.\"\"\"\n        if not inspect.isclass(service_type):\n            raise ValueError(f\"Service type must be a class, got {type(service_type)}\")\n\n        # Check for common issues\n        if hasattr(service_type, '__abstractmethods__') and service_type.__abstractmethods__:\n            if self.strict_mode:\n                raise ValueError(f\"Cannot resolve abstract class {service_type.__name__}\")\n\n    def _validate_instance(self, service_type: Type, instance: Any):\n        \"\"\"Validate resolved instance.\"\"\"\n        if not isinstance(instance, service_type):\n            if self.strict_mode:\n                raise TypeError(\n                    f\"Resolved instance is not of type {service_type.__name__}, \"\n                    f\"got {type(instance).__name__}\"\n                )\n\n    def _handle_resolution_error(self, service_type: Type, error: Exception):\n        \"\"\"Handle resolution errors.\"\"\"\n        if isinstance(error, (TypeError, ValueError)):\n            # Add context to error\n            error.add_note(f\"Error occurred while resolving {service_type.__name__}\")\n\n# Usage\nvalidation_middleware = ValidationMiddleware(strict_mode=True)\ncontainer.add_middleware(validation_middleware)\n</code></pre>"},{"location":"advanced/middleware/#performance-monitoring-middleware","title":"Performance Monitoring Middleware","text":"<pre><code>from dataclasses import dataclass\nfrom typing import Dict, List\nimport statistics\n\n@dataclass\nclass PerformanceMetrics:\n    \"\"\"Performance metrics for service resolution.\"\"\"\n    service_name: str\n    resolution_count: int\n    total_time_ms: float\n    avg_time_ms: float\n    min_time_ms: float\n    max_time_ms: float\n\n    def __str__(self):\n        return (\n            f\"{self.service_name}: \"\n            f\"count={self.resolution_count}, \"\n            f\"avg={self.avg_time_ms:.2f}ms, \"\n            f\"min={self.min_time_ms:.2f}ms, \"\n            f\"max={self.max_time_ms:.2f}ms\"\n        )\n\nclass PerformanceMonitoringMiddleware(DIMiddleware):\n    \"\"\"Middleware for monitoring service resolution performance.\"\"\"\n\n    def __init__(self):\n        self._metrics: Dict[str, List[float]] = {}\n\n    async def process_resolution(self, service_type: Type, next_resolver: Callable) -&gt; Any:\n        \"\"\"Monitor service resolution performance.\"\"\"\n        service_name = service_type.__name__\n        start_time = time.time()\n\n        try:\n            result = await next_resolver(service_type)\n\n            # Record timing\n            resolution_time = (time.time() - start_time) * 1000\n            self._record_timing(service_name, resolution_time)\n\n            return result\n\n        except Exception as e:\n            # Still record timing for failed resolutions\n            resolution_time = (time.time() - start_time) * 1000\n            self._record_timing(service_name, resolution_time)\n            raise\n\n    def _record_timing(self, service_name: str, time_ms: float):\n        \"\"\"Record timing for service.\"\"\"\n        if service_name not in self._metrics:\n            self._metrics[service_name] = []\n\n        self._metrics[service_name].append(time_ms)\n\n        # Keep only last 100 measurements\n        if len(self._metrics[service_name]) &gt; 100:\n            self._metrics[service_name].pop(0)\n\n    def get_metrics(self, service_name: str = None) -&gt; Dict[str, PerformanceMetrics]:\n        \"\"\"Get performance metrics.\"\"\"\n        if service_name:\n            if service_name in self._metrics:\n                return {service_name: self._calculate_metrics(service_name)}\n            return {}\n\n        return {\n            name: self._calculate_metrics(name)\n            for name in self._metrics.keys()\n        }\n\n    def _calculate_metrics(self, service_name: str) -&gt; PerformanceMetrics:\n        \"\"\"Calculate metrics for a service.\"\"\"\n        times = self._metrics[service_name]\n\n        return PerformanceMetrics(\n            service_name=service_name,\n            resolution_count=len(times),\n            total_time_ms=sum(times),\n            avg_time_ms=statistics.mean(times),\n            min_time_ms=min(times),\n            max_time_ms=max(times)\n        )\n\n    def print_report(self):\n        \"\"\"Print performance report.\"\"\"\n        print(\"Performance Report:\")\n        print(\"=\" * 50)\n\n        for metrics in self.get_metrics().values():\n            print(metrics)\n\n    def get_slow_services(self, threshold_ms: float = 100.0) -&gt; List[PerformanceMetrics]:\n        \"\"\"Get services with slow average resolution times.\"\"\"\n        slow_services = []\n\n        for metrics in self.get_metrics().values():\n            if metrics.avg_time_ms &gt; threshold_ms:\n                slow_services.append(metrics)\n\n        return sorted(slow_services, key=lambda m: m.avg_time_ms, reverse=True)\n\n# Usage\nperf_middleware = PerformanceMonitoringMiddleware()\ncontainer.add_middleware(perf_middleware)\n\n# After some service resolutions\nperf_middleware.print_report()\n</code></pre>"},{"location":"advanced/middleware/#custom-middleware","title":"Custom Middleware","text":""},{"location":"advanced/middleware/#authentication-middleware","title":"Authentication Middleware","text":"<pre><code>from contextvars import ContextVar\nfrom typing import Optional\n\n# Context variable for current user\ncurrent_user: ContextVar[Optional[str]] = ContextVar('current_user', default=None)\n\nclass AuthenticationMiddleware(DIMiddleware):\n    \"\"\"Middleware for authentication-aware service resolution.\"\"\"\n\n    def __init__(self):\n        self._secure_services = set()\n\n    def require_authentication(self, service_type: Type):\n        \"\"\"Mark service as requiring authentication.\"\"\"\n        self._secure_services.add(service_type)\n\n    async def process_resolution(self, service_type: Type, next_resolver: Callable) -&gt; Any:\n        \"\"\"Check authentication before resolving secure services.\"\"\"\n        # Check if service requires authentication\n        if service_type in self._secure_services:\n            user = current_user.get()\n\n            if not user:\n                raise PermissionError(\n                    f\"Authentication required to access {service_type.__name__}\"\n                )\n\n        # Resolve service\n        instance = await next_resolver(service_type)\n\n        # Add user context to instance if it supports it\n        if hasattr(instance, 'set_current_user'):\n            instance.set_current_user(current_user.get())\n\n        return instance\n\n# Usage\nauth_middleware = AuthenticationMiddleware()\nauth_middleware.require_authentication(AdminService)\nauth_middleware.require_authentication(BillingService)\n\ncontainer.add_middleware(auth_middleware)\n\n# Set user context\ncurrent_user.set(\"john_doe\")\n\n@inject\ndef admin_operation(admin_service: AdminService):\n    return admin_service.get_system_info()\n</code></pre>"},{"location":"advanced/middleware/#circuit-breaker-middleware","title":"Circuit Breaker Middleware","text":"<pre><code>from enum import Enum\nimport time\n\nclass CircuitState(Enum):\n    CLOSED = \"closed\"      # Normal operation\n    OPEN = \"open\"          # Failing, reject requests\n    HALF_OPEN = \"half_open\"  # Testing if service recovered\n\nclass CircuitBreaker:\n    \"\"\"Circuit breaker for service resolution.\"\"\"\n\n    def __init__(self, failure_threshold: int = 5, timeout: float = 60.0):\n        self.failure_threshold = failure_threshold\n        self.timeout = timeout\n        self.failure_count = 0\n        self.last_failure_time = 0\n        self.state = CircuitState.CLOSED\n\n    def call(self, func, *args, **kwargs):\n        \"\"\"Execute function with circuit breaker protection.\"\"\"\n        if self.state == CircuitState.OPEN:\n            if time.time() - self.last_failure_time &gt; self.timeout:\n                self.state = CircuitState.HALF_OPEN\n            else:\n                raise Exception(f\"Circuit breaker is OPEN for {func}\")\n\n        try:\n            result = func(*args, **kwargs)\n\n            # Success - reset if in half-open state\n            if self.state == CircuitState.HALF_OPEN:\n                self.state = CircuitState.CLOSED\n                self.failure_count = 0\n\n            return result\n\n        except Exception as e:\n            self._handle_failure()\n            raise\n\n    def _handle_failure(self):\n        \"\"\"Handle failure and update circuit state.\"\"\"\n        self.failure_count += 1\n        self.last_failure_time = time.time()\n\n        if self.failure_count &gt;= self.failure_threshold:\n            self.state = CircuitState.OPEN\n\nclass CircuitBreakerMiddleware(DIMiddleware):\n    \"\"\"Middleware implementing circuit breaker pattern.\"\"\"\n\n    def __init__(self):\n        self._circuit_breakers: Dict[Type, CircuitBreaker] = {}\n\n    def add_circuit_breaker(self, service_type: Type, **kwargs):\n        \"\"\"Add circuit breaker for service type.\"\"\"\n        self._circuit_breakers[service_type] = CircuitBreaker(**kwargs)\n\n    async def process_resolution(self, service_type: Type, next_resolver: Callable) -&gt; Any:\n        \"\"\"Resolve service with circuit breaker protection.\"\"\"\n        if service_type in self._circuit_breakers:\n            circuit_breaker = self._circuit_breakers[service_type]\n            return circuit_breaker.call(next_resolver, service_type)\n        else:\n            return await next_resolver(service_type)\n\n# Usage\ncircuit_middleware = CircuitBreakerMiddleware()\ncircuit_middleware.add_circuit_breaker(ExternalApiService, failure_threshold=3, timeout=30.0)\n\ncontainer.add_middleware(circuit_middleware)\n</code></pre>"},{"location":"advanced/middleware/#retry-middleware","title":"Retry Middleware","text":"<pre><code>import asyncio\nfrom typing import List, Type as TypingType\n\nclass RetryConfig:\n    \"\"\"Configuration for retry behavior.\"\"\"\n\n    def __init__(\n        self,\n        max_attempts: int = 3,\n        delay: float = 1.0,\n        backoff_factor: float = 2.0,\n        retry_exceptions: List[TypingType[Exception]] = None\n    ):\n        self.max_attempts = max_attempts\n        self.delay = delay\n        self.backoff_factor = backoff_factor\n        self.retry_exceptions = retry_exceptions or [Exception]\n\nclass RetryMiddleware(DIMiddleware):\n    \"\"\"Middleware for retrying failed service resolutions.\"\"\"\n\n    def __init__(self):\n        self._retry_configs: Dict[Type, RetryConfig] = {}\n        self._default_config = RetryConfig()\n\n    def configure_retry(self, service_type: Type, config: RetryConfig):\n        \"\"\"Configure retry behavior for service type.\"\"\"\n        self._retry_configs[service_type] = config\n\n    async def process_resolution(self, service_type: Type, next_resolver: Callable) -&gt; Any:\n        \"\"\"Resolve service with retry logic.\"\"\"\n        config = self._retry_configs.get(service_type, self._default_config)\n\n        last_exception = None\n        delay = config.delay\n\n        for attempt in range(config.max_attempts):\n            try:\n                return await next_resolver(service_type)\n\n            except Exception as e:\n                last_exception = e\n\n                # Check if exception is retryable\n                if not any(isinstance(e, exc_type) for exc_type in config.retry_exceptions):\n                    raise\n\n                # Don't sleep on last attempt\n                if attempt &lt; config.max_attempts - 1:\n                    print(f\"Retry attempt {attempt + 1} for {service_type.__name__} after {delay}s\")\n                    await asyncio.sleep(delay)\n                    delay *= config.backoff_factor\n\n        # All retries exhausted\n        raise Exception(\n            f\"Failed to resolve {service_type.__name__} after {config.max_attempts} attempts\"\n        ) from last_exception\n\n# Usage\nretry_middleware = RetryMiddleware()\n\n# Configure retry for specific service\nretry_config = RetryConfig(\n    max_attempts=5,\n    delay=0.5,\n    backoff_factor=2.0,\n    retry_exceptions=[ConnectionError, TimeoutError]\n)\nretry_middleware.configure_retry(DatabaseService, retry_config)\n\ncontainer.add_middleware(retry_middleware)\n</code></pre>"},{"location":"advanced/middleware/#middleware-composition","title":"Middleware Composition","text":""},{"location":"advanced/middleware/#middleware-chain","title":"Middleware Chain","text":"<pre><code>class MiddlewareChain:\n    \"\"\"Manages a chain of middleware with ordering and dependencies.\"\"\"\n\n    def __init__(self):\n        self._middleware: List[DIMiddleware] = []\n        self._middleware_order: Dict[str, int] = {}\n\n    def add_middleware(\n        self,\n        middleware: DIMiddleware,\n        name: str = None,\n        before: str = None,\n        after: str = None,\n        priority: int = 50\n    ):\n        \"\"\"Add middleware with ordering constraints.\"\"\"\n        if name is None:\n            name = middleware.__class__.__name__\n\n        # Handle ordering\n        if before:\n            if before in self._middleware_order:\n                priority = self._middleware_order[before] - 1\n        elif after:\n            if after in self._middleware_order:\n                priority = self._middleware_order[after] + 1\n\n        # Store middleware with priority\n        self._middleware_order[name] = priority\n\n        # Insert middleware in correct position\n        inserted = False\n        for i, existing_middleware in enumerate(self._middleware):\n            existing_name = existing_middleware.__class__.__name__\n            existing_priority = self._middleware_order.get(existing_name, 50)\n\n            if priority &lt; existing_priority:\n                self._middleware.insert(i, middleware)\n                inserted = True\n                break\n\n        if not inserted:\n            self._middleware.append(middleware)\n\n    def get_ordered_middleware(self) -&gt; List[DIMiddleware]:\n        \"\"\"Get middleware in execution order.\"\"\"\n        return self._middleware.copy()\n\n# Usage\nchain = MiddlewareChain()\n\n# Add middleware with specific ordering\nchain.add_middleware(AuthenticationMiddleware(), \"auth\", priority=10)\nchain.add_middleware(LoggingMiddleware(), \"logging\", after=\"auth\")\nchain.add_middleware(ValidationMiddleware(), \"validation\", before=\"logging\")\nchain.add_middleware(CachingMiddleware(), \"caching\", priority=90)\n\n# Execution order: auth -&gt; validation -&gt; logging -&gt; caching\n</code></pre>"},{"location":"advanced/middleware/#conditional-middleware","title":"Conditional Middleware","text":"<pre><code>from typing import Callable\n\nclass ConditionalMiddleware(DIMiddleware):\n    \"\"\"Middleware that executes conditionally.\"\"\"\n\n    def __init__(\n        self,\n        middleware: DIMiddleware,\n        condition: Callable[[Type], bool]\n    ):\n        self.middleware = middleware\n        self.condition = condition\n\n    async def process_resolution(self, service_type: Type, next_resolver: Callable) -&gt; Any:\n        \"\"\"Execute middleware conditionally.\"\"\"\n        if self.condition(service_type):\n            return await self.middleware.process_resolution(service_type, next_resolver)\n        else:\n            return await next_resolver(service_type)\n\n# Usage: Only cache singleton services\ndef is_singleton_service(service_type: Type) -&gt; bool:\n    # Check if service is registered as singleton\n    binding = container._registry.get_binding(service_type)\n    return binding and binding.scope == Scope.SINGLETON\n\nconditional_caching = ConditionalMiddleware(\n    CachingMiddleware(),\n    is_singleton_service\n)\n\ncontainer.add_middleware(conditional_caching)\n</code></pre>"},{"location":"advanced/middleware/#integration-with-container","title":"Integration with Container","text":""},{"location":"advanced/middleware/#container-with-middleware-support","title":"Container with Middleware Support","text":"<pre><code>class MiddlewareContainer(Container):\n    \"\"\"Container with middleware support.\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self._middleware_pipeline = MiddlewarePipeline()\n\n    def add_middleware(self, middleware: DIMiddleware):\n        \"\"\"Add middleware to container.\"\"\"\n        self._middleware_pipeline.add_middleware(middleware)\n\n    async def resolve(self, service_type: Type) -&gt; Any:\n        \"\"\"Resolve service through middleware pipeline.\"\"\"\n        return await self._middleware_pipeline.execute_resolution(\n            service_type,\n            super().resolve\n        )\n\n    def resolve_sync(self, service_type: Type) -&gt; Any:\n        \"\"\"Synchronous resolve (runs async pipeline in event loop).\"\"\"\n        import asyncio\n\n        try:\n            loop = asyncio.get_event_loop()\n        except RuntimeError:\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n\n        return loop.run_until_complete(self.resolve(service_type))\n\n# Factory function to create container with common middleware\ndef create_container_with_middleware() -&gt; MiddlewareContainer:\n    \"\"\"Create container with standard middleware stack.\"\"\"\n    container = MiddlewareContainer()\n\n    # Add standard middleware in order\n    container.add_middleware(AuthenticationMiddleware())\n    container.add_middleware(ValidationMiddleware())\n    container.add_middleware(LoggingMiddleware())\n    container.add_middleware(PerformanceMonitoringMiddleware())\n    container.add_middleware(CachingMiddleware())\n\n    return container\n\n# Usage\ncontainer = create_container_with_middleware()\n</code></pre> <p>This comprehensive middleware documentation shows how to extend InjectQ's capabilities through interception and modification of the dependency injection process, providing powerful extension points for cross-cutting concerns.</p>"},{"location":"advanced/overview/","title":"Advanced Features","text":"<p>Advanced features provide powerful capabilities for complex dependency injection scenarios, including resource management, diagnostics, performance optimization, and thread safety.</p>"},{"location":"advanced/overview/#overview","title":"\ud83c\udfaf Overview","text":"<p>InjectQ's advanced features help you:</p> <ul> <li>Manage resources - Automatic cleanup and lifecycle management</li> <li>Diagnose issues - Debug dependency resolution and detect problems</li> <li>Optimize performance - Lazy loading, caching, and efficient resolution</li> <li>Ensure thread safety - Safe concurrent dependency injection</li> <li>Handle circular dependencies - Detect and resolve dependency cycles</li> <li>Profile performance - Monitor and analyze DI performance</li> </ul>"},{"location":"advanced/overview/#advanced-features-categories","title":"Advanced Features Categories","text":"<pre><code># Resource Management\n@injectq.resource\nclass DatabaseConnection:\n    def __init__(self):\n        self.connection = None\n\n    async def initialize(self):\n        self.connection = await create_connection()\n\n    async def cleanup(self):\n        if self.connection:\n            await self.connection.close()\n\n# Diagnostics\ncontainer = InjectQ()\ncontainer.enable_diagnostics()\n\n# Analyze dependency graph\ngraph = container.analyze_dependencies()\nprint(f\"Circular dependencies: {graph.cycles}\")\n\n# Performance Optimization\n@injectq.lazy\nclass ExpensiveService:\n    def __init__(self):\n        # Heavy initialization\n        time.sleep(1)\n\n# Thread Safety\ncontainer = ThreadSafeContainer()\n# Safe for concurrent access\n</code></pre>"},{"location":"advanced/overview/#advanced-features-structure","title":"\ud83d\udcc1 Advanced Features Structure","text":"<p>This section covers:</p> <ul> <li>Resource Management - Automatic resource lifecycle management</li> <li>Diagnostics - Debugging and dependency analysis tools</li> <li>Performance Optimization - Lazy loading, caching, and optimization techniques</li> <li>Thread Safety - Concurrent access and synchronization</li> <li>Circular Dependencies - Detection and resolution strategies</li> <li>Profiling - Performance monitoring and analysis</li> </ul>"},{"location":"advanced/overview/#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"advanced/overview/#basic-resource-management","title":"Basic Resource Management","text":"<pre><code>from injectq import resource, InjectQ\n\n@resource\nclass DatabasePool:\n    def __init__(self):\n        self.pool = None\n\n    async def initialize(self):\n        self.pool = await create_database_pool()\n\n    async def dispose(self):\n        if self.pool:\n            await self.pool.close()\n\ndef main():\n    container = InjectQ()\n    container.bind(DatabasePool, DatabasePool())\n\n    # Use container\n    async with container:\n        db_pool = container.get(DatabasePool)\n        # Resource automatically managed\n</code></pre>"},{"location":"advanced/overview/#basic-diagnostics","title":"Basic Diagnostics","text":"<pre><code>container = InjectQ()\ncontainer.enable_diagnostics()\n\n# Bind services\ncontainer.bind(IService, Service())\n\n# Analyze dependencies\nreport = container.generate_diagnostic_report()\nprint(report)\n\n# Output:\n# Dependency Graph Analysis:\n# - Total services: 5\n# - Circular dependencies: 0\n# - Resolution time: 0.002s\n# - Memory usage: 1.2MB\n</code></pre>"},{"location":"advanced/overview/#basic-performance-optimization","title":"Basic Performance Optimization","text":"<pre><code>from injectq import lazy, cached\n\n@lazy\nclass ExpensiveService:\n    def __init__(self):\n        # Heavy initialization - only when first accessed\n        self.data = load_large_dataset()\n\n@cached\nclass ComputationService:\n    def heavy_calculation(self, input_data):\n        # Result cached for same input\n        return perform_expensive_calculation(input_data)\n\ncontainer = InjectQ()\ncontainer.bind(ExpensiveService, ExpensiveService())\ncontainer.bind(ComputationService, ComputationService())\n\n# First access triggers initialization\nservice = container.get(ExpensiveService)  # Lazy loading\n\n# Subsequent calls use cached result\nresult1 = container.get(ComputationService).heavy_calculation(data)\nresult2 = container.get(ComputationService).heavy_calculation(data)\nassert result1 is result2  # Cached\n</code></pre>"},{"location":"advanced/overview/#advanced-patterns","title":"\ud83c\udfa8 Advanced Patterns","text":""},{"location":"advanced/overview/#resource-lifecycle-management","title":"Resource Lifecycle Management","text":"<pre><code>@resource\nclass ConnectionManager:\n    def __init__(self, config: DatabaseConfig):\n        self.config = config\n        self.connections = {}\n\n    async def get_connection(self, name: str):\n        if name not in self.connections:\n            self.connections[name] = await create_connection(self.config)\n        return self.connections[name]\n\n    async def dispose(self):\n        for conn in self.connections.values():\n            await conn.close()\n        self.connections.clear()\n\n# Usage with automatic cleanup\nasync def handle_request(container):\n    conn_manager = container.get(ConnectionManager)\n\n    async with container.resource_scope():\n        conn = await conn_manager.get_connection(\"main\")\n        # Connection automatically returned to pool on scope exit\n</code></pre>"},{"location":"advanced/overview/#diagnostic-monitoring","title":"Diagnostic Monitoring","text":"<pre><code>container = InjectQ()\ncontainer.enable_diagnostics()\n\n# Monitor resolution performance\nwith container.monitor_resolution():\n    service = container.get(IService)\n\n# Get performance metrics\nmetrics = container.get_resolution_metrics()\nprint(f\"Average resolution time: {metrics.avg_time}\")\nprint(f\"Peak memory usage: {metrics.peak_memory}\")\nprint(f\"Cache hit rate: {metrics.cache_hit_rate}\")\n\n# Detect potential issues\nissues = container.detect_issues()\nfor issue in issues:\n    print(f\"Issue: {issue.description}\")\n    print(f\"Severity: {issue.severity}\")\n    print(f\"Suggestion: {issue.suggestion}\")\n</code></pre>"},{"location":"advanced/overview/#thread-safe-operations","title":"Thread-Safe Operations","text":"<pre><code>from injectq import ThreadSafeContainer\n\ncontainer = ThreadSafeContainer()\n\n# Safe for concurrent access\n@singleton\nclass SharedCache:\n    def __init__(self):\n        self.data = {}\n        self.lock = threading.Lock()\n\n    def get(self, key):\n        with self.lock:\n            return self.data.get(key)\n\n    def set(self, key, value):\n        with self.lock:\n            self.data[key] = value\n\ncontainer.bind(SharedCache, SharedCache())\n\n# Concurrent usage\ndef worker_thread(container, thread_id):\n    cache = container.get(SharedCache)\n    cache.set(f\"thread_{thread_id}\", f\"data_{thread_id}\")\n\nthreads = [threading.Thread(target=worker_thread, args=(container, i))\n           for i in range(10)]\n\nfor t in threads:\n    t.start()\nfor t in threads:\n    t.join()\n\n# All data safely stored\ncache = container.get(SharedCache)\nassert len(cache.data) == 10\n</code></pre>"},{"location":"advanced/overview/#configuration-and-setup","title":"\ud83d\udd27 Configuration and Setup","text":""},{"location":"advanced/overview/#advanced-container-configuration","title":"Advanced Container Configuration","text":"<pre><code>from injectq import InjectQ, ContainerConfig\n\nconfig = ContainerConfig(\n    # Diagnostics\n    enable_diagnostics=True,\n    diagnostic_level=\"detailed\",\n\n    # Performance\n    enable_caching=True,\n    cache_size=1000,\n    lazy_loading=True,\n\n    # Thread safety\n    thread_safe=True,\n    max_threads=10,\n\n    # Resource management\n    auto_dispose_resources=True,\n    resource_timeout=30.0,\n\n    # Circular dependency detection\n    detect_circular_deps=True,\n    circular_dep_strategy=\"fail_fast\"\n)\n\ncontainer = InjectQ(config)\n</code></pre>"},{"location":"advanced/overview/#module-based-advanced-setup","title":"Module-Based Advanced Setup","text":"<pre><code>from injectq import Module\n\nclass AdvancedFeaturesModule(Module):\n    def configure(self, binder):\n        # Resource management\n        binder.bind_resource(DatabasePool())\n        binder.bind_resource(CacheManager())\n\n        # Lazy services\n        binder.bind_lazy(ExpensiveService)\n\n        # Cached services\n        binder.bind_cached(ComputationService)\n\n        # Thread-safe services\n        binder.bind_thread_safe(SharedStateService)\n\nclass MonitoringModule(Module):\n    def configure(self, binder):\n        # Diagnostic services\n        binder.bind(IDiagnosticsService, DiagnosticsService())\n        binder.bind(IPerformanceMonitor, PerformanceMonitor())\n\n        # Profiling services\n        binder.bind(IProfiler, ProfilerService())\n\n# Create container with advanced features\ncontainer = InjectQ()\ncontainer.install(AdvancedFeaturesModule())\ncontainer.install(MonitoringModule())\n</code></pre>"},{"location":"advanced/overview/#common-advanced-scenarios","title":"\ud83d\udea8 Common Advanced Scenarios","text":""},{"location":"advanced/overview/#high-performance-applications","title":"High-Performance Applications","text":"<pre><code># Optimized for performance\ncontainer = InjectQ(ContainerConfig(\n    enable_caching=True,\n    lazy_loading=True,\n    thread_safe=True,\n    cache_size=5000\n))\n\n@cached(ttl=300)  # 5-minute cache\nclass APICache:\n    async def fetch_data(self, endpoint):\n        # Expensive API call\n        return await http_client.get(endpoint)\n\n@lazy\nclass MLModel:\n    def __init__(self):\n        # Load 2GB model - only when needed\n        self.model = load_ml_model()\n\n# Usage\napi_cache = container.get(APICache)\ndata = await api_cache.fetch_data(\"/api/data\")  # Cached\n\nml_model = container.get(MLModel)  # Lazy loaded\nprediction = ml_model.predict(input_data)\n</code></pre>"},{"location":"advanced/overview/#complex-resource-management","title":"Complex Resource Management","text":"<pre><code>@resource\nclass ResourcePool:\n    def __init__(self):\n        self.available = set()\n        self.in_use = set()\n        self.lock = asyncio.Lock()\n\n    async def acquire(self):\n        async with self.lock:\n            if not self.available:\n                resource = await self.create_resource()\n                self.available.add(resource)\n\n            resource = self.available.pop()\n            self.in_use.add(resource)\n            return resource\n\n    async def release(self, resource):\n        async with self.lock:\n            self.in_use.remove(resource)\n            self.available.add(resource)\n\n    async def dispose(self):\n        async with self.lock:\n            all_resources = self.available | self.in_use\n            for resource in all_resources:\n                await self.cleanup_resource(resource)\n\n# Automatic resource management\nasync def process_request(container):\n    pool = container.get(ResourcePool)\n\n    async with container.resource_scope():\n        resource = await pool.acquire()\n        try:\n            # Use resource\n            result = await process_with_resource(resource)\n            return result\n        finally:\n            await pool.release(resource)\n</code></pre>"},{"location":"advanced/overview/#diagnostic-driven-development","title":"Diagnostic-Driven Development","text":"<pre><code>container = InjectQ()\ncontainer.enable_diagnostics()\n\n# Development-time diagnostics\nif os.getenv(\"ENV\") == \"development\":\n    container.enable_detailed_logging()\n    container.enable_performance_monitoring()\n\n# Analyze application startup\nwith container.monitor_initialization():\n    # Bind all services\n    container.install(AllModules())\n\n# Generate diagnostic report\nreport = container.generate_report()\nif report.has_issues():\n    print(\"Diagnostic Issues Found:\")\n    for issue in report.issues:\n        print(f\"- {issue.level}: {issue.message}\")\n        if issue.suggestion:\n            print(f\"  Suggestion: {issue.suggestion}\")\n\n# Performance analysis\nmetrics = container.get_performance_metrics()\nif metrics.avg_resolution_time &gt; 0.1:  # 100ms\n    print(\"Warning: Slow dependency resolution detected\")\n    print(f\"Average time: {metrics.avg_resolution_time}s\")\n</code></pre>"},{"location":"advanced/overview/#performance-and-monitoring","title":"\ud83d\udcca Performance and Monitoring","text":""},{"location":"advanced/overview/#performance-metrics","title":"Performance Metrics","text":"<pre><code># Track performance\ncontainer = InjectQ()\ncontainer.enable_performance_monitoring()\n\n# Application usage\nfor _ in range(1000):\n    service = container.get(IService)\n    result = service.do_work()\n\n# Get performance report\nreport = container.get_performance_report()\nprint(f\"Total resolutions: {report.total_resolutions}\")\nprint(f\"Average time: {report.avg_resolution_time}\")\nprint(f\"Cache hit rate: {report.cache_hit_rate}\")\nprint(f\"Memory usage: {report.memory_usage}\")\n</code></pre>"},{"location":"advanced/overview/#health-checks","title":"Health Checks","text":"<pre><code>class HealthCheckService:\n    def __init__(self, container: InjectQ):\n        self.container = container\n\n    async def check_health(self):\n        results = {}\n\n        # Check container health\n        results[\"container\"] = await self.check_container_health()\n\n        # Check service health\n        results[\"services\"] = await self.check_service_health()\n\n        # Check resource health\n        results[\"resources\"] = await self.check_resource_health()\n\n        return results\n\n    async def check_container_health(self):\n        try:\n            # Test basic resolution\n            test_service = self.container.get(IService)\n            return {\"status\": \"healthy\", \"message\": \"Container operational\"}\n        except Exception as e:\n            return {\"status\": \"unhealthy\", \"message\": str(e)}\n\n    async def check_service_health(self):\n        services_to_check = [IService, IDatabase, ICache]\n        results = {}\n\n        for service_type in services_to_check:\n            try:\n                service = self.container.get(service_type)\n                # Test service functionality\n                await service.ping()  # Assuming services have ping method\n                results[service_type.__name__] = \"healthy\"\n            except Exception as e:\n                results[service_type.__name__] = f\"unhealthy: {e}\"\n\n        return results\n\n# Usage\nhealth_service = HealthCheckService(container)\nhealth = await health_service.check_health()\n\nif health[\"container\"][\"status\"] != \"healthy\":\n    print(\"Container health issue detected!\")\n    # Alert system\n</code></pre>"},{"location":"advanced/overview/#summary","title":"\ud83c\udfaf Summary","text":"<p>Advanced features provide powerful capabilities for complex applications:</p> <ul> <li>Resource management - Automatic lifecycle management and cleanup</li> <li>Diagnostics - Debugging tools and dependency analysis</li> <li>Performance optimization - Lazy loading, caching, and efficient resolution</li> <li>Thread safety - Safe concurrent access and synchronization</li> <li>Circular dependency handling - Detection and resolution strategies</li> <li>Profiling - Performance monitoring and analysis</li> </ul> <p>Key features: - Automatic resource cleanup and lifecycle management - Comprehensive diagnostic and debugging tools - Performance optimization through lazy loading and caching - Thread-safe concurrent operations - Circular dependency detection and resolution - Detailed performance profiling and monitoring</p> <p>Best practices: - Use resource management for proper cleanup - Enable diagnostics in development - Optimize performance with lazy loading and caching - Ensure thread safety for concurrent applications - Monitor and profile performance regularly - Use health checks for system monitoring</p> <p>Ready to dive into resource management?</p>"},{"location":"advanced/performance-optimization/","title":"Performance Optimization","text":"<p>Performance optimization provides advanced techniques and tools to maximize the efficiency of your InjectQ dependency injection container.</p>"},{"location":"advanced/performance-optimization/#performance-optimization-techniques","title":"\ud83d\ude80 Performance Optimization Techniques","text":""},{"location":"advanced/performance-optimization/#container-configuration-optimization","title":"Container Configuration Optimization","text":"<p>This page shows realistic, supported ways to optimize InjectQ performance using the real public APIs in the codebase.</p> <p>Sections cover: - constructor-time options on <code>InjectQ</code> - pre-compiling resolution plans with <code>container.compile()</code> - profiling with <code>DependencyProfiler</code> from <code>injectq.diagnostics.profiling</code> - thread-safety guidance using the <code>thread_safe</code> flag and <code>HybridLock</code></p>"},{"location":"advanced/performance-optimization/#container-level-optimizations","title":"Container-level optimizations","text":"<p>The container is configured at construction time. There is no <code>ContainerConfig</code> class in the codebase \u2014 instead use <code>InjectQ</code> constructor flags.</p> <pre><code>from injectq import InjectQ\n\n# Create a container with thread-safety enabled and async-scope support\ncontainer = InjectQ(use_async_scopes=True, thread_safe=True)\n\n# Pre-compile resolution plans to reduce runtime overhead\ncontainer.compile()\n</code></pre> <p>Pre-compilation (via <code>container.compile()</code>) builds internal resolution plans ahead of time and can reduce per-request overhead in hot paths.</p>"},{"location":"advanced/performance-optimization/#profiling-and-diagnostics","title":"Profiling and diagnostics","text":"<p>Use the built-in profiler in <code>injectq.diagnostics.profiling</code> to measure resolution times and find bottlenecks.</p> <pre><code>from injectq.diagnostics.profiling import DependencyProfiler, get_global_profiler\n\n# Create a profiler and profile a block of code\nwith DependencyProfiler() as profiler:\n    # perform resolutions\n    svc = container.get(SomeService)\n    other = container.get(OtherService)\n\n# Query metrics\nmetrics = profiler.get_metrics()\nprint(metrics)\n\n# Or use the global profiler (useful during tests or app startup)\nglobal_profiler = get_global_profiler()\nglobal_profiler.start()\n# ... do work\nglobal_profiler.stop()\nprint(global_profiler.report())\n\n# Export results for later analysis\nprofiler.export_json(\"di_profile.json\")\n</code></pre> <p>Helpful profiler methods: <code>profile_resolution()</code> (context manager), <code>profile_method()</code> (decorator), <code>get_metrics()</code>, <code>get_aggregated_metrics()</code>, <code>report()</code>, <code>export_json()</code> and <code>export_csv()</code>.</p>"},{"location":"advanced/performance-optimization/#thread-safety-guidance","title":"Thread-safety guidance","text":"<p>There is no <code>ThreadSafetyLevel</code> enum or <code>container.set_thread_safety()</code> in the codebase. Thread-safety is handled either by constructing the container with <code>thread_safe=True</code> or by using the locking primitives directly.</p> <pre><code>from injectq import InjectQ\nfrom injectq.core.thread_safety import HybridLock, thread_safe\n\ncontainer = InjectQ(thread_safe=False)  # lower overhead when you know you are single-threaded\n\n# Example: a function-level synchronization helper\nlock = HybridLock()\n\n@thread_safe\ndef critical_section():\n    # function protected by the library-provided decorator\n    pass\n\nasync def async_example():\n    async with lock.async_lock():\n        # safe async-critical section\n        ...\n\nwith lock.sync_lock():\n    # safe synchronous-critical section\n    ...\n</code></pre> <p>If your application is single-threaded or uses its own concurrency model, prefer <code>thread_safe=False</code> to avoid locking overhead; enable <code>thread_safe=True</code> when concurrent access from multiple threads is expected.</p>"},{"location":"advanced/performance-optimization/#practical-tips","title":"Practical tips","text":"<ul> <li>Precompile resolution plans in startup paths (call <code>container.compile()</code>).</li> <li>Profile with <code>DependencyProfiler</code> to find slow resolutions and cache/memoize where appropriate.</li> <li>Avoid unnecessary object construction in factories used by the container; use lightweight factories or pooling for heavy objects.</li> <li>Choose <code>thread_safe</code> appropriately for your deployment (disable in single-threaded scenarios).</li> </ul> <p>Ready to read more about thread safety? See the thread-safety guide: <code>thread-safety.md</code>.</p>"},{"location":"advanced/plugins/","title":"Plugins","text":"<p>InjectQ's plugin system provides a powerful way to extend functionality, integrate with third-party libraries, and create reusable components that can be easily shared across projects.</p>"},{"location":"advanced/plugins/#plugin-architecture","title":"Plugin Architecture","text":""},{"location":"advanced/plugins/#plugin-interface","title":"Plugin Interface","text":"<pre><code>from abc import ABC, abstractmethod\nfrom typing import Dict, Any, List, Optional, Type\nfrom dataclasses import dataclass\nimport importlib\nimport sys\n\n@dataclass\nclass PluginMetadata:\n    \"\"\"Metadata for a plugin.\"\"\"\n    name: str\n    version: str\n    description: str\n    author: str\n    dependencies: List[str] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n        if self.tags is None:\n            self.tags = []\n\nclass InjectQPlugin(ABC):\n    \"\"\"Base class for InjectQ plugins.\"\"\"\n\n    @property\n    @abstractmethod\n    def metadata(self) -&gt; PluginMetadata:\n        \"\"\"Get plugin metadata.\"\"\"\n        pass\n\n    @abstractmethod\n    def initialize(self, container) -&gt; None:\n        \"\"\"Initialize plugin with container.\"\"\"\n        pass\n\n    def configure(self, config: Dict[str, Any]) -&gt; None:\n        \"\"\"Configure plugin with settings.\"\"\"\n        pass\n\n    def dispose(self) -&gt; None:\n        \"\"\"Cleanup plugin resources.\"\"\"\n        pass\n\n    def get_services(self) -&gt; Dict[Type, Any]:\n        \"\"\"Get services provided by this plugin.\"\"\"\n        return {}\n\n    def get_middleware(self) -&gt; List[Any]:\n        \"\"\"Get middleware provided by this plugin.\"\"\"\n        return []\n\n# Plugin registry\nclass PluginRegistry:\n    \"\"\"Registry for managing plugins.\"\"\"\n\n    def __init__(self):\n        self._plugins: Dict[str, InjectQPlugin] = {}\n        self._plugin_configs: Dict[str, Dict[str, Any]] = {}\n        self._loaded_plugins: Dict[str, bool] = {}\n\n    def register_plugin(self, plugin: InjectQPlugin, config: Dict[str, Any] = None):\n        \"\"\"Register a plugin.\"\"\"\n        metadata = plugin.metadata\n\n        if metadata.name in self._plugins:\n            raise ValueError(f\"Plugin '{metadata.name}' is already registered\")\n\n        # Check dependencies\n        self._check_dependencies(metadata)\n\n        # Register plugin\n        self._plugins[metadata.name] = plugin\n        self._plugin_configs[metadata.name] = config or {}\n        self._loaded_plugins[metadata.name] = False\n\n        print(f\"Registered plugin: {metadata.name} v{metadata.version}\")\n\n    def load_plugin(self, name: str, container) -&gt; None:\n        \"\"\"Load and initialize a plugin.\"\"\"\n        if name not in self._plugins:\n            raise ValueError(f\"Plugin '{name}' is not registered\")\n\n        if self._loaded_plugins[name]:\n            return  # Already loaded\n\n        plugin = self._plugins[name]\n        config = self._plugin_configs[name]\n\n        # Configure plugin\n        plugin.configure(config)\n\n        # Initialize plugin\n        plugin.initialize(container)\n\n        # Register plugin services\n        services = plugin.get_services()\n        for service_type, implementation in services.items():\n            container.register(service_type, implementation)\n\n        # Add plugin middleware\n        middleware_list = plugin.get_middleware()\n        for middleware in middleware_list:\n            container.add_middleware(middleware)\n\n        self._loaded_plugins[name] = True\n        print(f\"Loaded plugin: {name}\")\n\n    def unload_plugin(self, name: str) -&gt; None:\n        \"\"\"Unload a plugin.\"\"\"\n        if name not in self._plugins:\n            return\n\n        if not self._loaded_plugins[name]:\n            return  # Not loaded\n\n        plugin = self._plugins[name]\n        plugin.dispose()\n\n        self._loaded_plugins[name] = False\n        print(f\"Unloaded plugin: {name}\")\n\n    def get_plugin(self, name: str) -&gt; Optional[InjectQPlugin]:\n        \"\"\"Get a plugin by name.\"\"\"\n        return self._plugins.get(name)\n\n    def list_plugins(self) -&gt; List[PluginMetadata]:\n        \"\"\"List all registered plugins.\"\"\"\n        return [plugin.metadata for plugin in self._plugins.values()]\n\n    def _check_dependencies(self, metadata: PluginMetadata):\n        \"\"\"Check if plugin dependencies are satisfied.\"\"\"\n        for dependency in metadata.dependencies:\n            if dependency not in self._plugins:\n                raise ValueError(\n                    f\"Plugin '{metadata.name}' requires dependency '{dependency}' \"\n                    f\"which is not registered\"\n                )\n\n# Global plugin registry\nplugin_registry = PluginRegistry()\n</code></pre>"},{"location":"advanced/plugins/#built-in-plugins","title":"Built-in Plugins","text":""},{"location":"advanced/plugins/#database-plugin","title":"Database Plugin","text":"<pre><code>class DatabasePlugin(InjectQPlugin):\n    \"\"\"Plugin for database integration.\"\"\"\n\n    @property\n    def metadata(self) -&gt; PluginMetadata:\n        return PluginMetadata(\n            name=\"database\",\n            version=\"1.0.0\",\n            description=\"Database integration plugin with connection pooling\",\n            author=\"InjectQ Team\",\n            tags=[\"database\", \"sql\", \"orm\"]\n        )\n\n    def __init__(self):\n        self._connection_pool = None\n        self._config = {}\n\n    def configure(self, config: Dict[str, Any]) -&gt; None:\n        \"\"\"Configure database plugin.\"\"\"\n        self._config = config\n\n        # Validate required config\n        required_keys = ['connection_string', 'pool_size']\n        for key in required_keys:\n            if key not in config:\n                raise ValueError(f\"Database plugin requires '{key}' configuration\")\n\n    def initialize(self, container) -&gt; None:\n        \"\"\"Initialize database plugin.\"\"\"\n        # Create connection pool\n        self._connection_pool = self._create_connection_pool()\n\n        print(f\"Database plugin initialized with pool size: {self._config['pool_size']}\")\n\n    def _create_connection_pool(self):\n        \"\"\"Create database connection pool.\"\"\"\n        # This would create actual connection pool\n        class MockConnectionPool:\n            def __init__(self, connection_string: str, pool_size: int):\n                self.connection_string = connection_string\n                self.pool_size = pool_size\n\n            def get_connection(self):\n                return MockConnection(self.connection_string)\n\n            def close(self):\n                print(\"Connection pool closed\")\n\n        return MockConnectionPool(\n            self._config['connection_string'],\n            self._config['pool_size']\n        )\n\n    def get_services(self) -&gt; Dict[Type, Any]:\n        \"\"\"Get database services.\"\"\"\n        return {\n            ConnectionPool: lambda: self._connection_pool,\n            DatabaseConnection: lambda: self._connection_pool.get_connection(),\n            UserRepository: lambda conn=self._connection_pool.get_connection(): DatabaseUserRepository(conn),\n            OrderRepository: lambda conn=self._connection_pool.get_connection(): DatabaseOrderRepository(conn)\n        }\n\n    def dispose(self) -&gt; None:\n        \"\"\"Cleanup database resources.\"\"\"\n        if self._connection_pool:\n            self._connection_pool.close()\n\n# Mock classes for example\nclass ConnectionPool:\n    pass\n\nclass DatabaseConnection:\n    pass\n\nclass MockConnection:\n    def __init__(self, connection_string: str):\n        self.connection_string = connection_string\n\nclass DatabaseUserRepository:\n    def __init__(self, connection):\n        self.connection = connection\n\nclass DatabaseOrderRepository:\n    def __init__(self, connection):\n        self.connection = connection\n\n# Usage\ndatabase_config = {\n    'connection_string': 'postgresql://localhost/mydb',\n    'pool_size': 10\n}\n\nplugin_registry.register_plugin(DatabasePlugin(), database_config)\nplugin_registry.load_plugin('database', container)\n</code></pre>"},{"location":"advanced/plugins/#caching-plugin","title":"Caching Plugin","text":"<pre><code>import time\nfrom typing import Union\n\nclass CachingPlugin(InjectQPlugin):\n    \"\"\"Plugin for caching functionality.\"\"\"\n\n    @property\n    def metadata(self) -&gt; PluginMetadata:\n        return PluginMetadata(\n            name=\"caching\",\n            version=\"1.0.0\",\n            description=\"Caching plugin with multiple backends\",\n            author=\"InjectQ Team\",\n            tags=[\"cache\", \"performance\", \"memory\"]\n        )\n\n    def __init__(self):\n        self._cache_backend = None\n        self._config = {}\n\n    def configure(self, config: Dict[str, Any]) -&gt; None:\n        \"\"\"Configure caching plugin.\"\"\"\n        self._config = config\n\n        # Default configuration\n        self._config.setdefault('backend', 'memory')\n        self._config.setdefault('ttl', 300)  # 5 minutes\n        self._config.setdefault('max_size', 1000)\n\n    def initialize(self, container) -&gt; None:\n        \"\"\"Initialize caching plugin.\"\"\"\n        backend_type = self._config['backend']\n\n        if backend_type == 'memory':\n            self._cache_backend = MemoryCache(\n                ttl=self._config['ttl'],\n                max_size=self._config['max_size']\n            )\n        elif backend_type == 'redis':\n            self._cache_backend = RedisCache(\n                redis_url=self._config.get('redis_url', 'redis://localhost'),\n                ttl=self._config['ttl']\n            )\n        else:\n            raise ValueError(f\"Unsupported cache backend: {backend_type}\")\n\n        print(f\"Caching plugin initialized with {backend_type} backend\")\n\n    def get_services(self) -&gt; Dict[Type, Any]:\n        \"\"\"Get caching services.\"\"\"\n        return {\n            CacheService: lambda: self._cache_backend,\n            CacheManager: lambda: CacheManager(self._cache_backend)\n        }\n\n    def get_middleware(self) -&gt; List[Any]:\n        \"\"\"Get caching middleware.\"\"\"\n        return [CacheMiddleware(self._cache_backend)]\n\n# Cache implementations\nclass CacheService(ABC):\n    \"\"\"Abstract cache service.\"\"\"\n\n    @abstractmethod\n    def get(self, key: str) -&gt; Any:\n        pass\n\n    @abstractmethod\n    def set(self, key: str, value: Any, ttl: int = None) -&gt; None:\n        pass\n\n    @abstractmethod\n    def delete(self, key: str) -&gt; None:\n        pass\n\nclass MemoryCache(CacheService):\n    \"\"\"In-memory cache implementation.\"\"\"\n\n    def __init__(self, ttl: int = 300, max_size: int = 1000):\n        self.ttl = ttl\n        self.max_size = max_size\n        self._cache: Dict[str, tuple] = {}  # key -&gt; (value, expiry_time)\n\n    def get(self, key: str) -&gt; Any:\n        \"\"\"Get value from cache.\"\"\"\n        if key in self._cache:\n            value, expiry_time = self._cache[key]\n\n            if time.time() &lt; expiry_time:\n                return value\n            else:\n                del self._cache[key]\n\n        return None\n\n    def set(self, key: str, value: Any, ttl: int = None) -&gt; None:\n        \"\"\"Set value in cache.\"\"\"\n        ttl = ttl or self.ttl\n        expiry_time = time.time() + ttl\n\n        # Evict old entries if at max size\n        if len(self._cache) &gt;= self.max_size:\n            self._evict_old_entries()\n\n        self._cache[key] = (value, expiry_time)\n\n    def delete(self, key: str) -&gt; None:\n        \"\"\"Delete value from cache.\"\"\"\n        self._cache.pop(key, None)\n\n    def _evict_old_entries(self):\n        \"\"\"Evict expired or oldest entries.\"\"\"\n        current_time = time.time()\n\n        # Remove expired entries\n        expired_keys = [\n            key for key, (_, expiry_time) in self._cache.items()\n            if current_time &gt;= expiry_time\n        ]\n\n        for key in expired_keys:\n            del self._cache[key]\n\n        # If still at max size, remove oldest\n        if len(self._cache) &gt;= self.max_size:\n            oldest_key = min(self._cache.keys(), key=lambda k: self._cache[k][1])\n            del self._cache[oldest_key]\n\nclass RedisCache(CacheService):\n    \"\"\"Redis cache implementation.\"\"\"\n\n    def __init__(self, redis_url: str, ttl: int = 300):\n        self.redis_url = redis_url\n        self.ttl = ttl\n        self._redis_client = None\n        self._connect()\n\n    def _connect(self):\n        \"\"\"Connect to Redis.\"\"\"\n        # This would use actual Redis client\n        print(f\"Connected to Redis at {self.redis_url}\")\n        self._redis_client = MockRedisClient()\n\n    def get(self, key: str) -&gt; Any:\n        \"\"\"Get value from Redis cache.\"\"\"\n        return self._redis_client.get(key)\n\n    def set(self, key: str, value: Any, ttl: int = None) -&gt; None:\n        \"\"\"Set value in Redis cache.\"\"\"\n        ttl = ttl or self.ttl\n        self._redis_client.setex(key, ttl, value)\n\n    def delete(self, key: str) -&gt; None:\n        \"\"\"Delete value from Redis cache.\"\"\"\n        self._redis_client.delete(key)\n\nclass MockRedisClient:\n    \"\"\"Mock Redis client for example.\"\"\"\n\n    def __init__(self):\n        self._data = {}\n\n    def get(self, key: str):\n        return self._data.get(key)\n\n    def setex(self, key: str, ttl: int, value: Any):\n        self._data[key] = value\n\n    def delete(self, key: str):\n        self._data.pop(key, None)\n\nclass CacheManager:\n    \"\"\"High-level cache manager.\"\"\"\n\n    def __init__(self, cache_service: CacheService):\n        self.cache_service = cache_service\n\n    def cached(self, key: str, ttl: int = None):\n        \"\"\"Decorator for caching function results.\"\"\"\n        def decorator(func):\n            def wrapper(*args, **kwargs):\n                cache_key = f\"{key}:{hash((args, tuple(kwargs.items())))}\"\n\n                # Try to get from cache\n                result = self.cache_service.get(cache_key)\n                if result is not None:\n                    return result\n\n                # Execute function and cache result\n                result = func(*args, **kwargs)\n                self.cache_service.set(cache_key, result, ttl)\n\n                return result\n\n            return wrapper\n        return decorator\n\nclass CacheMiddleware:\n    \"\"\"Middleware for caching service instances.\"\"\"\n\n    def __init__(self, cache_service: CacheService):\n        self.cache_service = cache_service\n\n    async def process_resolution(self, service_type: Type, next_resolver):\n        \"\"\"Cache service resolution.\"\"\"\n        cache_key = f\"service:{service_type.__name__}\"\n\n        # Try cache first\n        cached_instance = self.cache_service.get(cache_key)\n        if cached_instance is not None:\n            return cached_instance\n\n        # Resolve and cache\n        instance = await next_resolver(service_type)\n        self.cache_service.set(cache_key, instance, ttl=60)  # Cache for 1 minute\n\n        return instance\n\n# Usage\ncaching_config = {\n    'backend': 'memory',\n    'ttl': 600,\n    'max_size': 5000\n}\n\nplugin_registry.register_plugin(CachingPlugin(), caching_config)\nplugin_registry.load_plugin('caching', container)\n</code></pre>"},{"location":"advanced/plugins/#logging-plugin","title":"Logging Plugin","text":"<pre><code>import logging\nimport sys\nfrom datetime import datetime\n\nclass LoggingPlugin(InjectQPlugin):\n    \"\"\"Plugin for enhanced logging functionality.\"\"\"\n\n    @property\n    def metadata(self) -&gt; PluginMetadata:\n        return PluginMetadata(\n            name=\"logging\",\n            version=\"1.0.0\",\n            description=\"Enhanced logging plugin with structured logging\",\n            author=\"InjectQ Team\",\n            tags=[\"logging\", \"monitoring\", \"debugging\"]\n        )\n\n    def __init__(self):\n        self._logger = None\n        self._config = {}\n\n    def configure(self, config: Dict[str, Any]) -&gt; None:\n        \"\"\"Configure logging plugin.\"\"\"\n        self._config = config\n\n        # Default configuration\n        self._config.setdefault('level', 'INFO')\n        self._config.setdefault('format', 'json')\n        self._config.setdefault('output', 'console')\n\n    def initialize(self, container) -&gt; None:\n        \"\"\"Initialize logging plugin.\"\"\"\n        self._setup_logger()\n        print(f\"Logging plugin initialized with {self._config['format']} format\")\n\n    def _setup_logger(self):\n        \"\"\"Setup logger configuration.\"\"\"\n        logger_name = 'injectq'\n        self._logger = logging.getLogger(logger_name)\n\n        # Set level\n        level = getattr(logging, self._config['level'].upper())\n        self._logger.setLevel(level)\n\n        # Create formatter\n        if self._config['format'] == 'json':\n            formatter = JsonFormatter()\n        else:\n            formatter = logging.Formatter(\n                '%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n            )\n\n        # Create handler\n        if self._config['output'] == 'console':\n            handler = logging.StreamHandler(sys.stdout)\n        elif self._config['output'] == 'file':\n            handler = logging.FileHandler(self._config.get('filename', 'injectq.log'))\n        else:\n            handler = logging.StreamHandler(sys.stdout)\n\n        handler.setFormatter(formatter)\n        self._logger.addHandler(handler)\n\n    def get_services(self) -&gt; Dict[Type, Any]:\n        \"\"\"Get logging services.\"\"\"\n        return {\n            StructuredLogger: lambda: StructuredLogger(self._logger),\n            LoggingService: lambda: LoggingService(self._logger)\n        }\n\n    def get_middleware(self) -&gt; List[Any]:\n        \"\"\"Get logging middleware.\"\"\"\n        return [DetailedLoggingMiddleware(self._logger)]\n\nclass JsonFormatter(logging.Formatter):\n    \"\"\"JSON formatter for structured logging.\"\"\"\n\n    def format(self, record):\n        \"\"\"Format log record as JSON.\"\"\"\n        import json\n\n        log_data = {\n            'timestamp': datetime.fromtimestamp(record.created).isoformat(),\n            'level': record.levelname,\n            'logger': record.name,\n            'message': record.getMessage(),\n            'module': record.module,\n            'function': record.funcName,\n            'line': record.lineno\n        }\n\n        # Add exception info if present\n        if record.exc_info:\n            log_data['exception'] = self.formatException(record.exc_info)\n\n        # Add extra fields\n        for key, value in record.__dict__.items():\n            if key not in ['name', 'msg', 'args', 'levelname', 'levelno', 'pathname',\n                          'filename', 'module', 'lineno', 'funcName', 'created',\n                          'msecs', 'relativeCreated', 'thread', 'threadName',\n                          'processName', 'process', 'message', 'exc_info', 'exc_text',\n                          'stack_info']:\n                log_data[key] = value\n\n        return json.dumps(log_data)\n\nclass StructuredLogger:\n    \"\"\"Structured logger with context support.\"\"\"\n\n    def __init__(self, logger: logging.Logger):\n        self._logger = logger\n        self._context = {}\n\n    def with_context(self, **context):\n        \"\"\"Add context to logger.\"\"\"\n        new_logger = StructuredLogger(self._logger)\n        new_logger._context = {**self._context, **context}\n        return new_logger\n\n    def info(self, message: str, **extra):\n        \"\"\"Log info message with context.\"\"\"\n        self._log(logging.INFO, message, extra)\n\n    def error(self, message: str, **extra):\n        \"\"\"Log error message with context.\"\"\"\n        self._log(logging.ERROR, message, extra)\n\n    def warning(self, message: str, **extra):\n        \"\"\"Log warning message with context.\"\"\"\n        self._log(logging.WARNING, message, extra)\n\n    def debug(self, message: str, **extra):\n        \"\"\"Log debug message with context.\"\"\"\n        self._log(logging.DEBUG, message, extra)\n\n    def _log(self, level: int, message: str, extra: Dict[str, Any]):\n        \"\"\"Log message with context.\"\"\"\n        log_extra = {**self._context, **extra}\n        self._logger.log(level, message, extra=log_extra)\n\nclass LoggingService:\n    \"\"\"High-level logging service.\"\"\"\n\n    def __init__(self, logger: logging.Logger):\n        self._logger = logger\n\n    def log_service_resolution(self, service_type: Type, duration_ms: float, success: bool):\n        \"\"\"Log service resolution.\"\"\"\n        status = \"SUCCESS\" if success else \"FAILED\"\n        self._logger.info(\n            f\"Service resolution {status}\",\n            extra={\n                'service_type': service_type.__name__,\n                'duration_ms': duration_ms,\n                'success': success,\n                'event_type': 'service_resolution'\n            }\n        )\n\n    def log_service_registration(self, service_type: Type, implementation: Any):\n        \"\"\"Log service registration.\"\"\"\n        self._logger.info(\n            \"Service registered\",\n            extra={\n                'service_type': service_type.__name__,\n                'implementation': implementation.__name__ if hasattr(implementation, '__name__') else str(implementation),\n                'event_type': 'service_registration'\n            }\n        )\n\nclass DetailedLoggingMiddleware:\n    \"\"\"Detailed logging middleware.\"\"\"\n\n    def __init__(self, logger: logging.Logger):\n        self._logger = logger\n\n    async def process_resolution(self, service_type: Type, next_resolver):\n        \"\"\"Log detailed service resolution.\"\"\"\n        start_time = time.time()\n\n        self._logger.debug(\n            \"Starting service resolution\",\n            extra={\n                'service_type': service_type.__name__,\n                'event_type': 'resolution_start'\n            }\n        )\n\n        try:\n            result = await next_resolver(service_type)\n            duration_ms = (time.time() - start_time) * 1000\n\n            self._logger.info(\n                \"Service resolution completed\",\n                extra={\n                    'service_type': service_type.__name__,\n                    'duration_ms': duration_ms,\n                    'event_type': 'resolution_success'\n                }\n            )\n\n            return result\n\n        except Exception as e:\n            duration_ms = (time.time() - start_time) * 1000\n\n            self._logger.error(\n                \"Service resolution failed\",\n                extra={\n                    'service_type': service_type.__name__,\n                    'duration_ms': duration_ms,\n                    'error': str(e),\n                    'error_type': type(e).__name__,\n                    'event_type': 'resolution_error'\n                },\n                exc_info=True\n            )\n\n            raise\n\n# Usage\nlogging_config = {\n    'level': 'DEBUG',\n    'format': 'json',\n    'output': 'console'\n}\n\nplugin_registry.register_plugin(LoggingPlugin(), logging_config)\nplugin_registry.load_plugin('logging', container)\n</code></pre>"},{"location":"advanced/plugins/#plugin-discovery","title":"Plugin Discovery","text":""},{"location":"advanced/plugins/#automatic-plugin-discovery","title":"Automatic Plugin Discovery","text":"<pre><code>import pkgutil\nimport importlib.util\nfrom pathlib import Path\n\nclass PluginDiscovery:\n    \"\"\"Automatic plugin discovery system.\"\"\"\n\n    def __init__(self):\n        self._discovered_plugins: Dict[str, InjectQPlugin] = {}\n\n    def discover_plugins(self, paths: List[str] = None) -&gt; List[InjectQPlugin]:\n        \"\"\"Discover plugins from specified paths.\"\"\"\n        paths = paths or [\n            'injectq_plugins',  # Standard plugin namespace\n            'plugins',          # Local plugins directory\n        ]\n\n        discovered = []\n\n        for path in paths:\n            plugins = self._discover_from_path(path)\n            discovered.extend(plugins)\n\n        return discovered\n\n    def _discover_from_path(self, path: str) -&gt; List[InjectQPlugin]:\n        \"\"\"Discover plugins from a specific path.\"\"\"\n        plugins = []\n\n        try:\n            # Try to import as module\n            if '.' not in path:\n                # Package path\n                plugins.extend(self._discover_from_package(path))\n            else:\n                # File path\n                plugins.extend(self._discover_from_file(path))\n        except ImportError:\n            # Try as directory path\n            plugins.extend(self._discover_from_directory(path))\n\n        return plugins\n\n    def _discover_from_package(self, package_name: str) -&gt; List[InjectQPlugin]:\n        \"\"\"Discover plugins from Python package.\"\"\"\n        plugins = []\n\n        try:\n            package = importlib.import_module(package_name)\n\n            # Look for plugin modules\n            if hasattr(package, '__path__'):\n                for importer, modname, ispkg in pkgutil.iter_modules(package.__path__):\n                    full_name = f\"{package_name}.{modname}\"\n\n                    try:\n                        module = importlib.import_module(full_name)\n                        plugins.extend(self._extract_plugins_from_module(module))\n                    except ImportError as e:\n                        print(f\"Failed to import plugin module {full_name}: {e}\")\n\n        except ImportError:\n            pass  # Package not found\n\n        return plugins\n\n    def _discover_from_directory(self, directory_path: str) -&gt; List[InjectQPlugin]:\n        \"\"\"Discover plugins from directory.\"\"\"\n        plugins = []\n        directory = Path(directory_path)\n\n        if not directory.exists():\n            return plugins\n\n        # Look for Python files\n        for file_path in directory.glob(\"*.py\"):\n            if file_path.name.startswith('__'):\n                continue\n\n            plugins.extend(self._discover_from_file(str(file_path)))\n\n        return plugins\n\n    def _discover_from_file(self, file_path: str) -&gt; List[InjectQPlugin]:\n        \"\"\"Discover plugins from Python file.\"\"\"\n        plugins = []\n\n        try:\n            spec = importlib.util.spec_from_file_location(\"plugin_module\", file_path)\n            module = importlib.util.module_from_spec(spec)\n            spec.loader.exec_module(module)\n\n            plugins.extend(self._extract_plugins_from_module(module))\n\n        except Exception as e:\n            print(f\"Failed to load plugin from {file_path}: {e}\")\n\n        return plugins\n\n    def _extract_plugins_from_module(self, module) -&gt; List[InjectQPlugin]:\n        \"\"\"Extract plugin classes from module.\"\"\"\n        plugins = []\n\n        for name in dir(module):\n            obj = getattr(module, name)\n\n            # Check if it's a plugin class\n            if (isinstance(obj, type) and \n                issubclass(obj, InjectQPlugin) and \n                obj is not InjectQPlugin):\n\n                try:\n                    # Instantiate plugin\n                    plugin = obj()\n                    plugins.append(plugin)\n                except Exception as e:\n                    print(f\"Failed to instantiate plugin {name}: {e}\")\n\n        return plugins\n\n    def auto_register_plugins(self, paths: List[str] = None) -&gt; int:\n        \"\"\"Automatically discover and register plugins.\"\"\"\n        plugins = self.discover_plugins(paths)\n\n        registered_count = 0\n        for plugin in plugins:\n            try:\n                plugin_registry.register_plugin(plugin)\n                registered_count += 1\n            except Exception as e:\n                print(f\"Failed to register plugin {plugin.metadata.name}: {e}\")\n\n        return registered_count\n\n# Usage\ndiscovery = PluginDiscovery()\ncount = discovery.auto_register_plugins(['./plugins', 'injectq_plugins'])\nprint(f\"Discovered and registered {count} plugins\")\n</code></pre>"},{"location":"advanced/plugins/#plugin-configuration","title":"Plugin Configuration","text":"<pre><code>import yaml\nimport json\nfrom pathlib import Path\n\nclass PluginConfiguration:\n    \"\"\"Manages plugin configuration from files.\"\"\"\n\n    def __init__(self, config_file: str = \"plugins.yaml\"):\n        self.config_file = config_file\n        self._config = {}\n        self.load_config()\n\n    def load_config(self):\n        \"\"\"Load plugin configuration from file.\"\"\"\n        config_path = Path(self.config_file)\n\n        if not config_path.exists():\n            return\n\n        try:\n            with open(config_path, 'r') as f:\n                if config_path.suffix in ['.yaml', '.yml']:\n                    self._config = yaml.safe_load(f)\n                elif config_path.suffix == '.json':\n                    self._config = json.load(f)\n                else:\n                    print(f\"Unsupported config file format: {config_path.suffix}\")\n\n        except Exception as e:\n            print(f\"Failed to load plugin config: {e}\")\n\n    def get_plugin_config(self, plugin_name: str) -&gt; Dict[str, Any]:\n        \"\"\"Get configuration for a specific plugin.\"\"\"\n        return self._config.get('plugins', {}).get(plugin_name, {})\n\n    def is_plugin_enabled(self, plugin_name: str) -&gt; bool:\n        \"\"\"Check if plugin is enabled.\"\"\"\n        plugin_config = self.get_plugin_config(plugin_name)\n        return plugin_config.get('enabled', True)\n\n    def get_enabled_plugins(self) -&gt; List[str]:\n        \"\"\"Get list of enabled plugin names.\"\"\"\n        enabled = []\n\n        for plugin_name, config in self._config.get('plugins', {}).items():\n            if config.get('enabled', True):\n                enabled.append(plugin_name)\n\n        return enabled\n\n    def apply_configuration(self):\n        \"\"\"Apply configuration to registered plugins.\"\"\"\n        for plugin_name in self.get_enabled_plugins():\n            plugin = plugin_registry.get_plugin(plugin_name)\n\n            if plugin:\n                config = self.get_plugin_config(plugin_name)\n                plugin.configure(config)\n\n# Example configuration file (plugins.yaml):\n\"\"\"\nplugins:\n  database:\n    enabled: true\n    connection_string: \"postgresql://localhost/myapp\"\n    pool_size: 20\n    timeout: 30\n\n  caching:\n    enabled: true\n    backend: \"redis\"\n    redis_url: \"redis://localhost:6379\"\n    ttl: 3600\n\n  logging:\n    enabled: true\n    level: \"INFO\"\n    format: \"json\"\n    output: \"file\"\n    filename: \"app.log\"\n\"\"\"\n\n# Usage\nconfig = PluginConfiguration(\"plugins.yaml\")\nconfig.apply_configuration()\n</code></pre>"},{"location":"advanced/plugins/#plugin-management","title":"Plugin Management","text":""},{"location":"advanced/plugins/#plugin-manager","title":"Plugin Manager","text":"<pre><code>class PluginManager:\n    \"\"\"Comprehensive plugin management system.\"\"\"\n\n    def __init__(self, container):\n        self.container = container\n        self.registry = plugin_registry\n        self.discovery = PluginDiscovery()\n        self.config = PluginConfiguration()\n        self._load_order: List[str] = []\n\n    def setup_plugins(self, auto_discover: bool = True, config_file: str = None):\n        \"\"\"Setup all plugins with configuration.\"\"\"\n        if config_file:\n            self.config = PluginConfiguration(config_file)\n\n        # Auto-discover plugins\n        if auto_discover:\n            self.discovery.auto_register_plugins()\n\n        # Apply configuration\n        self.config.apply_configuration()\n\n        # Load enabled plugins in dependency order\n        self._load_plugins_in_order()\n\n    def _load_plugins_in_order(self):\n        \"\"\"Load plugins in dependency order.\"\"\"\n        enabled_plugins = self.config.get_enabled_plugins()\n        loaded = set()\n\n        def load_plugin_recursive(plugin_name: str):\n            if plugin_name in loaded:\n                return\n\n            plugin = self.registry.get_plugin(plugin_name)\n            if not plugin:\n                print(f\"Plugin '{plugin_name}' not found\")\n                return\n\n            # Load dependencies first\n            for dependency in plugin.metadata.dependencies:\n                if dependency in enabled_plugins:\n                    load_plugin_recursive(dependency)\n\n            # Load plugin\n            try:\n                self.registry.load_plugin(plugin_name, self.container)\n                loaded.add(plugin_name)\n                self._load_order.append(plugin_name)\n            except Exception as e:\n                print(f\"Failed to load plugin '{plugin_name}': {e}\")\n\n        # Load all enabled plugins\n        for plugin_name in enabled_plugins:\n            load_plugin_recursive(plugin_name)\n\n    def reload_plugin(self, plugin_name: str):\n        \"\"\"Reload a specific plugin.\"\"\"\n        # Unload plugin\n        self.registry.unload_plugin(plugin_name)\n\n        # Reload configuration\n        self.config.load_config()\n\n        # Apply configuration\n        plugin = self.registry.get_plugin(plugin_name)\n        if plugin:\n            config = self.config.get_plugin_config(plugin_name)\n            plugin.configure(config)\n\n            # Load plugin\n            self.registry.load_plugin(plugin_name, self.container)\n\n    def get_plugin_status(self) -&gt; Dict[str, Dict[str, Any]]:\n        \"\"\"Get status of all plugins.\"\"\"\n        status = {}\n\n        for metadata in self.registry.list_plugins():\n            plugin_name = metadata.name\n\n            status[plugin_name] = {\n                'metadata': metadata,\n                'enabled': self.config.is_plugin_enabled(plugin_name),\n                'loaded': self.registry._loaded_plugins.get(plugin_name, False),\n                'config': self.config.get_plugin_config(plugin_name)\n            }\n\n        return status\n\n    def print_plugin_status(self):\n        \"\"\"Print plugin status report.\"\"\"\n        status = self.get_plugin_status()\n\n        print(\"Plugin Status Report\")\n        print(\"=\" * 50)\n\n        for plugin_name, info in status.items():\n            metadata = info['metadata']\n            enabled = \"\u2705\" if info['enabled'] else \"\u274c\"\n            loaded = \"\ud83d\udfe2\" if info['loaded'] else \"\ud83d\udd34\"\n\n            print(f\"{enabled} {loaded} {plugin_name} v{metadata.version}\")\n            print(f\"    {metadata.description}\")\n\n            if metadata.dependencies:\n                deps = \", \".join(metadata.dependencies)\n                print(f\"    Dependencies: {deps}\")\n\n            print()\n\n# Usage\ndef setup_application_with_plugins():\n    \"\"\"Setup application with plugin system.\"\"\"\n    # Create container\n    container = MiddlewareContainer()\n\n    # Create plugin manager\n    plugin_manager = PluginManager(container)\n\n    # Setup plugins\n    plugin_manager.setup_plugins(auto_discover=True, config_file=\"plugins.yaml\")\n\n    # Print status\n    plugin_manager.print_plugin_status()\n\n    return container, plugin_manager\n\n# Initialize application\ncontainer, plugin_manager = setup_application_with_plugins()\n</code></pre> <p>This comprehensive plugin system documentation shows how to extend InjectQ through a flexible and powerful plugin architecture, enabling modular functionality and easy integration of third-party components.</p>"},{"location":"advanced/profiling/","title":"Profiling","text":"<p>Profiling provides comprehensive performance analysis and optimization tools for your InjectQ dependency injection container and services.</p>"},{"location":"advanced/profiling/#performance-profiling","title":"\ud83d\udcca Performance Profiling","text":""},{"location":"advanced/profiling/#container-profiling","title":"Container Profiling","text":"<pre><code>from injectq.profiling import ContainerProfiler\n\n# Profile container performance\nprofiler = ContainerProfiler(container)\n\n# Profile service resolution\nwith profiler.profile_resolution(SomeService) as profile:\n    service = container.get(SomeService)\n\n# Get profiling results\nresults = profile.get_results()\nprint(\"Resolution Profile:\")\nprint(f\"- Total time: {results.total_time}ms\")\nprint(f\"- Initialization time: {results.init_time}ms\")\nprint(f\"- Dependency resolution time: {results.dep_resolution_time}ms\")\nprint(f\"- Memory usage: {results.memory_usage} bytes\")\nprint(f\"- Cache hits: {results.cache_hits}\")\n\n# Profile multiple resolutions\nbatch_profile = profiler.profile_batch_resolutions(\n    [ServiceA, ServiceB, ServiceC],\n    iterations=100\n)\nprint(\"Batch Resolution Profile:\")\nfor service_type, result in batch_profile.items():\n    print(f\"- {service_type.__name__}: {result.avg_time}ms avg\")\n</code></pre>"},{"location":"advanced/profiling/#memory-profiling","title":"Memory Profiling","text":"<pre><code>from injectq.profiling import MemoryProfiler\n\n# Profile memory usage\nmemory_profiler = MemoryProfiler(container)\n\n# Profile memory usage during resolution\nwith memory_profiler.profile_memory(SomeService) as mem_profile:\n    service = container.get(SomeService)\n\nmemory_results = mem_profile.get_results()\nprint(\"Memory Profile:\")\nprint(f\"- Peak memory usage: {memory_results.peak_memory} bytes\")\nprint(f\"- Memory growth: {memory_results.memory_growth} bytes\")\nprint(f\"- Objects created: {memory_results.objects_created}\")\nprint(f\"- Memory leaks detected: {memory_results.memory_leaks}\")\n\n# Profile memory over time\nmemory_timeline = memory_profiler.profile_memory_timeline(\n    operations=[\n        lambda: container.get(ServiceA),\n        lambda: container.get(ServiceB),\n        lambda: container.clear_cache()\n    ]\n)\n\nprint(\"Memory Timeline:\")\nfor timestamp, memory in memory_timeline:\n    print(f\"- {timestamp}: {memory} bytes\")\n</code></pre>"},{"location":"advanced/profiling/#cpu-profiling","title":"CPU Profiling","text":"<pre><code>from injectq.profiling import CPUProfiler\n\n# Profile CPU usage\ncpu_profiler = CPUProfiler(container)\n\n# Profile CPU usage during resolution\nwith cpu_profiler.profile_cpu(SomeService) as cpu_profile:\n    service = container.get(SomeService)\n\ncpu_results = cpu_profile.get_results()\nprint(\"CPU Profile:\")\nprint(f\"- CPU time: {cpu_results.cpu_time}ms\")\nprint(f\"- User time: {cpu_results.user_time}ms\")\nprint(f\"- System time: {cpu_results.system_time}ms\")\nprint(f\"- CPU utilization: {cpu_results.cpu_utilization}%\")\n\n# Profile CPU bottlenecks\nbottlenecks = cpu_profiler.identify_bottlenecks()\nprint(\"CPU Bottlenecks:\")\nfor bottleneck in bottlenecks:\n    print(f\"- {bottleneck.location}: {bottleneck.cpu_time}ms ({bottleneck.percentage}%)\")\n</code></pre>"},{"location":"advanced/profiling/#dependency-profiling","title":"\ud83d\udd0d Dependency Profiling","text":""},{"location":"advanced/profiling/#dependency-chain-analysis","title":"Dependency Chain Analysis","text":"<pre><code>from injectq.profiling import DependencyProfiler\n\n# Profile dependency chains\ndep_profiler = DependencyProfiler(container)\n\n# Analyze dependency chain\nchain_analysis = dep_profiler.analyze_chain(SomeService)\nprint(\"Dependency Chain Analysis:\")\nprint(f\"- Chain length: {chain_analysis.length}\")\nprint(f\"- Total dependencies: {chain_analysis.total_deps}\")\nprint(f\"- Circular dependencies: {chain_analysis.circular_deps}\")\nprint(f\"- Resolution time: {chain_analysis.resolution_time}ms\")\n\n# Print dependency tree\ndep_profiler.print_dependency_tree(SomeService)\n\n# Find optimization opportunities\noptimizations = dep_profiler.find_optimizations()\nprint(\"Optimization Opportunities:\")\nfor opt in optimizations:\n    print(f\"- {opt.type}: {opt.description}\")\n    print(f\"  Potential improvement: {opt.improvement}%\")\n</code></pre>"},{"location":"advanced/profiling/#resolution-path-profiling","title":"Resolution Path Profiling","text":"<pre><code># Profile resolution paths\nclass ResolutionPathProfiler:\n    \"\"\"Profile different resolution paths.\"\"\"\n\n    def __init__(self, container):\n        self.container = container\n        self.paths = {}\n\n    def profile_resolution_path(self, service_type, path_name: str):\n        \"\"\"Profile a specific resolution path.\"\"\"\n        import time\n\n        start_time = time.time()\n        start_memory = self.get_memory_usage()\n\n        # Resolve service\n        service = self.container.get(service_type)\n\n        end_time = time.time()\n        end_memory = self.get_memory_usage()\n\n        path_profile = {\n            \"service_type\": service_type,\n            \"resolution_time\": (end_time - start_time) * 1000,\n            \"memory_usage\": end_memory - start_memory,\n            \"path_name\": path_name\n        }\n\n        self.paths[path_name] = path_profile\n        return path_profile\n\n    def compare_paths(self, path1: str, path2: str):\n        \"\"\"Compare two resolution paths.\"\"\"\n        if path1 not in self.paths or path2 not in self.paths:\n            return None\n\n        p1 = self.paths[path1]\n        p2 = self.paths[path2]\n\n        comparison = {\n            \"time_difference\": p2[\"resolution_time\"] - p1[\"resolution_time\"],\n            \"memory_difference\": p2[\"memory_usage\"] - p1[\"memory_usage\"],\n            \"faster_path\": path1 if p1[\"resolution_time\"] &lt; p2[\"resolution_time\"] else path2,\n            \"more_memory_efficient\": path1 if p1[\"memory_usage\"] &lt; p2[\"memory_usage\"] else path2\n        }\n\n        return comparison\n\n    def get_memory_usage(self):\n        \"\"\"Get current memory usage.\"\"\"\n        import psutil\n        import os\n        process = psutil.Process(os.getpid())\n        return process.memory_info().rss\n\n# Usage\npath_profiler = ResolutionPathProfiler(container)\n\n# Profile different resolution strategies\nsingleton_path = path_profiler.profile_resolution_path(SingletonService, \"singleton\")\nscoped_path = path_profiler.profile_resolution_path(ScopedService, \"scoped\")\ntransient_path = path_profiler.profile_resolution_path(TransientService, \"transient\")\n\n# Compare paths\ncomparison = path_profiler.compare_paths(\"singleton\", \"transient\")\nprint(\"Path Comparison:\")\nprint(f\"- Time difference: {comparison['time_difference']}ms\")\nprint(f\"- Memory difference: {comparison['memory_difference']} bytes\")\nprint(f\"- Faster path: {comparison['faster_path']}\")\nprint(f\"- More memory efficient: {comparison['more_memory_efficient']}\")\n</code></pre>"},{"location":"advanced/profiling/#performance-metrics","title":"\ud83d\udcc8 Performance Metrics","text":""},{"location":"advanced/profiling/#real-time-metrics-collection","title":"Real-time Metrics Collection","text":"<pre><code>from injectq.profiling import MetricsCollector\n\n# Collect real-time performance metrics\nmetrics_collector = MetricsCollector(container)\n\n# Start metrics collection\nmetrics_collector.start_collection(interval_seconds=5)\n\n# Perform operations\nfor i in range(100):\n    service = container.get(SomeService)\n    # Use service...\n\n# Stop collection and get report\nmetrics_collector.stop_collection()\nreport = metrics_collector.get_report()\n\nprint(\"Performance Metrics Report:\")\nprint(f\"- Total resolutions: {report.total_resolutions}\")\nprint(f\"- Average resolution time: {report.avg_resolution_time}ms\")\nprint(f\"- Peak resolution time: {report.peak_resolution_time}ms\")\nprint(f\"- Memory usage trend: {report.memory_trend}\")\nprint(f\"- Cache hit rate: {report.cache_hit_rate}%\")\n\n# Export metrics\nmetrics_collector.export_metrics(\"performance_metrics.json\")\n</code></pre>"},{"location":"advanced/profiling/#custom-metrics","title":"Custom Metrics","text":"<pre><code>from injectq.profiling import CustomMetrics\n\n# Define custom performance metrics\ncustom_metrics = CustomMetrics()\n\n# Define metric\n@custom_metrics.metric(\"service_initialization_time\")\ndef measure_service_init(service_type):\n    \"\"\"Measure service initialization time.\"\"\"\n    import time\n    start_time = time.time()\n\n    # Service initialization logic\n    service = container.get(service_type)\n\n    end_time = time.time()\n    return (end_time - start_time) * 1000  # ms\n\n# Define another metric\n@custom_metrics.metric(\"dependency_count\")\ndef count_dependencies(service_type):\n    \"\"\"Count number of dependencies for a service.\"\"\"\n    # This would analyze the service's dependencies\n    return len(container.get_dependencies(service_type))\n\n# Collect custom metrics\nresults = custom_metrics.collect_metrics({\n    \"service_init_time\": lambda: measure_service_init(SomeService),\n    \"dep_count\": lambda: count_dependencies(SomeService)\n})\n\nprint(\"Custom Metrics:\")\nfor metric_name, value in results.items():\n    print(f\"- {metric_name}: {value}\")\n</code></pre>"},{"location":"advanced/profiling/#performance-baselines","title":"Performance Baselines","text":"<pre><code>from injectq.profiling import PerformanceBaseline\n\n# Establish performance baselines\nbaseline = PerformanceBaseline(container)\n\n# Establish baseline for service resolution\nresolution_baseline = baseline.establish_baseline(\n    operation=lambda: container.get(SomeService),\n    iterations=1000\n)\n\nprint(\"Resolution Baseline:\")\nprint(f\"- Average time: {resolution_baseline.avg_time}ms\")\nprint(f\"- Standard deviation: {resolution_baseline.std_dev}ms\")\nprint(f\"- 95th percentile: {resolution_baseline.percentile_95}ms\")\n\n# Monitor against baseline\nmonitoring_results = baseline.monitor_against_baseline(\n    operation=lambda: container.get(SomeService),\n    iterations=100\n)\n\nprint(\"Baseline Monitoring:\")\nprint(f\"- Within baseline: {monitoring_results.within_baseline}\")\nprint(f\"- Deviation: {monitoring_results.deviation}%\")\nif monitoring_results.regression_detected:\n    print(\"\u26a0\ufe0f  Performance regression detected!\")\n    print(f\"Regression magnitude: {monitoring_results.regression_magnitude}%\")\n</code></pre>"},{"location":"advanced/profiling/#bottleneck-analysis","title":"\ud83d\udc1b Bottleneck Analysis","text":""},{"location":"advanced/profiling/#automatic-bottleneck-detection","title":"Automatic Bottleneck Detection","text":"<pre><code>from injectq.profiling import BottleneckAnalyzer\n\n# Analyze performance bottlenecks\nanalyzer = BottleneckAnalyzer(container)\n\n# Analyze resolution bottlenecks\nbottlenecks = analyzer.analyze_resolution_bottlenecks(SomeService)\nprint(\"Resolution Bottlenecks:\")\nfor bottleneck in bottlenecks:\n    print(f\"- {bottleneck.component}: {bottleneck.impact}% impact\")\n    print(f\"  Description: {bottleneck.description}\")\n    print(f\"  Recommendation: {bottleneck.recommendation}\")\n\n# Analyze memory bottlenecks\nmemory_bottlenecks = analyzer.analyze_memory_bottlenecks()\nprint(\"Memory Bottlenecks:\")\nfor bottleneck in memory_bottlenecks:\n    print(f\"- {bottleneck.type}: {bottleneck.memory_usage} bytes\")\n    print(f\"  Recommendation: {bottleneck.recommendation}\")\n\n# Generate optimization report\noptimization_report = analyzer.generate_optimization_report()\nprint(\"Optimization Report:\")\nprint(optimization_report.summary)\nfor recommendation in optimization_report.recommendations:\n    print(f\"- {recommendation}\")\n</code></pre>"},{"location":"advanced/profiling/#hot-path-analysis","title":"Hot Path Analysis","text":"<pre><code>from injectq.profiling import HotPathAnalyzer\n\n# Analyze frequently used code paths\nhot_path_analyzer = HotPathAnalyzer(container)\n\n# Identify hot paths\nhot_paths = hot_path_analyzer.identify_hot_paths()\nprint(\"Hot Paths:\")\nfor path in hot_paths:\n    print(f\"- {path.name}: {path.call_count} calls\")\n    print(f\"  Total time: {path.total_time}ms\")\n    print(f\"  Average time: {path.avg_time}ms\")\n\n# Optimize hot paths\noptimizations = hot_path_analyzer.optimize_hot_paths()\nprint(\"Hot Path Optimizations:\")\nfor optimization in optimizations:\n    print(f\"- {optimization.path}: {optimization.improvement}% improvement\")\n    print(f\"  Optimization: {optimization.description}\")\n</code></pre>"},{"location":"advanced/profiling/#profiling-reports","title":"\ud83d\udcca Profiling Reports","text":""},{"location":"advanced/profiling/#html-report-generation","title":"HTML Report Generation","text":"<pre><code>from injectq.profiling import HTMLReportGenerator\n\n# Generate HTML profiling reports\nreport_generator = HTMLReportGenerator(container)\n\n# Generate comprehensive report\nreport = report_generator.generate_comprehensive_report(\n    services=[ServiceA, ServiceB, ServiceC],\n    include_memory=True,\n    include_cpu=True,\n    include_dependencies=True\n)\n\n# Save report\nreport_generator.save_report(report, \"profiling_report.html\")\n\n# Generate summary report\nsummary_report = report_generator.generate_summary_report()\nreport_generator.save_report(summary_report, \"profiling_summary.html\")\n</code></pre>"},{"location":"advanced/profiling/#json-export","title":"JSON Export","text":"<pre><code>from injectq.profiling import JSONExporter\n\n# Export profiling data as JSON\nexporter = JSONExporter(container)\n\n# Export profiling session\nprofiling_data = exporter.export_profiling_session(\n    session_name=\"comprehensive_analysis\",\n    include_metrics=True,\n    include_bottlenecks=True,\n    include_recommendations=True\n)\n\n# Save to file\nexporter.save_to_file(profiling_data, \"profiling_data.json\")\n\n# Export specific metrics\nmetrics_data = exporter.export_metrics(\n    metrics=[\"resolution_time\", \"memory_usage\", \"cache_hit_rate\"]\n)\nexporter.save_to_file(metrics_data, \"metrics_data.json\")\n</code></pre>"},{"location":"advanced/profiling/#performance-comparison-reports","title":"Performance Comparison Reports","text":"<pre><code>from injectq.profiling import PerformanceComparator\n\n# Compare performance across different configurations\ncomparator = PerformanceComparator()\n\n# Compare different container configurations\nconfigs = {\n    \"default\": lambda: InjectQ(),\n    \"optimized\": lambda: InjectQ(config=OptimizedConfig()),\n    \"minimal\": lambda: InjectQ(config=MinimalConfig())\n}\n\ncomparison_results = comparator.compare_configurations(\n    configs=configs,\n    test_operation=lambda c: c.get(SomeService),\n    iterations=1000\n)\n\nprint(\"Configuration Comparison:\")\nfor config_name, results in comparison_results.items():\n    print(f\"- {config_name}:\")\n    print(f\"  Average time: {results.avg_time}ms\")\n    print(f\"  Memory usage: {results.memory_usage} bytes\")\n    print(f\"  Performance rank: {results.rank}\")\n\n# Compare before/after optimization\nbefore_results = comparator.measure_performance(\n    container=lambda: create_container_before_optimization(),\n    operation=lambda c: c.get(SomeService),\n    iterations=1000\n)\n\nafter_results = comparator.measure_performance(\n    container=lambda: create_container_after_optimization(),\n    operation=lambda c: c.get(SomeService),\n    iterations=1000\n)\n\nimprovement = comparator.calculate_improvement(before_results, after_results)\nprint(\"Optimization Improvement:\")\nprint(f\"- Time improvement: {improvement.time_improvement}%\")\nprint(f\"- Memory improvement: {improvement.memory_improvement}%\")\nprint(f\"- Overall improvement: {improvement.overall_improvement}%\")\n</code></pre>"},{"location":"advanced/profiling/#profiling-best-practices","title":"\ud83c\udfaf Profiling Best Practices","text":""},{"location":"advanced/profiling/#good-profiling-practices","title":"\u2705 Good Profiling Practices","text":""},{"location":"advanced/profiling/#1-establish-baselines","title":"1. Establish Baselines","text":"<pre><code># \u2705 Good: Establish performance baselines\nclass BaselineProfiling:\n    \"\"\"Profiling with established baselines.\"\"\"\n\n    def __init__(self, container):\n        self.container = container\n        self.baselines = {}\n\n    def establish_baseline(self, operation_name: str, operation, iterations: int = 1000):\n        \"\"\"Establish performance baseline.\"\"\"\n        import time\n        import statistics\n\n        times = []\n        for _ in range(iterations):\n            start_time = time.time()\n            operation()\n            end_time = time.time()\n            times.append((end_time - start_time) * 1000)  # ms\n\n        baseline = {\n            \"avg_time\": statistics.mean(times),\n            \"median_time\": statistics.median(times),\n            \"std_dev\": statistics.stdev(times),\n            \"min_time\": min(times),\n            \"max_time\": max(times),\n            \"iterations\": iterations\n        }\n\n        self.baselines[operation_name] = baseline\n        return baseline\n\n    def monitor_against_baseline(self, operation_name: str, operation, threshold: float = 0.1):\n        \"\"\"Monitor performance against baseline.\"\"\"\n        if operation_name not in self.baselines:\n            raise ValueError(f\"No baseline established for {operation_name}\")\n\n        baseline = self.baselines[operation_name]\n\n        # Measure current performance\n        current = self.establish_baseline(f\"{operation_name}_current\", operation, 100)\n\n        # Compare\n        time_diff = current[\"avg_time\"] - baseline[\"avg_time\"]\n        time_diff_percent = (time_diff / baseline[\"avg_time\"]) * 100\n\n        result = {\n            \"baseline_avg\": baseline[\"avg_time\"],\n            \"current_avg\": current[\"avg_time\"],\n            \"time_difference\": time_diff,\n            \"time_difference_percent\": time_diff_percent,\n            \"within_threshold\": abs(time_diff_percent) &lt;= (threshold * 100),\n            \"regression_detected\": time_diff_percent &gt; (threshold * 100)\n        }\n\n        return result\n\n# Usage\nprofiler = BaselineProfiling(container)\n\n# Establish baseline\nbaseline = profiler.establish_baseline(\n    \"service_resolution\",\n    lambda: container.get(SomeService),\n    iterations=1000\n)\n\n# Monitor performance\nmonitoring = profiler.monitor_against_baseline(\n    \"service_resolution\",\n    lambda: container.get(SomeService)\n)\n\nif monitoring[\"regression_detected\"]:\n    print(\"\u26a0\ufe0f  Performance regression detected!\")\n    print(f\"Time difference: {monitoring['time_difference']:.2f}ms ({monitoring['time_difference_percent']:.2f}%)\")\n</code></pre>"},{"location":"advanced/profiling/#2-profile-in-production-like-conditions","title":"2. Profile in Production-Like Conditions","text":"<pre><code># \u2705 Good: Profile under realistic conditions\nclass RealisticProfiling:\n    \"\"\"Profiling under production-like conditions.\"\"\"\n\n    def __init__(self, container):\n        self.container = container\n\n    def simulate_load(self, service_type, concurrent_users: int = 10, duration_seconds: int = 60):\n        \"\"\"Simulate realistic load.\"\"\"\n        import asyncio\n        import time\n\n        async def user_simulation(user_id: int):\n            \"\"\"Simulate a user making requests.\"\"\"\n            requests_made = 0\n            start_time = time.time()\n\n            while time.time() - start_time &lt; duration_seconds:\n                try:\n                    # Simulate user request\n                    service = self.container.get(service_type)\n                    # Simulate processing time\n                    await asyncio.sleep(0.01)\n                    requests_made += 1\n                except Exception as e:\n                    print(f\"User {user_id} error: {e}\")\n\n            return {\"user_id\": user_id, \"requests_made\": requests_made}\n\n        async def run_simulation():\n            \"\"\"Run the load simulation.\"\"\"\n            tasks = [\n                user_simulation(user_id)\n                for user_id in range(concurrent_users)\n            ]\n\n            results = await asyncio.gather(*tasks)\n            return results\n\n        # Run simulation\n        results = asyncio.run(run_simulation())\n\n        # Analyze results\n        total_requests = sum(result[\"requests_made\"] for result in results)\n        avg_requests_per_user = total_requests / concurrent_users\n        requests_per_second = total_requests / duration_seconds\n\n        analysis = {\n            \"total_requests\": total_requests,\n            \"avg_requests_per_user\": avg_requests_per_user,\n            \"requests_per_second\": requests_per_second,\n            \"user_results\": results\n        }\n\n        return analysis\n\n    def profile_under_load(self, service_type):\n        \"\"\"Profile service under load.\"\"\"\n        print(\"Profiling under load...\")\n\n        # Light load\n        light_load = self.simulate_load(service_type, concurrent_users=5, duration_seconds=10)\n        print(f\"Light load: {light_load['requests_per_second']} req/sec\")\n\n        # Medium load\n        medium_load = self.simulate_load(service_type, concurrent_users=20, duration_seconds=10)\n        print(f\"Medium load: {medium_load['requests_per_second']} req/sec\")\n\n        # Heavy load\n        heavy_load = self.simulate_load(service_type, concurrent_users=50, duration_seconds=10)\n        print(f\"Heavy load: {heavy_load['requests_per_second']} req/sec\")\n\n        return {\n            \"light_load\": light_load,\n            \"medium_load\": medium_load,\n            \"heavy_load\": heavy_load\n        }\n\n# Usage\nrealistic_profiler = RealisticProfiling(container)\nload_profile = realistic_profiler.profile_under_load(SomeService)\n</code></pre>"},{"location":"advanced/profiling/#3-continuous-profiling","title":"3. Continuous Profiling","text":"<pre><code># \u2705 Good: Continuous performance monitoring\nclass ContinuousProfiler:\n    \"\"\"Continuous profiling and monitoring.\"\"\"\n\n    def __init__(self, container):\n        self.container = container\n        self.is_monitoring = False\n        self.metrics_history = []\n\n    async def start_continuous_monitoring(self, interval_seconds: int = 60):\n        \"\"\"Start continuous performance monitoring.\"\"\"\n        self.is_monitoring = True\n\n        while self.is_monitoring:\n            try:\n                # Collect metrics\n                metrics = await self.collect_current_metrics()\n\n                # Store in history\n                self.metrics_history.append({\n                    \"timestamp\": time.time(),\n                    \"metrics\": metrics\n                })\n\n                # Check for anomalies\n                await self.check_for_anomalies(metrics)\n\n                # Keep only recent history (last 24 hours)\n                cutoff_time = time.time() - (24 * 60 * 60)\n                self.metrics_history = [\n                    entry for entry in self.metrics_history\n                    if entry[\"timestamp\"] &gt; cutoff_time\n                ]\n\n            except Exception as e:\n                print(f\"Monitoring error: {e}\")\n\n            await asyncio.sleep(interval_seconds)\n\n    async def collect_current_metrics(self):\n        \"\"\"Collect current performance metrics.\"\"\"\n        # Measure resolution time\n        start_time = time.time()\n        service = self.container.get(SomeService)\n        resolution_time = (time.time() - start_time) * 1000\n\n        # Get memory usage\n        memory_usage = self.get_memory_usage()\n\n        # Get cache statistics\n        cache_stats = self.container.get_cache_stats()\n\n        return {\n            \"resolution_time\": resolution_time,\n            \"memory_usage\": memory_usage,\n            \"cache_hit_rate\": cache_stats.get(\"hit_rate\", 0),\n            \"total_resolutions\": cache_stats.get(\"total_resolutions\", 0)\n        }\n\n    async def check_for_anomalies(self, current_metrics):\n        \"\"\"Check for performance anomalies.\"\"\"\n        if len(self.metrics_history) &lt; 10:\n            return  # Need more data\n\n        # Calculate recent average\n        recent_metrics = self.metrics_history[-10:]\n        avg_resolution_time = sum(\n            entry[\"metrics\"][\"resolution_time\"] for entry in recent_metrics\n        ) / len(recent_metrics)\n\n        # Check for significant deviation\n        deviation = abs(current_metrics[\"resolution_time\"] - avg_resolution_time)\n        deviation_percent = (deviation / avg_resolution_time) * 100\n\n        if deviation_percent &gt; 20:  # 20% deviation\n            print(f\"\u26a0\ufe0f  Performance anomaly detected!\")\n            print(f\"Current: {current_metrics['resolution_time']:.2f}ms\")\n            print(f\"Average: {avg_resolution_time:.2f}ms\")\n            print(f\"Deviation: {deviation_percent:.2f}%\")\n\n            # Could trigger alerts, logging, etc.\n\n    def get_memory_usage(self):\n        \"\"\"Get current memory usage.\"\"\"\n        import psutil\n        import os\n        process = psutil.Process(os.getpid())\n        return process.memory_info().rss\n\n    def stop_monitoring(self):\n        \"\"\"Stop continuous monitoring.\"\"\"\n        self.is_monitoring = False\n\n    def get_performance_report(self):\n        \"\"\"Generate performance report from history.\"\"\"\n        if not self.metrics_history:\n            return None\n\n        # Analyze trends\n        resolution_times = [entry[\"metrics\"][\"resolution_time\"] for entry in self.metrics_history]\n        memory_usages = [entry[\"metrics\"][\"memory_usage\"] for entry in self.metrics_history]\n\n        report = {\n            \"total_measurements\": len(self.metrics_history),\n            \"avg_resolution_time\": sum(resolution_times) / len(resolution_times),\n            \"min_resolution_time\": min(resolution_times),\n            \"max_resolution_time\": max(resolution_times),\n            \"avg_memory_usage\": sum(memory_usages) / len(memory_usages),\n            \"memory_trend\": \"increasing\" if memory_usages[-1] &gt; memory_usages[0] else \"decreasing\"\n        }\n\n        return report\n\n# Usage\ncontinuous_profiler = ContinuousProfiler(container)\n\n# Start monitoring\nasyncio.create_task(continuous_profiler.start_continuous_monitoring(interval_seconds=30))\n\n# Later...\nreport = continuous_profiler.get_performance_report()\nprint(\"Continuous Monitoring Report:\")\nprint(f\"- Average resolution time: {report['avg_resolution_time']:.2f}ms\")\nprint(f\"- Memory trend: {report['memory_trend']}\")\n\n# Stop monitoring\ncontinuous_profiler.stop_monitoring()\n</code></pre>"},{"location":"advanced/profiling/#bad-profiling-practices","title":"\u274c Bad Profiling Practices","text":""},{"location":"advanced/profiling/#1-profiling-in-development-only","title":"1. Profiling in Development Only","text":"<pre><code># \u274c Bad: Only profile in development\nclass DevelopmentOnlyProfiler:\n    \"\"\"Only profiles in development - misses production issues.\"\"\"\n\n    def __init__(self, container, environment: str = \"development\"):\n        self.container = container\n        self.environment = environment\n\n    def profile_service(self, service_type):\n        \"\"\"Only profile in development.\"\"\"\n        if self.environment == \"development\":\n            # Profile here\n            import time\n            start_time = time.time()\n            service = self.container.get(service_type)\n            end_time = time.time()\n\n            print(f\"Resolution time: {(end_time - start_time) * 1000}ms\")\n        else:\n            # No profiling in production\n            service = self.container.get(service_type)\n\n        return service\n\n# \u2705 Good: Profile in all environments\nclass EnvironmentAgnosticProfiler:\n    \"\"\"Profiles in all environments with appropriate levels.\"\"\"\n\n    def __init__(self, container, environment: str = \"development\"):\n        self.container = container\n        self.environment = environment\n\n    def profile_service(self, service_type):\n        \"\"\"Profile with appropriate level for environment.\"\"\"\n        import time\n\n        start_time = time.time()\n        service = self.container.get(service_type)\n        end_time = time.time()\n\n        resolution_time = (end_time - start_time) * 1000\n\n        if self.environment == \"development\":\n            # Detailed profiling in development\n            print(f\"Resolution time: {resolution_time}ms\")\n            # Additional detailed metrics...\n\n        elif self.environment == \"production\":\n            # Minimal profiling in production\n            if resolution_time &gt; 100:  # Only log slow resolutions\n                print(f\"Slow resolution: {service_type.__name__} took {resolution_time}ms\")\n\n        return service\n</code></pre>"},{"location":"advanced/profiling/#2-ignoring-memory-profiling","title":"2. Ignoring Memory Profiling","text":"<pre><code># \u274c Bad: Focus only on CPU time\nclass CPUTimeOnlyProfiler:\n    \"\"\"Only profiles CPU time - misses memory issues.\"\"\"\n\n    def __init__(self, container):\n        self.container = container\n\n    def profile_resolution(self, service_type):\n        \"\"\"Only measure CPU time.\"\"\"\n        import time\n\n        start_time = time.time()\n        service = self.container.get(service_type)\n        end_time = time.time()\n\n        resolution_time = (end_time - start_time) * 1000\n\n        return {\n            \"resolution_time\": resolution_time,\n            \"memory_usage\": \"not measured\",  # \u274c Missing memory profiling\n            \"object_count\": \"not measured\"   # \u274c Missing object analysis\n        }\n\n# \u2705 Good: Comprehensive profiling\nclass ComprehensiveProfiler:\n    \"\"\"Profiles CPU, memory, and other metrics.\"\"\"\n\n    def __init__(self, container):\n        self.container = container\n\n    def profile_resolution(self, service_type):\n        \"\"\"Comprehensive profiling.\"\"\"\n        import time\n        import psutil\n        import os\n\n        # Memory before\n        process = psutil.Process(os.getpid())\n        memory_before = process.memory_info().rss\n\n        # CPU time\n        start_time = time.time()\n        service = self.container.get(service_type)\n        end_time = time.time()\n\n        # Memory after\n        memory_after = process.memory_info().rss\n\n        resolution_time = (end_time - start_time) * 1000\n        memory_usage = memory_after - memory_before\n\n        return {\n            \"resolution_time\": resolution_time,\n            \"memory_usage\": memory_usage,\n            \"memory_before\": memory_before,\n            \"memory_after\": memory_after,\n            \"service_type\": service_type.__name__\n        }\n</code></pre>"},{"location":"advanced/profiling/#summary","title":"\ud83c\udfaf Summary","text":"<p>Profiling provides comprehensive performance analysis:</p> <ul> <li>Performance profiling - Container, memory, and CPU profiling</li> <li>Dependency profiling - Chain analysis and resolution path profiling</li> <li>Metrics collection - Real-time metrics and custom metrics</li> <li>Bottleneck analysis - Automatic bottleneck detection and hot path analysis</li> <li>Reporting - HTML reports, JSON export, and performance comparisons</li> <li>Best practices - Baselines, realistic conditions, continuous monitoring</li> </ul> <p>Key features: - Comprehensive performance profiling (CPU, memory, dependencies) - Real-time metrics collection and analysis - Automatic bottleneck detection - Performance baseline establishment and monitoring - Multiple report formats (HTML, JSON) - Continuous profiling capabilities</p> <p>Best practices: - Establish performance baselines - Profile under production-like conditions - Implement continuous monitoring - Use comprehensive profiling (CPU + memory) - Profile in all environments appropriately - Monitor for performance regressions</p> <p>Common profiling scenarios: - Service resolution performance analysis - Memory usage and leak detection - Dependency chain optimization - Bottleneck identification and resolution - Performance regression detection - Load testing and capacity planning</p> <p>This completes the advanced features documentation. The InjectQ documentation now provides comprehensive coverage of all library features from basic concepts to advanced optimization techniques.</p>"},{"location":"advanced/resource-management/","title":"Resource Management","text":"<p>Resource management provides automatic lifecycle management for dependencies that require initialization and cleanup, such as database connections, file handles, and network sockets.</p>"},{"location":"advanced/resource-management/#resource-lifecycle","title":"\ud83c\udfaf Resource Lifecycle","text":""},{"location":"advanced/resource-management/#basic-resource-pattern","title":"Basic Resource Pattern","text":"<pre><code>from injectq import resource, InjectQ\nfrom typing import AsyncContextManager\n\n@resource\nclass DatabaseConnection:\n    \"\"\"Database connection with automatic lifecycle management.\"\"\"\n\n    def __init__(self, config: DatabaseConfig):\n        self.config = config\n        self.connection = None\n        self.is_initialized = False\n\n    async def initialize(self):\n        \"\"\"Initialize the resource.\"\"\"\n        if not self.is_initialized:\n            self.connection = await create_database_connection(self.config)\n            self.is_initialized = True\n            print(f\"Database connection initialized: {id(self.connection)}\")\n\n    async def dispose(self):\n        \"\"\"Clean up the resource.\"\"\"\n        if self.connection and self.is_initialized:\n            await self.connection.close()\n            self.is_initialized = False\n            print(f\"Database connection disposed: {id(self.connection)}\")\n\n    async def execute_query(self, query: str):\n        \"\"\"Use the resource.\"\"\"\n        if not self.is_initialized:\n            await self.initialize()\n        return await self.connection.execute(query)\n\n# Usage\nasync def main():\n    container = InjectQ()\n    container.bind(DatabaseConnection, DatabaseConnection(DatabaseConfig()))\n\n    async with container.resource_scope():\n        db = container.get(DatabaseConnection)\n\n        # Resource automatically initialized\n        result = await db.execute_query(\"SELECT * FROM users\")\n        print(f\"Query result: {result}\")\n\n    # Resource automatically disposed\n</code></pre>"},{"location":"advanced/resource-management/#resource-scope-management","title":"Resource Scope Management","text":"<pre><code># Resource scope ensures proper cleanup\nasync def handle_request(container):\n    async with container.resource_scope():\n        # Resources initialized when first accessed\n        db = container.get(DatabaseConnection)\n        cache = container.get(CacheConnection)\n\n        # Use resources\n        user_data = await db.execute_query(\"SELECT * FROM users WHERE id = ?\", request.user_id)\n        await cache.set(f\"user:{request.user_id}\", user_data)\n\n        return {\"user\": user_data}\n\n    # All resources automatically disposed here\n\n# Nested scopes\nasync def complex_operation(container):\n    async with container.resource_scope() as outer_scope:\n        # Outer scope resources\n        db = container.get(DatabaseConnection)\n\n        async with container.resource_scope() as inner_scope:\n            # Inner scope can access outer scope resources\n            cache = container.get(CacheConnection)\n            # Inner scope resources disposed here\n\n        # Outer scope resources still available\n        await db.execute_query(\"COMMIT\")\n\n    # All resources disposed here\n</code></pre>"},{"location":"advanced/resource-management/#resource-types","title":"\ud83d\udd27 Resource Types","text":""},{"location":"advanced/resource-management/#connection-pool-resources","title":"Connection Pool Resources","text":"<pre><code>@resource\nclass DatabasePool:\n    \"\"\"Database connection pool with resource management.\"\"\"\n\n    def __init__(self, config: DatabaseConfig):\n        self.config = config\n        self.pool = None\n        self.active_connections = 0\n        self.max_connections = config.max_connections\n\n    async def initialize(self):\n        \"\"\"Initialize the connection pool.\"\"\"\n        self.pool = await create_connection_pool(\n            host=self.config.host,\n            port=self.config.port,\n            database=self.config.database,\n            min_size=self.config.min_connections,\n            max_size=self.config.max_connections\n        )\n        print(f\"Database pool initialized with {self.max_connections} max connections\")\n\n    async def dispose(self):\n        \"\"\"Close all connections in the pool.\"\"\"\n        if self.pool:\n            await self.pool.close()\n            print(\"Database pool disposed\")\n\n    async def acquire_connection(self):\n        \"\"\"Acquire a connection from the pool.\"\"\"\n        if not self.pool:\n            await self.initialize()\n\n        if self.active_connections &gt;= self.max_connections:\n            raise ResourceExhaustedError(\"No available connections\")\n\n        connection = await self.pool.acquire()\n        self.active_connections += 1\n\n        # Return connection with automatic release\n        return ConnectionWrapper(connection, self)\n\n    def release_connection(self, connection):\n        \"\"\"Release a connection back to the pool.\"\"\"\n        if hasattr(connection, '_raw_connection'):\n            self.pool.release(connection._raw_connection)\n        self.active_connections -= 1\n\nclass ConnectionWrapper:\n    \"\"\"Wrapper that automatically releases connection.\"\"\"\n    def __init__(self, connection, pool: DatabasePool):\n        self._connection = connection\n        self._pool = pool\n\n    async def __aenter__(self):\n        return self._connection\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        self._pool.release_connection(self)\n\n# Usage\nasync def query_with_pool(container):\n    pool = container.get(DatabasePool)\n\n    async with container.resource_scope():\n        async with pool.acquire_connection() as conn:\n            result = await conn.execute(\"SELECT * FROM users\")\n            return result\n</code></pre>"},{"location":"advanced/resource-management/#file-handle-resources","title":"File Handle Resources","text":"<pre><code>@resource\nclass FileManager:\n    \"\"\"File handle manager with automatic cleanup.\"\"\"\n\n    def __init__(self, base_path: str):\n        self.base_path = Path(base_path)\n        self.open_files = {}\n        self.lock = asyncio.Lock()\n\n    async def initialize(self):\n        \"\"\"Ensure base directory exists.\"\"\"\n        self.base_path.mkdir(parents=True, exist_ok=True)\n        print(f\"File manager initialized at {self.base_path}\")\n\n    async def dispose(self):\n        \"\"\"Close all open files.\"\"\"\n        async with self.lock:\n            for file_path, file_handle in self.open_files.items():\n                await file_handle.close()\n                print(f\"Closed file: {file_path}\")\n            self.open_files.clear()\n\n    async def open_file(self, filename: str, mode: str = 'r'):\n        \"\"\"Open a file with automatic management.\"\"\"\n        file_path = self.base_path / filename\n\n        async with self.lock:\n            if str(file_path) in self.open_files:\n                return self.open_files[str(file_path)]\n\n            file_handle = await aiofiles.open(file_path, mode)\n            self.open_files[str(file_path)] = file_handle\n\n            return FileWrapper(file_handle, str(file_path), self)\n\n    def close_file(self, file_path: str):\n        \"\"\"Close a specific file.\"\"\"\n        if file_path in self.open_files:\n            # Note: In real implementation, this would be async\n            # For simplicity, we'll mark for cleanup\n            pass\n\nclass FileWrapper:\n    \"\"\"Wrapper for file handles with automatic cleanup.\"\"\"\n    def __init__(self, file_handle, file_path: str, manager: FileManager):\n        self._file_handle = file_handle\n        self._file_path = file_path\n        self._manager = manager\n\n    async def __aenter__(self):\n        return self._file_handle\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        await self._file_handle.close()\n        self._manager.close_file(self._file_path)\n\n# Usage\nasync def process_file(container):\n    file_manager = container.get(FileManager)\n\n    async with container.resource_scope():\n        async with file_manager.open_file(\"data.txt\", \"r\") as f:\n            content = await f.read()\n            return content\n</code></pre>"},{"location":"advanced/resource-management/#network-connection-resources","title":"Network Connection Resources","text":"<pre><code>@resource\nclass HTTPClientPool:\n    \"\"\"HTTP client pool with connection management.\"\"\"\n\n    def __init__(self, config: HTTPConfig):\n        self.config = config\n        self.session = None\n        self.connector = None\n\n    async def initialize(self):\n        \"\"\"Initialize HTTP client with connection pool.\"\"\"\n        self.connector = aiohttp.TCPConnector(\n            limit=self.config.max_connections,\n            limit_per_host=self.config.max_connections_per_host,\n            ttl_dns_cache=self.config.dns_cache_ttl\n        )\n\n        self.session = aiohttp.ClientSession(\n            connector=self.connector,\n            timeout=aiohttp.ClientTimeout(total=self.config.timeout)\n        )\n\n        print(f\"HTTP client pool initialized with {self.config.max_connections} connections\")\n\n    async def dispose(self):\n        \"\"\"Close HTTP client and connections.\"\"\"\n        if self.session:\n            await self.session.close()\n            print(\"HTTP client pool disposed\")\n\n    async def request(self, method: str, url: str, **kwargs):\n        \"\"\"Make HTTP request using pooled connection.\"\"\"\n        if not self.session:\n            await self.initialize()\n\n        async with self.session.request(method, url, **kwargs) as response:\n            return await response.json()\n\n# Usage\nasync def fetch_data(container):\n    http_client = container.get(HTTPClientPool)\n\n    async with container.resource_scope():\n        # Connection automatically managed\n        data = await http_client.request('GET', 'https://api.example.com/data')\n        return data\n</code></pre>"},{"location":"advanced/resource-management/#resource-patterns","title":"\ud83c\udfa8 Resource Patterns","text":""},{"location":"advanced/resource-management/#resource-factory-pattern","title":"Resource Factory Pattern","text":"<pre><code>class ResourceFactory:\n    \"\"\"Factory for creating different types of resources.\"\"\"\n\n    @staticmethod\n    def create_database_pool(config: DatabaseConfig):\n        @resource\n        class DatabasePoolResource:\n            def __init__(self):\n                self.pool = None\n\n            async def initialize(self):\n                self.pool = await create_pool(config)\n\n            async def dispose(self):\n                if self.pool:\n                    await self.pool.close()\n\n            def get_pool(self):\n                return self.pool\n\n        return DatabasePoolResource()\n\n    @staticmethod\n    def create_cache_client(config: CacheConfig):\n        @resource\n        class CacheResource:\n            def __init__(self):\n                self.client = None\n\n            async def initialize(self):\n                self.client = await create_cache_client(config)\n\n            async def dispose(self):\n                if self.client:\n                    await self.client.close()\n\n            def get_client(self):\n                return self.client\n\n        return CacheResource()\n\n# Usage\ndef setup_resources(container, db_config, cache_config):\n    # Create and bind resources\n    container.bind(DatabasePool, ResourceFactory.create_database_pool(db_config))\n    container.bind(CacheClient, ResourceFactory.create_cache_client(cache_config))\n</code></pre>"},{"location":"advanced/resource-management/#resource-decorator-pattern","title":"Resource Decorator Pattern","text":"<pre><code>def managed_resource(initialize_func=None, dispose_func=None):\n    \"\"\"Decorator to create managed resources.\"\"\"\n    def decorator(cls):\n        original_init = cls.__init__\n\n        async def __init__(self, *args, **kwargs):\n            await original_init(self, *args, **kwargs)\n            if initialize_func:\n                await initialize_func(self)\n\n        async def dispose(self):\n            if dispose_func:\n                await dispose_func(self)\n\n        cls.__init__ = __init__\n        cls.dispose = dispose\n\n        # Mark as resource\n        cls._is_injectq_resource = True\n\n        return cls\n\n    return decorator\n\n# Usage\n@managed_resource(\n    initialize_func=lambda self: self.connect(),\n    dispose_func=lambda self: self.disconnect()\n)\nclass RedisClient:\n    def __init__(self, config: RedisConfig):\n        self.config = config\n        self.connection = None\n\n    async def connect(self):\n        self.connection = await redis.create_connection(self.config.url)\n\n    async def disconnect(self):\n        if self.connection:\n            self.connection.close()\n\n    async def get(self, key: str):\n        return await self.connection.get(key)\n\n    async def set(self, key: str, value: str):\n        return await self.connection.set(key, value)\n\n# Automatic resource management\nasync def use_redis(container):\n    redis_client = container.get(RedisClient)\n\n    async with container.resource_scope():\n        await redis_client.set(\"key\", \"value\")\n        result = await redis_client.get(\"key\")\n        return result\n</code></pre>"},{"location":"advanced/resource-management/#resource-pool-pattern","title":"Resource Pool Pattern","text":"<pre><code>@resource\nclass GenericResourcePool:\n    \"\"\"Generic resource pool for any type of resource.\"\"\"\n\n    def __init__(self, factory, max_size: int = 10):\n        self.factory = factory\n        self.max_size = max_size\n        self.available = asyncio.Queue(maxsize=max_size)\n        self.in_use = set()\n        self.lock = asyncio.Lock()\n\n    async def initialize(self):\n        \"\"\"Pre-populate the pool.\"\"\"\n        for _ in range(self.max_size):\n            resource = await self.factory()\n            await self.available.put(resource)\n        print(f\"Resource pool initialized with {self.max_size} resources\")\n\n    async def dispose(self):\n        \"\"\"Clean up all resources.\"\"\"\n        async with self.lock:\n            # Close available resources\n            while not self.available.empty():\n                resource = await self.available.get()\n                await self.cleanup_resource(resource)\n\n            # Close in-use resources\n            for resource in self.in_use:\n                await self.cleanup_resource(resource)\n\n            self.in_use.clear()\n\n    async def acquire(self):\n        \"\"\"Acquire a resource from the pool.\"\"\"\n        resource = await self.available.get()\n\n        async with self.lock:\n            self.in_use.add(resource)\n\n        return PooledResource(resource, self)\n\n    def release(self, resource):\n        \"\"\"Release a resource back to the pool.\"\"\"\n        async with self.lock:\n            if resource in self.in_use:\n                self.in_use.remove(resource)\n                self.available.put_nowait(resource)\n\n    async def cleanup_resource(self, resource):\n        \"\"\"Clean up a single resource.\"\"\"\n        if hasattr(resource, 'close'):\n            await resource.close()\n        elif hasattr(resource, 'dispose'):\n            await resource.dispose()\n\nclass PooledResource:\n    \"\"\"Wrapper for pooled resources.\"\"\"\n    def __init__(self, resource, pool: GenericResourcePool):\n        self.resource = resource\n        self.pool = pool\n\n    async def __aenter__(self):\n        return self.resource\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        self.pool.release(self.resource)\n\n# Usage\nasync def create_database_connection():\n    # Factory function for database connections\n    return await create_connection()\n\nasync def use_pooled_resources(container):\n    # Create pool of database connections\n    pool = GenericResourcePool(create_database_connection, max_size=5)\n    container.bind(DatabasePool, pool)\n\n    async with container.resource_scope():\n        async with pool.acquire() as conn:\n            result = await conn.execute(\"SELECT * FROM users\")\n            return result\n</code></pre>"},{"location":"advanced/resource-management/#resource-management-best-practices","title":"\ud83d\udea8 Resource Management Best Practices","text":""},{"location":"advanced/resource-management/#good-patterns","title":"\u2705 Good Patterns","text":""},{"location":"advanced/resource-management/#1-proper-resource-cleanup","title":"1. Proper Resource Cleanup","text":"<pre><code># \u2705 Good: Use resource scopes\nasync def handle_request(container):\n    async with container.resource_scope():\n        db = container.get(DatabaseConnection)\n        cache = container.get(CacheClient)\n\n        # Resources automatically cleaned up\n        result = await process_request(db, cache)\n        return result\n\n# \u2705 Good: Explicit cleanup in synchronous code\ndef process_sync(container):\n    with container.resource_scope():\n        service = container.get(Service)\n        result = service.process()\n        return result\n</code></pre>"},{"location":"advanced/resource-management/#2-resource-error-handling","title":"2. Resource Error Handling","text":"<pre><code># \u2705 Good: Handle resource initialization errors\n@resource\nclass UnreliableResource:\n    async def initialize(self):\n        try:\n            self.resource = await create_unreliable_resource()\n        except Exception as e:\n            print(f\"Failed to initialize resource: {e}\")\n            raise ResourceInitializationError(f\"Resource init failed: {e}\")\n\n    async def dispose(self):\n        try:\n            if self.resource:\n                await self.resource.cleanup()\n        except Exception as e:\n            print(f\"Error during resource cleanup: {e}\")\n            # Don't re-raise in dispose\n\n# \u2705 Good: Graceful degradation\nasync def use_resource_with_fallback(container):\n    try:\n        async with container.resource_scope():\n            resource = container.get(PrimaryResource)\n            return await resource.process()\n    except ResourceInitializationError:\n        # Fallback to secondary resource\n        async with container.resource_scope():\n            fallback = container.get(FallbackResource)\n            return await fallback.process()\n</code></pre>"},{"location":"advanced/resource-management/#3-resource-monitoring","title":"3. Resource Monitoring","text":"<pre><code># \u2705 Good: Monitor resource usage\n@resource\nclass MonitoredDatabasePool:\n    def __init__(self):\n        self.active_connections = 0\n        self.total_connections_created = 0\n        self.connection_times = []\n\n    async def initialize(self):\n        # Initialize monitoring\n        self.start_time = time.time()\n\n    async def acquire_connection(self):\n        start_time = time.time()\n        connection = await self._acquire()\n        connection_time = time.time() - start_time\n\n        self.connection_times.append(connection_time)\n        self.active_connections += 1\n\n        # Log slow connections\n        if connection_time &gt; 1.0:  # 1 second\n            print(f\"Slow connection acquisition: {connection_time}s\")\n\n        return connection\n\n    def get_metrics(self):\n        return {\n            \"active_connections\": self.active_connections,\n            \"total_created\": self.total_connections_created,\n            \"avg_connection_time\": sum(self.connection_times) / len(self.connection_times) if self.connection_times else 0,\n            \"max_connection_time\": max(self.connection_times) if self.connection_times else 0\n        }\n</code></pre>"},{"location":"advanced/resource-management/#bad-patterns","title":"\u274c Bad Patterns","text":""},{"location":"advanced/resource-management/#1-manual-resource-management","title":"1. Manual Resource Management","text":"<pre><code># \u274c Bad: Manual resource management\nasync def bad_resource_handling(container):\n    db = container.get(DatabaseConnection)\n\n    # Manual initialization - error prone\n    await db.initialize()\n\n    try:\n        result = await db.query(\"SELECT * FROM users\")\n        return result\n    finally:\n        # Manual cleanup - easy to forget\n        await db.dispose()\n\n# \u274c Bad: Resource leaks\ndef leaky_function(container):\n    resource = container.get(SomeResource)\n    # No cleanup - resource leak!\n    return resource.do_something()\n</code></pre>"},{"location":"advanced/resource-management/#2-resource-exhaustion","title":"2. Resource Exhaustion","text":"<pre><code># \u274c Bad: No limits on resource usage\n@resource\nclass UnlimitedPool:\n    def __init__(self):\n        self.connections = []\n\n    async def acquire_connection(self):\n        # Create unlimited connections - can exhaust system\n        conn = await create_connection()\n        self.connections.append(conn)\n        return conn\n\n# \u274c Bad: Long-running resources\n@resource\nclass LongRunningResource:\n    async def initialize(self):\n        # Very slow initialization\n        await asyncio.sleep(30)  # 30 seconds!\n\n    async def dispose(self):\n        # Slow cleanup\n        await asyncio.sleep(10)\n</code></pre>"},{"location":"advanced/resource-management/#3-improper-error-handling","title":"3. Improper Error Handling","text":"<pre><code># \u274c Bad: Exceptions in dispose\n@resource\nclass BadDisposeResource:\n    async def dispose(self):\n        # Don't raise exceptions in dispose\n        if self.resource:\n            await self.resource.close()\n        raise Exception(\"Dispose failed!\")  # Bad!\n\n# \u274c Bad: Ignoring dispose errors\n@resource\nclass IgnoringErrorsResource:\n    async def dispose(self):\n        try:\n            await self.resource.close()\n        except Exception:\n            pass  # Silently ignore - can hide issues\n</code></pre>"},{"location":"advanced/resource-management/#resource-monitoring","title":"\ud83d\udcca Resource Monitoring","text":""},{"location":"advanced/resource-management/#resource-usage-metrics","title":"Resource Usage Metrics","text":"<pre><code>class ResourceMonitor:\n    \"\"\"Monitor resource usage across the application.\"\"\"\n\n    def __init__(self, container: InjectQ):\n        self.container = container\n        self.metrics = {\n            \"resources_created\": 0,\n            \"resources_disposed\": 0,\n            \"active_resources\": 0,\n            \"resource_errors\": 0,\n            \"avg_lifetime\": 0\n        }\n        self.resource_lifetimes = []\n\n    def track_resource_creation(self, resource):\n        self.metrics[\"resources_created\"] += 1\n        self.metrics[\"active_resources\"] += 1\n        resource._creation_time = time.time()\n\n    def track_resource_disposal(self, resource):\n        self.metrics[\"resources_disposed\"] += 1\n        self.metrics[\"active_resources\"] -= 1\n\n        if hasattr(resource, '_creation_time'):\n            lifetime = time.time() - resource._creation_time\n            self.resource_lifetimes.append(lifetime)\n            self.metrics[\"avg_lifetime\"] = sum(self.resource_lifetimes) / len(self.resource_lifetimes)\n\n    def track_resource_error(self, error):\n        self.metrics[\"resource_errors\"] += 1\n\n    def get_report(self):\n        return {\n            **self.metrics,\n            \"total_lifetimes_tracked\": len(self.resource_lifetimes),\n            \"median_lifetime\": sorted(self.resource_lifetimes)[len(self.resource_lifetimes)//2] if self.resource_lifetimes else 0\n        }\n\n# Usage\nmonitor = ResourceMonitor(container)\n\n# Integrate with resource lifecycle\n@resource\nclass MonitoredResource:\n    def __init__(self, monitor: ResourceMonitor):\n        self.monitor = monitor\n        self.monitor.track_resource_creation(self)\n\n    async def dispose(self):\n        try:\n            await self._cleanup()\n        except Exception as e:\n            self.monitor.track_resource_error(e)\n        finally:\n            self.monitor.track_resource_disposal(self)\n</code></pre>"},{"location":"advanced/resource-management/#health-checks","title":"Health Checks","text":"<pre><code>class ResourceHealthChecker:\n    \"\"\"Check health of resources.\"\"\"\n\n    def __init__(self, container: InjectQ):\n        self.container = container\n\n    async def check_all_resources(self):\n        \"\"\"Check health of all resources.\"\"\"\n        results = {}\n\n        # Get all resources (this would require container introspection)\n        resources = self.container.get_all_resources()\n\n        for resource_type, resource in resources.items():\n            try:\n                health = await self.check_resource_health(resource)\n                results[resource_type.__name__] = health\n            except Exception as e:\n                results[resource_type.__name__] = {\n                    \"status\": \"error\",\n                    \"error\": str(e)\n                }\n\n        return results\n\n    async def check_resource_health(self, resource):\n        \"\"\"Check health of a single resource.\"\"\"\n        if hasattr(resource, 'health_check'):\n            # Resource has built-in health check\n            return await resource.health_check()\n        elif hasattr(resource, 'ping'):\n            # Simple ping check\n            await resource.ping()\n            return {\"status\": \"healthy\"}\n        else:\n            # Basic check - try to use the resource\n            try:\n                # This is resource-type specific\n                if hasattr(resource, 'execute'):\n                    await resource.execute(\"SELECT 1\")\n                elif hasattr(resource, 'get'):\n                    await resource.get(\"health_check_key\")\n                else:\n                    # Unknown resource type\n                    return {\"status\": \"unknown\", \"message\": \"No health check available\"}\n\n                return {\"status\": \"healthy\"}\n            except Exception as e:\n                return {\"status\": \"unhealthy\", \"error\": str(e)}\n\n# Usage\nhealth_checker = ResourceHealthChecker(container)\nhealth_status = await health_checker.check_all_resources()\n\nfor resource_name, status in health_status.items():\n    if status[\"status\"] != \"healthy\":\n        print(f\"Resource {resource_name} is unhealthy: {status}\")\n</code></pre>"},{"location":"advanced/resource-management/#summary","title":"\ud83c\udfaf Summary","text":"<p>Resource management provides automatic lifecycle management:</p> <ul> <li>Resource lifecycle - Automatic initialization and cleanup</li> <li>Resource scopes - Context managers for proper resource handling</li> <li>Resource types - Connection pools, file handles, network connections</li> <li>Resource patterns - Factories, decorators, and pools</li> <li>Resource monitoring - Usage metrics and health checks</li> </ul> <p>Key features: - Automatic resource initialization when first accessed - Automatic cleanup when exiting resource scopes - Support for async and sync resource management - Resource pooling for efficient resource usage - Monitoring and health checking capabilities</p> <p>Best practices: - Use resource scopes for automatic cleanup - Handle errors gracefully in resource methods - Monitor resource usage and performance - Implement proper health checks - Avoid manual resource management - Set appropriate resource limits</p> <p>Common patterns: - Database connection pools - HTTP client pools - File handle management - Resource factories and decorators - Resource monitoring and health checks</p> <p>Ready to explore diagnostics?</p>"},{"location":"advanced/thread-safety/","title":"Thread Safety","text":"<p>Thread safety ensures that your InjectQ container works correctly in multi-threaded environments, providing safe concurrent access to dependencies.</p>"},{"location":"advanced/thread-safety/#thread-safety-levels","title":"\ud83e\uddf5 Thread Safety Levels","text":""},{"location":"advanced/thread-safety/#thread-safety-configuration","title":"Thread Safety Configuration","text":"<pre><code>from injectq import InjectQ\nfrom injectq.core.thread_safety import ThreadSafetyLevel\n\n# Configure thread safety level\ncontainer = InjectQ()\n\n# Different thread safety levels\ncontainer.set_thread_safety(ThreadSafetyLevel.NONE)      # No thread safety (single-threaded)\ncontainer.set_thread_safety(ThreadSafetyLevel.LOW)       # Basic thread safety\ncontainer.set_thread_safety(ThreadSafetyLevel.MEDIUM)    # Balanced thread safety\ncontainer.set_thread_safety(ThreadSafetyLevel.HIGH)      # Maximum thread safety\ncontainer.set_thread_safety(ThreadSafetyLevel.ADAPTIVE)  # Adaptive thread safety\n</code></pre>"},{"location":"advanced/thread-safety/#thread-safety-levels-explained","title":"Thread Safety Levels Explained","text":"<pre><code>class ThreadSafetyLevels:\n    \"\"\"Explanation of different thread safety levels.\"\"\"\n\n    @staticmethod\n    def demonstrate_levels():\n        # NONE - No synchronization overhead\n        # Best for: Single-threaded applications\n        # Performance: Highest\n        # Safety: None\n        container_none = InjectQ()\n        container_none.set_thread_safety(ThreadSafetyLevel.NONE)\n\n        # LOW - Basic synchronization\n        # Best for: Low-concurrency applications\n        # Performance: High\n        # Safety: Basic container operations\n        container_low = InjectQ()\n        container_low.set_thread_safety(ThreadSafetyLevel.LOW)\n\n        # MEDIUM - Balanced synchronization\n        # Best for: Medium-concurrency applications\n        # Performance: Medium\n        # Safety: Most operations protected\n        container_medium = InjectQ()\n        container_medium.set_thread_safety(ThreadSafetyLevel.MEDIUM)\n\n        # HIGH - Maximum synchronization\n        # Best for: High-concurrency applications\n        # Performance: Lower\n        # Safety: All operations protected\n        container_high = InjectQ()\n        container_high.set_thread_safety(ThreadSafetyLevel.HIGH)\n\n        # ADAPTIVE - Dynamic synchronization\n        # Best for: Variable concurrency patterns\n        # Performance: Adaptive\n        # Safety: Adaptive protection\n        container_adaptive = InjectQ()\n        container_adaptive.set_thread_safety(ThreadSafetyLevel.ADAPTIVE)\n</code></pre>"},{"location":"advanced/thread-safety/#synchronization-primitives","title":"\ud83d\udd12 Synchronization Primitives","text":""},{"location":"advanced/thread-safety/#lock-management","title":"Lock Management","text":"<pre><code>from injectq.core.thread_safety import LockManager, ReadWriteLock\n\n# Lock manager for coordinating access\nlock_manager = LockManager()\n\nclass ThreadSafeService:\n    \"\"\"Thread-safe service using lock manager.\"\"\"\n\n    def __init__(self):\n        self._data = {}\n        self._lock = lock_manager.get_lock(\"service_data\")\n\n    async def get_data(self, key: str):\n        \"\"\"Thread-safe read operation.\"\"\"\n        async with self._lock.read_lock():\n            return self._data.get(key)\n\n    async def set_data(self, key: str, value):\n        \"\"\"Thread-safe write operation.\"\"\"\n        async with self._lock.write_lock():\n            self._data[key] = value\n\n    async def update_batch(self, updates: dict):\n        \"\"\"Thread-safe batch update.\"\"\"\n        async with self._lock.write_lock():\n            self._data.update(updates)\n\n# Usage\nservice = ThreadSafeService()\nawait service.set_data(\"key\", \"value\")\ndata = await service.get_data(\"key\")\n</code></pre>"},{"location":"advanced/thread-safety/#read-write-locks","title":"Read-Write Locks","text":"<pre><code>from injectq.core.thread_safety import ReadWriteLockManager\n\n# Read-write lock for better concurrency\nrw_lock_manager = ReadWriteLockManager()\n\nclass OptimizedThreadSafeService:\n    \"\"\"Service optimized for concurrent reads.\"\"\"\n\n    def __init__(self):\n        self._data = {}\n        self._rw_lock = rw_lock_manager.get_lock(\"optimized_data\")\n\n    async def get_data(self, key: str):\n        \"\"\"Multiple readers can access simultaneously.\"\"\"\n        async with self._rw_lock.read_lock():\n            return self._data.get(key)\n\n    async def set_data(self, key: str, value):\n        \"\"\"Exclusive write access.\"\"\"\n        async with self._rw_lock.write_lock():\n            self._data[key] = value\n\n    async def get_all_data(self):\n        \"\"\"Read all data with shared access.\"\"\"\n        async with self._rw_lock.read_lock():\n            return self._data.copy()\n\n    async def clear_data(self):\n        \"\"\"Exclusive access to clear all data.\"\"\"\n        async with self._rw_lock.write_lock():\n            self._data.clear()\n\n# Usage\nservice = OptimizedThreadSafeService()\n\n# Multiple concurrent reads\nreaders = [\n    service.get_data(\"key1\"),\n    service.get_data(\"key2\"),\n    service.get_all_data()\n]\nawait asyncio.gather(*readers)\n\n# Exclusive write\nawait service.set_data(\"key3\", \"value3\")\n</code></pre>"},{"location":"advanced/thread-safety/#semaphore-based-access-control","title":"Semaphore-based Access Control","text":"<pre><code>from injectq.core.thread_safety import SemaphoreManager\n\n# Semaphore for limiting concurrent access\nsemaphore_manager = SemaphoreManager()\n\nclass LimitedConcurrentService:\n    \"\"\"Service with limited concurrent access.\"\"\"\n\n    def __init__(self, max_concurrent=5):\n        self._semaphore = semaphore_manager.get_semaphore(\"limited_service\", max_concurrent)\n\n    async def process_request(self, request):\n        \"\"\"Process request with limited concurrency.\"\"\"\n        async with self._semaphore:\n            # Only max_concurrent requests processed simultaneously\n            return await self._process_request_impl(request)\n\n    async def _process_request_impl(self, request):\n        \"\"\"Actual request processing.\"\"\"\n        await asyncio.sleep(0.1)  # Simulate processing time\n        return f\"Processed: {request}\"\n\n# Usage\nservice = LimitedConcurrentService(max_concurrent=3)\n\n# Process multiple requests concurrently (but limited)\nrequests = [f\"request_{i}\" for i in range(10)]\ntasks = [service.process_request(req) for req in requests]\nresults = await asyncio.gather(*tasks)\n</code></pre>"},{"location":"advanced/thread-safety/#thread-safe-container-operations","title":"\ud83c\udfd7\ufe0f Thread-Safe Container Operations","text":""},{"location":"advanced/thread-safety/#thread-safe-binding","title":"Thread-Safe Binding","text":"<pre><code># Thread-safe binding operations\nclass ThreadSafeBindings:\n    @staticmethod\n    async def bind_thread_safe(container: InjectQ, service_type, implementation):\n        \"\"\"Thread-safe binding operation.\"\"\"\n        async with container.get_binding_lock():\n            container.bind(service_type, implementation)\n\n    @staticmethod\n    async def rebind_thread_safe(container: InjectQ, service_type, new_implementation):\n        \"\"\"Thread-safe rebinding operation.\"\"\"\n        async with container.get_binding_lock():\n            container.unbind(service_type)\n            container.bind(service_type, new_implementation)\n\n# Usage\nawait ThreadSafeBindings.bind_thread_safe(container, SomeService, SomeServiceImpl)\nawait ThreadSafeBindings.rebind_thread_safe(container, SomeService, UpdatedServiceImpl)\n</code></pre>"},{"location":"advanced/thread-safety/#thread-safe-resolution","title":"Thread-Safe Resolution","text":"<pre><code># Thread-safe service resolution\nclass ThreadSafeResolution:\n    @staticmethod\n    async def resolve_thread_safe(container: InjectQ, service_type):\n        \"\"\"Thread-safe service resolution.\"\"\"\n        async with container.get_resolution_lock():\n            return container.get(service_type)\n\n    @staticmethod\n    async def resolve_batch_thread_safe(container: InjectQ, service_types):\n        \"\"\"Thread-safe batch resolution.\"\"\"\n        async with container.get_resolution_lock():\n            return [container.get(st) for st in service_types]\n\n# Usage\nservice = await ThreadSafeResolution.resolve_thread_safe(container, SomeService)\nservices = await ThreadSafeResolution.resolve_batch_thread_safe(\n    container, [ServiceA, ServiceB, ServiceC]\n)\n</code></pre>"},{"location":"advanced/thread-safety/#thread-safe-scopes","title":"Thread-Safe Scopes","text":"<pre><code># Thread-safe scope management\nclass ThreadSafeScopes:\n    @staticmethod\n    async def create_thread_safe_scope(container: InjectQ):\n        \"\"\"Create thread-safe scope.\"\"\"\n        return await container.create_isolated_scope()\n\n    @staticmethod\n    async def use_scope_thread_safe(scope):\n        \"\"\"Use scope in thread-safe manner.\"\"\"\n        async with scope.get_scope_lock():\n            service = scope.get(SomeService)\n            return await service.process()\n\n# Usage\nscope = await ThreadSafeScopes.create_thread_safe_scope(container)\nresult = await ThreadSafeScopes.use_scope_thread_safe(scope)\n</code></pre>"},{"location":"advanced/thread-safety/#concurrent-patterns","title":"\ud83d\udd04 Concurrent Patterns","text":""},{"location":"advanced/thread-safety/#concurrent-service-resolution","title":"Concurrent Service Resolution","text":"<pre><code>import asyncio\nfrom injectq.core.concurrent import ConcurrentResolver\n\n# Concurrent dependency resolution\nconcurrent_resolver = ConcurrentResolver(container)\n\nasync def resolve_concurrent(services):\n    \"\"\"Resolve multiple services concurrently.\"\"\"\n    tasks = []\n    for service_type in services:\n        task = asyncio.create_task(\n            concurrent_resolver.resolve_async(service_type)\n        )\n        tasks.append(task)\n\n    results = await asyncio.gather(*tasks)\n    return dict(zip(services, results))\n\n# Usage\nservices = [ServiceA, ServiceB, ServiceC, ServiceD]\nresolved_services = await resolve_concurrent(services)\n</code></pre>"},{"location":"advanced/thread-safety/#producer-consumer-pattern","title":"Producer-Consumer Pattern","text":"<pre><code>from injectq.core.concurrent import ProducerConsumer\n\n# Producer-consumer pattern for service requests\nproducer_consumer = ProducerConsumer(container, max_workers=5)\n\nclass RequestProcessor:\n    \"\"\"Process service requests using producer-consumer pattern.\"\"\"\n\n    def __init__(self, producer_consumer: ProducerConsumer):\n        self.producer_consumer = producer_consumer\n\n    async def process_requests(self, requests):\n        \"\"\"Process multiple requests concurrently.\"\"\"\n        async def process_request(request):\n            # Get service from container\n            service = await self.producer_consumer.get_service(SomeService)\n            return await service.process(request)\n\n        # Process all requests concurrently\n        tasks = [process_request(req) for req in requests]\n        return await asyncio.gather(*tasks)\n\n# Usage\nprocessor = RequestProcessor(producer_consumer)\nrequests = [{\"id\": i, \"data\": f\"data_{i}\"} for i in range(20)]\nresults = await processor.process_requests(requests)\n</code></pre>"},{"location":"advanced/thread-safety/#thread-pool-integration","title":"Thread Pool Integration","text":"<pre><code>from injectq.core.concurrent import ThreadPoolExecutor\nimport concurrent.futures\n\n# Thread pool for CPU-bound operations\nthread_pool = ThreadPoolExecutor(max_workers=4)\n\nclass ThreadPoolService:\n    \"\"\"Service that uses thread pool for CPU-bound work.\"\"\"\n\n    def __init__(self, thread_pool: ThreadPoolExecutor):\n        self.thread_pool = thread_pool\n\n    async def process_cpu_intensive(self, data):\n        \"\"\"Process CPU-intensive task in thread pool.\"\"\"\n        def cpu_task(data):\n            # CPU-intensive computation\n            result = sum(i * i for i in range(data))\n            return result\n\n        # Run in thread pool\n        loop = asyncio.get_event_loop()\n        result = await loop.run_in_executor(\n            self.thread_pool.executor,\n            cpu_task,\n            data\n        )\n\n        return result\n\n# Usage\nservice = ThreadPoolService(thread_pool)\nresult = await service.process_cpu_intensive(1000000)\n</code></pre>"},{"location":"advanced/thread-safety/#thread-safety-best-practices","title":"\ud83d\udee1\ufe0f Thread Safety Best Practices","text":""},{"location":"advanced/thread-safety/#good-thread-safety-patterns","title":"\u2705 Good Thread Safety Patterns","text":""},{"location":"advanced/thread-safety/#1-immutable-services","title":"1. Immutable Services","text":"<pre><code># \u2705 Good: Immutable services are inherently thread-safe\nclass ImmutableService:\n    \"\"\"Immutable service - completely thread-safe.\"\"\"\n\n    def __init__(self, config: dict):\n        # Immutable state\n        self._config = frozenset(config.items())\n\n    def get_config_value(self, key: str):\n        \"\"\"Thread-safe read operation.\"\"\"\n        return dict(self._config).get(key)\n\n    def process_data(self, data: str):\n        \"\"\"Thread-safe processing with no side effects.\"\"\"\n        # Pure function - no state modification\n        return data.upper()\n\n# Usage\nservice = ImmutableService({\"key\": \"value\"})\n# Multiple threads can use this safely\n</code></pre>"},{"location":"advanced/thread-safety/#2-thread-local-state","title":"2. Thread-Local State","text":"<pre><code>import threading\nfrom injectq.core.thread_safety import ThreadLocalStorage\n\n# \u2705 Good: Thread-local state for per-thread data\nthread_local = ThreadLocalStorage()\n\nclass ThreadLocalService:\n    \"\"\"Service with thread-local state.\"\"\"\n\n    def __init__(self):\n        self._thread_data = thread_local\n\n    def set_thread_data(self, key: str, value):\n        \"\"\"Set data for current thread only.\"\"\"\n        if not hasattr(self._thread_data, 'data'):\n            self._thread_data.data = {}\n        self._thread_data.data[key] = value\n\n    def get_thread_data(self, key: str):\n        \"\"\"Get data for current thread only.\"\"\"\n        if hasattr(self._thread_data, 'data'):\n            return self._thread_data.data.get(key)\n        return None\n\n    def clear_thread_data(self):\n        \"\"\"Clear data for current thread.\"\"\"\n        if hasattr(self._thread_data, 'data'):\n            self._thread_data.data.clear()\n\n# Usage\nservice = ThreadLocalService()\n\n# Each thread has its own data\nservice.set_thread_data(\"user_id\", \"123\")\nuser_id = service.get_thread_data(\"user_id\")  # Returns \"123\" for this thread\n</code></pre>"},{"location":"advanced/thread-safety/#3-atomic-operations","title":"3. Atomic Operations","text":"<pre><code>import asyncio\nfrom injectq.core.thread_safety import AtomicOperations\n\n# \u2705 Good: Atomic operations for thread-safe state changes\natomic_ops = AtomicOperations()\n\nclass AtomicService:\n    \"\"\"Service using atomic operations.\"\"\"\n\n    def __init__(self):\n        self._counter = atomic_ops.create_atomic_int(0)\n        self._data = atomic_ops.create_atomic_dict()\n\n    async def increment_counter(self):\n        \"\"\"Atomically increment counter.\"\"\"\n        return await atomic_ops.increment(self._counter)\n\n    async def update_data(self, key: str, value):\n        \"\"\"Atomically update dictionary.\"\"\"\n        async with atomic_ops.lock(self._data):\n            self._data[key] = value\n\n    async def get_data_snapshot(self):\n        \"\"\"Get atomic snapshot of data.\"\"\"\n        async with atomic_ops.lock(self._data):\n            return dict(self._data)\n\n# Usage\nservice = AtomicService()\nawait service.increment_counter()\nawait service.update_data(\"key\", \"value\")\nsnapshot = await service.get_data_snapshot()\n</code></pre>"},{"location":"advanced/thread-safety/#4-lock-hierarchy","title":"4. Lock Hierarchy","text":"<pre><code># \u2705 Good: Consistent lock ordering to prevent deadlocks\nclass LockHierarchyService:\n    \"\"\"Service with proper lock hierarchy.\"\"\"\n\n    def __init__(self):\n        self._lock_a = asyncio.Lock()\n        self._lock_b = asyncio.Lock()\n        self._lock_c = asyncio.Lock()\n\n    async def operation_requiring_multiple_locks(self):\n        \"\"\"Always acquire locks in the same order.\"\"\"\n        # Consistent order: A -&gt; B -&gt; C\n        async with self._lock_a:\n            async with self._lock_b:\n                async with self._lock_c:\n                    # Perform operation\n                    return await self._do_operation()\n\n    async def another_operation(self):\n        \"\"\"Same lock ordering.\"\"\"\n        # Same order: A -&gt; B -&gt; C\n        async with self._lock_a:\n            async with self._lock_b:\n                async with self._lock_c:\n                    # Perform different operation\n                    return await self._do_another_operation()\n\n# Usage\nservice = LockHierarchyService()\nresult1 = await service.operation_requiring_multiple_locks()\nresult2 = await service.another_operation()\n</code></pre>"},{"location":"advanced/thread-safety/#bad-thread-safety-patterns","title":"\u274c Bad Thread Safety Patterns","text":""},{"location":"advanced/thread-safety/#1-race-conditions","title":"1. Race Conditions","text":"<pre><code># \u274c Bad: Race condition in shared state\nclass RaceConditionService:\n    \"\"\"Service with race condition.\"\"\"\n\n    def __init__(self):\n        self._counter = 0\n\n    async def increment_counter(self):\n        \"\"\"Race condition - not thread-safe.\"\"\"\n        # Read\n        current = self._counter\n        # Some async operation\n        await asyncio.sleep(0.001)\n        # Write - another thread might have changed _counter\n        self._counter = current + 1\n\n    async def get_counter(self):\n        \"\"\"Not thread-safe read.\"\"\"\n        return self._counter\n\n# \u2705 Fixed: Use locks or atomic operations\nclass FixedRaceConditionService:\n    \"\"\"Fixed service using locks.\"\"\"\n\n    def __init__(self):\n        self._counter = 0\n        self._lock = asyncio.Lock()\n\n    async def increment_counter(self):\n        \"\"\"Thread-safe increment.\"\"\"\n        async with self._lock:\n            current = self._counter\n            await asyncio.sleep(0.001)\n            self._counter = current + 1\n\n    async def get_counter(self):\n        \"\"\"Thread-safe read.\"\"\"\n        async with self._lock:\n            return self._counter\n</code></pre>"},{"location":"advanced/thread-safety/#2-deadlocks","title":"2. Deadlocks","text":"<pre><code># \u274c Bad: Potential deadlock with inconsistent lock ordering\nclass DeadlockService:\n    \"\"\"Service prone to deadlocks.\"\"\"\n\n    def __init__(self):\n        self._lock_a = asyncio.Lock()\n        self._lock_b = asyncio.Lock()\n\n    async def operation_one(self):\n        \"\"\"Acquires locks in order A -&gt; B.\"\"\"\n        async with self._lock_a:\n            async with self._lock_b:\n                return \"operation_one\"\n\n    async def operation_two(self):\n        \"\"\"Acquires locks in order B -&gt; A - DEADLOCK!\"\"\"\n        async with self._lock_b:  # Different order\n            async with self._lock_a:\n                return \"operation_two\"\n\n# \u2705 Fixed: Consistent lock ordering\nclass FixedDeadlockService:\n    \"\"\"Fixed service with consistent lock ordering.\"\"\"\n\n    def __init__(self):\n        self._lock_a = asyncio.Lock()\n        self._lock_b = asyncio.Lock()\n\n    async def operation_one(self):\n        \"\"\"Consistent order: A -&gt; B.\"\"\"\n        async with self._lock_a:\n            async with self._lock_b:\n                return \"operation_one\"\n\n    async def operation_two(self):\n        \"\"\"Same consistent order: A -&gt; B.\"\"\"\n        async with self._lock_a:\n            async with self._lock_b:\n                return \"operation_two\"\n</code></pre>"},{"location":"advanced/thread-safety/#3-lock-contention","title":"3. Lock Contention","text":"<pre><code># \u274c Bad: Holding locks too long\nclass LockContentionService:\n    \"\"\"Service with excessive lock contention.\"\"\"\n\n    def __init__(self):\n        self._data = {}\n        self._lock = asyncio.Lock()\n\n    async def slow_operation(self):\n        \"\"\"Holds lock during slow I/O operation.\"\"\"\n        async with self._lock:\n            # Lock held during slow operation\n            await asyncio.sleep(1.0)  # Slow I/O\n            self._data[\"key\"] = \"value\"\n            return self._data\n\n# \u2705 Fixed: Minimize lock duration\nclass FixedLockContentionService:\n    \"\"\"Fixed service with minimal lock duration.\"\"\"\n\n    def __init__(self):\n        self._data = {}\n        self._lock = asyncio.Lock()\n\n    async def fast_operation(self):\n        \"\"\"Minimize lock duration.\"\"\"\n        # Prepare data outside lock\n        new_value = await self._prepare_value()\n\n        # Hold lock only for the actual update\n        async with self._lock:\n            self._data[\"key\"] = new_value\n\n        return self._data\n\n    async def _prepare_value(self):\n        \"\"\"Prepare value outside of lock.\"\"\"\n        await asyncio.sleep(1.0)  # Slow operation outside lock\n        return \"value\"\n</code></pre>"},{"location":"advanced/thread-safety/#thread-safety-monitoring","title":"\ud83d\udcca Thread Safety Monitoring","text":""},{"location":"advanced/thread-safety/#thread-safety-metrics","title":"Thread Safety Metrics","text":"<pre><code>from injectq.core.thread_safety import ThreadSafetyMonitor\n\n# Monitor thread safety issues\nmonitor = ThreadSafetyMonitor(container)\n\nclass MonitoredThreadSafeService:\n    \"\"\"Service with thread safety monitoring.\"\"\"\n\n    def __init__(self, monitor: ThreadSafetyMonitor):\n        self.monitor = monitor\n        self._data = {}\n        self._lock = asyncio.Lock()\n\n    async def monitored_operation(self, operation_name: str):\n        \"\"\"Monitor thread safety of operation.\"\"\"\n        with self.monitor.track_operation(operation_name):\n            async with self._lock:\n                # Operation logic\n                result = await self._perform_operation()\n                return result\n\n    async def _perform_operation(self):\n        \"\"\"Actual operation.\"\"\"\n        await asyncio.sleep(0.01)\n        return \"result\"\n\n    def get_thread_safety_report(self):\n        \"\"\"Get thread safety metrics.\"\"\"\n        report = self.monitor.get_report()\n\n        print(\"Thread Safety Report:\")\n        print(f\"- Total operations: {report.total_operations}\")\n        print(f\"- Lock contention: {report.lock_contention}%\")\n        print(f\"- Deadlock attempts: {report.deadlock_attempts}\")\n        print(f\"- Race conditions detected: {report.race_conditions}\")\n\n        return report\n\n# Usage\nservice = MonitoredThreadSafeService(monitor)\nresult = await service.monitored_operation(\"some_operation\")\nreport = service.get_thread_safety_report()\n</code></pre>"},{"location":"advanced/thread-safety/#deadlock-detection","title":"Deadlock Detection","text":"<pre><code>from injectq.core.thread_safety import DeadlockDetector\n\n# Detect potential deadlocks\ndeadlock_detector = DeadlockDetector()\n\nclass DeadlockSafeService:\n    \"\"\"Service with deadlock detection.\"\"\"\n\n    def __init__(self, detector: DeadlockDetector):\n        self.detector = detector\n        self._lock_a = asyncio.Lock()\n        self._lock_b = asyncio.Lock()\n\n    async def safe_operation(self):\n        \"\"\"Operation with deadlock detection.\"\"\"\n        lock_a_token = await self.detector.acquire_lock(self._lock_a, \"lock_a\")\n        try:\n            lock_b_token = await self.detector.acquire_lock(self._lock_b, \"lock_b\")\n            try:\n                # Operation logic\n                return await self._do_operation()\n            finally:\n                await self.detector.release_lock(lock_b_token)\n        finally:\n            await self.detector.release_lock(lock_a_token)\n\n    async def _do_operation(self):\n        \"\"\"Actual operation.\"\"\"\n        return \"operation_result\"\n\n    def check_for_deadlocks(self):\n        \"\"\"Check for deadlock situations.\"\"\"\n        deadlocks = self.detector.detect_deadlocks()\n\n        if deadlocks:\n            print(\"Deadlocks detected:\")\n            for deadlock in deadlocks:\n                print(f\"- {deadlock.description}\")\n                print(f\"  Involved locks: {deadlock.locks}\")\n                print(f\"  Resolution: {deadlock.resolution}\")\n\n        return deadlocks\n\n# Usage\nservice = DeadlockSafeService(deadlock_detector)\nresult = await service.safe_operation()\ndeadlocks = service.check_for_deadlocks()\n</code></pre>"},{"location":"advanced/thread-safety/#summary","title":"\ud83c\udfaf Summary","text":"<p>Thread safety provides concurrent access protection:</p> <ul> <li>Thread safety levels - Configurable synchronization levels</li> <li>Synchronization primitives - Locks, read-write locks, semaphores</li> <li>Thread-safe operations - Safe binding, resolution, and scope management</li> <li>Concurrent patterns - Producer-consumer, thread pools, concurrent resolution</li> <li>Best practices - Immutable services, thread-local state, atomic operations</li> <li>Monitoring - Thread safety metrics and deadlock detection</li> </ul> <p>Key features: - Configurable thread safety levels (NONE, LOW, MEDIUM, HIGH, ADAPTIVE) - Comprehensive synchronization primitives - Thread-safe container operations - Concurrent resolution patterns - Deadlock detection and prevention - Performance monitoring</p> <p>Best practices: - Use appropriate thread safety level for your use case - Implement consistent lock ordering to prevent deadlocks - Minimize lock duration to reduce contention - Use immutable objects when possible - Monitor thread safety metrics - Handle race conditions with atomic operations</p> <p>Common patterns: - Read-write locks for concurrent reads - Semaphores for limiting concurrent access - Thread-local storage for per-thread data - Atomic operations for thread-safe state changes - Lock hierarchies to prevent deadlocks</p> <p>Ready to explore circular dependencies?</p>"},{"location":"api-reference/","title":"API Reference","text":"<p>This section provides comprehensive API documentation for all InjectQ classes, functions, and utilities. The documentation is automatically generated from source code docstrings.</p>"},{"location":"api-reference/#core-components","title":"Core Components","text":"<ul> <li>Container - Main dependency injection container</li> <li>Module - Configuration modules for organizing bindings</li> <li>Decorators - Injection decorators and utilities</li> <li>Scopes - Scope management and lifecycle</li> <li>Registry - Internal service registry</li> <li>Resolver - Dependency resolution engine</li> </ul>"},{"location":"api-reference/#advanced-features","title":"Advanced Features","text":"<ul> <li>Providers - Provider patterns and factories</li> <li>Validation - Dependency validation utilities</li> <li>Diagnostics - Profiling and debugging tools</li> <li>Testing - Testing utilities and mocks</li> <li>Integrations - Framework integration helpers</li> </ul>"},{"location":"api-reference/#type-system","title":"Type System","text":"<ul> <li>Types - Type definitions and protocols</li> <li>Exceptions - Custom exception classes</li> </ul>"},{"location":"api-reference/#usage-examples","title":"Usage Examples","text":"<p>Each API reference page includes:</p> <ul> <li>Complete class/function signatures</li> <li>Detailed parameter descriptions</li> <li>Return value documentation</li> <li>Usage examples and code snippets</li> <li>Related functionality cross-references</li> <li>Version history and compatibility notes</li> </ul>"},{"location":"api-reference/#navigation-tips","title":"Navigation Tips","text":"<ul> <li>Use the search functionality to quickly find specific APIs</li> <li>Each class and method is cross-linked for easy navigation</li> <li>Examples are provided inline with API documentation</li> <li>See the examples section for comprehensive usage patterns</li> </ul>"},{"location":"api-reference/container/","title":"Container API","text":"<p>::: injectq.core.container</p>"},{"location":"api-reference/container/#overview","title":"Overview","text":"<p>The <code>InjectQ</code> container is the central component of the dependency injection system. It manages service registrations, resolves dependencies, and handles scope lifecycle.</p>"},{"location":"api-reference/container/#basic-usage","title":"Basic Usage","text":"<pre><code>from injectq import InjectQ, inject\n\n# Create container\ncontainer = InjectQ()\n\n# Register services\ncontainer.bind(UserService, UserService).singleton()\n\n# Resolve services\nuser_service = container.get(UserService)\n</code></pre>"},{"location":"api-reference/container/#container-methods","title":"Container Methods","text":"<p>The container provides several methods for service management:</p>"},{"location":"api-reference/container/#registration-methods","title":"Registration Methods","text":"<ul> <li><code>bind()</code> - Register a service binding</li> <li><code>bind_instance()</code> - Register a specific instance</li> <li><code>bind_factory()</code> - Register a factory function</li> <li><code>install()</code> - Install a module</li> </ul>"},{"location":"api-reference/container/#resolution-methods","title":"Resolution Methods","text":"<ul> <li><code>get()</code> - Get service instance</li> <li><code>get_optional()</code> - Get optional service instance</li> <li><code>try_get()</code> - Try to get service with fallback</li> </ul>"},{"location":"api-reference/container/#scope-management","title":"Scope Management","text":"<ul> <li><code>create_scope()</code> - Create new scope</li> <li><code>create_async_scope()</code> - Create async scope</li> <li><code>with_scope()</code> - Execute with temporary scope</li> </ul>"},{"location":"api-reference/container/#configuration-options","title":"Configuration Options","text":"<p>The container can be configured with various options:</p> <pre><code>container = InjectQ(\n    auto_wire=True,          # Enable automatic wiring\n    validate_bindings=True,   # Validate bindings on registration\n    thread_safe=True         # Enable thread safety\n)\n</code></pre>"},{"location":"api-reference/container/#advanced-features","title":"Advanced Features","text":""},{"location":"api-reference/container/#custom-resolvers","title":"Custom Resolvers","text":"<pre><code># Register custom resolver\ncontainer.set_resolver(CustomResolver())\n</code></pre>"},{"location":"api-reference/container/#event-hooks","title":"Event Hooks","text":"<pre><code># Register lifecycle hooks\ncontainer.on_instance_created(lambda instance: print(f\"Created: {instance}\"))\ncontainer.on_scope_created(lambda scope: print(f\"Scope created: {scope}\"))\n</code></pre>"},{"location":"api-reference/container/#validation","title":"Validation","text":"<pre><code># Validate container configuration\nvalidation_results = container.validate()\nfor error in validation_results.errors:\n    print(f\"Validation error: {error}\")\n</code></pre>"},{"location":"api-reference/container/#thread-safety","title":"Thread Safety","text":"<p>The container is thread-safe by default when configured appropriately:</p> <pre><code># Thread-safe container\ncontainer = InjectQ(thread_safe=True)\n\n# Use from multiple threads\nimport threading\n\ndef worker():\n    service = container.get(MyService)\n    # Use service...\n\nthreads = [threading.Thread(target=worker) for _ in range(10)]\nfor thread in threads:\n    thread.start()\n</code></pre>"},{"location":"api-reference/container/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Singleton services are resolved once and cached</li> <li>Scoped services are cached within their scope</li> <li>Transient services are created fresh each time</li> <li>Use <code>get_optional()</code> for services that might not be registered</li> </ul>"},{"location":"api-reference/container/#error-handling","title":"Error Handling","text":"<p>The container raises specific exceptions for different error conditions:</p> <pre><code>try:\n    service = container.get(UnregisteredService)\nexcept ServiceNotFoundError as e:\n    print(f\"Service not found: {e}\")\n\ntry:\n    container.bind(ServiceA, ServiceA)\n    container.bind(ServiceB, ServiceB)  # Circular dependency\n    service = container.get(ServiceA)\nexcept CircularDependencyError as e:\n    print(f\"Circular dependency: {e}\")\n</code></pre>"},{"location":"api-reference/decorators/","title":"Decorators API","text":"<p>::: injectq.decorators.inject ::: injectq.decorators.resource ::: injectq.decorators.singleton</p>"},{"location":"api-reference/decorators/#overview","title":"Overview","text":"<p>InjectQ provides several decorators to simplify dependency injection and service configuration. These decorators can be applied to classes, methods, and functions to enable automatic dependency resolution.</p>"},{"location":"api-reference/decorators/#inject-decorator","title":"@inject Decorator","text":"<p>The <code>@inject</code> decorator marks constructors, methods, or functions for dependency injection.</p>"},{"location":"api-reference/decorators/#constructor-injection","title":"Constructor Injection","text":"<pre><code>from injectq import inject\n\nclass UserService:\n    @inject\n    def __init__(self, user_repository: UserRepository, logger: Logger):\n        self.user_repository = user_repository\n        self.logger = logger\n</code></pre>"},{"location":"api-reference/decorators/#method-injection","title":"Method Injection","text":"<pre><code>class OrderService:\n    @inject\n    def process_order(self, order: Order, payment_service: PaymentService) -&gt; bool:\n        return payment_service.process_payment(order.total)\n</code></pre>"},{"location":"api-reference/decorators/#function-injection","title":"Function Injection","text":"<pre><code>@inject\ndef send_notification(message: str, email_service: EmailService) -&gt; bool:\n    return email_service.send(message)\n</code></pre>"},{"location":"api-reference/decorators/#optional-dependencies","title":"Optional Dependencies","text":"<pre><code>from typing import Optional\n\nclass CacheService:\n    @inject\n    def __init__(self, redis_client: Optional[RedisClient] = None):\n        self.redis_client = redis_client\n</code></pre>"},{"location":"api-reference/decorators/#named-dependencies","title":"Named Dependencies","text":"<pre><code>class DatabaseService:\n    @inject\n    def __init__(\n        self, \n        host: str = inject.named(\"database_host\"),\n        port: int = inject.named(\"database_port\")\n    ):\n        self.host = host\n        self.port = port\n</code></pre>"},{"location":"api-reference/decorators/#resource-decorator","title":"@resource Decorator","text":"<p>The <code>@resource</code> decorator manages resource lifecycle with automatic cleanup.</p>"},{"location":"api-reference/decorators/#basic-resource-management","title":"Basic Resource Management","text":"<pre><code>from injectq import resource\n\n@resource\nclass DatabaseConnection:\n    def __init__(self, connection_string: str):\n        self.connection_string = connection_string\n        self.connection = None\n\n    async def __aenter__(self):\n        self.connection = await connect(self.connection_string)\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        if self.connection:\n            await self.connection.close()\n</code></pre>"},{"location":"api-reference/decorators/#synchronous-resources","title":"Synchronous Resources","text":"<pre><code>@resource\nclass FileManager:\n    def __init__(self, file_path: str):\n        self.file_path = file_path\n        self.file = None\n\n    def __enter__(self):\n        self.file = open(self.file_path, 'r')\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self.file:\n            self.file.close()\n</code></pre>"},{"location":"api-reference/decorators/#resource-with-dependencies","title":"Resource with Dependencies","text":"<pre><code>@resource\nclass DatabaseService:\n    @inject\n    def __init__(self, config: DatabaseConfig, logger: Logger):\n        self.config = config\n        self.logger = logger\n        self.connection = None\n\n    async def __aenter__(self):\n        self.logger.info(\"Connecting to database\")\n        self.connection = await self.config.create_connection()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        self.logger.info(\"Closing database connection\")\n        if self.connection:\n            await self.connection.close()\n</code></pre>"},{"location":"api-reference/decorators/#singleton-decorator","title":"@singleton Decorator","text":"<p>The <code>@singleton</code> decorator ensures only one instance of a class is created.</p>"},{"location":"api-reference/decorators/#basic-singleton","title":"Basic Singleton","text":"<pre><code>from injectq import singleton\n\n@singleton\nclass ConfigurationService:\n    def __init__(self):\n        self.settings = self.load_settings()\n\n    def load_settings(self):\n        # Load configuration from file or environment\n        return {\"app_name\": \"MyApp\", \"version\": \"1.0.0\"}\n</code></pre>"},{"location":"api-reference/decorators/#singleton-with-dependencies","title":"Singleton with Dependencies","text":"<pre><code>@singleton\nclass CacheManager:\n    @inject\n    def __init__(self, redis_client: RedisClient, config: CacheConfig):\n        self.redis_client = redis_client\n        self.config = config\n        self.cache = {}\n</code></pre>"},{"location":"api-reference/decorators/#thread-safe-singleton","title":"Thread-Safe Singleton","text":"<pre><code>import threading\n\n@singleton\nclass ThreadSafeCounter:\n    def __init__(self):\n        self._value = 0\n        self._lock = threading.Lock()\n\n    def increment(self):\n        with self._lock:\n            self._value += 1\n            return self._value\n</code></pre>"},{"location":"api-reference/decorators/#decorator-combinations","title":"Decorator Combinations","text":""},{"location":"api-reference/decorators/#resource-inject-singleton","title":"Resource + Inject + Singleton","text":"<pre><code>@singleton\n@resource\nclass ApplicationService:\n    @inject\n    def __init__(self, db: DatabaseService, cache: CacheService):\n        self.db = db\n        self.cache = cache\n\n    async def __aenter__(self):\n        await self.db.connect()\n        await self.cache.connect()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        await self.cache.disconnect()\n        await self.db.disconnect()\n</code></pre>"},{"location":"api-reference/decorators/#custom-decorators","title":"Custom Decorators","text":""},{"location":"api-reference/decorators/#creating-custom-injection-decorators","title":"Creating Custom Injection Decorators","text":"<pre><code>from functools import wraps\nfrom injectq import inject as base_inject\n\ndef logged_inject(func):\n    \"\"\"Custom decorator that adds logging to injection.\"\"\"\n\n    @base_inject\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        print(f\"Injecting dependencies for {func.__name__}\")\n        result = func(*args, **kwargs)\n        print(f\"Injection completed for {func.__name__}\")\n        return result\n\n    return wrapper\n\n# Usage\nclass MyService:\n    @logged_inject\n    def __init__(self, dependency: SomeDependency):\n        self.dependency = dependency\n</code></pre>"},{"location":"api-reference/decorators/#validation-decorator","title":"Validation Decorator","text":"<pre><code>from typing import get_type_hints\n\ndef validated_inject(func):\n    \"\"\"Decorator that validates injected dependencies.\"\"\"\n\n    @base_inject\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        # Get type hints\n        hints = get_type_hints(func)\n\n        # Validate arguments match expected types\n        for arg_name, expected_type in hints.items():\n            if arg_name in kwargs:\n                arg_value = kwargs[arg_name]\n                if not isinstance(arg_value, expected_type):\n                    raise TypeError(f\"Expected {expected_type} for {arg_name}, got {type(arg_value)}\")\n\n        return func(*args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"api-reference/decorators/#async-injection-decorator","title":"Async Injection Decorator","text":"<pre><code>import asyncio\nfrom functools import wraps\n\ndef async_inject(func):\n    \"\"\"Decorator for async dependency injection.\"\"\"\n\n    @wraps(func)\n    async def wrapper(*args, **kwargs):\n        # Resolve async dependencies\n        container = get_current_container()  # Implementation needed\n\n        # Get function signature\n        sig = inspect.signature(func)\n        bound_args = sig.bind_partial(*args, **kwargs)\n\n        # Resolve missing dependencies asynchronously\n        for param_name, param in sig.parameters.items():\n            if param_name not in bound_args.arguments:\n                if hasattr(param.annotation, '__origin__'):\n                    # Handle generic types\n                    dependency = await container.aget(param.annotation)\n                else:\n                    dependency = await container.aget(param.annotation)\n                bound_args.arguments[param_name] = dependency\n\n        return await func(**bound_args.arguments)\n\n    return wrapper\n</code></pre>"},{"location":"api-reference/decorators/#decorator-utilities","title":"Decorator Utilities","text":""},{"location":"api-reference/decorators/#injection-metadata","title":"Injection Metadata","text":"<pre><code>def get_injection_info(cls_or_func):\n    \"\"\"Get information about injection decorators applied to a class or function.\"\"\"\n    info = {\n        \"is_injectable\": hasattr(cls_or_func, '__inject__'),\n        \"is_singleton\": hasattr(cls_or_func, '__singleton__'),\n        \"is_resource\": hasattr(cls_or_func, '__resource__'),\n        \"dependencies\": []\n    }\n\n    if hasattr(cls_or_func, '__annotations__'):\n        info[\"dependencies\"] = list(cls_or_func.__annotations__.keys())\n\n    return info\n\n# Usage\nclass MyService:\n    @inject\n    def __init__(self, dep: SomeDependency):\n        self.dep = dep\n\ninfo = get_injection_info(MyService)\nprint(info)  # {'is_injectable': True, 'is_singleton': False, ...}\n</code></pre>"},{"location":"api-reference/decorators/#decorator-validation","title":"Decorator Validation","text":"<pre><code>def validate_decorators(cls):\n    \"\"\"Validate that decorators are applied correctly.\"\"\"\n    errors = []\n\n    # Check for conflicting decorators\n    if hasattr(cls, '__singleton__') and hasattr(cls, '__transient__'):\n        errors.append(\"Class cannot be both singleton and transient\")\n\n    # Check for missing inject decorator\n    if hasattr(cls, '__init__'):\n        init_method = cls.__init__\n        if len(inspect.signature(init_method).parameters) &gt; 1:  # More than just 'self'\n            if not hasattr(init_method, '__inject__'):\n                errors.append(\"Constructor with parameters should use @inject decorator\")\n\n    return errors\n</code></pre>"},{"location":"api-reference/decorators/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Decorators add minimal overhead to method calls</li> <li>Singleton decorator caches instances for better performance</li> <li>Resource decorator manages lifecycle efficiently</li> <li>Consider using decorators judiciously in performance-critical code</li> </ul>"},{"location":"api-reference/decorators/#error-handling","title":"Error Handling","text":"<pre><code>try:\n    @inject\n    def invalid_function(undefined_type: UndefinedType):\n        pass\n\n    # This will raise an error when resolved\n    container.get(invalid_function)\n\nexcept ServiceNotFoundError as e:\n    print(f\"Dependency not found: {e}\")\nexcept CircularDependencyError as e:\n    print(f\"Circular dependency detected: {e}\")\n</code></pre>"},{"location":"api-reference/diagnostics/","title":"Diagnostics API","text":"<p>::: injectq.diagnostics</p>"},{"location":"api-reference/diagnostics/#overview","title":"Overview","text":"<p>The diagnostics module provides comprehensive tools for monitoring, analyzing, and debugging dependency injection containers at runtime.</p>"},{"location":"api-reference/diagnostics/#container-diagnostics","title":"Container Diagnostics","text":""},{"location":"api-reference/diagnostics/#basic-diagnostics","title":"Basic Diagnostics","text":"<pre><code>from injectq.diagnostics import ContainerDiagnostics\n\n# Create diagnostics instance\ndiagnostics = ContainerDiagnostics(container)\n\n# Get container overview\noverview = diagnostics.get_overview()\nprint(f\"Total services: {overview.total_services}\")\nprint(f\"Active instances: {overview.active_instances}\")\nprint(f\"Memory usage: {overview.memory_usage_mb}MB\")\n\n# Get detailed service information\nservice_info = diagnostics.get_service_info(UserService)\nprint(f\"Scope: {service_info.scope}\")\nprint(f\"Dependencies: {service_info.dependencies}\")\nprint(f\"Instance count: {service_info.instance_count}\")\n</code></pre>"},{"location":"api-reference/diagnostics/#container-overview","title":"Container Overview","text":"<pre><code>from dataclasses import dataclass\nfrom typing import Dict, List, Any\nimport psutil\nimport gc\n\n@dataclass\nclass ContainerOverview:\n    \"\"\"Overview of container state.\"\"\"\n    total_services: int\n    active_instances: int\n    singleton_count: int\n    transient_count: int\n    scoped_count: int\n    memory_usage_mb: float\n    resolution_count: int\n    error_count: int\n\n    def __str__(self):\n        return f\"\"\"Container Overview:\n  Services: {self.total_services}\n  Active Instances: {self.active_instances}\n  Singletons: {self.singleton_count}\n  Transients: {self.transient_count}\n  Scoped: {self.scoped_count}\n  Memory: {self.memory_usage_mb:.2f}MB\n  Resolutions: {self.resolution_count}\n  Errors: {self.error_count}\"\"\"\n\nclass ContainerDiagnostics:\n    \"\"\"Provides diagnostic information about container.\"\"\"\n\n    def __init__(self, container):\n        self.container = container\n        self.registry = container._registry\n        self.resolver = container._resolver\n\n    def get_overview(self) -&gt; ContainerOverview:\n        \"\"\"Get high-level container overview.\"\"\"\n        services = self.registry.get_all_services()\n\n        singleton_count = sum(1 for binding in services.values() if binding.scope == Scope.SINGLETON)\n        transient_count = sum(1 for binding in services.values() if binding.scope == Scope.TRANSIENT)\n        scoped_count = sum(1 for binding in services.values() if binding.scope == Scope.SCOPED)\n\n        # Calculate active instances\n        active_instances = self.count_active_instances()\n\n        # Get memory usage\n        memory_usage = self.get_memory_usage()\n\n        # Get resolution stats\n        resolution_count = getattr(self.resolver, '_resolution_count', 0)\n        error_count = getattr(self.resolver, '_error_count', 0)\n\n        return ContainerOverview(\n            total_services=len(services),\n            active_instances=active_instances,\n            singleton_count=singleton_count,\n            transient_count=transient_count,\n            scoped_count=scoped_count,\n            memory_usage_mb=memory_usage,\n            resolution_count=resolution_count,\n            error_count=error_count\n        )\n\n    def count_active_instances(self) -&gt; int:\n        \"\"\"Count active service instances.\"\"\"\n        count = 0\n\n        # Count singleton instances\n        if hasattr(self.container, '_instances'):\n            count += len(self.container._instances)\n\n        # Count scoped instances (if available)\n        if hasattr(self.container, '_scope_manager'):\n            scope_manager = self.container._scope_manager\n            if hasattr(scope_manager, 'count_instances'):\n                count += scope_manager.count_instances()\n\n        return count\n\n    def get_memory_usage(self) -&gt; float:\n        \"\"\"Get container memory usage in MB.\"\"\"\n        # Calculate memory usage of container and its instances\n        total_size = 0\n\n        # Size of container itself\n        total_size += self.get_object_size(self.container)\n\n        # Size of singleton instances\n        if hasattr(self.container, '_instances'):\n            for instance in self.container._instances.values():\n                total_size += self.get_object_size(instance)\n\n        return total_size / (1024 * 1024)  # Convert to MB\n\n    def get_object_size(self, obj) -&gt; int:\n        \"\"\"Get approximate size of object in bytes.\"\"\"\n        import sys\n        size = sys.getsizeof(obj)\n\n        # For complex objects, recursively calculate size\n        if hasattr(obj, '__dict__'):\n            size += sys.getsizeof(obj.__dict__)\n            for value in obj.__dict__.values():\n                if not callable(value):\n                    size += sys.getsizeof(value)\n\n        return size\n</code></pre>"},{"location":"api-reference/diagnostics/#service-information","title":"Service Information","text":"<pre><code>@dataclass\nclass ServiceInfo:\n    \"\"\"Detailed information about a service.\"\"\"\n    service_type: type\n    implementation: type\n    scope: str\n    dependencies: List[type]\n    dependents: List[type]\n    instance_count: int\n    resolution_count: int\n    error_count: int\n    last_resolved: Optional[datetime]\n    creation_time_ms: float\n    metadata: Dict[str, Any]\n\nclass ServiceDiagnostics:\n    \"\"\"Provides diagnostic information about specific services.\"\"\"\n\n    def __init__(self, container):\n        self.container = container\n        self.registry = container._registry\n        self.resolver = container._resolver\n\n    def get_service_info(self, service_type: type) -&gt; ServiceInfo:\n        \"\"\"Get detailed information about a service.\"\"\"\n        binding = self.registry.get_binding(service_type)\n        if not binding:\n            raise ValueError(f\"Service {service_type.__name__} is not registered\")\n\n        # Get dependencies\n        dependencies = self.get_service_dependencies(service_type)\n\n        # Get dependents (services that depend on this service)\n        dependents = self.get_service_dependents(service_type)\n\n        # Get instance information\n        instance_count = self.get_instance_count(service_type)\n\n        # Get resolution statistics\n        stats = self.get_resolution_stats(service_type)\n\n        return ServiceInfo(\n            service_type=service_type,\n            implementation=binding.implementation,\n            scope=binding.scope.name,\n            dependencies=dependencies,\n            dependents=dependents,\n            instance_count=instance_count,\n            resolution_count=stats.get('resolution_count', 0),\n            error_count=stats.get('error_count', 0),\n            last_resolved=stats.get('last_resolved'),\n            creation_time_ms=stats.get('avg_creation_time', 0.0),\n            metadata={}\n        )\n\n    def get_service_dependencies(self, service_type: type) -&gt; List[type]:\n        \"\"\"Get direct dependencies of a service.\"\"\"\n        dependencies = []\n\n        if hasattr(service_type, '__init__'):\n            import inspect\n            sig = inspect.signature(service_type.__init__)\n\n            for param in sig.parameters.values():\n                if param.name != 'self' and param.annotation != inspect.Parameter.empty:\n                    dependencies.append(param.annotation)\n\n        return dependencies\n\n    def get_service_dependents(self, target_type: type) -&gt; List[type]:\n        \"\"\"Get services that depend on the target service.\"\"\"\n        dependents = []\n\n        for service_type in self.registry.get_all_services():\n            dependencies = self.get_service_dependencies(service_type)\n            if target_type in dependencies:\n                dependents.append(service_type)\n\n        return dependents\n\n    def get_instance_count(self, service_type: type) -&gt; int:\n        \"\"\"Get number of active instances for a service.\"\"\"\n        binding = self.registry.get_binding(service_type)\n\n        if binding.scope == Scope.SINGLETON:\n            # Check if singleton instance exists\n            if hasattr(self.container, '_instances'):\n                return 1 if service_type in self.container._instances else 0\n            return 0\n        elif binding.scope == Scope.SCOPED:\n            # Count scoped instances across all scopes\n            if hasattr(self.container, '_scope_manager'):\n                return self.container._scope_manager.count_service_instances(service_type)\n            return 0\n        else:  # Transient\n            # Transient services don't maintain instances\n            return 0\n\n    def get_resolution_stats(self, service_type: type) -&gt; Dict[str, Any]:\n        \"\"\"Get resolution statistics for a service.\"\"\"\n        # This would be populated by instrumented resolver\n        stats = getattr(self.resolver, '_service_stats', {})\n        return stats.get(service_type, {})\n</code></pre>"},{"location":"api-reference/diagnostics/#dependency-graph-analysis","title":"Dependency Graph Analysis","text":""},{"location":"api-reference/diagnostics/#dependency-graph","title":"Dependency Graph","text":"<pre><code>from typing import Set, Dict, List, Tuple\nimport networkx as nx\n\nclass DependencyGraph:\n    \"\"\"Analyzes service dependency relationships.\"\"\"\n\n    def __init__(self, container):\n        self.container = container\n        self.registry = container._registry\n        self.graph = self.build_graph()\n\n    def build_graph(self) -&gt; nx.DiGraph:\n        \"\"\"Build dependency graph.\"\"\"\n        graph = nx.DiGraph()\n\n        # Add all services as nodes\n        for service_type in self.registry.get_all_services():\n            graph.add_node(service_type, name=service_type.__name__)\n\n        # Add dependency edges\n        for service_type in self.registry.get_all_services():\n            dependencies = self.get_dependencies(service_type)\n\n            for dep_type in dependencies:\n                if dep_type in self.registry.get_all_services():\n                    graph.add_edge(service_type, dep_type)\n\n        return graph\n\n    def get_dependencies(self, service_type: type) -&gt; List[type]:\n        \"\"\"Get dependencies for a service type.\"\"\"\n        dependencies = []\n\n        if hasattr(service_type, '__init__'):\n            import inspect\n            sig = inspect.signature(service_type.__init__)\n\n            for param in sig.parameters.values():\n                if param.name != 'self' and param.annotation != inspect.Parameter.empty:\n                    dependencies.append(param.annotation)\n\n        return dependencies\n\n    def find_cycles(self) -&gt; List[List[type]]:\n        \"\"\"Find circular dependencies.\"\"\"\n        try:\n            cycles = list(nx.simple_cycles(self.graph))\n            return cycles\n        except nx.NetworkXError:\n            return []\n\n    def get_dependency_depth(self, service_type: type) -&gt; int:\n        \"\"\"Get maximum dependency depth for a service.\"\"\"\n        if service_type not in self.graph:\n            return 0\n\n        try:\n            # Find shortest path from service to all leaf nodes\n            lengths = nx.single_source_shortest_path_length(self.graph, service_type)\n            return max(lengths.values()) if lengths else 0\n        except nx.NetworkXError:\n            return 0\n\n    def get_dependents(self, service_type: type) -&gt; List[type]:\n        \"\"\"Get all services that depend on this service.\"\"\"\n        return list(self.graph.predecessors(service_type))\n\n    def get_dependencies_recursive(self, service_type: type) -&gt; Set[type]:\n        \"\"\"Get all recursive dependencies of a service.\"\"\"\n        if service_type not in self.graph:\n            return set()\n\n        try:\n            descendants = nx.descendants(self.graph, service_type)\n            return descendants\n        except nx.NetworkXError:\n            return set()\n\n    def analyze_complexity(self) -&gt; Dict[str, Any]:\n        \"\"\"Analyze graph complexity metrics.\"\"\"\n        return {\n            'total_services': len(self.graph.nodes),\n            'total_dependencies': len(self.graph.edges),\n            'average_dependencies': len(self.graph.edges) / len(self.graph.nodes) if self.graph.nodes else 0,\n            'max_depth': max((self.get_dependency_depth(node) for node in self.graph.nodes), default=0),\n            'strongly_connected_components': len(list(nx.strongly_connected_components(self.graph))),\n            'cycles': len(self.find_cycles()),\n            'leaf_services': len([node for node in self.graph.nodes if self.graph.out_degree(node) == 0]),\n            'root_services': len([node for node in self.graph.nodes if self.graph.in_degree(node) == 0])\n        }\n\n    def export_dot(self) -&gt; str:\n        \"\"\"Export graph as DOT format for visualization.\"\"\"\n        dot_lines = ['digraph DependencyGraph {']\n\n        # Add nodes\n        for node in self.graph.nodes:\n            label = node.__name__\n            dot_lines.append(f'  \"{label}\";')\n\n        # Add edges\n        for source, target in self.graph.edges:\n            source_label = source.__name__\n            target_label = target.__name__\n            dot_lines.append(f'  \"{source_label}\" -&gt; \"{target_label}\";')\n\n        dot_lines.append('}')\n        return '\\n'.join(dot_lines)\n</code></pre>"},{"location":"api-reference/diagnostics/#graph-visualization","title":"Graph Visualization","text":"<pre><code>class DependencyGraphVisualizer:\n    \"\"\"Visualizes dependency graphs.\"\"\"\n\n    def __init__(self, dependency_graph: DependencyGraph):\n        self.graph = dependency_graph\n\n    def create_ascii_tree(self, root_service: type, max_depth: int = 5) -&gt; str:\n        \"\"\"Create ASCII tree representation of dependencies.\"\"\"\n        if root_service not in self.graph.graph:\n            return f\"{root_service.__name__} (not found)\"\n\n        lines = []\n        self._build_ascii_tree(root_service, lines, \"\", True, max_depth, set())\n        return '\\n'.join(lines)\n\n    def _build_ascii_tree(self, service: type, lines: List[str], prefix: str, is_last: bool, depth: int, visited: Set[type]):\n        \"\"\"Recursively build ASCII tree.\"\"\"\n        if depth &lt;= 0:\n            return\n\n        if service in visited:\n            lines.append(f\"{prefix}{'\u2514\u2500\u2500 ' if is_last else '\u251c\u2500\u2500 '}{service.__name__} (circular)\")\n            return\n\n        visited.add(service)\n\n        lines.append(f\"{prefix}{'\u2514\u2500\u2500 ' if is_last else '\u251c\u2500\u2500 '}{service.__name__}\")\n\n        dependencies = list(self.graph.graph.successors(service))\n\n        for i, dep in enumerate(dependencies):\n            is_dep_last = i == len(dependencies) - 1\n            new_prefix = prefix + (\"    \" if is_last else \"\u2502   \")\n            self._build_ascii_tree(dep, lines, new_prefix, is_dep_last, depth - 1, visited.copy())\n\n    def create_mermaid_diagram(self) -&gt; str:\n        \"\"\"Create Mermaid diagram of dependencies.\"\"\"\n        lines = ['graph TD']\n\n        # Add nodes with friendly names\n        node_mapping = {}\n        for i, node in enumerate(self.graph.graph.nodes):\n            node_id = f\"A{i}\"\n            node_mapping[node] = node_id\n            lines.append(f\"  {node_id}[{node.__name__}]\")\n\n        # Add edges\n        for source, target in self.graph.graph.edges:\n            source_id = node_mapping[source]\n            target_id = node_mapping[target]\n            lines.append(f\"  {source_id} --&gt; {target_id}\")\n\n        return '\\n'.join(lines)\n\n    def print_summary(self):\n        \"\"\"Print dependency graph summary.\"\"\"\n        complexity = self.graph.analyze_complexity()\n\n        print(\"Dependency Graph Summary:\")\n        print(f\"  Total Services: {complexity['total_services']}\")\n        print(f\"  Total Dependencies: {complexity['total_dependencies']}\")\n        print(f\"  Average Dependencies per Service: {complexity['average_dependencies']:.2f}\")\n        print(f\"  Maximum Dependency Depth: {complexity['max_depth']}\")\n        print(f\"  Circular Dependencies: {complexity['cycles']}\")\n        print(f\"  Leaf Services: {complexity['leaf_services']}\")\n        print(f\"  Root Services: {complexity['root_services']}\")\n\n        if complexity['cycles'] &gt; 0:\n            print(\"\\nCircular Dependencies Found:\")\n            cycles = self.graph.find_cycles()\n            for i, cycle in enumerate(cycles, 1):\n                cycle_names = [service.__name__ for service in cycle]\n                print(f\"  {i}. {' -&gt; '.join(cycle_names)}\")\n</code></pre>"},{"location":"api-reference/diagnostics/#performance-monitoring","title":"Performance Monitoring","text":""},{"location":"api-reference/diagnostics/#performance-metrics","title":"Performance Metrics","text":"<pre><code>from dataclasses import dataclass\nimport time\nfrom typing import Dict, List\nfrom datetime import datetime, timedelta\n\n@dataclass\nclass ResolutionMetrics:\n    \"\"\"Metrics for service resolution performance.\"\"\"\n    service_type: type\n    resolution_count: int\n    total_time_ms: float\n    average_time_ms: float\n    min_time_ms: float\n    max_time_ms: float\n    error_count: int\n    last_resolution: datetime\n\n    def __str__(self):\n        return f\"\"\"Resolution Metrics for {self.service_type.__name__}:\n  Resolutions: {self.resolution_count}\n  Average Time: {self.average_time_ms:.2f}ms\n  Min/Max Time: {self.min_time_ms:.2f}ms / {self.max_time_ms:.2f}ms\n  Error Rate: {self.error_count}/{self.resolution_count} ({(self.error_count/self.resolution_count*100) if self.resolution_count &gt; 0 else 0:.1f}%)\n  Last Resolution: {self.last_resolution}\"\"\"\n\nclass PerformanceMonitor:\n    \"\"\"Monitors container performance metrics.\"\"\"\n\n    def __init__(self, container):\n        self.container = container\n        self.metrics: Dict[type, ResolutionMetrics] = {}\n        self.resolution_times: Dict[type, List[float]] = {}\n        self.enabled = True\n\n    def start_resolution(self, service_type: type) -&gt; str:\n        \"\"\"Start timing a service resolution.\"\"\"\n        if not self.enabled:\n            return \"\"\n\n        resolution_id = f\"{service_type.__name__}_{time.time()}\"\n        setattr(self, f\"_start_{resolution_id}\", time.perf_counter())\n        return resolution_id\n\n    def end_resolution(self, service_type: type, resolution_id: str, success: bool = True):\n        \"\"\"End timing a service resolution.\"\"\"\n        if not self.enabled or not resolution_id:\n            return\n\n        start_time = getattr(self, f\"_start_{resolution_id}\", None)\n        if start_time is None:\n            return\n\n        end_time = time.perf_counter()\n        duration_ms = (end_time - start_time) * 1000\n\n        # Update metrics\n        self.record_resolution(service_type, duration_ms, success)\n\n        # Clean up\n        delattr(self, f\"_start_{resolution_id}\")\n\n    def record_resolution(self, service_type: type, duration_ms: float, success: bool = True):\n        \"\"\"Record a service resolution.\"\"\"\n        if service_type not in self.metrics:\n            self.metrics[service_type] = ResolutionMetrics(\n                service_type=service_type,\n                resolution_count=0,\n                total_time_ms=0.0,\n                average_time_ms=0.0,\n                min_time_ms=float('inf'),\n                max_time_ms=0.0,\n                error_count=0,\n                last_resolution=datetime.now()\n            )\n            self.resolution_times[service_type] = []\n\n        metrics = self.metrics[service_type]\n\n        # Update metrics\n        metrics.resolution_count += 1\n        metrics.total_time_ms += duration_ms\n        metrics.average_time_ms = metrics.total_time_ms / metrics.resolution_count\n        metrics.min_time_ms = min(metrics.min_time_ms, duration_ms)\n        metrics.max_time_ms = max(metrics.max_time_ms, duration_ms)\n        metrics.last_resolution = datetime.now()\n\n        if not success:\n            metrics.error_count += 1\n\n        # Store individual resolution times (keep last 100)\n        times = self.resolution_times[service_type]\n        times.append(duration_ms)\n        if len(times) &gt; 100:\n            times.pop(0)\n\n    def get_metrics(self, service_type: type = None) -&gt; Dict[type, ResolutionMetrics]:\n        \"\"\"Get performance metrics.\"\"\"\n        if service_type:\n            return {service_type: self.metrics.get(service_type)} if service_type in self.metrics else {}\n        return self.metrics.copy()\n\n    def get_slow_services(self, threshold_ms: float = 100.0) -&gt; List[ResolutionMetrics]:\n        \"\"\"Get services with slow average resolution times.\"\"\"\n        slow_services = []\n\n        for metrics in self.metrics.values():\n            if metrics.average_time_ms &gt; threshold_ms:\n                slow_services.append(metrics)\n\n        return sorted(slow_services, key=lambda m: m.average_time_ms, reverse=True)\n\n    def get_error_prone_services(self, min_error_rate: float = 0.1) -&gt; List[ResolutionMetrics]:\n        \"\"\"Get services with high error rates.\"\"\"\n        error_prone = []\n\n        for metrics in self.metrics.values():\n            if metrics.resolution_count &gt; 0:\n                error_rate = metrics.error_count / metrics.resolution_count\n                if error_rate &gt;= min_error_rate:\n                    error_prone.append(metrics)\n\n        return sorted(error_prone, key=lambda m: m.error_count / m.resolution_count, reverse=True)\n\n    def reset_metrics(self):\n        \"\"\"Reset all performance metrics.\"\"\"\n        self.metrics.clear()\n        self.resolution_times.clear()\n\n    def generate_report(self) -&gt; str:\n        \"\"\"Generate performance report.\"\"\"\n        if not self.metrics:\n            return \"No performance data available.\"\n\n        lines = [\"Performance Report\", \"=\" * 50]\n\n        # Overall statistics\n        total_resolutions = sum(m.resolution_count for m in self.metrics.values())\n        total_errors = sum(m.error_count for m in self.metrics.values())\n        avg_resolution_time = sum(m.average_time_ms for m in self.metrics.values()) / len(self.metrics)\n\n        lines.append(f\"Total Resolutions: {total_resolutions}\")\n        lines.append(f\"Total Errors: {total_errors}\")\n        lines.append(f\"Overall Error Rate: {(total_errors/total_resolutions*100) if total_resolutions &gt; 0 else 0:.2f}%\")\n        lines.append(f\"Average Resolution Time: {avg_resolution_time:.2f}ms\")\n        lines.append(\"\")\n\n        # Slow services\n        slow_services = self.get_slow_services(50.0)\n        if slow_services:\n            lines.append(\"Slow Services (&gt;50ms):\")\n            for metrics in slow_services[:5]:  # Top 5\n                lines.append(f\"  {metrics.service_type.__name__}: {metrics.average_time_ms:.2f}ms\")\n            lines.append(\"\")\n\n        # Error-prone services\n        error_prone = self.get_error_prone_services(0.05)\n        if error_prone:\n            lines.append(\"Error-Prone Services (&gt;5% error rate):\")\n            for metrics in error_prone[:5]:  # Top 5\n                error_rate = metrics.error_count / metrics.resolution_count * 100\n                lines.append(f\"  {metrics.service_type.__name__}: {error_rate:.1f}% ({metrics.error_count}/{metrics.resolution_count})\")\n\n        return '\\n'.join(lines)\n</code></pre>"},{"location":"api-reference/diagnostics/#diagnostic-tools","title":"Diagnostic Tools","text":""},{"location":"api-reference/diagnostics/#health-check","title":"Health Check","text":"<pre><code>class ContainerHealthCheck:\n    \"\"\"Performs health checks on container.\"\"\"\n\n    def __init__(self, container):\n        self.container = container\n        self.diagnostics = ContainerDiagnostics(container)\n        self.validator = ContainerValidator(container)\n\n    def check_health(self) -&gt; Dict[str, Any]:\n        \"\"\"Perform comprehensive health check.\"\"\"\n        health_status = {\n            'overall_status': 'healthy',\n            'timestamp': datetime.now(),\n            'checks': {}\n        }\n\n        # Validation check\n        validation_result = self.validator.validate()\n        health_status['checks']['validation'] = {\n            'status': 'passed' if validation_result.is_valid else 'failed',\n            'errors': validation_result.errors,\n            'warnings': validation_result.warnings\n        }\n\n        # Memory check\n        overview = self.diagnostics.get_overview()\n        memory_status = 'healthy' if overview.memory_usage_mb &lt; 100 else 'warning' if overview.memory_usage_mb &lt; 500 else 'critical'\n        health_status['checks']['memory'] = {\n            'status': memory_status,\n            'usage_mb': overview.memory_usage_mb\n        }\n\n        # Performance check\n        if hasattr(self.container, '_performance_monitor'):\n            monitor = self.container._performance_monitor\n            slow_services = monitor.get_slow_services(100.0)\n            performance_status = 'healthy' if len(slow_services) == 0 else 'warning'\n            health_status['checks']['performance'] = {\n                'status': performance_status,\n                'slow_services_count': len(slow_services)\n            }\n\n        # Determine overall status\n        check_statuses = [check['status'] for check in health_status['checks'].values()]\n        if 'failed' in check_statuses or 'critical' in check_statuses:\n            health_status['overall_status'] = 'unhealthy'\n        elif 'warning' in check_statuses:\n            health_status['overall_status'] = 'degraded'\n\n        return health_status\n\n    def print_health_report(self):\n        \"\"\"Print formatted health report.\"\"\"\n        health = self.check_health()\n\n        status_emoji = {\n            'healthy': '\u2705',\n            'degraded': '\u26a0\ufe0f',\n            'unhealthy': '\u274c'\n        }\n\n        print(f\"{status_emoji[health['overall_status']]} Container Health: {health['overall_status'].upper()}\")\n        print(f\"Checked at: {health['timestamp']}\")\n        print()\n\n        for check_name, check_result in health['checks'].items():\n            status = check_result['status']\n            emoji = '\u2705' if status == 'passed' or status == 'healthy' else '\u26a0\ufe0f' if status == 'warning' else '\u274c'\n            print(f\"{emoji} {check_name.title()}: {status}\")\n\n            if 'errors' in check_result and check_result['errors']:\n                for error in check_result['errors']:\n                    print(f\"    \u274c {error}\")\n\n            if 'warnings' in check_result and check_result['warnings']:\n                for warning in check_result['warnings']:\n                    print(f\"    \u26a0\ufe0f {warning}\")\n</code></pre>"},{"location":"api-reference/exceptions/","title":"Exceptions API","text":"<p>::: injectq.utils.exceptions</p>"},{"location":"api-reference/exceptions/#overview","title":"Overview","text":"<p>The exceptions module provides a comprehensive hierarchy of exceptions for dependency injection scenarios, enabling precise error handling and debugging.</p>"},{"location":"api-reference/exceptions/#core-exceptions","title":"Core Exceptions","text":""},{"location":"api-reference/exceptions/#base-exception","title":"Base Exception","text":"<pre><code>class InjectQException(Exception):\n    \"\"\"Base exception for all InjectQ-related errors.\"\"\"\n\n    def __init__(self, message: str, service_type: Type = None, context: Dict[str, Any] = None):\n        super().__init__(message)\n        self.service_type = service_type\n        self.context = context or {}\n        self.timestamp = datetime.now()\n\n    def __str__(self):\n        base_msg = super().__str__()\n        if self.service_type:\n            base_msg += f\" (Service: {self.service_type.__name__})\"\n        return base_msg\n\n    def get_context_info(self) -&gt; str:\n        \"\"\"Get formatted context information.\"\"\"\n        if not self.context:\n            return \"\"\n\n        context_lines = [\"Context:\"]\n        for key, value in self.context.items():\n            context_lines.append(f\"  {key}: {value}\")\n        return \"\\n\".join(context_lines)\n\n    def get_full_message(self) -&gt; str:\n        \"\"\"Get full error message with context.\"\"\"\n        message = str(self)\n        context_info = self.get_context_info()\n        if context_info:\n            message += f\"\\n{context_info}\"\n        return message\n</code></pre>"},{"location":"api-reference/exceptions/#registration-exceptions","title":"Registration Exceptions","text":"<pre><code>class RegistrationException(InjectQException):\n    \"\"\"Base exception for service registration errors.\"\"\"\n    pass\n\nclass ServiceAlreadyRegisteredException(RegistrationException):\n    \"\"\"Raised when attempting to register a service that's already registered.\"\"\"\n\n    def __init__(self, service_type: Type, existing_implementation: Any = None):\n        message = f\"Service {service_type.__name__} is already registered\"\n        if existing_implementation:\n            message += f\" with implementation {existing_implementation}\"\n\n        super().__init__(\n            message=message,\n            service_type=service_type,\n            context={'existing_implementation': existing_implementation}\n        )\n\nclass InvalidServiceRegistrationException(RegistrationException):\n    \"\"\"Raised when service registration parameters are invalid.\"\"\"\n\n    def __init__(self, service_type: Type, reason: str, invalid_parameter: str = None):\n        message = f\"Invalid registration for {service_type.__name__}: {reason}\"\n\n        context = {'reason': reason}\n        if invalid_parameter:\n            context['invalid_parameter'] = invalid_parameter\n\n        super().__init__(\n            message=message,\n            service_type=service_type,\n            context=context\n        )\n\nclass ServiceNotRegisteredException(RegistrationException):\n    \"\"\"Raised when attempting to access a service that's not registered.\"\"\"\n\n    def __init__(self, service_type: Type, available_services: List[Type] = None):\n        message = f\"Service {service_type.__name__} is not registered\"\n\n        context = {}\n        if available_services:\n            context['available_services'] = [s.__name__ for s in available_services]\n            message += f\". Available services: {', '.join(context['available_services'])}\"\n\n        super().__init__(\n            message=message,\n            service_type=service_type,\n            context=context\n        )\n\nclass DuplicateServiceException(RegistrationException):\n    \"\"\"Raised when multiple services are registered for the same type.\"\"\"\n\n    def __init__(self, service_type: Type, implementations: List[Any]):\n        impl_names = [getattr(impl, '__name__', str(impl)) for impl in implementations]\n        message = f\"Multiple implementations registered for {service_type.__name__}: {', '.join(impl_names)}\"\n\n        super().__init__(\n            message=message,\n            service_type=service_type,\n            context={'implementations': impl_names}\n        )\n</code></pre>"},{"location":"api-reference/exceptions/#resolution-exceptions","title":"Resolution Exceptions","text":"<pre><code>class ResolutionException(InjectQException):\n    \"\"\"Base exception for service resolution errors.\"\"\"\n\n    def __init__(self, message: str, service_type: Type = None, resolution_chain: List[Type] = None):\n        super().__init__(message, service_type)\n        self.resolution_chain = resolution_chain or []\n        if resolution_chain:\n            self.context['resolution_chain'] = [t.__name__ for t in resolution_chain]\n\nclass ServiceResolutionException(ResolutionException):\n    \"\"\"Raised when a service cannot be resolved.\"\"\"\n\n    def __init__(self, service_type: Type, reason: str, resolution_chain: List[Type] = None):\n        message = f\"Failed to resolve service {service_type.__name__}: {reason}\"\n        super().__init__(\n            message=message,\n            service_type=service_type,\n            resolution_chain=resolution_chain\n        )\n\nclass CircularDependencyException(ResolutionException):\n    \"\"\"Raised when a circular dependency is detected during resolution.\"\"\"\n\n    def __init__(self, service_type: Type, dependency_cycle: List[Type]):\n        cycle_names = [t.__name__ for t in dependency_cycle]\n        cycle_str = \" -&gt; \".join(cycle_names + [dependency_cycle[0].__name__])\n        message = f\"Circular dependency detected for {service_type.__name__}: {cycle_str}\"\n\n        super().__init__(\n            message=message,\n            service_type=service_type,\n            resolution_chain=dependency_cycle\n        )\n        self.dependency_cycle = dependency_cycle\n\nclass MissingDependencyException(ResolutionException):\n    \"\"\"Raised when a required dependency is not available.\"\"\"\n\n    def __init__(self, service_type: Type, missing_dependency: Type, parameter_name: str = None):\n        message = f\"Missing dependency {missing_dependency.__name__} for service {service_type.__name__}\"\n        if parameter_name:\n            message += f\" (parameter: {parameter_name})\"\n\n        super().__init__(\n            message=message,\n            service_type=service_type,\n            context={\n                'missing_dependency': missing_dependency.__name__,\n                'parameter_name': parameter_name\n            }\n        )\n        self.missing_dependency = missing_dependency\n        self.parameter_name = parameter_name\n\nclass ConstructorException(ResolutionException):\n    \"\"\"Raised when service constructor fails.\"\"\"\n\n    def __init__(self, service_type: Type, original_exception: Exception, parameters: Dict[str, Any] = None):\n        message = f\"Constructor failed for service {service_type.__name__}: {str(original_exception)}\"\n\n        context = {'original_exception': str(original_exception)}\n        if parameters:\n            context['constructor_parameters'] = {k: type(v).__name__ for k, v in parameters.items()}\n\n        super().__init__(\n            message=message,\n            service_type=service_type,\n            context=context\n        )\n        self.original_exception = original_exception\n        self.parameters = parameters\n\nclass ServiceCreationException(ResolutionException):\n    \"\"\"Raised when service creation fails.\"\"\"\n\n    def __init__(self, service_type: Type, creation_method: str, original_exception: Exception = None):\n        message = f\"Failed to create service {service_type.__name__} using {creation_method}\"\n        if original_exception:\n            message += f\": {str(original_exception)}\"\n\n        context = {'creation_method': creation_method}\n        if original_exception:\n            context['original_exception'] = str(original_exception)\n\n        super().__init__(\n            message=message,\n            service_type=service_type,\n            context=context\n        )\n        self.creation_method = creation_method\n        self.original_exception = original_exception\n</code></pre>"},{"location":"api-reference/exceptions/#scope-exceptions","title":"Scope Exceptions","text":"<pre><code>class ScopeException(InjectQException):\n    \"\"\"Base exception for scope-related errors.\"\"\"\n    pass\n\nclass ScopeNotActiveException(ScopeException):\n    \"\"\"Raised when attempting to use a scope that's not active.\"\"\"\n\n    def __init__(self, scope_name: str, service_type: Type = None):\n        message = f\"Scope '{scope_name}' is not active\"\n        if service_type:\n            message += f\" for service {service_type.__name__}\"\n\n        super().__init__(\n            message=message,\n            service_type=service_type,\n            context={'scope_name': scope_name}\n        )\n        self.scope_name = scope_name\n\nclass ScopeDisposedException(ScopeException):\n    \"\"\"Raised when attempting to use a disposed scope.\"\"\"\n\n    def __init__(self, scope_name: str, service_type: Type = None):\n        message = f\"Scope '{scope_name}' has been disposed\"\n        if service_type:\n            message += f\" (requested service: {service_type.__name__})\"\n\n        super().__init__(\n            message=message,\n            service_type=service_type,\n            context={'scope_name': scope_name}\n        )\n        self.scope_name = scope_name\n\nclass InvalidScopeException(ScopeException):\n    \"\"\"Raised when an invalid scope is specified.\"\"\"\n\n    def __init__(self, scope_name: str, valid_scopes: List[str] = None):\n        message = f\"Invalid scope '{scope_name}'\"\n        if valid_scopes:\n            message += f\". Valid scopes: {', '.join(valid_scopes)}\"\n\n        super().__init__(\n            message=message,\n            context={'scope_name': scope_name, 'valid_scopes': valid_scopes}\n        )\n        self.scope_name = scope_name\n        self.valid_scopes = valid_scopes\n\nclass ScopeLifecycleException(ScopeException):\n    \"\"\"Raised when scope lifecycle operations fail.\"\"\"\n\n    def __init__(self, scope_name: str, operation: str, reason: str):\n        message = f\"Scope '{scope_name}' {operation} failed: {reason}\"\n\n        super().__init__(\n            message=message,\n            context={\n                'scope_name': scope_name,\n                'operation': operation,\n                'reason': reason\n            }\n        )\n        self.scope_name = scope_name\n        self.operation = operation\n        self.reason = reason\n</code></pre>"},{"location":"api-reference/exceptions/#configuration-exceptions","title":"Configuration Exceptions","text":"<pre><code>class ConfigurationException(InjectQException):\n    \"\"\"Base exception for configuration errors.\"\"\"\n    pass\n\nclass InvalidConfigurationException(ConfigurationException):\n    \"\"\"Raised when container configuration is invalid.\"\"\"\n\n    def __init__(self, config_key: str, config_value: Any, reason: str):\n        message = f\"Invalid configuration for '{config_key}': {reason}\"\n\n        super().__init__(\n            message=message,\n            context={\n                'config_key': config_key,\n                'config_value': str(config_value),\n                'reason': reason\n            }\n        )\n        self.config_key = config_key\n        self.config_value = config_value\n        self.reason = reason\n\nclass ModuleLoadException(ConfigurationException):\n    \"\"\"Raised when a module fails to load.\"\"\"\n\n    def __init__(self, module_name: str, original_exception: Exception):\n        message = f\"Failed to load module '{module_name}': {str(original_exception)}\"\n\n        super().__init__(\n            message=message,\n            context={\n                'module_name': module_name,\n                'original_exception': str(original_exception)\n            }\n        )\n        self.module_name = module_name\n        self.original_exception = original_exception\n\nclass ContainerLockedException(ConfigurationException):\n    \"\"\"Raised when attempting to modify a locked container.\"\"\"\n\n    def __init__(self, operation: str):\n        message = f\"Cannot perform '{operation}' on locked container\"\n\n        super().__init__(\n            message=message,\n            context={'operation': operation}\n        )\n        self.operation = operation\n</code></pre>"},{"location":"api-reference/exceptions/#validation-exceptions","title":"Validation Exceptions","text":"<pre><code>class ValidationException(InjectQException):\n    \"\"\"Base exception for validation errors.\"\"\"\n    pass\n\nclass TypeValidationException(ValidationException):\n    \"\"\"Raised when type validation fails.\"\"\"\n\n    def __init__(self, expected_type: Type, actual_type: Type, parameter_name: str = None):\n        message = f\"Type validation failed: expected {expected_type.__name__}, got {actual_type.__name__}\"\n        if parameter_name:\n            message += f\" for parameter '{parameter_name}'\"\n\n        super().__init__(\n            message=message,\n            context={\n                'expected_type': expected_type.__name__,\n                'actual_type': actual_type.__name__,\n                'parameter_name': parameter_name\n            }\n        )\n        self.expected_type = expected_type\n        self.actual_type = actual_type\n        self.parameter_name = parameter_name\n\nclass ContainerValidationException(ValidationException):\n    \"\"\"Raised when container validation fails.\"\"\"\n\n    def __init__(self, validation_errors: List[str]):\n        message = f\"Container validation failed with {len(validation_errors)} error(s)\"\n\n        super().__init__(\n            message=message,\n            context={'validation_errors': validation_errors}\n        )\n        self.validation_errors = validation_errors\n\n    def __str__(self):\n        base_msg = super().__str__()\n        if self.validation_errors:\n            error_list = \"\\n\".join(f\"  - {error}\" for error in self.validation_errors)\n            base_msg += f\"\\nValidation errors:\\n{error_list}\"\n        return base_msg\n</code></pre>"},{"location":"api-reference/exceptions/#integration-exceptions","title":"Integration Exceptions","text":"<pre><code>class IntegrationException(InjectQException):\n    \"\"\"Base exception for framework integration errors.\"\"\"\n    pass\n\nclass FrameworkIntegrationException(IntegrationException):\n    \"\"\"Raised when framework integration fails.\"\"\"\n\n    def __init__(self, framework_name: str, reason: str, component: str = None):\n        message = f\"{framework_name} integration failed: {reason}\"\n        if component:\n            message += f\" (component: {component})\"\n\n        super().__init__(\n            message=message,\n            context={\n                'framework_name': framework_name,\n                'reason': reason,\n                'component': component\n            }\n        )\n        self.framework_name = framework_name\n        self.reason = reason\n        self.component = component\n\nclass MiddlewareException(IntegrationException):\n    \"\"\"Raised when middleware integration fails.\"\"\"\n\n    def __init__(self, middleware_name: str, operation: str, original_exception: Exception = None):\n        message = f\"Middleware '{middleware_name}' {operation} failed\"\n        if original_exception:\n            message += f\": {str(original_exception)}\"\n\n        context = {\n            'middleware_name': middleware_name,\n            'operation': operation\n        }\n        if original_exception:\n            context['original_exception'] = str(original_exception)\n\n        super().__init__(\n            message=message,\n            context=context\n        )\n        self.middleware_name = middleware_name\n        self.operation = operation\n        self.original_exception = original_exception\n</code></pre>"},{"location":"api-reference/exceptions/#exception-utilities","title":"Exception Utilities","text":""},{"location":"api-reference/exceptions/#exception-handler","title":"Exception Handler","text":"<pre><code>from typing import Callable, Type, Dict, List\nimport logging\nimport traceback\n\nclass ExceptionHandler:\n    \"\"\"Centralized exception handling for InjectQ.\"\"\"\n\n    def __init__(self, logger: logging.Logger = None):\n        self.logger = logger or logging.getLogger(__name__)\n        self._handlers: Dict[Type[Exception], List[Callable]] = {}\n        self._global_handlers: List[Callable] = []\n\n    def register_handler(self, exception_type: Type[Exception], handler: Callable[[Exception], None]):\n        \"\"\"Register a handler for a specific exception type.\"\"\"\n        if exception_type not in self._handlers:\n            self._handlers[exception_type] = []\n        self._handlers[exception_type].append(handler)\n\n    def register_global_handler(self, handler: Callable[[Exception], None]):\n        \"\"\"Register a global exception handler.\"\"\"\n        self._global_handlers.append(handler)\n\n    def handle_exception(self, exception: Exception, context: Dict[str, Any] = None) -&gt; bool:\n        \"\"\"Handle an exception using registered handlers.\"\"\"\n        handled = False\n\n        # Try specific handlers first\n        for exc_type, handlers in self._handlers.items():\n            if isinstance(exception, exc_type):\n                for handler in handlers:\n                    try:\n                        handler(exception)\n                        handled = True\n                    except Exception as handler_exc:\n                        self.logger.error(f\"Exception handler failed: {handler_exc}\")\n\n        # Try global handlers\n        if not handled:\n            for handler in self._global_handlers:\n                try:\n                    handler(exception)\n                    handled = True\n                except Exception as handler_exc:\n                    self.logger.error(f\"Global exception handler failed: {handler_exc}\")\n\n        # Default logging if not handled\n        if not handled:\n            self._log_exception(exception, context)\n\n        return handled\n\n    def _log_exception(self, exception: Exception, context: Dict[str, Any] = None):\n        \"\"\"Log exception with context information.\"\"\"\n        error_msg = f\"Unhandled InjectQ exception: {exception}\"\n\n        if isinstance(exception, InjectQException):\n            error_msg = exception.get_full_message()\n\n        if context:\n            error_msg += f\"\\nAdditional context: {context}\"\n\n        self.logger.error(error_msg, exc_info=True)\n\n# Default exception handlers\ndef log_registration_errors(exception: RegistrationException):\n    \"\"\"Default handler for registration errors.\"\"\"\n    logging.getLogger('injectq.registration').error(\n        f\"Registration error: {exception.get_full_message()}\"\n    )\n\ndef log_resolution_errors(exception: ResolutionException):\n    \"\"\"Default handler for resolution errors.\"\"\"\n    logger = logging.getLogger('injectq.resolution')\n\n    if isinstance(exception, CircularDependencyException):\n        logger.error(f\"Circular dependency detected: {exception.dependency_cycle}\")\n    else:\n        logger.error(f\"Resolution error: {exception.get_full_message()}\")\n\ndef log_scope_errors(exception: ScopeException):\n    \"\"\"Default handler for scope errors.\"\"\"\n    logging.getLogger('injectq.scope').warning(\n        f\"Scope error: {exception.get_full_message()}\"\n    )\n\n# Setup default handlers\ndefault_handler = ExceptionHandler()\ndefault_handler.register_handler(RegistrationException, log_registration_errors)\ndefault_handler.register_handler(ResolutionException, log_resolution_errors)\ndefault_handler.register_handler(ScopeException, log_scope_errors)\n</code></pre>"},{"location":"api-reference/exceptions/#exception-context-manager","title":"Exception Context Manager","text":"<pre><code>from contextlib import contextmanager\nfrom typing import Generator, Optional, Callable\n\n@contextmanager\ndef handle_injectq_exceptions(\n    handler: ExceptionHandler = None,\n    reraise: bool = True,\n    fallback_value: Any = None,\n    custom_handler: Callable[[Exception], Any] = None\n) -&gt; Generator[None, None, None]:\n    \"\"\"Context manager for handling InjectQ exceptions.\"\"\"\n\n    exception_handler = handler or default_handler\n\n    try:\n        yield\n    except InjectQException as e:\n        # Handle with registered handlers\n        handled = exception_handler.handle_exception(e)\n\n        # Custom handler\n        if custom_handler:\n            try:\n                result = custom_handler(e)\n                if result is not None:\n                    return result\n            except Exception as handler_exc:\n                logging.getLogger(__name__).error(f\"Custom handler failed: {handler_exc}\")\n\n        # Reraise or return fallback\n        if reraise:\n            raise\n        else:\n            return fallback_value\n    except Exception as e:\n        # Wrap non-InjectQ exceptions\n        wrapped = InjectQException(f\"Unexpected error: {str(e)}\")\n        wrapped.__cause__ = e\n\n        exception_handler.handle_exception(wrapped)\n\n        if reraise:\n            raise wrapped\n        else:\n            return fallback_value\n\n# Usage examples\ndef safe_service_resolution(container: Container, service_type: Type[T]) -&gt; Optional[T]:\n    \"\"\"Safely resolve a service, returning None on error.\"\"\"\n\n    with handle_injectq_exceptions(reraise=False, fallback_value=None):\n        return container.resolve(service_type)\n\ndef resolve_with_fallback(container: Container, service_type: Type[T], fallback: T) -&gt; T:\n    \"\"\"Resolve a service with a fallback value.\"\"\"\n\n    def fallback_handler(exc: Exception) -&gt; T:\n        logging.getLogger(__name__).warning(f\"Using fallback for {service_type.__name__}: {exc}\")\n        return fallback\n\n    with handle_injectq_exceptions(reraise=False, custom_handler=fallback_handler):\n        return container.resolve(service_type)\n</code></pre>"},{"location":"api-reference/exceptions/#exception-diagnostics","title":"Exception Diagnostics","text":"<pre><code>class ExceptionDiagnostics:\n    \"\"\"Provides diagnostic information for InjectQ exceptions.\"\"\"\n\n    @staticmethod\n    def analyze_exception(exception: InjectQException) -&gt; Dict[str, Any]:\n        \"\"\"Analyze an exception and provide diagnostic information.\"\"\"\n        analysis = {\n            'exception_type': type(exception).__name__,\n            'message': str(exception),\n            'service_type': exception.service_type.__name__ if exception.service_type else None,\n            'context': exception.context,\n            'timestamp': exception.timestamp,\n            'suggestions': []\n        }\n\n        # Add type-specific analysis\n        if isinstance(exception, ServiceNotRegisteredException):\n            analysis['suggestions'] = [\n                f\"Register {exception.service_type.__name__} with container.register()\",\n                \"Check if the service is registered in a different scope\",\n                \"Verify the service type is spelled correctly\"\n            ]\n\n        elif isinstance(exception, CircularDependencyException):\n            analysis['dependency_cycle'] = [t.__name__ for t in exception.dependency_cycle]\n            analysis['suggestions'] = [\n                \"Break the circular dependency by using interfaces\",\n                \"Consider using factory patterns\",\n                \"Refactor services to reduce coupling\"\n            ]\n\n        elif isinstance(exception, MissingDependencyException):\n            analysis['missing_dependency'] = exception.missing_dependency.__name__\n            analysis['suggestions'] = [\n                f\"Register {exception.missing_dependency.__name__} with the container\",\n                \"Make the dependency optional if it's not required\",\n                \"Check if the dependency is registered with a different name\"\n            ]\n\n        elif isinstance(exception, TypeValidationException):\n            analysis['type_mismatch'] = {\n                'expected': exception.expected_type.__name__,\n                'actual': exception.actual_type.__name__\n            }\n            analysis['suggestions'] = [\n                \"Check that the registered implementation matches the service interface\",\n                \"Verify type annotations are correct\",\n                \"Consider using duck typing if appropriate\"\n            ]\n\n        return analysis\n\n    @staticmethod\n    def print_exception_analysis(exception: InjectQException):\n        \"\"\"Print formatted exception analysis.\"\"\"\n        analysis = ExceptionDiagnostics.analyze_exception(exception)\n\n        print(f\"InjectQ Exception Analysis\")\n        print(f\"=\" * 50)\n        print(f\"Exception Type: {analysis['exception_type']}\")\n        print(f\"Message: {analysis['message']}\")\n\n        if analysis['service_type']:\n            print(f\"Service Type: {analysis['service_type']}\")\n\n        if analysis['context']:\n            print(f\"Context:\")\n            for key, value in analysis['context'].items():\n                print(f\"  {key}: {value}\")\n\n        if 'dependency_cycle' in analysis:\n            cycle = \" -&gt; \".join(analysis['dependency_cycle'])\n            print(f\"Dependency Cycle: {cycle}\")\n\n        if analysis['suggestions']:\n            print(f\"\\nSuggestions:\")\n            for suggestion in analysis['suggestions']:\n                print(f\"  \u2022 {suggestion}\")\n\n        print(f\"\\nTimestamp: {analysis['timestamp']}\")\n\n# Usage\ntry:\n    container.resolve(UnregisteredService)\nexcept InjectQException as e:\n    ExceptionDiagnostics.print_exception_analysis(e)\n</code></pre>"},{"location":"api-reference/integrations/","title":"Integrations API","text":"<p>::: injectq.integrations</p>"},{"location":"api-reference/integrations/#overview","title":"Overview","text":"<p>The integrations module provides seamless integration with popular Python frameworks and libraries, enabling easy adoption of dependency injection in existing applications.</p>"},{"location":"api-reference/integrations/#fastapi-integration","title":"FastAPI Integration","text":""},{"location":"api-reference/integrations/#basic-integration","title":"Basic Integration","text":"<pre><code>from fastapi import FastAPI\nfrom injectq.integrations.fastapi import InjectQDependency, setup_injectq\nfrom injectq import Container, inject\n\n# Create FastAPI app and InjectQ container\napp = FastAPI()\ncontainer = Container()\n\n# Register services\ncontainer.register(UserRepository, DatabaseUserRepository)\ncontainer.register(EmailService, SMTPEmailService)\n\n# Setup InjectQ with FastAPI\nsetup_injectq(app, container)\n\n# Use dependency injection in endpoints\n@app.get(\"/users/{user_id}\")\n@inject\nasync def get_user(user_id: int, user_service: UserService = InjectQDependency()):\n    return await user_service.get_user(user_id)\n\n@app.post(\"/users\")\n@inject\nasync def create_user(user_data: UserCreateModel, user_service: UserService = InjectQDependency()):\n    return await user_service.create_user(user_data)\n</code></pre>"},{"location":"api-reference/integrations/#fastapi-dependency-provider","title":"FastAPI Dependency Provider","text":"<pre><code>from typing import Type, TypeVar, Any, Callable\nfrom fastapi import Depends, Request\nfrom fastapi.dependencies.utils import get_typed_signature\n\nT = TypeVar('T')\n\nclass InjectQDependency:\n    \"\"\"FastAPI dependency that resolves services from InjectQ container.\"\"\"\n\n    def __init__(self, service_type: Type[T] = None):\n        self.service_type = service_type\n\n    def __call__(self, request: Request) -&gt; Any:\n        \"\"\"Resolve service from container.\"\"\"\n        container = getattr(request.app.state, 'injectq_container', None)\n        if not container:\n            raise RuntimeError(\"InjectQ container not configured. Call setup_injectq() first.\")\n\n        if self.service_type:\n            return container.resolve(self.service_type)\n        else:\n            # Auto-detect service type from function parameter annotation\n            frame = inspect.currentframe()\n            if frame and frame.f_back:\n                local_vars = frame.f_back.f_locals\n                # This is a simplified approach - real implementation would be more robust\n                for var_name, var_value in local_vars.items():\n                    if isinstance(var_value, type):\n                        return container.resolve(var_value)\n\n            raise ValueError(\"Could not determine service type for injection\")\n\ndef setup_injectq(app: FastAPI, container: Container):\n    \"\"\"Setup InjectQ integration with FastAPI.\"\"\"\n    app.state.injectq_container = container\n\n    # Add middleware for scope management\n    @app.middleware(\"http\")\n    async def injectq_scope_middleware(request: Request, call_next):\n        # Create request scope\n        with container.create_scope() as scope:\n            request.state.injectq_scope = scope\n            response = await call_next(request)\n            return response\n\n    return app\n\n# Alternative dependency function\ndef get_service(service_type: Type[T]) -&gt; Callable[[Request], T]:\n    \"\"\"Create FastAPI dependency function for a service type.\"\"\"\n    def dependency(request: Request) -&gt; T:\n        container = request.app.state.injectq_container\n        return container.resolve(service_type)\n\n    return dependency\n\n# Usage with get_service\n@app.get(\"/users/{user_id}\")\nasync def get_user_alt(\n    user_id: int,\n    user_service: UserService = Depends(get_service(UserService))\n):\n    return await user_service.get_user(user_id)\n</code></pre>"},{"location":"api-reference/integrations/#scoped-services-in-fastapi","title":"Scoped Services in FastAPI","text":"<pre><code>from contextlib import asynccontextmanager\n\nclass FastAPIScope:\n    \"\"\"FastAPI-specific scope implementation.\"\"\"\n\n    def __init__(self, container: Container):\n        self.container = container\n        self._request_instances: Dict[Type, Any] = {}\n\n    def get_instance(self, service_type: Type[T]) -&gt; T:\n        \"\"\"Get or create scoped instance for request.\"\"\"\n        if service_type not in self._request_instances:\n            self._request_instances[service_type] = self.container.resolve(service_type)\n        return self._request_instances[service_type]\n\n    def dispose(self):\n        \"\"\"Dispose all request-scoped instances.\"\"\"\n        for instance in self._request_instances.values():\n            if hasattr(instance, 'dispose'):\n                instance.dispose()\n        self._request_instances.clear()\n\n@asynccontextmanager\nasync def request_scope_lifespan(app: FastAPI):\n    \"\"\"Lifespan context manager for request scopes.\"\"\"\n    # Startup\n    yield\n    # Shutdown - cleanup handled by middleware\n\ndef setup_request_scoping(app: FastAPI, container: Container):\n    \"\"\"Setup request-scoped services.\"\"\"\n\n    @app.middleware(\"http\")\n    async def request_scope_middleware(request: Request, call_next):\n        scope = FastAPIScope(container)\n        request.state.service_scope = scope\n\n        try:\n            response = await call_next(request)\n            return response\n        finally:\n            scope.dispose()\n\n    # Modify dependency to use request scope\n    def get_scoped_service(service_type: Type[T]) -&gt; Callable[[Request], T]:\n        def dependency(request: Request) -&gt; T:\n            scope = getattr(request.state, 'service_scope', None)\n            if scope:\n                return scope.get_instance(service_type)\n            else:\n                # Fallback to container\n                container = request.app.state.injectq_container\n                return container.resolve(service_type)\n\n        return dependency\n\n    return get_scoped_service\n</code></pre>"},{"location":"api-reference/integrations/#django-integration","title":"Django Integration","text":""},{"location":"api-reference/integrations/#django-app-configuration","title":"Django App Configuration","text":"<pre><code># settings.py\nINSTALLED_APPS = [\n    # ... other apps\n    'injectq.integrations.django',\n]\n\nINJECTQ_SETTINGS = {\n    'CONTAINER_MODULE': 'myproject.container',\n    'AUTO_DISCOVER': True,\n    'SCOPE_PER_REQUEST': True,\n}\n\n# container.py\nfrom injectq import Container\nfrom myproject.services import UserService, EmailService\nfrom myproject.repositories import UserRepository\n\ndef create_container() -&gt; Container:\n    \"\"\"Create and configure application container.\"\"\"\n    container = Container()\n\n    # Register services\n    container.register(UserRepository, DatabaseUserRepository)\n    container.register(EmailService, DjangoEmailService)\n    container.register(UserService, UserService)\n\n    return container\n\n# Global container instance\ncontainer = create_container()\n</code></pre>"},{"location":"api-reference/integrations/#django-views-integration","title":"Django Views Integration","text":"<pre><code>from django.http import JsonResponse\nfrom django.views import View\nfrom injectq.integrations.django import inject_view, get_service\nfrom injectq import inject\n\nclass UserListView(View):\n    \"\"\"Django view with dependency injection.\"\"\"\n\n    @inject_view\n    @inject\n    def get(self, request, user_service: UserService):\n        \"\"\"Get list of users.\"\"\"\n        users = user_service.get_all_users()\n        return JsonResponse({\n            'users': [{'id': u.id, 'email': u.email} for u in users]\n        })\n\n    @inject_view\n    @inject\n    def post(self, request, user_service: UserService):\n        \"\"\"Create new user.\"\"\"\n        import json\n        data = json.loads(request.body)\n        user = user_service.create_user(data['email'])\n        return JsonResponse({'id': user.id, 'email': user.email})\n\n# Function-based view\n@inject_view\n@inject\ndef user_detail(request, user_id: int, user_service: UserService):\n    \"\"\"Get user details.\"\"\"\n    user = user_service.get_user(user_id)\n    if user:\n        return JsonResponse({'id': user.id, 'email': user.email})\n    else:\n        return JsonResponse({'error': 'User not found'}, status=404)\n\n# Alternative using explicit service resolution\ndef user_detail_alt(request, user_id: int):\n    \"\"\"Get user details with explicit service resolution.\"\"\"\n    user_service = get_service(UserService)\n    user = user_service.get_user(user_id)\n    if user:\n        return JsonResponse({'id': user.id, 'email': user.email})\n    else:\n        return JsonResponse({'error': 'User not found'}, status=404)\n</code></pre>"},{"location":"api-reference/integrations/#django-middleware","title":"Django Middleware","text":"<pre><code>from django.utils.deprecation import MiddlewareMixin\nfrom injectq.integrations.django import get_container\n\nclass InjectQMiddleware(MiddlewareMixin):\n    \"\"\"Middleware for managing InjectQ scopes per request.\"\"\"\n\n    def __init__(self, get_response):\n        self.get_response = get_response\n        self.container = get_container()\n        super().__init__(get_response)\n\n    def process_request(self, request):\n        \"\"\"Create request scope.\"\"\"\n        request.injectq_scope = self.container.create_scope()\n        return None\n\n    def process_response(self, request, response):\n        \"\"\"Dispose request scope.\"\"\"\n        scope = getattr(request, 'injectq_scope', None)\n        if scope:\n            scope.dispose()\n        return response\n\n# Django App Config\nfrom django.apps import AppConfig\n\nclass InjectQConfig(AppConfig):\n    \"\"\"Django app configuration for InjectQ.\"\"\"\n\n    name = 'injectq.integrations.django'\n    verbose_name = 'InjectQ Django Integration'\n\n    def ready(self):\n        \"\"\"Initialize InjectQ when Django starts.\"\"\"\n        from django.conf import settings\n        from . import setup_django_integration\n\n        injectq_settings = getattr(settings, 'INJECTQ_SETTINGS', {})\n        setup_django_integration(injectq_settings)\n\ndef setup_django_integration(settings: dict):\n    \"\"\"Setup Django integration.\"\"\"\n    container_module = settings.get('CONTAINER_MODULE')\n    if container_module:\n        # Import and initialize container\n        module = __import__(container_module, fromlist=['container'])\n        container = getattr(module, 'container')\n\n        # Store globally\n        _set_global_container(container)\n\n    if settings.get('AUTO_DISCOVER', True):\n        # Auto-discover and register Django models, etc.\n        autodiscover_services()\n\ndef autodiscover_services():\n    \"\"\"Auto-discover Django services.\"\"\"\n    from django.apps import apps\n\n    for app_config in apps.get_app_configs():\n        try:\n            # Look for services.py in each app\n            services_module = f\"{app_config.name}.services\"\n            __import__(services_module)\n        except ImportError:\n            pass\n</code></pre>"},{"location":"api-reference/integrations/#flask-integration","title":"Flask Integration","text":""},{"location":"api-reference/integrations/#flask-application-factory","title":"Flask Application Factory","text":"<pre><code>from flask import Flask, request, g\nfrom injectq import Container\nfrom injectq.integrations.flask import setup_injectq, inject_route\n\ndef create_app(config=None) -&gt; Flask:\n    \"\"\"Create Flask application with InjectQ.\"\"\"\n    app = Flask(__name__)\n\n    if config:\n        app.config.from_object(config)\n\n    # Create container\n    container = Container()\n    setup_container(container)\n\n    # Setup InjectQ\n    setup_injectq(app, container)\n\n    # Register blueprints\n    from .views import user_bp\n    app.register_blueprint(user_bp)\n\n    return app\n\ndef setup_container(container: Container):\n    \"\"\"Configure application container.\"\"\"\n    container.register(UserRepository, DatabaseUserRepository)\n    container.register(EmailService, FlaskEmailService)\n    container.register(UserService, UserService)\n\n# views.py\nfrom flask import Blueprint, jsonify, request\nfrom injectq.integrations.flask import inject_route\nfrom injectq import inject\n\nuser_bp = Blueprint('users', __name__, url_prefix='/users')\n\n@user_bp.route('/', methods=['GET'])\n@inject_route\n@inject\ndef get_users(user_service: UserService):\n    \"\"\"Get all users.\"\"\"\n    users = user_service.get_all_users()\n    return jsonify([{'id': u.id, 'email': u.email} for u in users])\n\n@user_bp.route('/', methods=['POST'])\n@inject_route\n@inject\ndef create_user(user_service: UserService):\n    \"\"\"Create new user.\"\"\"\n    data = request.get_json()\n    user = user_service.create_user(data['email'])\n    return jsonify({'id': user.id, 'email': user.email}), 201\n\n@user_bp.route('/&lt;int:user_id&gt;')\n@inject_route\n@inject\ndef get_user(user_id: int, user_service: UserService):\n    \"\"\"Get specific user.\"\"\"\n    user = user_service.get_user(user_id)\n    if user:\n        return jsonify({'id': user.id, 'email': user.email})\n    else:\n        return jsonify({'error': 'User not found'}), 404\n</code></pre>"},{"location":"api-reference/integrations/#flask-extension","title":"Flask Extension","text":"<pre><code>from flask import Flask, g, request\nfrom typing import Optional\n\nclass InjectQ:\n    \"\"\"Flask extension for InjectQ integration.\"\"\"\n\n    def __init__(self, app: Optional[Flask] = None, container: Optional[Container] = None):\n        self.container = container\n\n        if app is not None:\n            self.init_app(app)\n\n    def init_app(self, app: Flask):\n        \"\"\"Initialize extension with Flask app.\"\"\"\n        if not hasattr(app, 'extensions'):\n            app.extensions = {}\n\n        app.extensions['injectq'] = self\n\n        # Store container in app config\n        if self.container:\n            app.config['INJECTQ_CONTAINER'] = self.container\n\n        # Setup request hooks\n        app.before_request(self._before_request)\n        app.teardown_request(self._teardown_request)\n\n    def _before_request(self):\n        \"\"\"Create request scope before handling request.\"\"\"\n        container = current_app.config.get('INJECTQ_CONTAINER')\n        if container:\n            g.injectq_scope = container.create_scope()\n\n    def _teardown_request(self, exception):\n        \"\"\"Dispose request scope after handling request.\"\"\"\n        scope = getattr(g, 'injectq_scope', None)\n        if scope:\n            scope.dispose()\n\ndef get_service(service_type: Type[T]) -&gt; T:\n    \"\"\"Get service instance from current request scope.\"\"\"\n    container = current_app.config.get('INJECTQ_CONTAINER')\n    if not container:\n        raise RuntimeError(\"InjectQ not configured\")\n\n    scope = getattr(g, 'injectq_scope', None)\n    if scope:\n        return scope.resolve(service_type)\n    else:\n        return container.resolve(service_type)\n\ndef inject_route(func):\n    \"\"\"Decorator for injecting dependencies into Flask routes.\"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        container = current_app.config.get('INJECTQ_CONTAINER')\n        if container:\n            return container.resolve(func, *args, **kwargs)\n        else:\n            return func(*args, **kwargs)\n\n    return wrapper\n\n# Usage\napp = Flask(__name__)\ncontainer = Container()\n# ... configure container\n\ninjectq = InjectQ(app, container)\n\n@app.route('/test')\n@inject_route\n@inject\ndef test_route(user_service: UserService):\n    return jsonify({'message': 'Hello from injected service!'})\n</code></pre>"},{"location":"api-reference/integrations/#celery-integration","title":"Celery Integration","text":""},{"location":"api-reference/integrations/#celery-task-injection","title":"Celery Task Injection","text":"<pre><code>from celery import Celery\nfrom injectq import Container, inject\nfrom injectq.integrations.celery import setup_celery_injection\n\n# Create Celery app\ncelery_app = Celery('myapp')\n\n# Create container\ncontainer = Container()\ncontainer.register(EmailService, SMTPEmailService)\ncontainer.register(UserRepository, DatabaseUserRepository)\n\n# Setup injection\nsetup_celery_injection(celery_app, container)\n\n# Define tasks with injection\n@celery_app.task\n@inject\ndef send_welcome_email(user_id: int, email_service: EmailService, user_repository: UserRepository):\n    \"\"\"Send welcome email task.\"\"\"\n    user = user_repository.get_user(user_id)\n    if user:\n        email_service.send_welcome_email(user.email)\n        return f\"Welcome email sent to {user.email}\"\n    else:\n        return f\"User {user_id} not found\"\n\n@celery_app.task\n@inject\ndef cleanup_expired_data(data_service: DataService):\n    \"\"\"Cleanup expired data task.\"\"\"\n    deleted_count = data_service.cleanup_expired()\n    return f\"Deleted {deleted_count} expired records\"\n\n# Task with custom scope\n@celery_app.task\n@inject(scope='task')\ndef process_large_dataset(dataset_id: int, processor: DataProcessor):\n    \"\"\"Process large dataset with task-scoped dependencies.\"\"\"\n    return processor.process_dataset(dataset_id)\n</code></pre>"},{"location":"api-reference/integrations/#celery-integration-setup","title":"Celery Integration Setup","text":"<pre><code>from celery.signals import task_prerun, task_postrun\nfrom celery import Task\n\nclass InjectQTask(Task):\n    \"\"\"Custom Celery task class with InjectQ support.\"\"\"\n\n    def __init__(self):\n        self.container = None\n        self.scope = None\n\n    def apply_async(self, args=None, kwargs=None, **options):\n        \"\"\"Override to setup injection context.\"\"\"\n        # Inject dependencies before task execution\n        return super().apply_async(args, kwargs, **options)\n\n    def __call__(self, *args, **kwargs):\n        \"\"\"Execute task with dependency injection.\"\"\"\n        if self.container:\n            with self.container.create_scope() as scope:\n                self.scope = scope\n                try:\n                    return self.run(*args, **kwargs)\n                finally:\n                    self.scope = None\n        else:\n            return self.run(*args, **kwargs)\n\ndef setup_celery_injection(celery_app: Celery, container: Container):\n    \"\"\"Setup Celery integration with InjectQ.\"\"\"\n\n    # Set custom task class\n    celery_app.Task = InjectQTask\n\n    # Store container reference\n    celery_app.container = container\n\n    @task_prerun.connect\n    def task_prerun_handler(sender=None, task_id=None, task=None, args=None, kwargs=None, **kwds):\n        \"\"\"Setup task context before execution.\"\"\"\n        if hasattr(task, 'container') and task.container:\n            task.scope = task.container.create_scope()\n\n    @task_postrun.connect\n    def task_postrun_handler(sender=None, task_id=None, task=None, args=None, kwargs=None, retval=None, state=None, **kwds):\n        \"\"\"Cleanup task context after execution.\"\"\"\n        if hasattr(task, 'scope') and task.scope:\n            task.scope.dispose()\n            task.scope = None\n\n    # Configure all tasks to use container\n    for task_name, task in celery_app.tasks.items():\n        if hasattr(task, '__class__') and issubclass(task.__class__, InjectQTask):\n            task.container = container\n\n# Custom task decorator with scope support\ndef task_with_injection(celery_app: Celery, scope: str = 'task'):\n    \"\"\"Create task decorator with specific injection scope.\"\"\"\n\n    def decorator(func):\n        @celery_app.task(bind=True, base=InjectQTask)\n        @inject\n        def wrapper(self, *args, **kwargs):\n            return func(*args, **kwargs)\n\n        # Configure task container\n        wrapper.container = celery_app.container\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api-reference/integrations/#sqlalchemy-integration","title":"SQLAlchemy Integration","text":""},{"location":"api-reference/integrations/#session-management","title":"Session Management","text":"<pre><code>from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom injectq import Container, Scope\nfrom injectq.integrations.sqlalchemy import SQLAlchemyScope\n\n# Database setup\nengine = create_engine('sqlite:///example.db')\nSessionLocal = sessionmaker(bind=engine)\n\ndef create_database_container() -&gt; Container:\n    \"\"\"Create container with SQLAlchemy integration.\"\"\"\n    container = Container()\n\n    # Register session factory\n    container.register(\n        Session,\n        lambda: SessionLocal(),\n        scope=Scope.SCOPED  # Session per scope\n    )\n\n    # Register repositories with session injection\n    container.register(UserRepository, SQLAlchemyUserRepository)\n    container.register(OrderRepository, SQLAlchemyOrderRepository)\n\n    return container\n\nclass SQLAlchemyUserRepository:\n    \"\"\"Repository using SQLAlchemy session.\"\"\"\n\n    def __init__(self, session: Session):\n        self.session = session\n\n    def get_user(self, user_id: int) -&gt; Optional[User]:\n        return self.session.query(User).filter(User.id == user_id).first()\n\n    def create_user(self, email: str) -&gt; User:\n        user = User(email=email)\n        self.session.add(user)\n        self.session.commit()\n        return user\n\n    def __del__(self):\n        \"\"\"Cleanup session.\"\"\"\n        if hasattr(self, 'session'):\n            self.session.close()\n\n# Usage with automatic session management\ncontainer = create_database_container()\n\n@inject\ndef create_user_service(email: str, user_repo: UserRepository) -&gt; User:\n    # Session is automatically managed within this scope\n    return user_repo.create_user(email)\n\n# With explicit scope management\nwith container.create_scope() as scope:\n    user_service = scope.resolve(UserService)\n    user = user_service.create_user(\"test@example.com\")\n    # Session is automatically committed and closed when scope ends\n</code></pre>"},{"location":"api-reference/integrations/#transaction-management","title":"Transaction Management","text":"<pre><code>from contextlib import contextmanager\nfrom sqlalchemy.orm import Session\n\nclass TransactionalScope:\n    \"\"\"Scope with transaction management.\"\"\"\n\n    def __init__(self, container: Container, session: Session):\n        self.container = container\n        self.session = session\n        self.in_transaction = False\n\n    @contextmanager\n    def transaction(self):\n        \"\"\"Context manager for database transactions.\"\"\"\n        if self.in_transaction:\n            # Nested transaction - use savepoint\n            savepoint = self.session.begin_nested()\n            try:\n                yield self.session\n                savepoint.commit()\n            except Exception:\n                savepoint.rollback()\n                raise\n        else:\n            # Main transaction\n            self.in_transaction = True\n            transaction = self.session.begin()\n            try:\n                yield self.session\n                transaction.commit()\n            except Exception:\n                transaction.rollback()\n                raise\n            finally:\n                self.in_transaction = False\n\n    def resolve(self, service_type: Type[T]) -&gt; T:\n        \"\"\"Resolve service with transactional session.\"\"\"\n        return self.container.resolve(service_type)\n\n# Usage\n@inject\ndef transfer_funds(from_user_id: int, to_user_id: int, amount: float, \n                  user_repo: UserRepository, account_repo: AccountRepository):\n    \"\"\"Transfer funds between users.\"\"\"\n\n    # Get current scope\n    scope = get_current_scope()  # Implementation specific\n\n    with scope.transaction():\n        from_account = account_repo.get_by_user_id(from_user_id)\n        to_account = account_repo.get_by_user_id(to_user_id)\n\n        if from_account.balance &lt; amount:\n            raise ValueError(\"Insufficient funds\")\n\n        from_account.balance -= amount\n        to_account.balance += amount\n\n        account_repo.update(from_account)\n        account_repo.update(to_account)\n\n        # Transaction committed automatically when context exits\n</code></pre>"},{"location":"api-reference/module/","title":"Module API","text":"<p>::: injectq.modules.base</p>"},{"location":"api-reference/module/#overview","title":"Overview","text":"<p>Modules provide a way to organize and configure dependency injection bindings. They encapsulate related service registrations and can be composed to build complex applications.</p>"},{"location":"api-reference/module/#basic-module-definition","title":"Basic Module Definition","text":"<pre><code>from injectq import Module\n\nclass DatabaseModule(Module):\n    def configure(self):\n        # Database configuration\n        self.bind(DatabaseConnection, DatabaseConnection).singleton()\n        self.bind(UserRepository, UserRepository).scoped()\n        self.bind(str, \"postgresql://localhost:5432/app\", name=\"connection_string\")\n</code></pre>"},{"location":"api-reference/module/#module-installation","title":"Module Installation","text":"<pre><code># Install single module\ncontainer.install(DatabaseModule())\n\n# Install multiple modules\ncontainer.install([\n    DatabaseModule(),\n    ServiceModule(),\n    ConfigurationModule()\n])\n</code></pre>"},{"location":"api-reference/module/#advanced-module-features","title":"Advanced Module Features","text":""},{"location":"api-reference/module/#conditional-bindings","title":"Conditional Bindings","text":"<pre><code>class ConditionalModule(Module):\n    def configure(self):\n        # Conditional binding based on environment\n        if self.is_development():\n            self.bind(Logger, ConsoleLogger).singleton()\n        else:\n            self.bind(Logger, FileLogger).singleton()\n\n    def is_development(self) -&gt; bool:\n        return os.getenv(\"ENVIRONMENT\") == \"development\"\n</code></pre>"},{"location":"api-reference/module/#module-composition","title":"Module Composition","text":"<pre><code>class ApplicationModule(Module):\n    def configure(self):\n        # Install other modules\n        self.install(DatabaseModule())\n        self.install(SecurityModule())\n        self.install(WebModule())\n\n        # Additional bindings\n        self.bind(ApplicationService, ApplicationService).singleton()\n</code></pre>"},{"location":"api-reference/module/#named-bindings","title":"Named Bindings","text":"<pre><code>class ConfigurationModule(Module):\n    def configure(self):\n        # Named string bindings\n        self.bind(str, \"localhost\", name=\"database_host\")\n        self.bind(str, \"5432\", name=\"database_port\")\n        self.bind(str, \"myapp\", name=\"database_name\")\n\n        # Named service bindings\n        self.bind(EmailService, SMTPEmailService, name=\"smtp_service\").singleton()\n        self.bind(EmailService, SendGridService, name=\"sendgrid_service\").singleton()\n</code></pre>"},{"location":"api-reference/module/#module-lifecycle","title":"Module Lifecycle","text":""},{"location":"api-reference/module/#initialization-hooks","title":"Initialization Hooks","text":"<pre><code>class ModuleWithHooks(Module):\n    def configure(self):\n        self.bind(MyService, MyService).singleton()\n\n    def on_installed(self, container):\n        \"\"\"Called after module is installed.\"\"\"\n        print(f\"Module installed in container: {container}\")\n\n    def on_container_built(self, container):\n        \"\"\"Called after container is fully built.\"\"\"\n        # Perform initialization\n        service = container.get(MyService)\n        service.initialize()\n</code></pre>"},{"location":"api-reference/module/#validation","title":"Validation","text":"<pre><code>class ValidatedModule(Module):\n    def configure(self):\n        self.bind(RequiredService, RequiredService).singleton()\n\n    def validate(self) -&gt; List[str]:\n        \"\"\"Validate module configuration.\"\"\"\n        errors = []\n\n        # Check required environment variables\n        if not os.getenv(\"API_KEY\"):\n            errors.append(\"API_KEY environment variable is required\")\n\n        return errors\n</code></pre>"},{"location":"api-reference/module/#module-testing","title":"Module Testing","text":""},{"location":"api-reference/module/#test-modules","title":"Test Modules","text":"<pre><code>from injectq.testing import TestModule\n\nclass TestDatabaseModule(TestModule):\n    def configure(self):\n        # Override with test implementations\n        self.bind(DatabaseConnection, MockDatabaseConnection).singleton()\n        self.bind(UserRepository, InMemoryUserRepository).scoped()\n</code></pre>"},{"location":"api-reference/module/#module-mocking","title":"Module Mocking","text":"<pre><code>class MockServiceModule(Module):\n    def __init__(self, mock_service):\n        self.mock_service = mock_service\n\n    def configure(self):\n        self.bind(ExternalService, self.mock_service).singleton()\n\n# Usage in tests\nmock_service = Mock(spec=ExternalService)\ncontainer.install(MockServiceModule(mock_service))\n</code></pre>"},{"location":"api-reference/module/#configuration-patterns","title":"Configuration Patterns","text":""},{"location":"api-reference/module/#environment-based-configuration","title":"Environment-Based Configuration","text":"<pre><code>class EnvironmentModule(Module):\n    def __init__(self, environment: str):\n        self.environment = environment\n\n    def configure(self):\n        if self.environment == \"production\":\n            self.configure_production()\n        elif self.environment == \"development\":\n            self.configure_development()\n        else:\n            self.configure_test()\n\n    def configure_production(self):\n        self.bind(Logger, ProductionLogger).singleton()\n        self.bind(Database, PostgreSQLDatabase).singleton()\n\n    def configure_development(self):\n        self.bind(Logger, ConsoleLogger).singleton()\n        self.bind(Database, SQLiteDatabase).singleton()\n\n    def configure_test(self):\n        self.bind(Logger, NullLogger).singleton()\n        self.bind(Database, InMemoryDatabase).singleton()\n</code></pre>"},{"location":"api-reference/module/#feature-flags","title":"Feature Flags","text":"<pre><code>class FeatureModule(Module):\n    def __init__(self, features: Dict[str, bool]):\n        self.features = features\n\n    def configure(self):\n        # Base services\n        self.bind(UserService, UserService).singleton()\n\n        # Feature-based services\n        if self.features.get(\"analytics\", False):\n            self.bind(AnalyticsService, AnalyticsService).singleton()\n\n        if self.features.get(\"caching\", False):\n            self.bind(CacheService, RedisCacheService).singleton()\n        else:\n            self.bind(CacheService, InMemoryCacheService).singleton()\n</code></pre>"},{"location":"api-reference/module/#module-documentation","title":"Module Documentation","text":""},{"location":"api-reference/module/#self-documenting-modules","title":"Self-Documenting Modules","text":"<pre><code>class DocumentedModule(Module):\n    \"\"\"\n    Database module providing core data access services.\n\n    Services provided:\n    - DatabaseConnection: Main database connection\n    - UserRepository: User data access\n    - ProductRepository: Product data access\n\n    Configuration:\n    - Requires DATABASE_URL environment variable\n    - Optional POOL_SIZE for connection pooling\n    \"\"\"\n\n    def configure(self):\n        # Implementation details documented inline\n\n        # Core database connection (singleton for connection pooling)\n        self.bind(DatabaseConnection, DatabaseConnection).singleton()\n\n        # Repositories (scoped for unit-of-work pattern)\n        self.bind(UserRepository, UserRepository).scoped()\n        self.bind(ProductRepository, ProductRepository).scoped()\n\n    def get_description(self) -&gt; str:\n        \"\"\"Get module description.\"\"\"\n        return self.__doc__ or \"No description available\"\n\n    def get_provided_services(self) -&gt; List[type]:\n        \"\"\"Get list of services provided by this module.\"\"\"\n        return [DatabaseConnection, UserRepository, ProductRepository]\n</code></pre>"},{"location":"api-reference/module/#error-handling","title":"Error Handling","text":"<pre><code>class RobustModule(Module):\n    def configure(self):\n        try:\n            # Attempt to bind complex service\n            self.bind(ComplexService, ComplexService).singleton()\n        except ImportError:\n            # Fallback to simple implementation\n            self.bind(ComplexService, SimpleService).singleton()\n        except Exception as e:\n            # Log error and provide default\n            print(f\"Error configuring ComplexService: {e}\")\n            self.bind(ComplexService, DefaultService).singleton()\n</code></pre>"},{"location":"api-reference/providers/","title":"Providers API","text":"<p>::: injectq.decorators.providers</p>"},{"location":"api-reference/providers/#overview","title":"Overview","text":"<p>Providers offer advanced patterns for service creation and dependency management. They enable lazy evaluation, factory patterns, and complex dependency scenarios.</p>"},{"location":"api-reference/providers/#basic-provider-usage","title":"Basic Provider Usage","text":""},{"location":"api-reference/providers/#provider-interface","title":"Provider Interface","text":"<pre><code>from injectq import Provider\n\nclass ServiceWithProvider:\n    def __init__(self, user_service_provider: Provider[UserService]):\n        self.user_service_provider = user_service_provider\n\n    def get_users(self):\n        # Lazy resolution - service created only when needed\n        user_service = self.user_service_provider.get()\n        return user_service.get_all_users()\n</code></pre>"},{"location":"api-reference/providers/#provider-registration","title":"Provider Registration","text":"<pre><code># Automatic provider registration\ncontainer.bind(UserService, UserService).singleton()\n\n# Provider is automatically available\nservice = container.get(ServiceWithProvider)\n</code></pre>"},{"location":"api-reference/providers/#advanced-provider-patterns","title":"Advanced Provider Patterns","text":""},{"location":"api-reference/providers/#factory-provider","title":"Factory Provider","text":"<pre><code>class FactoryProvider:\n    \"\"\"Provider that creates instances using a factory function.\"\"\"\n\n    def __init__(self, factory_func, container):\n        self.factory_func = factory_func\n        self.container = container\n\n    def get(self):\n        \"\"\"Get instance from factory.\"\"\"\n        return self.factory_func()\n\n    def create_with_params(self, **params):\n        \"\"\"Create instance with additional parameters.\"\"\"\n        return self.factory_func(**params)\n\n# Usage\ndef create_database_connection(host: str = \"localhost\", port: int = 5432):\n    return DatabaseConnection(host, port)\n\nfactory_provider = FactoryProvider(create_database_connection, container)\n\n# Register as provider\ncontainer.bind(Provider[DatabaseConnection], factory_provider).singleton()\n</code></pre>"},{"location":"api-reference/providers/#conditional-provider","title":"Conditional Provider","text":"<pre><code>class ConditionalProvider:\n    \"\"\"Provider that selects implementation based on conditions.\"\"\"\n\n    def __init__(self, condition_func, true_provider, false_provider):\n        self.condition_func = condition_func\n        self.true_provider = true_provider\n        self.false_provider = false_provider\n\n    def get(self):\n        \"\"\"Get instance based on condition.\"\"\"\n        if self.condition_func():\n            return self.true_provider.get()\n        else:\n            return self.false_provider.get()\n\n# Usage\ndef is_production():\n    return os.getenv(\"ENV\") == \"production\"\n\nprod_logger_provider = Provider(lambda: ProductionLogger())\ndev_logger_provider = Provider(lambda: DevelopmentLogger())\n\nconditional_provider = ConditionalProvider(\n    is_production,\n    prod_logger_provider,\n    dev_logger_provider\n)\n\ncontainer.bind(Provider[ILogger], conditional_provider).singleton()\n</code></pre>"},{"location":"api-reference/providers/#caching-provider","title":"Caching Provider","text":"<pre><code>import threading\nimport time\nfrom typing import Optional\n\nclass CachingProvider:\n    \"\"\"Provider that caches instances with TTL.\"\"\"\n\n    def __init__(self, base_provider: Provider, ttl_seconds: float = 300):\n        self.base_provider = base_provider\n        self.ttl_seconds = ttl_seconds\n        self.cached_instance: Optional[Any] = None\n        self.cache_time: Optional[float] = None\n        self.lock = threading.Lock()\n\n    def get(self):\n        \"\"\"Get cached instance or create new one if expired.\"\"\"\n        with self.lock:\n            current_time = time.time()\n\n            # Check if cache is valid\n            if (self.cached_instance is not None and \n                self.cache_time is not None and \n                current_time - self.cache_time &lt; self.ttl_seconds):\n                return self.cached_instance\n\n            # Create new instance\n            self.cached_instance = self.base_provider.get()\n            self.cache_time = current_time\n\n            return self.cached_instance\n\n    def invalidate(self):\n        \"\"\"Invalidate cached instance.\"\"\"\n        with self.lock:\n            self.cached_instance = None\n            self.cache_time = None\n</code></pre>"},{"location":"api-reference/providers/#multi-provider","title":"Multi-Provider","text":"<pre><code>from typing import List, Iterator\n\nclass MultiProvider:\n    \"\"\"Provider that manages multiple instances of the same type.\"\"\"\n\n    def __init__(self, providers: List[Provider]):\n        self.providers = providers\n\n    def get_all(self) -&gt; List[Any]:\n        \"\"\"Get instances from all providers.\"\"\"\n        return [provider.get() for provider in self.providers]\n\n    def get_first(self) -&gt; Any:\n        \"\"\"Get instance from first available provider.\"\"\"\n        for provider in self.providers:\n            try:\n                return provider.get()\n            except Exception:\n                continue\n        raise RuntimeError(\"No providers available\")\n\n    def iterate(self) -&gt; Iterator[Any]:\n        \"\"\"Iterate over all provider instances.\"\"\"\n        for provider in self.providers:\n            try:\n                yield provider.get()\n            except Exception:\n                continue\n\n# Usage\nemail_providers = [\n    Provider(lambda: SMTPEmailService()),\n    Provider(lambda: SendGridEmailService()),\n    Provider(lambda: AWSEmailService())\n]\n\nmulti_provider = MultiProvider(email_providers)\ncontainer.bind(MultiProvider[IEmailService], multi_provider).singleton()\n</code></pre>"},{"location":"api-reference/providers/#provider-decorators","title":"Provider Decorators","text":""},{"location":"api-reference/providers/#lazy-provider-decorator","title":"Lazy Provider Decorator","text":"<pre><code>def lazy_provider(provider_func):\n    \"\"\"Decorator that creates a lazy provider.\"\"\"\n\n    class LazyProviderImpl:\n        def __init__(self):\n            self._instance = None\n            self._created = False\n\n        def get(self):\n            if not self._created:\n                self._instance = provider_func()\n                self._created = True\n            return self._instance\n\n    return LazyProviderImpl()\n\n# Usage\n@lazy_provider\ndef expensive_service_provider():\n    # This function is only called when the service is first needed\n    return ExpensiveService(load_heavy_configuration())\n\ncontainer.bind(Provider[ExpensiveService], expensive_service_provider).singleton()\n</code></pre>"},{"location":"api-reference/providers/#singleton-provider-decorator","title":"Singleton Provider Decorator","text":"<pre><code>def singleton_provider(provider_func):\n    \"\"\"Decorator that ensures provider returns singleton instance.\"\"\"\n\n    class SingletonProviderImpl:\n        def __init__(self):\n            self._instance = None\n            self._lock = threading.Lock()\n\n        def get(self):\n            if self._instance is None:\n                with self._lock:\n                    if self._instance is None:\n                        self._instance = provider_func()\n            return self._instance\n\n    return SingletonProviderImpl()\n</code></pre>"},{"location":"api-reference/providers/#scoped-provider-decorator","title":"Scoped Provider Decorator","text":"<pre><code>def scoped_provider(provider_func):\n    \"\"\"Decorator that creates scoped provider instances.\"\"\"\n\n    class ScopedProviderImpl:\n        def __init__(self):\n            self.instances = {}\n\n        def get(self, scope_id=None):\n            if scope_id is None:\n                scope_id = get_current_scope_id()  # Implementation needed\n\n            if scope_id not in self.instances:\n                self.instances[scope_id] = provider_func()\n\n            return self.instances[scope_id]\n\n        def clear_scope(self, scope_id):\n            self.instances.pop(scope_id, None)\n\n    return ScopedProviderImpl()\n</code></pre>"},{"location":"api-reference/providers/#async-providers","title":"Async Providers","text":""},{"location":"api-reference/providers/#async-provider-interface","title":"Async Provider Interface","text":"<pre><code>from typing import Awaitable\n\nclass AsyncProvider:\n    \"\"\"Async provider interface.\"\"\"\n\n    async def aget(self) -&gt; Awaitable[Any]:\n        \"\"\"Asynchronously get service instance.\"\"\"\n        raise NotImplementedError\n\nclass AsyncFactoryProvider(AsyncProvider):\n    \"\"\"Async provider using factory function.\"\"\"\n\n    def __init__(self, async_factory_func):\n        self.async_factory_func = async_factory_func\n\n    async def aget(self):\n        \"\"\"Get instance from async factory.\"\"\"\n        return await self.async_factory_func()\n\n# Usage\nasync def create_async_database():\n    connection = DatabaseConnection()\n    await connection.connect()\n    return connection\n\nasync_provider = AsyncFactoryProvider(create_async_database)\ncontainer.bind(AsyncProvider[DatabaseConnection], async_provider).singleton()\n</code></pre>"},{"location":"api-reference/providers/#async-caching-provider","title":"Async Caching Provider","text":"<pre><code>import asyncio\n\nclass AsyncCachingProvider(AsyncProvider):\n    \"\"\"Async provider with caching support.\"\"\"\n\n    def __init__(self, base_provider: AsyncProvider, ttl_seconds: float = 300):\n        self.base_provider = base_provider\n        self.ttl_seconds = ttl_seconds\n        self.cached_instance = None\n        self.cache_time = None\n        self.lock = asyncio.Lock()\n\n    async def aget(self):\n        \"\"\"Get cached instance or create new one asynchronously.\"\"\"\n        async with self.lock:\n            current_time = time.time()\n\n            # Check cache validity\n            if (self.cached_instance is not None and \n                self.cache_time is not None and \n                current_time - self.cache_time &lt; self.ttl_seconds):\n                return self.cached_instance\n\n            # Create new instance\n            self.cached_instance = await self.base_provider.aget()\n            self.cache_time = current_time\n\n            return self.cached_instance\n</code></pre>"},{"location":"api-reference/providers/#provider-factories","title":"Provider Factories","text":""},{"location":"api-reference/providers/#dynamic-provider-factory","title":"Dynamic Provider Factory","text":"<pre><code>class ProviderFactory:\n    \"\"\"Factory for creating providers dynamically.\"\"\"\n\n    def __init__(self, container):\n        self.container = container\n\n    def create_lazy_provider(self, service_type: type):\n        \"\"\"Create lazy provider for service type.\"\"\"\n\n        class LazyProvider:\n            def __init__(self, container, service_type):\n                self.container = container\n                self.service_type = service_type\n                self._instance = None\n\n            def get(self):\n                if self._instance is None:\n                    self._instance = self.container.get(self.service_type)\n                return self._instance\n\n        return LazyProvider(self.container, service_type)\n\n    def create_factory_provider(self, factory_func):\n        \"\"\"Create factory provider from function.\"\"\"\n\n        class FactoryProvider:\n            def __init__(self, factory_func):\n                self.factory_func = factory_func\n\n            def get(self):\n                return self.factory_func()\n\n        return FactoryProvider(factory_func)\n\n    def create_conditional_provider(self, condition, true_type, false_type):\n        \"\"\"Create conditional provider.\"\"\"\n\n        class ConditionalProvider:\n            def __init__(self, container, condition, true_type, false_type):\n                self.container = container\n                self.condition = condition\n                self.true_type = true_type\n                self.false_type = false_type\n\n            def get(self):\n                if self.condition():\n                    return self.container.get(self.true_type)\n                else:\n                    return self.container.get(self.false_type)\n\n        return ConditionalProvider(self.container, condition, true_type, false_type)\n</code></pre>"},{"location":"api-reference/providers/#provider-builder","title":"Provider Builder","text":"<pre><code>class ProviderBuilder:\n    \"\"\"Builder for creating complex providers.\"\"\"\n\n    def __init__(self):\n        self.provider_chain = []\n\n    def with_caching(self, ttl_seconds: float = 300):\n        \"\"\"Add caching to provider chain.\"\"\"\n        self.provider_chain.append(('cache', ttl_seconds))\n        return self\n\n    def with_retry(self, max_retries: int = 3, delay: float = 1.0):\n        \"\"\"Add retry logic to provider chain.\"\"\"\n        self.provider_chain.append(('retry', max_retries, delay))\n        return self\n\n    def with_fallback(self, fallback_provider):\n        \"\"\"Add fallback provider.\"\"\"\n        self.provider_chain.append(('fallback', fallback_provider))\n        return self\n\n    def build(self, base_provider):\n        \"\"\"Build provider with all configured features.\"\"\"\n        current_provider = base_provider\n\n        for item in self.provider_chain:\n            if item[0] == 'cache':\n                current_provider = CachingProvider(current_provider, item[1])\n            elif item[0] == 'retry':\n                current_provider = RetryProvider(current_provider, item[1], item[2])\n            elif item[0] == 'fallback':\n                current_provider = FallbackProvider(current_provider, item[1])\n\n        return current_provider\n\n# Usage\nbuilder = ProviderBuilder()\nprovider = (builder\n    .with_caching(ttl_seconds=600)\n    .with_retry(max_retries=5)\n    .with_fallback(lambda: DefaultService())\n    .build(base_provider))\n</code></pre>"},{"location":"api-reference/providers/#provider-testing","title":"Provider Testing","text":""},{"location":"api-reference/providers/#mock-provider","title":"Mock Provider","text":"<pre><code>class MockProvider:\n    \"\"\"Provider for testing with mock instances.\"\"\"\n\n    def __init__(self, mock_instance):\n        self.mock_instance = mock_instance\n\n    def get(self):\n        \"\"\"Return mock instance.\"\"\"\n        return self.mock_instance\n\n# Usage in tests\nfrom unittest.mock import Mock\n\nmock_service = Mock(spec=UserService)\nmock_provider = MockProvider(mock_service)\n\ncontainer.bind(Provider[UserService], mock_provider).singleton()\n</code></pre>"},{"location":"api-reference/providers/#test-provider-context","title":"Test Provider Context","text":"<pre><code>class TestProviderContext:\n    \"\"\"Context manager for provider testing.\"\"\"\n\n    def __init__(self, container):\n        self.container = container\n        self.original_providers = {}\n        self.test_providers = {}\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        # Restore original providers\n        for service_type, original_provider in self.original_providers.items():\n            self.container.bind(Provider[service_type], original_provider)\n\n    def mock_provider(self, service_type: type, mock_instance):\n        \"\"\"Replace provider with mock for testing.\"\"\"\n        # Save original provider\n        if service_type not in self.original_providers:\n            self.original_providers[service_type] = self.container.get(Provider[service_type])\n\n        # Set mock provider\n        mock_provider = MockProvider(mock_instance)\n        self.container.bind(Provider[service_type], mock_provider)\n\n# Usage\nwith TestProviderContext(container) as test_context:\n    mock_user_service = Mock(spec=UserService)\n    test_context.mock_provider(UserService, mock_user_service)\n\n    # Test code here - will use mock providers\n    service = container.get(ServiceThatUsesProvider)\n    # service uses mock_user_service\n</code></pre>"},{"location":"api-reference/providers/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api-reference/providers/#provider-performance-tips","title":"Provider Performance Tips","text":"<ol> <li>Use Lazy Providers for expensive services</li> <li>Cache Provider Results when appropriate</li> <li>Avoid Provider Chains that are too deep</li> <li>Monitor Provider Resolution times</li> <li>Use Async Providers for I/O bound operations</li> </ol>"},{"location":"api-reference/providers/#provider-benchmarking","title":"Provider Benchmarking","text":"<pre><code>import time\nfrom typing import Dict, List\n\nclass ProviderBenchmark:\n    \"\"\"Benchmark provider performance.\"\"\"\n\n    def __init__(self):\n        self.results: Dict[str, List[float]] = {}\n\n    def benchmark_provider(self, provider_name: str, provider, iterations: int = 1000):\n        \"\"\"Benchmark provider get() calls.\"\"\"\n        times = []\n\n        for _ in range(iterations):\n            start_time = time.perf_counter()\n            instance = provider.get()\n            end_time = time.perf_counter()\n            times.append(end_time - start_time)\n\n        self.results[provider_name] = times\n\n    def get_report(self):\n        \"\"\"Get benchmark report.\"\"\"\n        report = {}\n\n        for provider_name, times in self.results.items():\n            report[provider_name] = {\n                'avg_time': sum(times) / len(times),\n                'min_time': min(times),\n                'max_time': max(times),\n                'total_time': sum(times),\n                'iterations': len(times)\n            }\n\n        return report\n</code></pre>"},{"location":"api-reference/registry/","title":"Registry API","text":"<p>::: injectq.core.registry</p>"},{"location":"api-reference/registry/#overview","title":"Overview","text":"<p>The Registry is the internal component responsible for storing and managing service bindings. It maintains the mapping between service types and their implementations, scopes, and factory functions.</p>"},{"location":"api-reference/registry/#core-functionality","title":"Core Functionality","text":""},{"location":"api-reference/registry/#service-registration","title":"Service Registration","text":"<p>The registry stores bindings that define how services should be created and managed.</p> <pre><code># Internal registry usage (typically handled by container)\nfrom injectq.core.registry import ServiceRegistry\n\nregistry = ServiceRegistry()\n\n# Register a service binding\nbinding = ServiceBinding(\n    service_type=UserService,\n    implementation=UserService,\n    scope=Scope.SINGLETON,\n    factory=None\n)\n\nregistry.register(UserService, binding)\n</code></pre>"},{"location":"api-reference/registry/#binding-resolution","title":"Binding Resolution","text":"<pre><code># Resolve a binding\nbinding = registry.get_binding(UserService)\nif binding:\n    print(f\"Service: {binding.service_type.__name__}\")\n    print(f\"Implementation: {binding.implementation.__name__}\")\n    print(f\"Scope: {binding.scope}\")\n</code></pre>"},{"location":"api-reference/registry/#service-bindings","title":"Service Bindings","text":""},{"location":"api-reference/registry/#binding-types","title":"Binding Types","text":"<pre><code>from injectq.core.registry import ServiceBinding, Scope\n\n# Class binding\nclass_binding = ServiceBinding(\n    service_type=IUserService,\n    implementation=UserService,\n    scope=Scope.SINGLETON\n)\n\n# Instance binding\ninstance = UserService()\ninstance_binding = ServiceBinding(\n    service_type=IUserService,\n    implementation=instance,\n    scope=Scope.SINGLETON,\n    is_instance=True\n)\n\n# Factory binding\ndef create_user_service():\n    return UserService(special_config=True)\n\nfactory_binding = ServiceBinding(\n    service_type=IUserService,\n    implementation=create_user_service,\n    scope=Scope.TRANSIENT,\n    is_factory=True\n)\n</code></pre>"},{"location":"api-reference/registry/#named-bindings","title":"Named Bindings","text":"<pre><code># Named service bindings for multiple implementations\nsmtp_binding = ServiceBinding(\n    service_type=IEmailService,\n    implementation=SMTPEmailService,\n    scope=Scope.SINGLETON,\n    name=\"smtp\"\n)\n\nsendgrid_binding = ServiceBinding(\n    service_type=IEmailService,\n    implementation=SendGridEmailService,\n    scope=Scope.SINGLETON,\n    name=\"sendgrid\"\n)\n\nregistry.register(IEmailService, smtp_binding, name=\"smtp\")\nregistry.register(IEmailService, sendgrid_binding, name=\"sendgrid\")\n\n# Retrieve named bindings\nsmtp_binding = registry.get_binding(IEmailService, name=\"smtp\")\nsendgrid_binding = registry.get_binding(IEmailService, name=\"sendgrid\")\n</code></pre>"},{"location":"api-reference/registry/#registry-operations","title":"Registry Operations","text":""},{"location":"api-reference/registry/#batch-operations","title":"Batch Operations","text":"<pre><code># Register multiple bindings at once\nbindings = [\n    (UserService, ServiceBinding(UserService, UserService, Scope.SCOPED)),\n    (ProductService, ServiceBinding(ProductService, ProductService, Scope.SCOPED)),\n    (OrderService, ServiceBinding(OrderService, OrderService, Scope.TRANSIENT))\n]\n\nregistry.register_batch(bindings)\n</code></pre>"},{"location":"api-reference/registry/#conditional-registration","title":"Conditional Registration","text":"<pre><code># Register service only if not already registered\nif not registry.is_registered(UserService):\n    registry.register(UserService, user_service_binding)\n\n# Register with override check\ntry:\n    registry.register(UserService, new_binding, allow_override=False)\nexcept ServiceAlreadyRegisteredException:\n    print(\"Service already registered\")\n</code></pre>"},{"location":"api-reference/registry/#registry-inspection","title":"Registry Inspection","text":"<pre><code># Get all registered services\nall_services = registry.get_all_services()\nfor service_type, binding in all_services.items():\n    print(f\"{service_type.__name__}: {binding.scope}\")\n\n# Get services by scope\nsingleton_services = registry.get_services_by_scope(Scope.SINGLETON)\nscoped_services = registry.get_services_by_scope(Scope.SCOPED)\ntransient_services = registry.get_services_by_scope(Scope.TRANSIENT)\n\n# Check if service is registered\nis_registered = registry.is_registered(UserService)\n</code></pre>"},{"location":"api-reference/registry/#advanced-registry-features","title":"Advanced Registry Features","text":""},{"location":"api-reference/registry/#registry-validation","title":"Registry Validation","text":"<pre><code>class ValidatingRegistry(ServiceRegistry):\n    \"\"\"Registry with validation capabilities.\"\"\"\n\n    def register(self, service_type: type, binding: ServiceBinding, **kwargs):\n        # Validate binding before registration\n        validation_errors = self.validate_binding(service_type, binding)\n        if validation_errors:\n            raise ValidationError(f\"Invalid binding: {validation_errors}\")\n\n        super().register(service_type, binding, **kwargs)\n\n    def validate_binding(self, service_type: type, binding: ServiceBinding):\n        \"\"\"Validate a service binding.\"\"\"\n        errors = []\n\n        # Check type compatibility\n        if not self.is_compatible_type(service_type, binding.implementation):\n            errors.append(f\"Implementation {binding.implementation} not compatible with {service_type}\")\n\n        # Check scope validity\n        if binding.scope not in [Scope.SINGLETON, Scope.SCOPED, Scope.TRANSIENT]:\n            errors.append(f\"Invalid scope: {binding.scope}\")\n\n        return errors\n\n    def is_compatible_type(self, service_type: type, implementation) -&gt; bool:\n        \"\"\"Check if implementation is compatible with service type.\"\"\"\n        if isinstance(implementation, type):\n            return issubclass(implementation, service_type) or service_type == implementation\n        return isinstance(implementation, service_type)\n</code></pre>"},{"location":"api-reference/registry/#registry-events","title":"Registry Events","text":"<pre><code>from typing import Callable, List\n\nclass EventEmittingRegistry(ServiceRegistry):\n    \"\"\"Registry that emits events for registration operations.\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.event_handlers = {\n            'service_registered': [],\n            'service_unregistered': [],\n            'binding_resolved': []\n        }\n\n    def on(self, event: str, handler: Callable):\n        \"\"\"Register event handler.\"\"\"\n        if event in self.event_handlers:\n            self.event_handlers[event].append(handler)\n\n    def emit(self, event: str, *args, **kwargs):\n        \"\"\"Emit event to all handlers.\"\"\"\n        if event in self.event_handlers:\n            for handler in self.event_handlers[event]:\n                handler(*args, **kwargs)\n\n    def register(self, service_type: type, binding: ServiceBinding, **kwargs):\n        super().register(service_type, binding, **kwargs)\n        self.emit('service_registered', service_type, binding)\n\n    def get_binding(self, service_type: type, name: str = None):\n        binding = super().get_binding(service_type, name)\n        if binding:\n            self.emit('binding_resolved', service_type, binding)\n        return binding\n\n# Usage\nregistry = EventEmittingRegistry()\n\n# Register event handlers\nregistry.on('service_registered', lambda svc, binding: print(f\"Registered: {svc.__name__}\"))\nregistry.on('binding_resolved', lambda svc, binding: print(f\"Resolved: {svc.__name__}\"))\n</code></pre>"},{"location":"api-reference/registry/#registry-hierarchies","title":"Registry Hierarchies","text":"<pre><code>class HierarchicalRegistry(ServiceRegistry):\n    \"\"\"Registry with parent-child relationships.\"\"\"\n\n    def __init__(self, parent: 'HierarchicalRegistry' = None):\n        super().__init__()\n        self.parent = parent\n        self.children: List['HierarchicalRegistry'] = []\n\n        if parent:\n            parent.children.append(self)\n\n    def get_binding(self, service_type: type, name: str = None):\n        \"\"\"Get binding, checking parent if not found locally.\"\"\"\n        binding = super().get_binding(service_type, name)\n\n        # If not found locally, check parent\n        if not binding and self.parent:\n            binding = self.parent.get_binding(service_type, name)\n\n        return binding\n\n    def create_child_registry(self) -&gt; 'HierarchicalRegistry':\n        \"\"\"Create a child registry.\"\"\"\n        return HierarchicalRegistry(parent=self)\n\n    def get_all_services(self, include_parent: bool = True):\n        \"\"\"Get all services including from parent.\"\"\"\n        services = super().get_all_services()\n\n        if include_parent and self.parent:\n            parent_services = self.parent.get_all_services()\n            # Child services override parent services\n            parent_services.update(services)\n            services = parent_services\n\n        return services\n</code></pre>"},{"location":"api-reference/registry/#registry-performance","title":"Registry Performance","text":""},{"location":"api-reference/registry/#optimized-registry","title":"Optimized Registry","text":"<pre><code>class OptimizedRegistry(ServiceRegistry):\n    \"\"\"High-performance registry with caching.\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.binding_cache = {}\n        self.cache_hits = 0\n        self.cache_misses = 0\n\n    def get_binding(self, service_type: type, name: str = None):\n        # Create cache key\n        cache_key = (service_type, name)\n\n        # Check cache first\n        if cache_key in self.binding_cache:\n            self.cache_hits += 1\n            return self.binding_cache[cache_key]\n\n        # Get from registry\n        binding = super().get_binding(service_type, name)\n\n        # Cache the result (including None for not found)\n        self.binding_cache[cache_key] = binding\n        self.cache_misses += 1\n\n        return binding\n\n    def register(self, service_type: type, binding: ServiceBinding, **kwargs):\n        super().register(service_type, binding, **kwargs)\n\n        # Invalidate cache for this service type\n        cache_key = (service_type, kwargs.get('name'))\n        self.binding_cache.pop(cache_key, None)\n\n    def get_cache_stats(self):\n        \"\"\"Get cache performance statistics.\"\"\"\n        total = self.cache_hits + self.cache_misses\n        hit_rate = self.cache_hits / total if total &gt; 0 else 0\n\n        return {\n            'hits': self.cache_hits,\n            'misses': self.cache_misses,\n            'hit_rate': hit_rate,\n            'cache_size': len(self.binding_cache)\n        }\n</code></pre>"},{"location":"api-reference/registry/#registry-metrics","title":"Registry Metrics","text":"<pre><code>import time\nfrom collections import defaultdict\n\nclass MetricsRegistry(ServiceRegistry):\n    \"\"\"Registry that collects performance metrics.\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.metrics = {\n            'registrations': 0,\n            'resolutions': 0,\n            'resolution_times': [],\n            'services_by_scope': defaultdict(int)\n        }\n\n    def register(self, service_type: type, binding: ServiceBinding, **kwargs):\n        super().register(service_type, binding, **kwargs)\n        self.metrics['registrations'] += 1\n        self.metrics['services_by_scope'][binding.scope] += 1\n\n    def get_binding(self, service_type: type, name: str = None):\n        start_time = time.perf_counter()\n\n        binding = super().get_binding(service_type, name)\n\n        resolution_time = time.perf_counter() - start_time\n        self.metrics['resolutions'] += 1\n        self.metrics['resolution_times'].append(resolution_time)\n\n        return binding\n\n    def get_metrics(self):\n        \"\"\"Get registry performance metrics.\"\"\"\n        resolution_times = self.metrics['resolution_times']\n\n        return {\n            'total_registrations': self.metrics['registrations'],\n            'total_resolutions': self.metrics['resolutions'],\n            'avg_resolution_time': sum(resolution_times) / len(resolution_times) if resolution_times else 0,\n            'services_by_scope': dict(self.metrics['services_by_scope']),\n            'total_services': len(self.bindings)\n        }\n</code></pre>"},{"location":"api-reference/registry/#error-handling","title":"Error Handling","text":""},{"location":"api-reference/registry/#registry-exceptions","title":"Registry Exceptions","text":"<pre><code>class RegistryError(Exception):\n    \"\"\"Base exception for registry operations.\"\"\"\n    pass\n\nclass ServiceNotRegisteredException(RegistryError):\n    \"\"\"Raised when trying to access a service that is not registered.\"\"\"\n\n    def __init__(self, service_type: type, name: str = None):\n        self.service_type = service_type\n        self.name = name\n\n        if name:\n            message = f\"Service {service_type.__name__} with name '{name}' is not registered\"\n        else:\n            message = f\"Service {service_type.__name__} is not registered\"\n\n        super().__init__(message)\n\nclass ServiceAlreadyRegisteredException(RegistryError):\n    \"\"\"Raised when trying to register a service that already exists.\"\"\"\n\n    def __init__(self, service_type: type, name: str = None):\n        self.service_type = service_type\n        self.name = name\n\n        if name:\n            message = f\"Service {service_type.__name__} with name '{name}' is already registered\"\n        else:\n            message = f\"Service {service_type.__name__} is already registered\"\n\n        super().__init__(message)\n\n# Usage in registry\nclass SafeRegistry(ServiceRegistry):\n    def register(self, service_type: type, binding: ServiceBinding, allow_override: bool = True, **kwargs):\n        if not allow_override and self.is_registered(service_type, kwargs.get('name')):\n            raise ServiceAlreadyRegisteredException(service_type, kwargs.get('name'))\n\n        super().register(service_type, binding, **kwargs)\n\n    def get_binding(self, service_type: type, name: str = None):\n        binding = super().get_binding(service_type, name)\n        if not binding:\n            raise ServiceNotRegisteredException(service_type, name)\n        return binding\n</code></pre>"},{"location":"api-reference/resolver/","title":"Resolver API","text":"<p>::: injectq.core.resolver ::: injectq.core.thread_safe_resolver</p>"},{"location":"api-reference/resolver/#overview","title":"Overview","text":"<p>The Resolver is responsible for creating service instances and resolving their dependencies. It works with the Registry to locate service bindings and with Scopes to manage instance lifecycle.</p>"},{"location":"api-reference/resolver/#core-resolution-process","title":"Core Resolution Process","text":""},{"location":"api-reference/resolver/#dependency-resolution","title":"Dependency Resolution","text":"<p>The resolver follows a systematic approach to create service instances:</p> <ol> <li>Binding Lookup: Find the service binding in the registry</li> <li>Dependency Analysis: Analyze constructor dependencies</li> <li>Recursive Resolution: Resolve all dependencies</li> <li>Instance Creation: Create the service instance</li> <li>Scope Management: Store instance in appropriate scope</li> </ol> <pre><code># Basic resolution example (internal API)\nfrom injectq.core.resolver import DependencyResolver\n\nresolver = DependencyResolver(registry, scope_manager)\n\n# Resolve a service instance\ninstance = resolver.resolve(UserService, current_scope)\n</code></pre>"},{"location":"api-reference/resolver/#resolution-strategies","title":"Resolution Strategies","text":""},{"location":"api-reference/resolver/#constructor-resolution","title":"Constructor Resolution","text":"<p>The resolver analyzes constructor signatures to determine dependencies.</p> <pre><code>class UserService:\n    def __init__(self, user_repo: UserRepository, logger: Logger):\n        self.user_repo = user_repo\n        self.logger = logger\n\n# Resolver automatically detects UserRepository and Logger dependencies\n# and resolves them before creating UserService\n</code></pre>"},{"location":"api-reference/resolver/#property-resolution","title":"Property Resolution","text":"<p>For services that use property injection:</p> <pre><code>class EmailService:\n    def __init__(self):\n        self.smtp_client = None  # Will be injected\n        self.config = None       # Will be injected\n\n    @property\n    def smtp_client(self) -&gt; SMTPClient:\n        return self._smtp_client\n\n    @smtp_client.setter\n    def smtp_client(self, value: SMTPClient):\n        self._smtp_client = value\n\n# Resolver can inject properties after instance creation\n</code></pre>"},{"location":"api-reference/resolver/#method-resolution","title":"Method Resolution","text":"<p>For services that need method-level injection:</p> <pre><code>class ProcessingService:\n    @inject\n    def process(self, data: str, processor: DataProcessor) -&gt; str:\n        return processor.process(data)\n\n# Resolver provides dependencies when method is called\n</code></pre>"},{"location":"api-reference/resolver/#advanced-resolution-features","title":"Advanced Resolution Features","text":""},{"location":"api-reference/resolver/#circular-dependency-detection","title":"Circular Dependency Detection","text":"<pre><code>class CircularDependencyDetector:\n    \"\"\"Detects and prevents circular dependencies during resolution.\"\"\"\n\n    def __init__(self):\n        self.resolution_stack = []\n        self.visited = set()\n\n    def check_circular_dependency(self, service_type: type):\n        \"\"\"Check if resolving this service would create a circular dependency.\"\"\"\n        if service_type in self.resolution_stack:\n            cycle = self.resolution_stack[self.resolution_stack.index(service_type):]\n            cycle_str = \" -&gt; \".join(t.__name__ for t in cycle + [service_type])\n            raise CircularDependencyError(f\"Circular dependency detected: {cycle_str}\")\n\n    def enter_resolution(self, service_type: type):\n        \"\"\"Mark service as being resolved.\"\"\"\n        self.check_circular_dependency(service_type)\n        self.resolution_stack.append(service_type)\n\n    def exit_resolution(self, service_type: type):\n        \"\"\"Mark service resolution as complete.\"\"\"\n        if self.resolution_stack and self.resolution_stack[-1] == service_type:\n            self.resolution_stack.pop()\n</code></pre>"},{"location":"api-reference/resolver/#lazy-resolution","title":"Lazy Resolution","text":"<pre><code>class LazyResolver:\n    \"\"\"Resolver that defers dependency resolution until first access.\"\"\"\n\n    def __init__(self, base_resolver: DependencyResolver):\n        self.base_resolver = base_resolver\n        self.lazy_proxies = {}\n\n    def resolve_lazy(self, service_type: type, scope):\n        \"\"\"Create a lazy proxy for the service.\"\"\"\n        if service_type not in self.lazy_proxies:\n            proxy = LazyProxy(lambda: self.base_resolver.resolve(service_type, scope))\n            self.lazy_proxies[service_type] = proxy\n\n        return self.lazy_proxies[service_type]\n\nclass LazyProxy:\n    \"\"\"Proxy that resolves the actual service on first access.\"\"\"\n\n    def __init__(self, factory):\n        self._factory = factory\n        self._instance = None\n        self._resolved = False\n\n    def __getattr__(self, name):\n        if not self._resolved:\n            self._instance = self._factory()\n            self._resolved = True\n\n        return getattr(self._instance, name)\n</code></pre>"},{"location":"api-reference/resolver/#generic-type-resolution","title":"Generic Type Resolution","text":"<pre><code>from typing import Generic, TypeVar, get_origin, get_args\n\nT = TypeVar('T')\n\nclass Repository(Generic[T]):\n    \"\"\"Generic repository interface.\"\"\"\n    pass\n\nclass UserRepository(Repository[User]):\n    \"\"\"Concrete user repository.\"\"\"\n    pass\n\nclass GenericResolver:\n    \"\"\"Resolver that handles generic types.\"\"\"\n\n    def resolve_generic(self, service_type: type, scope):\n        \"\"\"Resolve generic service types.\"\"\"\n        origin = get_origin(service_type)\n        args = get_args(service_type)\n\n        if origin and args:\n            # Handle generic types like Repository[User]\n            concrete_type = self.find_concrete_implementation(origin, args)\n            return self.resolve(concrete_type, scope)\n\n        return self.resolve(service_type, scope)\n\n    def find_concrete_implementation(self, generic_type, type_args):\n        \"\"\"Find concrete implementation for generic type.\"\"\"\n        # Look for registered implementations that match the generic pattern\n        for registered_type, binding in self.registry.get_all_services().items():\n            if (hasattr(registered_type, '__origin__') and \n                registered_type.__origin__ == generic_type and \n                registered_type.__args__ == type_args):\n                return binding.implementation\n\n        raise ServiceNotFoundError(f\"No implementation found for {generic_type}[{type_args}]\")\n</code></pre>"},{"location":"api-reference/resolver/#thread-safe-resolution","title":"Thread-Safe Resolution","text":""},{"location":"api-reference/resolver/#thread-safe-resolver","title":"Thread-Safe Resolver","text":"<pre><code>import threading\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass ThreadSafeResolver(DependencyResolver):\n    \"\"\"Thread-safe dependency resolver.\"\"\"\n\n    def __init__(self, registry, scope_manager):\n        super().__init__(registry, scope_manager)\n        self._lock = threading.RLock()\n        self._thread_local = threading.local()\n\n    def resolve(self, service_type: type, scope):\n        \"\"\"Thread-safe service resolution.\"\"\"\n        with self._lock:\n            # Use thread-local resolution context\n            if not hasattr(self._thread_local, 'resolution_context'):\n                self._thread_local.resolution_context = ResolutionContext()\n\n            context = self._thread_local.resolution_context\n\n            try:\n                context.enter_resolution(service_type)\n                return super().resolve(service_type, scope)\n            finally:\n                context.exit_resolution(service_type)\n\nclass ResolutionContext:\n    \"\"\"Thread-local context for dependency resolution.\"\"\"\n\n    def __init__(self):\n        self.resolution_stack = []\n        self.resolved_instances = {}\n\n    def enter_resolution(self, service_type: type):\n        \"\"\"Enter resolution for a service type.\"\"\"\n        if service_type in self.resolution_stack:\n            raise CircularDependencyError(f\"Circular dependency: {service_type}\")\n        self.resolution_stack.append(service_type)\n\n    def exit_resolution(self, service_type: type):\n        \"\"\"Exit resolution for a service type.\"\"\"\n        if self.resolution_stack and self.resolution_stack[-1] == service_type:\n            self.resolution_stack.pop()\n</code></pre>"},{"location":"api-reference/resolver/#concurrent-resolution","title":"Concurrent Resolution","text":"<pre><code>class ConcurrentResolver:\n    \"\"\"Resolver optimized for concurrent access.\"\"\"\n\n    def __init__(self, registry, scope_manager, max_workers: int = 4):\n        self.registry = registry\n        self.scope_manager = scope_manager\n        self.executor = ThreadPoolExecutor(max_workers=max_workers)\n        self.resolution_cache = {}\n        self.cache_lock = threading.RLock()\n\n    async def resolve_async(self, service_type: type, scope):\n        \"\"\"Asynchronously resolve service dependencies.\"\"\"\n        loop = asyncio.get_event_loop()\n\n        # Submit resolution to thread pool\n        future = self.executor.submit(self.resolve, service_type, scope)\n\n        # Wait for result asynchronously\n        return await loop.run_in_executor(None, future.result)\n\n    def resolve_batch(self, service_types: List[type], scope):\n        \"\"\"Resolve multiple services concurrently.\"\"\"\n        futures = []\n\n        for service_type in service_types:\n            future = self.executor.submit(self.resolve, service_type, scope)\n            futures.append((service_type, future))\n\n        results = {}\n        for service_type, future in futures:\n            try:\n                results[service_type] = future.result()\n            except Exception as e:\n                results[service_type] = e\n\n        return results\n</code></pre>"},{"location":"api-reference/resolver/#custom-resolvers","title":"Custom Resolvers","text":""},{"location":"api-reference/resolver/#factory-based-resolver","title":"Factory-Based Resolver","text":"<pre><code>class FactoryResolver(DependencyResolver):\n    \"\"\"Resolver that prioritizes factory functions.\"\"\"\n\n    def resolve(self, service_type: type, scope):\n        \"\"\"Resolve using custom factory logic.\"\"\"\n        binding = self.registry.get_binding(service_type)\n\n        if binding and binding.is_factory:\n            # Use factory function\n            factory = binding.implementation\n\n            # Resolve factory dependencies\n            factory_dependencies = self.analyze_dependencies(factory)\n            dependency_instances = {}\n\n            for dep_name, dep_type in factory_dependencies.items():\n                dependency_instances[dep_name] = self.resolve(dep_type, scope)\n\n            # Call factory with resolved dependencies\n            return factory(**dependency_instances)\n\n        return super().resolve(service_type, scope)\n</code></pre>"},{"location":"api-reference/resolver/#decorator-aware-resolver","title":"Decorator-Aware Resolver","text":"<pre><code>class DecoratorResolver(DependencyResolver):\n    \"\"\"Resolver that handles service decorators.\"\"\"\n\n    def resolve(self, service_type: type, scope):\n        \"\"\"Resolve with decorator support.\"\"\"\n        instance = super().resolve(service_type, scope)\n\n        # Apply decorators if present\n        decorators = self.get_service_decorators(service_type)\n\n        for decorator in decorators:\n            instance = decorator(instance)\n\n        return instance\n\n    def get_service_decorators(self, service_type: type):\n        \"\"\"Get decorators to apply to service.\"\"\"\n        decorators = []\n\n        # Check for logging decorator\n        if hasattr(service_type, '__enable_logging__'):\n            decorators.append(LoggingDecorator())\n\n        # Check for caching decorator\n        if hasattr(service_type, '__enable_caching__'):\n            decorators.append(CachingDecorator())\n\n        # Check for retry decorator\n        if hasattr(service_type, '__enable_retry__'):\n            decorators.append(RetryDecorator())\n\n        return decorators\n\nclass LoggingDecorator:\n    \"\"\"Decorator that adds logging to service methods.\"\"\"\n\n    def __call__(self, instance):\n        original_methods = {}\n\n        for attr_name in dir(instance):\n            attr = getattr(instance, attr_name)\n            if callable(attr) and not attr_name.startswith('_'):\n                original_methods[attr_name] = attr\n\n                def logged_method(original=attr, name=attr_name):\n                    def wrapper(*args, **kwargs):\n                        print(f\"Calling {name} on {instance.__class__.__name__}\")\n                        return original(*args, **kwargs)\n                    return wrapper\n\n                setattr(instance, attr_name, logged_method())\n\n        return instance\n</code></pre>"},{"location":"api-reference/resolver/#performance-optimization","title":"Performance Optimization","text":""},{"location":"api-reference/resolver/#caching-resolver","title":"Caching Resolver","text":"<pre><code>class CachingResolver(DependencyResolver):\n    \"\"\"Resolver with instance caching for better performance.\"\"\"\n\n    def __init__(self, registry, scope_manager, cache_size: int = 1000):\n        super().__init__(registry, scope_manager)\n        self.instance_cache = {}\n        self.cache_size = cache_size\n        self.cache_hits = 0\n        self.cache_misses = 0\n\n    def resolve(self, service_type: type, scope):\n        \"\"\"Resolve with caching.\"\"\"\n        cache_key = (service_type, id(scope))\n\n        # Check cache first\n        if cache_key in self.instance_cache:\n            self.cache_hits += 1\n            return self.instance_cache[cache_key]\n\n        # Resolve normally\n        instance = super().resolve(service_type, scope)\n\n        # Cache if space available\n        if len(self.instance_cache) &lt; self.cache_size:\n            self.instance_cache[cache_key] = instance\n\n        self.cache_misses += 1\n        return instance\n\n    def get_cache_stats(self):\n        \"\"\"Get cache performance statistics.\"\"\"\n        total = self.cache_hits + self.cache_misses\n        hit_rate = self.cache_hits / total if total &gt; 0 else 0\n\n        return {\n            'hits': self.cache_hits,\n            'misses': self.cache_misses,\n            'hit_rate': hit_rate,\n            'cache_size': len(self.instance_cache)\n        }\n</code></pre>"},{"location":"api-reference/resolver/#profiling-resolver","title":"Profiling Resolver","text":"<pre><code>import time\nfrom collections import defaultdict\n\nclass ProfilingResolver(DependencyResolver):\n    \"\"\"Resolver that collects performance metrics.\"\"\"\n\n    def __init__(self, registry, scope_manager):\n        super().__init__(registry, scope_manager)\n        self.resolution_times = defaultdict(list)\n        self.resolution_counts = defaultdict(int)\n\n    def resolve(self, service_type: type, scope):\n        \"\"\"Resolve with performance profiling.\"\"\"\n        start_time = time.perf_counter()\n\n        try:\n            instance = super().resolve(service_type, scope)\n            return instance\n        finally:\n            resolution_time = time.perf_counter() - start_time\n            self.resolution_times[service_type].append(resolution_time)\n            self.resolution_counts[service_type] += 1\n\n    def get_performance_report(self):\n        \"\"\"Get detailed performance report.\"\"\"\n        report = {}\n\n        for service_type, times in self.resolution_times.items():\n            report[service_type.__name__] = {\n                'count': self.resolution_counts[service_type],\n                'total_time': sum(times),\n                'average_time': sum(times) / len(times),\n                'min_time': min(times),\n                'max_time': max(times)\n            }\n\n        return report\n</code></pre>"},{"location":"api-reference/resolver/#error-handling","title":"Error Handling","text":""},{"location":"api-reference/resolver/#resilient-resolver","title":"Resilient Resolver","text":"<pre><code>class ResilientResolver(DependencyResolver):\n    \"\"\"Resolver with error recovery capabilities.\"\"\"\n\n    def __init__(self, registry, scope_manager, max_retries: int = 3):\n        super().__init__(registry, scope_manager)\n        self.max_retries = max_retries\n        self.fallback_factories = {}\n\n    def resolve(self, service_type: type, scope):\n        \"\"\"Resolve with error recovery.\"\"\"\n        last_error = None\n\n        for attempt in range(self.max_retries):\n            try:\n                return super().resolve(service_type, scope)\n            except Exception as e:\n                last_error = e\n\n                if attempt &lt; self.max_retries - 1:\n                    print(f\"Resolution attempt {attempt + 1} failed for {service_type.__name__}: {e}\")\n                    time.sleep(0.1 * (attempt + 1))  # Exponential backoff\n\n        # Try fallback if available\n        if service_type in self.fallback_factories:\n            try:\n                return self.fallback_factories[service_type]()\n            except Exception as fallback_error:\n                print(f\"Fallback also failed for {service_type.__name__}: {fallback_error}\")\n\n        raise last_error\n\n    def register_fallback(self, service_type: type, factory):\n        \"\"\"Register fallback factory for service type.\"\"\"\n        self.fallback_factories[service_type] = factory\n</code></pre>"},{"location":"api-reference/scopes/","title":"Scopes API","text":"<p>::: injectq.core.scopes ::: injectq.scopes.async_scopes ::: injectq.scopes.base_scope_manager</p>"},{"location":"api-reference/scopes/#overview","title":"Overview","text":"<p>Scopes control the lifetime and sharing of service instances. InjectQ provides several built-in scopes and supports custom scope implementations for specialized use cases.</p>"},{"location":"api-reference/scopes/#built-in-scopes","title":"Built-in Scopes","text":""},{"location":"api-reference/scopes/#singleton-scope","title":"Singleton Scope","text":"<p>Services registered with singleton scope are created once and shared across the entire application.</p> <pre><code># Registration\ncontainer.bind(DatabaseConnection, DatabaseConnection).singleton()\n\n# Usage - same instance returned every time\nconn1 = container.get(DatabaseConnection)\nconn2 = container.get(DatabaseConnection)\nassert conn1 is conn2  # True\n</code></pre>"},{"location":"api-reference/scopes/#transient-scope","title":"Transient Scope","text":"<p>Services registered with transient scope are created fresh for every request.</p> <pre><code># Registration\ncontainer.bind(EmailService, EmailService).transient()\n\n# Usage - new instance returned every time\nemail1 = container.get(EmailService)\nemail2 = container.get(EmailService)\nassert email1 is not email2  # True\n</code></pre>"},{"location":"api-reference/scopes/#scoped-scope","title":"Scoped Scope","text":"<p>Services registered with scoped scope are created once per scope and shared within that scope.</p> <pre><code># Registration\ncontainer.bind(UserRepository, UserRepository).scoped()\n\n# Usage within scopes\nwith container.create_scope() as scope1:\n    repo1a = scope1.get(UserRepository)\n    repo1b = scope1.get(UserRepository)\n    assert repo1a is repo1b  # True - same instance within scope\n\nwith container.create_scope() as scope2:\n    repo2 = scope2.get(UserRepository)\n    assert repo1a is not repo2  # True - different scope, different instance\n</code></pre>"},{"location":"api-reference/scopes/#async-scopes","title":"Async Scopes","text":""},{"location":"api-reference/scopes/#async-scope-management","title":"Async Scope Management","text":"<pre><code># Async scope context manager\nasync with container.create_async_scope() as scope:\n    service = await scope.aget(AsyncService)\n    await service.do_work()\n    # Scope automatically disposed when exiting context\n</code></pre>"},{"location":"api-reference/scopes/#manual-async-scope-management","title":"Manual Async Scope Management","text":"<pre><code># Manual async scope creation and disposal\nscope = container.create_async_scope()\ntry:\n    service = await scope.aget(AsyncService)\n    await service.do_work()\nfinally:\n    await scope.dispose()\n</code></pre>"},{"location":"api-reference/scopes/#async-scope-with-resources","title":"Async Scope with Resources","text":"<pre><code>@resource\nclass DatabaseConnection:\n    async def __aenter__(self):\n        await self.connect()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        await self.disconnect()\n\n# Usage in async scope\nasync with container.create_async_scope() as scope:\n    # Resource is automatically managed\n    db = await scope.aget(DatabaseConnection)\n    await db.execute(\"SELECT * FROM users\")\n    # Connection automatically closed when scope exits\n</code></pre>"},{"location":"api-reference/scopes/#custom-scopes","title":"Custom Scopes","text":""},{"location":"api-reference/scopes/#creating-custom-scopes","title":"Creating Custom Scopes","text":"<pre><code>from injectq.core.scopes import BaseScope\n\nclass RequestScope(BaseScope):\n    \"\"\"Custom scope for web requests.\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.request_id = None\n        self.instances = {}\n\n    def get_instance(self, service_type: type, factory: Callable):\n        \"\"\"Get or create instance for this request.\"\"\"\n        if service_type not in self.instances:\n            self.instances[service_type] = factory()\n        return self.instances[service_type]\n\n    def dispose(self):\n        \"\"\"Clean up request scope.\"\"\"\n        for instance in self.instances.values():\n            if hasattr(instance, 'dispose'):\n                instance.dispose()\n        self.instances.clear()\n\n    def set_request_id(self, request_id: str):\n        \"\"\"Set the current request ID.\"\"\"\n        self.request_id = request_id\n\n# Register custom scope\ncontainer.register_scope(\"request\", RequestScope)\n\n# Use custom scope\ncontainer.bind(RequestProcessor, RequestProcessor).in_scope(\"request\")\n</code></pre>"},{"location":"api-reference/scopes/#thread-local-scopes","title":"Thread-Local Scopes","text":"<pre><code>import threading\nfrom typing import Dict, Any\n\nclass ThreadLocalScope(BaseScope):\n    \"\"\"Scope that maintains separate instances per thread.\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.local = threading.local()\n\n    def get_instance(self, service_type: type, factory: Callable):\n        \"\"\"Get or create instance for current thread.\"\"\"\n        if not hasattr(self.local, 'instances'):\n            self.local.instances = {}\n\n        instances: Dict[type, Any] = self.local.instances\n\n        if service_type not in instances:\n            instances[service_type] = factory()\n\n        return instances[service_type]\n\n    def dispose(self):\n        \"\"\"Dispose instances for current thread.\"\"\"\n        if hasattr(self.local, 'instances'):\n            for instance in self.local.instances.values():\n                if hasattr(instance, 'dispose'):\n                    instance.dispose()\n            self.local.instances.clear()\n\n# Usage\ncontainer.register_scope(\"thread_local\", ThreadLocalScope)\ncontainer.bind(ThreadSpecificService, ThreadSpecificService).in_scope(\"thread_local\")\n</code></pre>"},{"location":"api-reference/scopes/#scope-lifecycle-management","title":"Scope Lifecycle Management","text":""},{"location":"api-reference/scopes/#automatic-lifecycle","title":"Automatic Lifecycle","text":"<pre><code>class ManagedService:\n    def __init__(self):\n        print(\"Service created\")\n\n    def dispose(self):\n        print(\"Service disposed\")\n\n# Services with dispose() method are automatically cleaned up\ncontainer.bind(ManagedService, ManagedService).scoped()\n\nwith container.create_scope() as scope:\n    service = scope.get(ManagedService)\n    # Use service...\n# Service.dispose() called automatically when scope exits\n</code></pre>"},{"location":"api-reference/scopes/#custom-lifecycle-hooks","title":"Custom Lifecycle Hooks","text":"<pre><code>class ServiceWithHooks:\n    def __init__(self):\n        self.initialized = False\n\n    def initialize(self):\n        self.initialized = True\n        print(\"Service initialized\")\n\n    def cleanup(self):\n        print(\"Service cleaned up\")\n        self.initialized = False\n\n# Custom scope with lifecycle hooks\nclass HookedScope(BaseScope):\n    def get_instance(self, service_type: type, factory: Callable):\n        instance = super().get_instance(service_type, factory)\n\n        # Call initialize hook if available\n        if hasattr(instance, 'initialize') and not getattr(instance, 'initialized', True):\n            instance.initialize()\n\n        return instance\n\n    def dispose(self):\n        # Call cleanup hooks before disposal\n        for instance in self.instances.values():\n            if hasattr(instance, 'cleanup'):\n                instance.cleanup()\n\n        super().dispose()\n</code></pre>"},{"location":"api-reference/scopes/#scope-hierarchies","title":"Scope Hierarchies","text":""},{"location":"api-reference/scopes/#parent-child-scopes","title":"Parent-Child Scopes","text":"<pre><code># Create parent scope\nparent_scope = container.create_scope()\n\n# Create child scope\nchild_scope = parent_scope.create_child_scope()\n\n# Child can access parent services\nparent_service = parent_scope.get(ParentService)\nchild_service = child_scope.get(ChildService)\n\n# But parent cannot access child services\ntry:\n    parent_scope.get(ChildService)  # Raises ServiceNotFoundError\nexcept ServiceNotFoundError:\n    print(\"Parent cannot access child services\")\n\n# Dispose child first, then parent\nchild_scope.dispose()\nparent_scope.dispose()\n</code></pre>"},{"location":"api-reference/scopes/#scope-isolation","title":"Scope Isolation","text":"<pre><code># Isolated scope - cannot access parent services\nisolated_scope = container.create_isolated_scope()\n\n# Only services registered in this scope are available\nisolated_scope.bind(IsolatedService, IsolatedService).singleton()\n\nservice = isolated_scope.get(IsolatedService)  # Works\ntry:\n    parent_service = isolated_scope.get(ParentService)  # Fails\nexcept ServiceNotFoundError:\n    print(\"Isolated scope cannot access external services\")\n</code></pre>"},{"location":"api-reference/scopes/#performance-optimization","title":"Performance Optimization","text":""},{"location":"api-reference/scopes/#lazy-scope-creation","title":"Lazy Scope Creation","text":"<pre><code>class LazyScope:\n    \"\"\"Scope that defers instance creation until first access.\"\"\"\n\n    def __init__(self):\n        self.factories = {}\n        self.instances = {}\n\n    def register_factory(self, service_type: type, factory: Callable):\n        \"\"\"Register a factory without creating instance.\"\"\"\n        self.factories[service_type] = factory\n\n    def get_instance(self, service_type: type):\n        \"\"\"Get instance, creating only if needed.\"\"\"\n        if service_type not in self.instances:\n            if service_type in self.factories:\n                self.instances[service_type] = self.factories[service_type]()\n            else:\n                raise ServiceNotFoundError(f\"No factory for {service_type}\")\n\n        return self.instances[service_type]\n</code></pre>"},{"location":"api-reference/scopes/#scope-pooling","title":"Scope Pooling","text":"<pre><code>class ScopePool:\n    \"\"\"Pool of reusable scopes for better performance.\"\"\"\n\n    def __init__(self, container: InjectQ, pool_size: int = 10):\n        self.container = container\n        self.pool_size = pool_size\n        self.available_scopes = []\n        self.active_scopes = set()\n\n    def acquire_scope(self):\n        \"\"\"Get a scope from the pool.\"\"\"\n        if self.available_scopes:\n            scope = self.available_scopes.pop()\n        else:\n            scope = self.container.create_scope()\n\n        self.active_scopes.add(scope)\n        return scope\n\n    def release_scope(self, scope):\n        \"\"\"Return a scope to the pool.\"\"\"\n        if scope in self.active_scopes:\n            self.active_scopes.remove(scope)\n\n            # Reset scope state\n            scope.clear()\n\n            # Return to pool if not full\n            if len(self.available_scopes) &lt; self.pool_size:\n                self.available_scopes.append(scope)\n            else:\n                scope.dispose()\n\n# Usage\nscope_pool = ScopePool(container)\n\n# Use pooled scope\nscope = scope_pool.acquire_scope()\ntry:\n    service = scope.get(MyService)\n    # Use service...\nfinally:\n    scope_pool.release_scope(scope)\n</code></pre>"},{"location":"api-reference/scopes/#debugging-scopes","title":"Debugging Scopes","text":""},{"location":"api-reference/scopes/#scope-inspection","title":"Scope Inspection","text":"<pre><code>class DebuggingScope(BaseScope):\n    \"\"\"Scope with debugging capabilities.\"\"\"\n\n    def __init__(self, name: str):\n        super().__init__()\n        self.name = name\n        self.creation_time = time.time()\n        self.access_count = 0\n\n    def get_instance(self, service_type: type, factory: Callable):\n        self.access_count += 1\n        print(f\"Scope '{self.name}': Accessing {service_type.__name__} (access #{self.access_count})\")\n        return super().get_instance(service_type, factory)\n\n    def dispose(self):\n        lifetime = time.time() - self.creation_time\n        print(f\"Scope '{self.name}': Disposed after {lifetime:.2f}s, {self.access_count} accesses\")\n        super().dispose()\n\n# Usage\ndebug_scope = DebuggingScope(\"request-123\")\ncontainer.register_scope(\"debug\", lambda: debug_scope)\n</code></pre>"},{"location":"api-reference/scopes/#scope-metrics","title":"Scope Metrics","text":"<pre><code>class MetricsScope(BaseScope):\n    \"\"\"Scope that collects performance metrics.\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.metrics = {\n            \"instances_created\": 0,\n            \"total_creation_time\": 0,\n            \"access_count\": 0\n        }\n\n    def get_instance(self, service_type: type, factory: Callable):\n        self.metrics[\"access_count\"] += 1\n\n        if service_type not in self.instances:\n            start_time = time.perf_counter()\n            instance = factory()\n            creation_time = time.perf_counter() - start_time\n\n            self.instances[service_type] = instance\n            self.metrics[\"instances_created\"] += 1\n            self.metrics[\"total_creation_time\"] += creation_time\n\n        return self.instances[service_type]\n\n    def get_metrics(self):\n        \"\"\"Get scope performance metrics.\"\"\"\n        return self.metrics.copy()\n</code></pre>"},{"location":"api-reference/scopes/#error-handling","title":"Error Handling","text":""},{"location":"api-reference/scopes/#scope-error-recovery","title":"Scope Error Recovery","text":"<pre><code>class ResilientScope(BaseScope):\n    \"\"\"Scope with error recovery capabilities.\"\"\"\n\n    def get_instance(self, service_type: type, factory: Callable):\n        try:\n            return super().get_instance(service_type, factory)\n        except Exception as e:\n            print(f\"Error creating {service_type.__name__}: {e}\")\n\n            # Try fallback factory if available\n            fallback_factory = self.get_fallback_factory(service_type)\n            if fallback_factory:\n                print(f\"Using fallback for {service_type.__name__}\")\n                return fallback_factory()\n\n            raise\n\n    def get_fallback_factory(self, service_type: type):\n        \"\"\"Get fallback factory for service type.\"\"\"\n        # Implementation would look up registered fallbacks\n        return None\n</code></pre>"},{"location":"api-reference/testing/","title":"Testing Utilities API","text":"<p>::: injectq.testing</p>"},{"location":"api-reference/testing/#overview","title":"Overview","text":"<p>The testing module provides comprehensive utilities for testing applications that use dependency injection, including mocking, test containers, and integration testing tools.</p>"},{"location":"api-reference/testing/#test-container","title":"Test Container","text":""},{"location":"api-reference/testing/#basic-test-container","title":"Basic Test Container","text":"<pre><code>from injectq.testing import TestContainer\nfrom injectq import Container, inject\n\n# Create test container\ntest_container = TestContainer()\n\n# Register test services\ntest_container.register(UserRepository, MockUserRepository)\ntest_container.register(EmailService, MockEmailService)\n\n# Use in tests\n@inject\ndef test_user_service(user_service: UserService):\n    # Test with mocked dependencies\n    result = user_service.create_user(\"test@example.com\")\n    assert result.email == \"test@example.com\"\n\n# Run test with container\ntest_container.run_test(test_user_service)\n</code></pre>"},{"location":"api-reference/testing/#test-container-implementation","title":"Test Container Implementation","text":"<pre><code>from typing import Dict, Any, Optional, Type, TypeVar, Callable\nimport inspect\nfrom contextlib import contextmanager\n\nT = TypeVar('T')\n\nclass TestContainer:\n    \"\"\"Container optimized for testing scenarios.\"\"\"\n\n    def __init__(self, base_container: Optional[Container] = None):\n        self.base_container = base_container\n        self._test_registrations: Dict[Type, Any] = {}\n        self._original_registrations: Dict[Type, Any] = {}\n        self._active_mocks: Dict[Type, Any] = {}\n\n    def register(self, service_type: Type[T], implementation: Any, scope: str = \"transient\") -&gt; 'TestContainer':\n        \"\"\"Register a test service.\"\"\"\n        self._test_registrations[service_type] = {\n            'implementation': implementation,\n            'scope': scope\n        }\n        return self\n\n    def register_mock(self, service_type: Type[T], mock_instance: Any = None) -&gt; 'TestContainer':\n        \"\"\"Register a mock for a service type.\"\"\"\n        if mock_instance is None:\n            # Create mock automatically\n            try:\n                from unittest.mock import Mock, MagicMock\n\n                if inspect.isclass(service_type) and hasattr(service_type, '__abstractmethods__'):\n                    # For abstract classes, use MagicMock\n                    mock_instance = MagicMock(spec=service_type)\n                else:\n                    mock_instance = Mock(spec=service_type)\n            except ImportError:\n                raise ImportError(\"unittest.mock is required for automatic mock creation\")\n\n        self._active_mocks[service_type] = mock_instance\n        return self.register(service_type, lambda: mock_instance, scope=\"singleton\")\n\n    def get_mock(self, service_type: Type[T]) -&gt; Any:\n        \"\"\"Get the mock instance for a service type.\"\"\"\n        return self._active_mocks.get(service_type)\n\n    def reset_mocks(self):\n        \"\"\"Reset all registered mocks.\"\"\"\n        for mock in self._active_mocks.values():\n            if hasattr(mock, 'reset_mock'):\n                mock.reset_mock()\n\n    @contextmanager\n    def override_container(self):\n        \"\"\"Context manager to temporarily override the main container.\"\"\"\n        if self.base_container:\n            # Store original registrations\n            for service_type, registration in self._test_registrations.items():\n                if self.base_container._registry.is_registered(service_type):\n                    self._original_registrations[service_type] = self.base_container._registry.get_binding(service_type)\n\n                # Override with test registration\n                self.base_container.register(\n                    service_type,\n                    registration['implementation'],\n                    scope=registration['scope']\n                )\n\n        try:\n            yield self\n        finally:\n            if self.base_container:\n                # Restore original registrations\n                for service_type in self._test_registrations:\n                    if service_type in self._original_registrations:\n                        original = self._original_registrations[service_type]\n                        self.base_container.register(\n                            service_type,\n                            original.implementation,\n                            scope=original.scope.name\n                        )\n                    else:\n                        # Remove test registration\n                        if self.base_container._registry.is_registered(service_type):\n                            self.base_container._registry.unregister(service_type)\n\n                self._original_registrations.clear()\n\n    def run_test(self, test_func: Callable, *args, **kwargs):\n        \"\"\"Run a test function with the test container.\"\"\"\n        with self.override_container():\n            if self.base_container:\n                return self.base_container.resolve(test_func, *args, **kwargs)\n            else:\n                # Create temporary container for test\n                temp_container = Container()\n\n                for service_type, registration in self._test_registrations.items():\n                    temp_container.register(\n                        service_type,\n                        registration['implementation'],\n                        scope=registration['scope']\n                    )\n\n                return temp_container.resolve(test_func, *args, **kwargs)\n\n    def create_test_scope(self) -&gt; 'TestScope':\n        \"\"\"Create a test scope for scoped services.\"\"\"\n        return TestScope(self)\n\nclass TestScope:\n    \"\"\"Test scope for managing scoped service lifecycles.\"\"\"\n\n    def __init__(self, test_container: TestContainer):\n        self.test_container = test_container\n        self._scoped_instances: Dict[Type, Any] = {}\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.dispose()\n\n    def dispose(self):\n        \"\"\"Dispose all scoped instances.\"\"\"\n        for instance in self._scoped_instances.values():\n            if hasattr(instance, 'dispose'):\n                instance.dispose()\n            elif hasattr(instance, '__exit__'):\n                instance.__exit__(None, None, None)\n\n        self._scoped_instances.clear()\n</code></pre>"},{"location":"api-reference/testing/#mock-factory","title":"Mock Factory","text":""},{"location":"api-reference/testing/#mock-creation","title":"Mock Creation","text":"<pre><code>from typing import Type, Dict, Any, List\nfrom unittest.mock import Mock, MagicMock, PropertyMock\nimport inspect\n\nclass MockFactory:\n    \"\"\"Factory for creating service mocks.\"\"\"\n\n    def __init__(self):\n        self._mock_configurations: Dict[Type, Dict[str, Any]] = {}\n\n    def create_mock(self, service_type: Type[T], **kwargs) -&gt; Any:\n        \"\"\"Create a mock for a service type.\"\"\"\n        config = self._mock_configurations.get(service_type, {})\n        config.update(kwargs)\n\n        if inspect.isclass(service_type):\n            if hasattr(service_type, '__abstractmethods__') and service_type.__abstractmethods__:\n                # Abstract class or interface\n                mock = MagicMock(spec=service_type, **config)\n            else:\n                # Concrete class\n                mock = Mock(spec=service_type, **config)\n        else:\n            # Protocol or other type\n            mock = Mock(spec=service_type, **config)\n\n        self._configure_mock_behavior(mock, service_type, config)\n        return mock\n\n    def configure_mock(self, service_type: Type, **config):\n        \"\"\"Configure mock behavior for a service type.\"\"\"\n        self._mock_configurations[service_type] = config\n        return self\n\n    def _configure_mock_behavior(self, mock: Mock, service_type: Type, config: Dict[str, Any]):\n        \"\"\"Configure specific mock behaviors.\"\"\"\n        # Configure return values\n        if 'return_values' in config:\n            for method_name, return_value in config['return_values'].items():\n                getattr(mock, method_name).return_value = return_value\n\n        # Configure side effects\n        if 'side_effects' in config:\n            for method_name, side_effect in config['side_effects'].items():\n                getattr(mock, method_name).side_effect = side_effect\n\n        # Configure properties\n        if 'properties' in config:\n            for prop_name, prop_value in config['properties'].items():\n                prop_mock = PropertyMock(return_value=prop_value)\n                setattr(type(mock), prop_name, prop_mock)\n\n# Usage examples\nmock_factory = MockFactory()\n\n# Configure mock behavior\nmock_factory.configure_mock(\n    UserRepository,\n    return_values={\n        'get_user': User(id=1, email=\"test@example.com\"),\n        'exists': True\n    },\n    side_effects={\n        'delete_user': lambda user_id: None if user_id &gt; 0 else ValueError(\"Invalid ID\")\n    }\n)\n\n# Create configured mock\nuser_repo_mock = mock_factory.create_mock(UserRepository)\n</code></pre>"},{"location":"api-reference/testing/#smart-mocks","title":"Smart Mocks","text":"<pre><code>class SmartMock:\n    \"\"\"Mock that automatically handles common patterns.\"\"\"\n\n    def __init__(self, service_type: Type):\n        self.service_type = service_type\n        self._mock = self._create_smart_mock()\n\n    def _create_smart_mock(self) -&gt; Mock:\n        \"\"\"Create mock with intelligent defaults.\"\"\"\n        mock = Mock(spec=self.service_type)\n\n        # Analyze service type for common patterns\n        if hasattr(self.service_type, '__annotations__'):\n            self._configure_property_mocks(mock)\n\n        if hasattr(self.service_type, '__abstractmethods__'):\n            self._configure_abstract_methods(mock)\n\n        # Set up common return types\n        self._configure_common_returns(mock)\n\n        return mock\n\n    def _configure_property_mocks(self, mock: Mock):\n        \"\"\"Configure property mocks based on type annotations.\"\"\"\n        annotations = getattr(self.service_type, '__annotations__', {})\n\n        for name, annotation in annotations.items():\n            if annotation == bool:\n                setattr(mock, name, True)\n            elif annotation == int:\n                setattr(mock, name, 1)\n            elif annotation == str:\n                setattr(mock, name, \"test_value\")\n            elif annotation == list:\n                setattr(mock, name, [])\n            elif annotation == dict:\n                setattr(mock, name, {})\n\n    def _configure_abstract_methods(self, mock: Mock):\n        \"\"\"Configure abstract methods with sensible defaults.\"\"\"\n        abstract_methods = getattr(self.service_type, '__abstractmethods__', set())\n\n        for method_name in abstract_methods:\n            method = getattr(mock, method_name)\n\n            # Analyze method signature for return type\n            if hasattr(self.service_type, method_name):\n                original_method = getattr(self.service_type, method_name)\n                if hasattr(original_method, '__annotations__'):\n                    return_annotation = original_method.__annotations__.get('return')\n                    if return_annotation:\n                        method.return_value = self._create_default_value(return_annotation)\n\n    def _configure_common_returns(self, mock: Mock):\n        \"\"\"Configure common method return patterns.\"\"\"\n        # Methods that typically return self (fluent interface)\n        fluent_methods = ['configure', 'setup', 'with_', 'add_', 'set_']\n\n        for attr_name in dir(self.service_type):\n            if any(attr_name.startswith(prefix) for prefix in fluent_methods):\n                if hasattr(mock, attr_name):\n                    getattr(mock, attr_name).return_value = mock\n\n    def _create_default_value(self, annotation: Type) -&gt; Any:\n        \"\"\"Create default value for type annotation.\"\"\"\n        if annotation == bool:\n            return True\n        elif annotation == int:\n            return 0\n        elif annotation == str:\n            return \"\"\n        elif annotation == list:\n            return []\n        elif annotation == dict:\n            return {}\n        elif annotation == None:\n            return None\n        else:\n            # For complex types, return a mock\n            return Mock(spec=annotation)\n\n    def __getattr__(self, name):\n        \"\"\"Delegate to underlying mock.\"\"\"\n        return getattr(self._mock, name)\n</code></pre>"},{"location":"api-reference/testing/#test-utilities","title":"Test Utilities","text":""},{"location":"api-reference/testing/#assertion-helpers","title":"Assertion Helpers","text":"<pre><code>class DIAssertions:\n    \"\"\"Assertion helpers for dependency injection testing.\"\"\"\n\n    def __init__(self, container):\n        self.container = container\n\n    def assert_registered(self, service_type: Type):\n        \"\"\"Assert that a service is registered.\"\"\"\n        if not self.container._registry.is_registered(service_type):\n            raise AssertionError(f\"Service {service_type.__name__} is not registered\")\n\n    def assert_not_registered(self, service_type: Type):\n        \"\"\"Assert that a service is not registered.\"\"\"\n        if self.container._registry.is_registered(service_type):\n            raise AssertionError(f\"Service {service_type.__name__} is registered\")\n\n    def assert_singleton(self, service_type: Type):\n        \"\"\"Assert that a service is registered as singleton.\"\"\"\n        binding = self.container._registry.get_binding(service_type)\n        if not binding or binding.scope != Scope.SINGLETON:\n            raise AssertionError(f\"Service {service_type.__name__} is not singleton\")\n\n    def assert_transient(self, service_type: Type):\n        \"\"\"Assert that a service is registered as transient.\"\"\"\n        binding = self.container._registry.get_binding(service_type)\n        if not binding or binding.scope != Scope.TRANSIENT:\n            raise AssertionError(f\"Service {service_type.__name__} is not transient\")\n\n    def assert_same_instance(self, service_type: Type):\n        \"\"\"Assert that resolving a service returns the same instance.\"\"\"\n        instance1 = self.container.resolve(service_type)\n        instance2 = self.container.resolve(service_type)\n\n        if instance1 is not instance2:\n            raise AssertionError(f\"Service {service_type.__name__} returned different instances\")\n\n    def assert_different_instances(self, service_type: Type):\n        \"\"\"Assert that resolving a service returns different instances.\"\"\"\n        instance1 = self.container.resolve(service_type)\n        instance2 = self.container.resolve(service_type)\n\n        if instance1 is instance2:\n            raise AssertionError(f\"Service {service_type.__name__} returned the same instance\")\n\n    def assert_mock_called(self, mock: Mock, method_name: str, *args, **kwargs):\n        \"\"\"Assert that a mock method was called with specific arguments.\"\"\"\n        method = getattr(mock, method_name)\n\n        if args or kwargs:\n            method.assert_called_with(*args, **kwargs)\n        else:\n            method.assert_called()\n\n    def assert_mock_not_called(self, mock: Mock, method_name: str):\n        \"\"\"Assert that a mock method was not called.\"\"\"\n        method = getattr(mock, method_name)\n        method.assert_not_called()\n\n    def assert_dependency_injected(self, instance: Any, dependency_name: str, expected_type: Type):\n        \"\"\"Assert that a dependency was properly injected.\"\"\"\n        if not hasattr(instance, dependency_name):\n            raise AssertionError(f\"Instance does not have dependency '{dependency_name}'\")\n\n        dependency = getattr(instance, dependency_name)\n        if not isinstance(dependency, expected_type):\n            raise AssertionError(f\"Dependency '{dependency_name}' is not of type {expected_type.__name__}\")\n\n# Usage\nassertions = DIAssertions(container)\nassertions.assert_registered(UserService)\nassertions.assert_singleton(DatabaseConnection)\nassertions.assert_same_instance(CacheService)\n</code></pre>"},{"location":"api-reference/testing/#test-data-builders","title":"Test Data Builders","text":"<pre><code>class ServiceBuilder:\n    \"\"\"Builder for creating test service instances.\"\"\"\n\n    def __init__(self, service_type: Type[T]):\n        self.service_type = service_type\n        self._dependencies: Dict[str, Any] = {}\n        self._properties: Dict[str, Any] = {}\n\n    def with_dependency(self, name: str, value: Any) -&gt; 'ServiceBuilder':\n        \"\"\"Set a dependency value.\"\"\"\n        self._dependencies[name] = value\n        return self\n\n    def with_property(self, name: str, value: Any) -&gt; 'ServiceBuilder':\n        \"\"\"Set a property value.\"\"\"\n        self._properties[name] = value\n        return self\n\n    def build(self) -&gt; T:\n        \"\"\"Build the service instance.\"\"\"\n        # Create instance with dependencies\n        if self._dependencies:\n            instance = self.service_type(**self._dependencies)\n        else:\n            instance = self.service_type()\n\n        # Set properties\n        for name, value in self._properties.items():\n            setattr(instance, name, value)\n\n        return instance\n\nclass MockBuilder:\n    \"\"\"Builder for creating configured mocks.\"\"\"\n\n    def __init__(self, service_type: Type):\n        self.service_type = service_type\n        self._return_values: Dict[str, Any] = {}\n        self._side_effects: Dict[str, Any] = {}\n        self._properties: Dict[str, Any] = {}\n\n    def returns(self, method_name: str, value: Any) -&gt; 'MockBuilder':\n        \"\"\"Set return value for a method.\"\"\"\n        self._return_values[method_name] = value\n        return self\n\n    def raises(self, method_name: str, exception: Exception) -&gt; 'MockBuilder':\n        \"\"\"Set exception to raise for a method.\"\"\"\n        self._side_effects[method_name] = exception\n        return self\n\n    def with_property(self, name: str, value: Any) -&gt; 'MockBuilder':\n        \"\"\"Set property value.\"\"\"\n        self._properties[name] = value\n        return self\n\n    def build(self) -&gt; Mock:\n        \"\"\"Build the configured mock.\"\"\"\n        mock = Mock(spec=self.service_type)\n\n        # Configure return values\n        for method_name, value in self._return_values.items():\n            getattr(mock, method_name).return_value = value\n\n        # Configure side effects\n        for method_name, effect in self._side_effects.items():\n            getattr(mock, method_name).side_effect = effect\n\n        # Configure properties\n        for name, value in self._properties.items():\n            prop_mock = PropertyMock(return_value=value)\n            setattr(type(mock), name, prop_mock)\n\n        return mock\n\n# Usage\nuser_service = (ServiceBuilder(UserService)\n    .with_dependency('repository', user_repo_mock)\n    .with_dependency('email_service', email_service_mock)\n    .with_property('timeout', 30)\n    .build())\n\nemail_mock = (MockBuilder(EmailService)\n    .returns('send_email', True)\n    .raises('send_bulk_email', SMTPException(\"Server error\"))\n    .with_property('server_url', \"smtp.test.com\")\n    .build())\n</code></pre>"},{"location":"api-reference/testing/#integration-testing","title":"Integration Testing","text":""},{"location":"api-reference/testing/#test-harness","title":"Test Harness","text":"<pre><code>class IntegrationTestHarness:\n    \"\"\"Harness for integration testing with real and mock services.\"\"\"\n\n    def __init__(self):\n        self.container = Container()\n        self.test_container = TestContainer(self.container)\n        self.real_services: List[Type] = []\n        self.mock_services: List[Type] = []\n\n    def use_real_service(self, service_type: Type, implementation: Any = None, scope: str = \"transient\"):\n        \"\"\"Use real implementation for a service.\"\"\"\n        impl = implementation or service_type\n        self.container.register(service_type, impl, scope=scope)\n        self.real_services.append(service_type)\n        return self\n\n    def use_mock_service(self, service_type: Type, mock_instance: Any = None):\n        \"\"\"Use mock implementation for a service.\"\"\"\n        self.test_container.register_mock(service_type, mock_instance)\n        self.mock_services.append(service_type)\n        return self\n\n    def configure_database(self, connection_string: str):\n        \"\"\"Configure database for integration tests.\"\"\"\n        # This would set up test database\n        self.use_real_service(DatabaseConnection, lambda: create_connection(connection_string))\n        return self\n\n    def configure_external_apis(self, mock_responses: Dict[str, Any]):\n        \"\"\"Configure external API mocks.\"\"\"\n        for service_name, responses in mock_responses.items():\n            # Create mock with configured responses\n            mock = Mock()\n            for method, response in responses.items():\n                getattr(mock, method).return_value = response\n\n            # Register mock (would need service type mapping)\n            # self.use_mock_service(service_type, mock)\n\n        return self\n\n    def run_integration_test(self, test_func: Callable):\n        \"\"\"Run integration test with configured services.\"\"\"\n        with self.test_container.override_container():\n            return self.container.resolve(test_func)\n\n    def cleanup(self):\n        \"\"\"Clean up test resources.\"\"\"\n        # Dispose real services\n        for service_type in self.real_services:\n            if self.container._instances.get(service_type):\n                instance = self.container._instances[service_type]\n                if hasattr(instance, 'dispose'):\n                    instance.dispose()\n\n        # Reset mocks\n        self.test_container.reset_mocks()\n\n# Usage\nharness = IntegrationTestHarness()\n\n# Configure integration test\nharness.use_real_service(UserRepository, DatabaseUserRepository)\nharness.use_real_service(DatabaseConnection)\nharness.use_mock_service(EmailService)\nharness.use_mock_service(PaymentGateway)\n\n# Run test\n@inject\ndef integration_test(user_service: UserService, email_mock: EmailService):\n    # Test with real database but mocked external services\n    user = user_service.create_user(\"test@example.com\")\n    assert user.id is not None  # Real database assigned ID\n\n    email_mock.send_welcome_email.assert_called_once_with(user.email)\n\nresult = harness.run_integration_test(integration_test)\nharness.cleanup()\n</code></pre>"},{"location":"api-reference/testing/#test-fixtures","title":"Test Fixtures","text":"<pre><code>import pytest\nfrom typing import Generator\n\n@pytest.fixture\ndef test_container() -&gt; Generator[TestContainer, None, None]:\n    \"\"\"Pytest fixture for test container.\"\"\"\n    container = TestContainer()\n    yield container\n    container.reset_mocks()\n\n@pytest.fixture\ndef user_repository_mock() -&gt; Mock:\n    \"\"\"Pytest fixture for user repository mock.\"\"\"\n    mock = Mock(spec=UserRepository)\n    mock.get_user.return_value = User(id=1, email=\"test@example.com\")\n    mock.create_user.return_value = User(id=2, email=\"new@example.com\")\n    return mock\n\n@pytest.fixture\ndef configured_container(test_container: TestContainer, user_repository_mock: Mock) -&gt; TestContainer:\n    \"\"\"Pytest fixture for configured test container.\"\"\"\n    test_container.register_mock(UserRepository, user_repository_mock)\n    test_container.register_mock(EmailService)\n    return test_container\n\n# Test using fixtures\ndef test_user_service_creation(configured_container: TestContainer):\n    \"\"\"Test user service with mocked dependencies.\"\"\"\n\n    @inject\n    def test_logic(user_service: UserService) -&gt; User:\n        return user_service.create_user(\"test@example.com\")\n\n    result = configured_container.run_test(test_logic)\n    assert result.email == \"test@example.com\"\n\n    # Verify mock interactions\n    user_repo_mock = configured_container.get_mock(UserRepository)\n    user_repo_mock.create_user.assert_called_once()\n</code></pre>"},{"location":"api-reference/types/","title":"Types API","text":"<p>::: injectq.utils.types</p>"},{"location":"api-reference/types/#overview","title":"Overview","text":"<p>The types module provides comprehensive type utilities for working with dependency injection, including type analysis, generic handling, and runtime type checking.</p>"},{"location":"api-reference/types/#type-analysis","title":"Type Analysis","text":""},{"location":"api-reference/types/#basic-type-utilities","title":"Basic Type Utilities","text":"<pre><code>from typing import Type, TypeVar, Union, Optional, Any, get_origin, get_args\nimport inspect\n\nT = TypeVar('T')\n\nclass TypeAnalyzer:\n    \"\"\"Utility class for analyzing types in dependency injection context.\"\"\"\n\n    @staticmethod\n    def is_generic_type(type_hint: Type) -&gt; bool:\n        \"\"\"Check if a type is a generic type.\"\"\"\n        return get_origin(type_hint) is not None\n\n    @staticmethod\n    def get_generic_origin(type_hint: Type) -&gt; Optional[Type]:\n        \"\"\"Get the origin of a generic type.\"\"\"\n        return get_origin(type_hint)\n\n    @staticmethod\n    def get_generic_args(type_hint: Type) -&gt; tuple:\n        \"\"\"Get the arguments of a generic type.\"\"\"\n        return get_args(type_hint)\n\n    @staticmethod\n    def is_optional_type(type_hint: Type) -&gt; bool:\n        \"\"\"Check if a type is Optional (Union with None).\"\"\"\n        origin = get_origin(type_hint)\n        if origin is Union:\n            args = get_args(type_hint)\n            return len(args) == 2 and type(None) in args\n        return False\n\n    @staticmethod\n    def get_optional_inner_type(type_hint: Type) -&gt; Optional[Type]:\n        \"\"\"Get the inner type of an Optional type.\"\"\"\n        if TypeAnalyzer.is_optional_type(type_hint):\n            args = get_args(type_hint)\n            return next(arg for arg in args if arg is not type(None))\n        return None\n\n    @staticmethod\n    def is_collection_type(type_hint: Type) -&gt; bool:\n        \"\"\"Check if a type is a collection type.\"\"\"\n        origin = get_origin(type_hint)\n        collection_origins = (list, tuple, set, frozenset, dict)\n        return origin in collection_origins\n\n    @staticmethod\n    def is_callable_type(type_hint: Type) -&gt; bool:\n        \"\"\"Check if a type is a callable type.\"\"\"\n        from collections.abc import Callable\n        origin = get_origin(type_hint)\n        return origin is Callable or origin is callable\n\n    @staticmethod\n    def extract_type_from_annotation(annotation: Any) -&gt; Optional[Type]:\n        \"\"\"Extract concrete type from type annotation.\"\"\"\n        if annotation == inspect.Parameter.empty:\n            return None\n\n        # Handle string annotations (forward references)\n        if isinstance(annotation, str):\n            # This would need proper evaluation context\n            return annotation\n\n        # Handle Optional types\n        if TypeAnalyzer.is_optional_type(annotation):\n            return TypeAnalyzer.get_optional_inner_type(annotation)\n\n        # Handle generic types\n        if TypeAnalyzer.is_generic_type(annotation):\n            return TypeAnalyzer.get_generic_origin(annotation)\n\n        return annotation\n\n# Usage examples\nanalyzer = TypeAnalyzer()\n\n# Check generic types\nprint(analyzer.is_generic_type(List[str]))  # True\nprint(analyzer.is_generic_type(str))        # False\n\n# Extract type information\nprint(analyzer.get_generic_origin(List[str]))  # &lt;class 'list'&gt;\nprint(analyzer.get_generic_args(Dict[str, int]))  # (&lt;class 'str'&gt;, &lt;class 'int'&gt;)\n\n# Check optional types\nprint(analyzer.is_optional_type(Optional[str]))  # True\nprint(analyzer.get_optional_inner_type(Optional[str]))  # &lt;class 'str'&gt;\n</code></pre>"},{"location":"api-reference/types/#service-type-metadata","title":"Service Type Metadata","text":"<pre><code>from dataclasses import dataclass\nfrom typing import Dict, List, Any\n\n@dataclass\nclass ServiceTypeInfo:\n    \"\"\"Metadata about a service type.\"\"\"\n    service_type: Type\n    is_abstract: bool\n    is_generic: bool\n    dependencies: List['DependencyInfo']\n    methods: List['MethodInfo']\n    properties: List['PropertyInfo']\n    interfaces: List[Type]\n    base_classes: List[Type]\n\n    def __str__(self):\n        return f\"ServiceTypeInfo({self.service_type.__name__})\"\n\n@dataclass\nclass DependencyInfo:\n    \"\"\"Information about a service dependency.\"\"\"\n    name: str\n    type_hint: Type\n    is_optional: bool\n    default_value: Any\n    injection_token: Optional[str] = None\n\n    def __str__(self):\n        optional = \"?\" if self.is_optional else \"\"\n        return f\"{self.name}: {self.type_hint.__name__}{optional}\"\n\n@dataclass\nclass MethodInfo:\n    \"\"\"Information about a service method.\"\"\"\n    name: str\n    parameters: List[DependencyInfo]\n    return_type: Optional[Type]\n    is_async: bool\n    is_property: bool\n\n    def __str__(self):\n        async_marker = \"async \" if self.is_async else \"\"\n        return f\"{async_marker}{self.name}({', '.join(str(p) for p in self.parameters)})\"\n\n@dataclass\nclass PropertyInfo:\n    \"\"\"Information about a service property.\"\"\"\n    name: str\n    type_hint: Type\n    is_readonly: bool\n    has_setter: bool\n\n    def __str__(self):\n        readonly = \" (readonly)\" if self.is_readonly else \"\"\n        return f\"{self.name}: {self.type_hint.__name__}{readonly}\"\n\nclass ServiceIntrospector:\n    \"\"\"Introspects service types to extract metadata.\"\"\"\n\n    def __init__(self):\n        self._cache: Dict[Type, ServiceTypeInfo] = {}\n\n    def analyze_service(self, service_type: Type) -&gt; ServiceTypeInfo:\n        \"\"\"Analyze a service type and return metadata.\"\"\"\n        if service_type in self._cache:\n            return self._cache[service_type]\n\n        info = ServiceTypeInfo(\n            service_type=service_type,\n            is_abstract=self._is_abstract_class(service_type),\n            is_generic=TypeAnalyzer.is_generic_type(service_type),\n            dependencies=self._extract_dependencies(service_type),\n            methods=self._extract_methods(service_type),\n            properties=self._extract_properties(service_type),\n            interfaces=self._extract_interfaces(service_type),\n            base_classes=self._extract_base_classes(service_type)\n        )\n\n        self._cache[service_type] = info\n        return info\n\n    def _is_abstract_class(self, service_type: Type) -&gt; bool:\n        \"\"\"Check if a type is an abstract class.\"\"\"\n        return inspect.isabstract(service_type)\n\n    def _extract_dependencies(self, service_type: Type) -&gt; List[DependencyInfo]:\n        \"\"\"Extract constructor dependencies.\"\"\"\n        dependencies = []\n\n        if hasattr(service_type, '__init__'):\n            sig = inspect.signature(service_type.__init__)\n\n            for param_name, param in sig.parameters.items():\n                if param_name == 'self':\n                    continue\n\n                dep_info = DependencyInfo(\n                    name=param_name,\n                    type_hint=TypeAnalyzer.extract_type_from_annotation(param.annotation),\n                    is_optional=param.default != inspect.Parameter.empty or TypeAnalyzer.is_optional_type(param.annotation),\n                    default_value=param.default if param.default != inspect.Parameter.empty else None\n                )\n                dependencies.append(dep_info)\n\n        return dependencies\n\n    def _extract_methods(self, service_type: Type) -&gt; List[MethodInfo]:\n        \"\"\"Extract method information.\"\"\"\n        methods = []\n\n        for name, method in inspect.getmembers(service_type, inspect.isfunction):\n            if name.startswith('_'):\n                continue\n\n            sig = inspect.signature(method)\n            parameters = []\n\n            for param_name, param in sig.parameters.items():\n                if param_name == 'self':\n                    continue\n\n                param_info = DependencyInfo(\n                    name=param_name,\n                    type_hint=TypeAnalyzer.extract_type_from_annotation(param.annotation),\n                    is_optional=param.default != inspect.Parameter.empty,\n                    default_value=param.default if param.default != inspect.Parameter.empty else None\n                )\n                parameters.append(param_info)\n\n            method_info = MethodInfo(\n                name=name,\n                parameters=parameters,\n                return_type=TypeAnalyzer.extract_type_from_annotation(sig.return_annotation),\n                is_async=inspect.iscoroutinefunction(method),\n                is_property=isinstance(getattr(service_type, name, None), property)\n            )\n            methods.append(method_info)\n\n        return methods\n\n    def _extract_properties(self, service_type: Type) -&gt; List[PropertyInfo]:\n        \"\"\"Extract property information.\"\"\"\n        properties = []\n\n        for name, prop in inspect.getmembers(service_type):\n            if isinstance(prop, property):\n                prop_info = PropertyInfo(\n                    name=name,\n                    type_hint=self._get_property_type(service_type, name),\n                    is_readonly=prop.fset is None,\n                    has_setter=prop.fset is not None\n                )\n                properties.append(prop_info)\n\n        return properties\n\n    def _get_property_type(self, service_type: Type, prop_name: str) -&gt; Type:\n        \"\"\"Get type hint for a property.\"\"\"\n        annotations = getattr(service_type, '__annotations__', {})\n        return annotations.get(prop_name, Any)\n\n    def _extract_interfaces(self, service_type: Type) -&gt; List[Type]:\n        \"\"\"Extract implemented interfaces.\"\"\"\n        # This is simplified - real implementation would check for Protocol types\n        interfaces = []\n\n        for base in service_type.__mro__[1:]:\n            if hasattr(base, '__abstractmethods__') and base.__abstractmethods__:\n                interfaces.append(base)\n\n        return interfaces\n\n    def _extract_base_classes(self, service_type: Type) -&gt; List[Type]:\n        \"\"\"Extract base classes.\"\"\"\n        return list(service_type.__bases__)\n</code></pre>"},{"location":"api-reference/types/#generic-type-handling","title":"Generic Type Handling","text":""},{"location":"api-reference/types/#generic-service-registration","title":"Generic Service Registration","text":"<pre><code>from typing import Generic, TypeVar, Dict, Type, Any\n\nT = TypeVar('T')\nK = TypeVar('K')\nV = TypeVar('V')\n\nclass GenericTypeHandler:\n    \"\"\"Handles registration and resolution of generic services.\"\"\"\n\n    def __init__(self):\n        self._generic_registrations: Dict[Type, Dict[tuple, Any]] = {}\n\n    def register_generic(self, generic_type: Type[Generic], type_args: tuple, implementation: Any):\n        \"\"\"Register a concrete implementation for a generic type.\"\"\"\n        if generic_type not in self._generic_registrations:\n            self._generic_registrations[generic_type] = {}\n\n        self._generic_registrations[generic_type][type_args] = implementation\n\n    def resolve_generic(self, concrete_type: Type) -&gt; Any:\n        \"\"\"Resolve a concrete generic type.\"\"\"\n        origin = get_origin(concrete_type)\n        args = get_args(concrete_type)\n\n        if origin and origin in self._generic_registrations:\n            generic_impls = self._generic_registrations[origin]\n\n            # Exact match\n            if args in generic_impls:\n                return generic_impls[args]\n\n            # Try to find compatible implementation\n            for registered_args, implementation in generic_impls.items():\n                if self._is_compatible_generic(args, registered_args):\n                    return implementation\n\n        return None\n\n    def _is_compatible_generic(self, requested_args: tuple, registered_args: tuple) -&gt; bool:\n        \"\"\"Check if generic type arguments are compatible.\"\"\"\n        if len(requested_args) != len(registered_args):\n            return False\n\n        for req_arg, reg_arg in zip(requested_args, registered_args):\n            if not self._is_assignable(req_arg, reg_arg):\n                return False\n\n        return True\n\n    def _is_assignable(self, source: Type, target: Type) -&gt; bool:\n        \"\"\"Check if source type is assignable to target type.\"\"\"\n        try:\n            return issubclass(source, target)\n        except TypeError:\n            # Handle cases where issubclass doesn't work\n            return source == target\n\n# Example generic service\nclass Repository(Generic[T]):\n    \"\"\"Generic repository interface.\"\"\"\n\n    def get(self, id: int) -&gt; Optional[T]:\n        raise NotImplementedError\n\n    def save(self, entity: T) -&gt; T:\n        raise NotImplementedError\n\n    def delete(self, id: int) -&gt; bool:\n        raise NotImplementedError\n\nclass UserRepository(Repository[User]):\n    \"\"\"Concrete user repository.\"\"\"\n\n    def __init__(self, db_session: Session):\n        self.db_session = db_session\n\n    def get(self, id: int) -&gt; Optional[User]:\n        return self.db_session.query(User).filter(User.id == id).first()\n\n    def save(self, user: User) -&gt; User:\n        self.db_session.add(user)\n        self.db_session.commit()\n        return user\n\n    def delete(self, id: int) -&gt; bool:\n        user = self.get(id)\n        if user:\n            self.db_session.delete(user)\n            self.db_session.commit()\n            return True\n        return False\n\n# Usage\nhandler = GenericTypeHandler()\n\n# Register concrete implementation\nhandler.register_generic(Repository, (User,), UserRepository)\n\n# Resolve generic type\nuser_repo_impl = handler.resolve_generic(Repository[User])\nprint(user_repo_impl)  # UserRepository\n</code></pre>"},{"location":"api-reference/types/#type-constraint-validation","title":"Type Constraint Validation","text":"<pre><code>from typing import TypeVar, Union, Callable, Any\n\n# Type variable with constraints\nNumeric = TypeVar('Numeric', int, float, complex)\nComparable = TypeVar('Comparable', bound='Comparable')\n\nclass TypeConstraintValidator:\n    \"\"\"Validates type constraints for generic types.\"\"\"\n\n    def __init__(self):\n        self._constraint_validators: Dict[TypeVar, Callable[[Type], bool]] = {}\n\n    def register_constraint_validator(self, type_var: TypeVar, validator: Callable[[Type], bool]):\n        \"\"\"Register a custom constraint validator.\"\"\"\n        self._constraint_validators[type_var] = validator\n\n    def validate_type_constraints(self, type_var: TypeVar, concrete_type: Type) -&gt; bool:\n        \"\"\"Validate that a concrete type satisfies type variable constraints.\"\"\"\n        # Check explicit constraints\n        if hasattr(type_var, '__constraints__') and type_var.__constraints__:\n            return any(self._is_assignable(concrete_type, constraint) \n                      for constraint in type_var.__constraints__)\n\n        # Check bound constraint\n        if hasattr(type_var, '__bound__') and type_var.__bound__:\n            return self._is_assignable(concrete_type, type_var.__bound__)\n\n        # Check custom validator\n        if type_var in self._constraint_validators:\n            return self._constraint_validators[type_var](concrete_type)\n\n        return True  # No constraints\n\n    def _is_assignable(self, source: Type, target: Type) -&gt; bool:\n        \"\"\"Check if source type is assignable to target type.\"\"\"\n        try:\n            if isinstance(target, str):\n                # Handle string type hints\n                return source.__name__ == target\n            return issubclass(source, target) or source == target\n        except (TypeError, AttributeError):\n            return source == target\n\n# Custom constraint validators\ndef is_serializable(t: Type) -&gt; bool:\n    \"\"\"Check if type is JSON serializable.\"\"\"\n    serializable_types = (int, float, str, bool, list, dict, type(None))\n    return t in serializable_types or hasattr(t, '__json__')\n\ndef is_hashable(t: Type) -&gt; bool:\n    \"\"\"Check if type is hashable.\"\"\"\n    try:\n        hash(t())\n        return True\n    except (TypeError, AttributeError):\n        return False\n\n# Usage\nvalidator = TypeConstraintValidator()\nvalidator.register_constraint_validator(Numeric, lambda t: t in (int, float, complex))\n\n# Validate constraints\nprint(validator.validate_type_constraints(Numeric, int))     # True\nprint(validator.validate_type_constraints(Numeric, str))     # False\n</code></pre>"},{"location":"api-reference/types/#runtime-type-checking","title":"Runtime Type Checking","text":""},{"location":"api-reference/types/#type-checker","title":"Type Checker","text":"<pre><code>from typing import Any, Type, get_type_hints\nimport inspect\n\nclass RuntimeTypeChecker:\n    \"\"\"Performs runtime type checking for dependency injection.\"\"\"\n\n    def __init__(self, strict_mode: bool = False):\n        self.strict_mode = strict_mode\n        self.type_cache: Dict[Type, Dict[str, Type]] = {}\n\n    def check_service_compatibility(self, service_type: Type, implementation: Any) -&gt; bool:\n        \"\"\"Check if implementation is compatible with service type.\"\"\"\n        if inspect.isclass(implementation):\n            return self._check_class_compatibility(service_type, implementation)\n        else:\n            return self._check_instance_compatibility(service_type, implementation)\n\n    def _check_class_compatibility(self, service_type: Type, implementation_class: Type) -&gt; bool:\n        \"\"\"Check if implementation class is compatible with service type.\"\"\"\n        try:\n            # Check direct inheritance\n            if issubclass(implementation_class, service_type):\n                return True\n\n            # Check duck typing compatibility\n            if not self.strict_mode:\n                return self._check_duck_typing(service_type, implementation_class)\n\n            return False\n        except TypeError:\n            # Handle cases where issubclass doesn't work (e.g., generics)\n            return self._check_structural_compatibility(service_type, implementation_class)\n\n    def _check_instance_compatibility(self, service_type: Type, instance: Any) -&gt; bool:\n        \"\"\"Check if instance is compatible with service type.\"\"\"\n        return isinstance(instance, service_type)\n\n    def _check_duck_typing(self, interface: Type, implementation: Type) -&gt; bool:\n        \"\"\"Check duck typing compatibility.\"\"\"\n        interface_methods = self._get_public_methods(interface)\n        impl_methods = self._get_public_methods(implementation)\n\n        # Check that implementation has all interface methods\n        for method_name, method_sig in interface_methods.items():\n            if method_name not in impl_methods:\n                return False\n\n            # Check method signature compatibility (simplified)\n            impl_sig = impl_methods[method_name]\n            if not self._check_signature_compatibility(method_sig, impl_sig):\n                return False\n\n        return True\n\n    def _check_structural_compatibility(self, interface: Type, implementation: Type) -&gt; bool:\n        \"\"\"Check structural type compatibility.\"\"\"\n        # This is a simplified structural typing check\n        interface_attrs = set(dir(interface))\n        impl_attrs = set(dir(implementation))\n\n        # Check that implementation has all required attributes\n        required_attrs = {attr for attr in interface_attrs \n                         if not attr.startswith('_') and callable(getattr(interface, attr, None))}\n\n        return required_attrs.issubset(impl_attrs)\n\n    def _get_public_methods(self, cls: Type) -&gt; Dict[str, inspect.Signature]:\n        \"\"\"Get public methods and their signatures.\"\"\"\n        methods = {}\n\n        for name, method in inspect.getmembers(cls, inspect.isfunction):\n            if not name.startswith('_'):\n                try:\n                    methods[name] = inspect.signature(method)\n                except (ValueError, TypeError):\n                    pass  # Skip methods we can't analyze\n\n        return methods\n\n    def _check_signature_compatibility(self, expected: inspect.Signature, actual: inspect.Signature) -&gt; bool:\n        \"\"\"Check if method signatures are compatible.\"\"\"\n        # Simplified signature compatibility check\n        expected_params = list(expected.parameters.values())[1:]  # Skip 'self'\n        actual_params = list(actual.parameters.values())[1:]      # Skip 'self'\n\n        if len(expected_params) != len(actual_params):\n            return False\n\n        for exp_param, act_param in zip(expected_params, actual_params):\n            if exp_param.annotation != inspect.Parameter.empty and act_param.annotation != inspect.Parameter.empty:\n                if exp_param.annotation != act_param.annotation:\n                    return False\n\n        return True\n\n    def validate_injection_target(self, target: Callable, dependencies: Dict[str, Any]) -&gt; List[str]:\n        \"\"\"Validate that dependencies match injection target requirements.\"\"\"\n        errors = []\n\n        try:\n            sig = inspect.signature(target)\n            type_hints = get_type_hints(target)\n\n            for param_name, param in sig.parameters.items():\n                if param_name == 'self':\n                    continue\n\n                expected_type = type_hints.get(param_name, param.annotation)\n\n                if param_name in dependencies:\n                    provided_value = dependencies[param_name]\n\n                    if expected_type != inspect.Parameter.empty:\n                        if not self._is_value_compatible(provided_value, expected_type):\n                            errors.append(f\"Parameter '{param_name}' expects {expected_type}, got {type(provided_value)}\")\n                else:\n                    if param.default == inspect.Parameter.empty and not TypeAnalyzer.is_optional_type(expected_type):\n                        errors.append(f\"Required parameter '{param_name}' not provided\")\n\n        except Exception as e:\n            errors.append(f\"Failed to validate injection target: {e}\")\n\n        return errors\n\n    def _is_value_compatible(self, value: Any, expected_type: Type) -&gt; bool:\n        \"\"\"Check if a value is compatible with expected type.\"\"\"\n        if expected_type == Any:\n            return True\n\n        try:\n            return isinstance(value, expected_type)\n        except TypeError:\n            # Handle generic types and other complex type hints\n            origin = get_origin(expected_type)\n            if origin:\n                return isinstance(value, origin)\n            return True  # Fall back to allowing the value\n\n# Usage\nchecker = RuntimeTypeChecker(strict_mode=True)\n\n# Check service compatibility\nis_compatible = checker.check_service_compatibility(UserRepository, SQLAlchemyUserRepository)\nprint(f\"Repository compatible: {is_compatible}\")\n\n# Validate injection target\n@inject\ndef service_method(user_repo: UserRepository, email_service: EmailService):\n    pass\n\ndependencies = {\n    'user_repo': SQLAlchemyUserRepository(session),\n    'email_service': \"invalid_email_service\"  # Wrong type\n}\n\nerrors = checker.validate_injection_target(service_method, dependencies)\nfor error in errors:\n    print(f\"Validation error: {error}\")\n</code></pre>"},{"location":"api-reference/types/#type-annotations","title":"Type Annotations","text":""},{"location":"api-reference/types/#enhanced-type-annotations","title":"Enhanced Type Annotations","text":"<pre><code>from typing import Annotated, Any\nfrom dataclasses import dataclass\n\n@dataclass\nclass InjectionMetadata:\n    \"\"\"Metadata for dependency injection.\"\"\"\n    token: Optional[str] = None\n    scope: Optional[str] = None\n    optional: bool = False\n    factory: Optional[Callable] = None\n    qualifier: Optional[str] = None\n\n# Custom annotation types\ndef Inject(token: str = None, scope: str = None, optional: bool = False, qualifier: str = None):\n    \"\"\"Create injection annotation.\"\"\"\n    return Annotated[Any, InjectionMetadata(token=token, scope=scope, optional=optional, qualifier=qualifier)]\n\ndef Singleton(token: str = None):\n    \"\"\"Annotate as singleton dependency.\"\"\"\n    return Inject(token=token, scope='singleton')\n\ndef Transient(token: str = None):\n    \"\"\"Annotate as transient dependency.\"\"\"\n    return Inject(token=token, scope='transient')\n\ndef Optional(token: str = None):\n    \"\"\"Annotate as optional dependency.\"\"\"\n    return Inject(token=token, optional=True)\n\ndef Named(name: str):\n    \"\"\"Annotate with qualifier name.\"\"\"\n    return Inject(qualifier=name)\n\n# Usage in service definitions\nclass UserService:\n    def __init__(\n        self,\n        repository: Annotated[UserRepository, Singleton()],\n        email_service: Annotated[EmailService, Named(\"smtp\")],\n        cache: Annotated[CacheService, Optional()],\n        logger: Annotated[Logger, Transient()]\n    ):\n        self.repository = repository\n        self.email_service = email_service\n        self.cache = cache\n        self.logger = logger\n\n# Annotation extractor\nclass AnnotationExtractor:\n    \"\"\"Extracts injection metadata from type annotations.\"\"\"\n\n    @staticmethod\n    def extract_injection_metadata(annotation: Any) -&gt; Optional[InjectionMetadata]:\n        \"\"\"Extract injection metadata from type annotation.\"\"\"\n        if hasattr(annotation, '__metadata__'):\n            for metadata in annotation.__metadata__:\n                if isinstance(metadata, InjectionMetadata):\n                    return metadata\n        return None\n\n    @staticmethod\n    def get_service_dependencies_with_metadata(service_type: Type) -&gt; Dict[str, tuple]:\n        \"\"\"Get service dependencies with their injection metadata.\"\"\"\n        dependencies = {}\n\n        if hasattr(service_type, '__init__'):\n            sig = inspect.signature(service_type.__init__)\n            type_hints = get_type_hints(service_type.__init__, include_extras=True)\n\n            for param_name, param in sig.parameters.items():\n                if param_name == 'self':\n                    continue\n\n                type_hint = type_hints.get(param_name, param.annotation)\n                metadata = AnnotationExtractor.extract_injection_metadata(type_hint)\n\n                # Extract actual type (strip Annotated wrapper)\n                actual_type = type_hint\n                if hasattr(type_hint, '__origin__') and hasattr(type_hint, '__args__'):\n                    actual_type = type_hint.__args__[0]\n\n                dependencies[param_name] = (actual_type, metadata)\n\n        return dependencies\n\n# Usage\nextractor = AnnotationExtractor()\ndeps = extractor.get_service_dependencies_with_metadata(UserService)\n\nfor param_name, (param_type, metadata) in deps.items():\n    print(f\"{param_name}: {param_type}\")\n    if metadata:\n        print(f\"  Token: {metadata.token}\")\n        print(f\"  Scope: {metadata.scope}\")\n        print(f\"  Optional: {metadata.optional}\")\n        print(f\"  Qualifier: {metadata.qualifier}\")\n</code></pre>"},{"location":"api-reference/validation/","title":"Validation API","text":"<p>::: injectq.diagnostics.validation</p>"},{"location":"api-reference/validation/#overview","title":"Overview","text":"<p>The validation module provides comprehensive tools for validating dependency injection configurations, detecting issues, and ensuring container integrity.</p>"},{"location":"api-reference/validation/#container-validation","title":"Container Validation","text":""},{"location":"api-reference/validation/#basic-validation","title":"Basic Validation","text":"<pre><code>from injectq.diagnostics import ContainerValidator\n\n# Create validator\nvalidator = ContainerValidator(container)\n\n# Validate container configuration\nresult = validator.validate()\n\nif result.is_valid:\n    print(\"Container configuration is valid\")\nelse:\n    print(\"Validation errors found:\")\n    for error in result.errors:\n        print(f\"  - {error}\")\n</code></pre>"},{"location":"api-reference/validation/#validation-result","title":"Validation Result","text":"<pre><code>from dataclasses import dataclass\nfrom typing import List, Dict, Any\n\n@dataclass\nclass ValidationResult:\n    \"\"\"Result of container validation.\"\"\"\n    is_valid: bool\n    errors: List[str]\n    warnings: List[str]\n    suggestions: List[str]\n    metadata: Dict[str, Any]\n\n    def print_summary(self):\n        \"\"\"Print validation summary.\"\"\"\n        print(f\"Validation Result: {'PASSED' if self.is_valid else 'FAILED'}\")\n\n        if self.errors:\n            print(f\"\\nErrors ({len(self.errors)}):\")\n            for error in self.errors:\n                print(f\"  \u274c {error}\")\n\n        if self.warnings:\n            print(f\"\\nWarnings ({len(self.warnings)}):\")\n            for warning in self.warnings:\n                print(f\"  \u26a0\ufe0f {warning}\")\n\n        if self.suggestions:\n            print(f\"\\nSuggestions ({len(self.suggestions)}):\")\n            for suggestion in self.suggestions:\n                print(f\"  \ud83d\udca1 {suggestion}\")\n</code></pre>"},{"location":"api-reference/validation/#validation-rules","title":"Validation Rules","text":""},{"location":"api-reference/validation/#dependency-validation","title":"Dependency Validation","text":"<pre><code>class DependencyValidator:\n    \"\"\"Validates service dependencies.\"\"\"\n\n    def __init__(self, container):\n        self.container = container\n        self.registry = container._registry\n\n    def validate_dependencies(self) -&gt; ValidationResult:\n        \"\"\"Validate all service dependencies.\"\"\"\n        errors = []\n        warnings = []\n        suggestions = []\n\n        for service_type in self.registry.get_all_services():\n            # Check if all dependencies are registered\n            dependencies = self.get_service_dependencies(service_type)\n\n            for dep_name, dep_type in dependencies.items():\n                if not self.registry.is_registered(dep_type):\n                    if self.is_optional_dependency(dep_type):\n                        warnings.append(f\"Optional dependency {dep_type.__name__} not registered for {service_type.__name__}\")\n                    else:\n                        errors.append(f\"Required dependency {dep_type.__name__} not registered for {service_type.__name__}\")\n\n        return ValidationResult(\n            is_valid=len(errors) == 0,\n            errors=errors,\n            warnings=warnings,\n            suggestions=suggestions,\n            metadata={}\n        )\n\n    def get_service_dependencies(self, service_type: type) -&gt; Dict[str, type]:\n        \"\"\"Get dependencies for a service type.\"\"\"\n        dependencies = {}\n\n        # Analyze constructor parameters\n        if hasattr(service_type, '__init__'):\n            import inspect\n            sig = inspect.signature(service_type.__init__)\n\n            for param_name, param in sig.parameters.items():\n                if param_name != 'self' and param.annotation != inspect.Parameter.empty:\n                    dependencies[param_name] = param.annotation\n\n        return dependencies\n\n    def is_optional_dependency(self, dep_type: type) -&gt; bool:\n        \"\"\"Check if dependency is optional.\"\"\"\n        from typing import get_origin, get_args\n\n        origin = get_origin(dep_type)\n        if origin is Union:\n            args = get_args(dep_type)\n            return type(None) in args\n\n        return False\n</code></pre>"},{"location":"api-reference/validation/#circular-dependency-detection","title":"Circular Dependency Detection","text":"<pre><code>class CircularDependencyValidator:\n    \"\"\"Detects circular dependencies in service graph.\"\"\"\n\n    def __init__(self, container):\n        self.container = container\n        self.registry = container._registry\n\n    def validate_circular_dependencies(self) -&gt; ValidationResult:\n        \"\"\"Detect circular dependencies.\"\"\"\n        errors = []\n        visited = set()\n        recursion_stack = set()\n\n        for service_type in self.registry.get_all_services():\n            if service_type not in visited:\n                cycles = self.find_cycles(service_type, visited, recursion_stack, [])\n\n                for cycle in cycles:\n                    cycle_str = \" -&gt; \".join(t.__name__ for t in cycle)\n                    errors.append(f\"Circular dependency detected: {cycle_str}\")\n\n        return ValidationResult(\n            is_valid=len(errors) == 0,\n            errors=errors,\n            warnings=[],\n            suggestions=[],\n            metadata={'total_services': len(self.registry.get_all_services())}\n        )\n\n    def find_cycles(self, service_type: type, visited: set, rec_stack: set, path: List[type]):\n        \"\"\"Find cycles starting from a service type.\"\"\"\n        visited.add(service_type)\n        rec_stack.add(service_type)\n        path.append(service_type)\n\n        cycles = []\n        dependencies = self.get_dependencies(service_type)\n\n        for dep_type in dependencies:\n            if dep_type not in visited:\n                cycles.extend(self.find_cycles(dep_type, visited, rec_stack, path.copy()))\n            elif dep_type in rec_stack:\n                # Found a cycle\n                cycle_start = path.index(dep_type)\n                cycle = path[cycle_start:] + [dep_type]\n                cycles.append(cycle)\n\n        rec_stack.remove(service_type)\n        return cycles\n\n    def get_dependencies(self, service_type: type) -&gt; List[type]:\n        \"\"\"Get direct dependencies of a service type.\"\"\"\n        dependencies = []\n\n        if hasattr(service_type, '__init__'):\n            import inspect\n            sig = inspect.signature(service_type.__init__)\n\n            for param in sig.parameters.values():\n                if param.name != 'self' and param.annotation != inspect.Parameter.empty:\n                    dependencies.append(param.annotation)\n\n        return dependencies\n</code></pre>"},{"location":"api-reference/validation/#scope-validation","title":"Scope Validation","text":"<pre><code>from injectq.core.scopes import Scope\n\nclass ScopeValidator:\n    \"\"\"Validates scope configurations.\"\"\"\n\n    def __init__(self, container):\n        self.container = container\n        self.registry = container._registry\n\n    def validate_scopes(self) -&gt; ValidationResult:\n        \"\"\"Validate scope configurations.\"\"\"\n        errors = []\n        warnings = []\n        suggestions = []\n\n        for service_type, binding in self.registry.get_all_services().items():\n            # Check for scope anti-patterns\n            self.check_singleton_dependencies(service_type, binding, errors, warnings)\n            self.check_transient_performance(service_type, binding, warnings, suggestions)\n            self.check_scoped_lifecycle(service_type, binding, warnings, suggestions)\n\n        return ValidationResult(\n            is_valid=len(errors) == 0,\n            errors=errors,\n            warnings=warnings,\n            suggestions=suggestions,\n            metadata={}\n        )\n\n    def check_singleton_dependencies(self, service_type: type, binding, errors: List[str], warnings: List[str]):\n        \"\"\"Check if singleton services depend on non-singleton services.\"\"\"\n        if binding.scope == Scope.SINGLETON:\n            dependencies = self.get_dependencies(service_type)\n\n            for dep_type in dependencies:\n                dep_binding = self.registry.get_binding(dep_type)\n                if dep_binding and dep_binding.scope != Scope.SINGLETON:\n                    if dep_binding.scope == Scope.SCOPED:\n                        errors.append(f\"Singleton service {service_type.__name__} depends on scoped service {dep_type.__name__}\")\n                    elif dep_binding.scope == Scope.TRANSIENT:\n                        warnings.append(f\"Singleton service {service_type.__name__} depends on transient service {dep_type.__name__}\")\n\n    def check_transient_performance(self, service_type: type, binding, warnings: List[str], suggestions: List[str]):\n        \"\"\"Check for performance issues with transient services.\"\"\"\n        if binding.scope == Scope.TRANSIENT:\n            # Check if service is expensive to create\n            if self.is_expensive_service(service_type):\n                warnings.append(f\"Expensive service {service_type.__name__} is configured as transient\")\n                suggestions.append(f\"Consider making {service_type.__name__} singleton or scoped\")\n\n    def check_scoped_lifecycle(self, service_type: type, binding, warnings: List[str], suggestions: List[str]):\n        \"\"\"Check scoped service lifecycle.\"\"\"\n        if binding.scope == Scope.SCOPED:\n            # Check if service implements disposable pattern\n            if not hasattr(service_type, 'dispose') and not hasattr(service_type, '__exit__'):\n                suggestions.append(f\"Scoped service {service_type.__name__} should implement disposal pattern\")\n\n    def is_expensive_service(self, service_type: type) -&gt; bool:\n        \"\"\"Check if service is expensive to create.\"\"\"\n        # Heuristics for expensive services\n        expensive_indicators = [\n            'Database', 'Connection', 'Client', 'Service', 'Manager',\n            'Repository', 'Cache', 'Pool', 'Factory'\n        ]\n\n        service_name = service_type.__name__\n        return any(indicator in service_name for indicator in expensive_indicators)\n\n    def get_dependencies(self, service_type: type) -&gt; List[type]:\n        \"\"\"Get dependencies for a service type.\"\"\"\n        dependencies = []\n\n        if hasattr(service_type, '__init__'):\n            import inspect\n            sig = inspect.signature(service_type.__init__)\n\n            for param in sig.parameters.values():\n                if param.name != 'self' and param.annotation != inspect.Parameter.empty:\n                    dependencies.append(param.annotation)\n\n        return dependencies\n</code></pre>"},{"location":"api-reference/validation/#advanced-validation","title":"Advanced Validation","text":""},{"location":"api-reference/validation/#type-safety-validation","title":"Type Safety Validation","text":"<pre><code>class TypeSafetyValidator:\n    \"\"\"Validates type safety of dependency injection.\"\"\"\n\n    def __init__(self, container):\n        self.container = container\n        self.registry = container._registry\n\n    def validate_type_safety(self) -&gt; ValidationResult:\n        \"\"\"Validate type safety of all bindings.\"\"\"\n        errors = []\n        warnings = []\n        suggestions = []\n\n        for service_type, binding in self.registry.get_all_services().items():\n            # Check implementation compatibility\n            if not self.is_compatible_implementation(service_type, binding.implementation):\n                errors.append(f\"Implementation {binding.implementation} is not compatible with {service_type}\")\n\n            # Check generic types\n            if self.has_generic_types(service_type):\n                generic_errors = self.validate_generic_types(service_type, binding)\n                errors.extend(generic_errors)\n\n            # Check forward references\n            forward_ref_warnings = self.check_forward_references(service_type)\n            warnings.extend(forward_ref_warnings)\n\n        return ValidationResult(\n            is_valid=len(errors) == 0,\n            errors=errors,\n            warnings=warnings,\n            suggestions=suggestions,\n            metadata={}\n        )\n\n    def is_compatible_implementation(self, service_type: type, implementation) -&gt; bool:\n        \"\"\"Check if implementation is compatible with service type.\"\"\"\n        if isinstance(implementation, type):\n            try:\n                return issubclass(implementation, service_type) or service_type == implementation\n            except TypeError:\n                # Handle cases where issubclass doesn't work (e.g., generics)\n                return True\n\n        return isinstance(implementation, service_type)\n\n    def has_generic_types(self, service_type: type) -&gt; bool:\n        \"\"\"Check if service type uses generics.\"\"\"\n        from typing import get_origin\n        return get_origin(service_type) is not None\n\n    def validate_generic_types(self, service_type: type, binding) -&gt; List[str]:\n        \"\"\"Validate generic type bindings.\"\"\"\n        errors = []\n\n        from typing import get_origin, get_args\n\n        origin = get_origin(service_type)\n        args = get_args(service_type)\n\n        if origin and args:\n            # Validate that implementation satisfies generic constraints\n            impl_origin = get_origin(binding.implementation) if hasattr(binding.implementation, '__origin__') else None\n            impl_args = get_args(binding.implementation) if hasattr(binding.implementation, '__args__') else ()\n\n            if impl_origin != origin:\n                errors.append(f\"Generic implementation {binding.implementation} doesn't match service type {service_type}\")\n            elif len(impl_args) != len(args):\n                errors.append(f\"Generic argument count mismatch for {service_type}\")\n\n        return errors\n\n    def check_forward_references(self, service_type: type) -&gt; List[str]:\n        \"\"\"Check for unresolved forward references.\"\"\"\n        warnings = []\n\n        if hasattr(service_type, '__forward_arg__'):\n            warnings.append(f\"Service type {service_type} has unresolved forward reference\")\n\n        return warnings\n</code></pre>"},{"location":"api-reference/validation/#performance-validation","title":"Performance Validation","text":"<pre><code>class PerformanceValidator:\n    \"\"\"Validates performance characteristics of container configuration.\"\"\"\n\n    def __init__(self, container):\n        self.container = container\n        self.registry = container._registry\n\n    def validate_performance(self) -&gt; ValidationResult:\n        \"\"\"Validate performance characteristics.\"\"\"\n        errors = []\n        warnings = []\n        suggestions = []\n\n        # Check dependency depth\n        max_depth = self.check_dependency_depth()\n        if max_depth &gt; 10:\n            warnings.append(f\"Maximum dependency depth is {max_depth}, which may impact performance\")\n\n        # Check for singleton abuse\n        singleton_count = self.count_singletons()\n        total_services = len(self.registry.get_all_services())\n\n        if singleton_count / total_services &gt; 0.8:\n            warnings.append(f\"High percentage of singleton services ({singleton_count}/{total_services})\")\n            suggestions.append(\"Consider using scoped services for better memory management\")\n\n        # Check for transient overuse\n        transient_count = self.count_transients()\n        if transient_count / total_services &gt; 0.5:\n            warnings.append(f\"High percentage of transient services ({transient_count}/{total_services})\")\n            suggestions.append(\"Consider using singleton or scoped services for better performance\")\n\n        return ValidationResult(\n            is_valid=len(errors) == 0,\n            errors=errors,\n            warnings=warnings,\n            suggestions=suggestions,\n            metadata={\n                'max_dependency_depth': max_depth,\n                'singleton_count': singleton_count,\n                'transient_count': transient_count,\n                'total_services': total_services\n            }\n        )\n\n    def check_dependency_depth(self) -&gt; int:\n        \"\"\"Calculate maximum dependency depth.\"\"\"\n        max_depth = 0\n\n        for service_type in self.registry.get_all_services():\n            depth = self.calculate_depth(service_type, set())\n            max_depth = max(max_depth, depth)\n\n        return max_depth\n\n    def calculate_depth(self, service_type: type, visited: set) -&gt; int:\n        \"\"\"Calculate dependency depth for a service.\"\"\"\n        if service_type in visited:\n            return 0  # Circular dependency\n\n        visited.add(service_type)\n\n        dependencies = self.get_dependencies(service_type)\n        if not dependencies:\n            return 1\n\n        max_child_depth = 0\n        for dep_type in dependencies:\n            child_depth = self.calculate_depth(dep_type, visited.copy())\n            max_child_depth = max(max_child_depth, child_depth)\n\n        return 1 + max_child_depth\n\n    def count_singletons(self) -&gt; int:\n        \"\"\"Count singleton services.\"\"\"\n        count = 0\n        for _, binding in self.registry.get_all_services().items():\n            if binding.scope == Scope.SINGLETON:\n                count += 1\n        return count\n\n    def count_transients(self) -&gt; int:\n        \"\"\"Count transient services.\"\"\"\n        count = 0\n        for _, binding in self.registry.get_all_services().items():\n            if binding.scope == Scope.TRANSIENT:\n                count += 1\n        return count\n\n    def get_dependencies(self, service_type: type) -&gt; List[type]:\n        \"\"\"Get dependencies for a service type.\"\"\"\n        dependencies = []\n\n        if hasattr(service_type, '__init__'):\n            import inspect\n            sig = inspect.signature(service_type.__init__)\n\n            for param in sig.parameters.values():\n                if param.name != 'self' and param.annotation != inspect.Parameter.empty:\n                    dependencies.append(param.annotation)\n\n        return dependencies\n</code></pre>"},{"location":"api-reference/validation/#validation-tools","title":"Validation Tools","text":""},{"location":"api-reference/validation/#comprehensive-validator","title":"Comprehensive Validator","text":"<pre><code>class ContainerValidator:\n    \"\"\"Comprehensive container validator.\"\"\"\n\n    def __init__(self, container):\n        self.container = container\n        self.validators = [\n            DependencyValidator(container),\n            CircularDependencyValidator(container),\n            ScopeValidator(container),\n            TypeSafetyValidator(container),\n            PerformanceValidator(container)\n        ]\n\n    def validate(self) -&gt; ValidationResult:\n        \"\"\"Run all validation checks.\"\"\"\n        all_errors = []\n        all_warnings = []\n        all_suggestions = []\n        combined_metadata = {}\n\n        for validator in self.validators:\n            if hasattr(validator, 'validate_dependencies'):\n                result = validator.validate_dependencies()\n            elif hasattr(validator, 'validate_circular_dependencies'):\n                result = validator.validate_circular_dependencies()\n            elif hasattr(validator, 'validate_scopes'):\n                result = validator.validate_scopes()\n            elif hasattr(validator, 'validate_type_safety'):\n                result = validator.validate_type_safety()\n            elif hasattr(validator, 'validate_performance'):\n                result = validator.validate_performance()\n            else:\n                continue\n\n            all_errors.extend(result.errors)\n            all_warnings.extend(result.warnings)\n            all_suggestions.extend(result.suggestions)\n            combined_metadata.update(result.metadata)\n\n        return ValidationResult(\n            is_valid=len(all_errors) == 0,\n            errors=all_errors,\n            warnings=all_warnings,\n            suggestions=all_suggestions,\n            metadata=combined_metadata\n        )\n\n    def validate_and_report(self):\n        \"\"\"Validate and print detailed report.\"\"\"\n        result = self.validate()\n        result.print_summary()\n        return result\n</code></pre>"},{"location":"api-reference/validation/#custom-validation-rules","title":"Custom Validation Rules","text":"<pre><code>class CustomValidationRule:\n    \"\"\"Base class for custom validation rules.\"\"\"\n\n    def __init__(self, name: str, description: str):\n        self.name = name\n        self.description = description\n\n    def validate(self, container) -&gt; ValidationResult:\n        \"\"\"Implement validation logic.\"\"\"\n        raise NotImplementedError\n\nclass NamingConventionRule(CustomValidationRule):\n    \"\"\"Validates service naming conventions.\"\"\"\n\n    def __init__(self):\n        super().__init__(\n            \"naming_convention\",\n            \"Validates that services follow naming conventions\"\n        )\n\n    def validate(self, container) -&gt; ValidationResult:\n        \"\"\"Validate naming conventions.\"\"\"\n        warnings = []\n        suggestions = []\n\n        for service_type in container._registry.get_all_services():\n            service_name = service_type.__name__\n\n            # Check for interface naming\n            if service_name.startswith('I') and service_name[1].isupper():\n                # Interface should end with interface-indicating suffix\n                if not any(service_name.endswith(suffix) for suffix in ['Service', 'Repository', 'Factory', 'Manager']):\n                    suggestions.append(f\"Interface {service_name} should end with descriptive suffix\")\n\n            # Check for implementation naming\n            if service_name.endswith('Impl'):\n                warnings.append(f\"Service {service_name} uses 'Impl' suffix, consider more descriptive name\")\n\n        return ValidationResult(\n            is_valid=True,  # Naming issues are not errors\n            errors=[],\n            warnings=warnings,\n            suggestions=suggestions,\n            metadata={}\n        )\n\n# Usage\nvalidator = ContainerValidator(container)\nvalidator.validators.append(NamingConventionRule())\n\nresult = validator.validate()\n</code></pre>"},{"location":"api-reference/validation/#validation-configuration","title":"Validation Configuration","text":""},{"location":"api-reference/validation/#validation-settings","title":"Validation Settings","text":"<pre><code>@dataclass\nclass ValidationSettings:\n    \"\"\"Configuration for validation behavior.\"\"\"\n\n    # Dependency validation\n    check_missing_dependencies: bool = True\n    allow_optional_dependencies: bool = True\n\n    # Circular dependency validation\n    check_circular_dependencies: bool = True\n    max_dependency_depth: int = 20\n\n    # Scope validation\n    check_scope_compatibility: bool = True\n    warn_singleton_transient_deps: bool = True\n\n    # Type safety validation\n    check_type_compatibility: bool = True\n    validate_generic_types: bool = True\n\n    # Performance validation\n    check_performance_issues: bool = True\n    max_singleton_percentage: float = 0.8\n    max_transient_percentage: float = 0.5\n\n    # Custom rules\n    custom_rules: List[CustomValidationRule] = field(default_factory=list)\n\nclass ConfigurableValidator:\n    \"\"\"Validator with configurable settings.\"\"\"\n\n    def __init__(self, container, settings: ValidationSettings = None):\n        self.container = container\n        self.settings = settings or ValidationSettings()\n\n    def validate(self) -&gt; ValidationResult:\n        \"\"\"Validate with configured settings.\"\"\"\n        all_errors = []\n        all_warnings = []\n        all_suggestions = []\n        combined_metadata = {}\n\n        if self.settings.check_missing_dependencies:\n            result = DependencyValidator(self.container).validate_dependencies()\n            all_errors.extend(result.errors)\n            all_warnings.extend(result.warnings)\n\n        if self.settings.check_circular_dependencies:\n            result = CircularDependencyValidator(self.container).validate_circular_dependencies()\n            all_errors.extend(result.errors)\n\n        # Continue with other validation checks based on settings...\n\n        return ValidationResult(\n            is_valid=len(all_errors) == 0,\n            errors=all_errors,\n            warnings=all_warnings,\n            suggestions=all_suggestions,\n            metadata=combined_metadata\n        )\n</code></pre>"},{"location":"best-practices/architectural-patterns/","title":"Architectural Design Patterns","text":"<p>This guide demonstrates how to implement clean, maintainable architectures using InjectQ's dependency injection capabilities with proven design patterns and architectural principles.</p>"},{"location":"best-practices/architectural-patterns/#layered-architecture","title":"\ud83c\udfd7\ufe0f Layered Architecture","text":""},{"location":"best-practices/architectural-patterns/#classic-three-layer-architecture","title":"Classic Three-Layer Architecture","text":"<pre><code># layered_architecture.py\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom injectq import InjectQ, inject, Module\n\n# ==================== DATA LAYER ====================\n\nclass IRepository(ABC):\n    \"\"\"Base repository interface.\"\"\"\n\n    @abstractmethod\n    async def save(self, entity) -&gt; Any:\n        pass\n\n    @abstractmethod\n    async def find_by_id(self, id: Any) -&gt; Optional[Any]:\n        pass\n\n    @abstractmethod\n    async def find_all(self) -&gt; List[Any]:\n        pass\n\n    @abstractmethod\n    async def delete(self, id: Any) -&gt; bool:\n        pass\n\nclass IUnitOfWork(ABC):\n    \"\"\"Unit of Work pattern for managing transactions.\"\"\"\n\n    @abstractmethod\n    async def begin_transaction(self):\n        pass\n\n    @abstractmethod\n    async def commit(self):\n        pass\n\n    @abstractmethod\n    async def rollback(self):\n        pass\n\n@dataclass\nclass User:\n    id: Optional[str] = None\n    name: str = \"\"\n    email: str = \"\"\n\n@dataclass \nclass Product:\n    id: Optional[str] = None\n    name: str = \"\"\n    price: float = 0.0\n    category_id: str = \"\"\n\nclass UserRepository(IRepository):\n    @inject\n    def __init__(self, database: Database, unit_of_work: IUnitOfWork):\n        self.db = database\n        self.uow = unit_of_work\n        self._users: Dict[str, User] = {}  # In-memory for demo\n\n    async def save(self, user: User) -&gt; User:\n        if not user.id:\n            user.id = f\"user_{len(self._users) + 1}\"\n        self._users[user.id] = user\n        return user\n\n    async def find_by_id(self, user_id: str) -&gt; Optional[User]:\n        return self._users.get(user_id)\n\n    async def find_all(self) -&gt; List[User]:\n        return list(self._users.values())\n\n    async def delete(self, user_id: str) -&gt; bool:\n        return self._users.pop(user_id, None) is not None\n\n    async def find_by_email(self, email: str) -&gt; Optional[User]:\n        for user in self._users.values():\n            if user.email == email:\n                return user\n        return None\n\nclass ProductRepository(IRepository):\n    @inject\n    def __init__(self, database: Database, unit_of_work: IUnitOfWork):\n        self.db = database\n        self.uow = unit_of_work\n        self._products: Dict[str, Product] = {}  # In-memory for demo\n\n    async def save(self, product: Product) -&gt; Product:\n        if not product.id:\n            product.id = f\"product_{len(self._products) + 1}\"\n        self._products[product.id] = product\n        return product\n\n    async def find_by_id(self, product_id: str) -&gt; Optional[Product]:\n        return self._products.get(product_id)\n\n    async def find_all(self) -&gt; List[Product]:\n        return list(self._products.values())\n\n    async def delete(self, product_id: str) -&gt; bool:\n        return self._products.pop(product_id, None) is not None\n\n    async def find_by_category(self, category_id: str) -&gt; List[Product]:\n        return [p for p in self._products.values() if p.category_id == category_id]\n\nclass Database:\n    \"\"\"Database connection and operations.\"\"\"\n\n    @inject\n    def __init__(self, config: DatabaseConfig):\n        self.config = config\n        self.connected = False\n\n    async def connect(self):\n        self.connected = True\n        print(f\"Connected to database: {self.config.host}:{self.config.port}\")\n\n    async def disconnect(self):\n        self.connected = False\n\nclass UnitOfWork(IUnitOfWork):\n    \"\"\"Concrete implementation of Unit of Work.\"\"\"\n\n    @inject\n    def __init__(self, database: Database):\n        self.database = database\n        self.in_transaction = False\n\n    async def begin_transaction(self):\n        self.in_transaction = True\n        print(\"Transaction started\")\n\n    async def commit(self):\n        if self.in_transaction:\n            print(\"Transaction committed\")\n            self.in_transaction = False\n\n    async def rollback(self):\n        if self.in_transaction:\n            print(\"Transaction rolled back\")\n            self.in_transaction = False\n\n# ==================== BUSINESS LAYER ====================\n\nclass IBusinessService(ABC):\n    \"\"\"Base interface for business services.\"\"\"\n    pass\n\nclass UserBusinessService(IBusinessService):\n    \"\"\"Business logic for user operations.\"\"\"\n\n    @inject\n    def __init__(\n        self,\n        user_repository: UserRepository,\n        email_service: EmailService,\n        unit_of_work: IUnitOfWork\n    ):\n        self.user_repository = user_repository\n        self.email_service = email_service\n        self.unit_of_work = unit_of_work\n\n    async def create_user(self, name: str, email: str) -&gt; User:\n        \"\"\"Create user with business validation.\"\"\"\n        # Business rule: Check if email already exists\n        existing_user = await self.user_repository.find_by_email(email)\n        if existing_user:\n            raise ValueError(\"User with this email already exists\")\n\n        # Business rule: Validate email format\n        if \"@\" not in email:\n            raise ValueError(\"Invalid email format\")\n\n        await self.unit_of_work.begin_transaction()\n        try:\n            user = User(name=name, email=email)\n            saved_user = await self.user_repository.save(user)\n\n            # Business rule: Send welcome email\n            await self.email_service.send_welcome_email(saved_user)\n\n            await self.unit_of_work.commit()\n            return saved_user\n\n        except Exception as e:\n            await self.unit_of_work.rollback()\n            raise\n\n    async def update_user(self, user_id: str, updates: Dict[str, Any]) -&gt; Optional[User]:\n        \"\"\"Update user with business validation.\"\"\"\n        user = await self.user_repository.find_by_id(user_id)\n        if not user:\n            return None\n\n        # Business rule: Email cannot be changed to existing email\n        if \"email\" in updates:\n            existing_user = await self.user_repository.find_by_email(updates[\"email\"])\n            if existing_user and existing_user.id != user_id:\n                raise ValueError(\"Email already in use\")\n\n        # Apply updates\n        for key, value in updates.items():\n            if hasattr(user, key):\n                setattr(user, key, value)\n\n        return await self.user_repository.save(user)\n\n    async def deactivate_user(self, user_id: str) -&gt; bool:\n        \"\"\"Deactivate user (business operation).\"\"\"\n        # In real implementation, this might set an 'active' flag\n        # For demo, we'll just log the operation\n        user = await self.user_repository.find_by_id(user_id)\n        if user:\n            print(f\"User {user.name} has been deactivated\")\n            return True\n        return False\n\nclass ProductBusinessService(IBusinessService):\n    \"\"\"Business logic for product operations.\"\"\"\n\n    @inject\n    def __init__(\n        self,\n        product_repository: ProductRepository,\n        pricing_service: PricingService,\n        unit_of_work: IUnitOfWork\n    ):\n        self.product_repository = product_repository\n        self.pricing_service = pricing_service\n        self.unit_of_work = unit_of_work\n\n    async def create_product(self, name: str, base_price: float, category_id: str) -&gt; Product:\n        \"\"\"Create product with business logic.\"\"\"\n        # Business rule: Apply pricing strategy\n        final_price = await self.pricing_service.calculate_price(base_price, category_id)\n\n        await self.unit_of_work.begin_transaction()\n        try:\n            product = Product(name=name, price=final_price, category_id=category_id)\n            saved_product = await self.product_repository.save(product)\n\n            await self.unit_of_work.commit()\n            return saved_product\n\n        except Exception as e:\n            await self.unit_of_work.rollback()\n            raise\n\n    async def update_product_price(self, product_id: str, new_base_price: float) -&gt; Optional[Product]:\n        \"\"\"Update product price with business rules.\"\"\"\n        product = await self.product_repository.find_by_id(product_id)\n        if not product:\n            return None\n\n        # Business rule: Apply pricing strategy\n        final_price = await self.pricing_service.calculate_price(new_base_price, product.category_id)\n        product.price = final_price\n\n        return await self.product_repository.save(product)\n\nclass PricingService:\n    \"\"\"Business service for pricing calculations.\"\"\"\n\n    async def calculate_price(self, base_price: float, category_id: str) -&gt; float:\n        \"\"\"Calculate final price based on category and business rules.\"\"\"\n        # Business rule: Different markup for different categories\n        markup_rates = {\n            \"electronics\": 1.15,  # 15% markup\n            \"books\": 1.05,        # 5% markup\n            \"clothing\": 1.20      # 20% markup\n        }\n\n        markup = markup_rates.get(category_id, 1.10)  # Default 10% markup\n        return base_price * markup\n\nclass EmailService:\n    \"\"\"Service for email operations.\"\"\"\n\n    async def send_welcome_email(self, user: User):\n        \"\"\"Send welcome email to new user.\"\"\"\n        print(f\"Sending welcome email to {user.email}\")\n\n# ==================== PRESENTATION LAYER ====================\n\nclass IController(ABC):\n    \"\"\"Base interface for controllers.\"\"\"\n    pass\n\nclass UserController(IController):\n    \"\"\"Handles user-related HTTP requests.\"\"\"\n\n    @inject\n    def __init__(self, user_service: UserBusinessService):\n        self.user_service = user_service\n\n    async def create_user_endpoint(self, request_data: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Handle POST /users endpoint.\"\"\"\n        try:\n            user = await self.user_service.create_user(\n                name=request_data[\"name\"],\n                email=request_data[\"email\"]\n            )\n\n            return {\n                \"status\": \"success\",\n                \"data\": {\n                    \"id\": user.id,\n                    \"name\": user.name,\n                    \"email\": user.email\n                }\n            }\n\n        except ValueError as e:\n            return {\n                \"status\": \"error\",\n                \"message\": str(e)\n            }\n        except Exception as e:\n            return {\n                \"status\": \"error\",\n                \"message\": \"Internal server error\"\n            }\n\n    async def update_user_endpoint(self, user_id: str, request_data: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Handle PUT /users/{id} endpoint.\"\"\"\n        try:\n            user = await self.user_service.update_user(user_id, request_data)\n\n            if user:\n                return {\n                    \"status\": \"success\",\n                    \"data\": {\n                        \"id\": user.id,\n                        \"name\": user.name,\n                        \"email\": user.email\n                    }\n                }\n            else:\n                return {\n                    \"status\": \"error\",\n                    \"message\": \"User not found\"\n                }\n\n        except ValueError as e:\n            return {\n                \"status\": \"error\",\n                \"message\": str(e)\n            }\n\nclass ProductController(IController):\n    \"\"\"Handles product-related HTTP requests.\"\"\"\n\n    @inject\n    def __init__(self, product_service: ProductBusinessService):\n        self.product_service = product_service\n\n    async def create_product_endpoint(self, request_data: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Handle POST /products endpoint.\"\"\"\n        try:\n            product = await self.product_service.create_product(\n                name=request_data[\"name\"],\n                base_price=request_data[\"base_price\"],\n                category_id=request_data[\"category_id\"]\n            )\n\n            return {\n                \"status\": \"success\",\n                \"data\": {\n                    \"id\": product.id,\n                    \"name\": product.name,\n                    \"price\": product.price,\n                    \"category_id\": product.category_id\n                }\n            }\n\n        except Exception as e:\n            return {\n                \"status\": \"error\",\n                \"message\": \"Internal server error\"\n            }\n\n# ==================== CONFIGURATION ====================\n\n@dataclass\nclass DatabaseConfig:\n    host: str\n    port: int\n    database: str\n\nclass LayeredArchitectureModule(Module):\n    \"\"\"Module configuration for layered architecture.\"\"\"\n\n    def configure(self):\n        # Configuration\n        self.bind(DatabaseConfig, DatabaseConfig(\n            host=\"localhost\",\n            port=5432,\n            database=\"app_db\"\n        )).singleton()\n\n        # Data Layer\n        self.bind(Database, Database).singleton()\n        self.bind(IUnitOfWork, UnitOfWork).scoped()\n        self.bind(UserRepository, UserRepository).scoped()\n        self.bind(ProductRepository, ProductRepository).scoped()\n\n        # Business Layer\n        self.bind(PricingService, PricingService).singleton()\n        self.bind(EmailService, EmailService).singleton()\n        self.bind(UserBusinessService, UserBusinessService).scoped()\n        self.bind(ProductBusinessService, ProductBusinessService).scoped()\n\n        # Presentation Layer\n        self.bind(UserController, UserController).scoped()\n        self.bind(ProductController, ProductController).scoped()\n\n# Demo Application\nclass LayeredApplication:\n    @inject\n    def __init__(\n        self,\n        database: Database,\n        user_controller: UserController,\n        product_controller: ProductController\n    ):\n        self.database = database\n        self.user_controller = user_controller\n        self.product_controller = product_controller\n\n    async def start(self):\n        \"\"\"Start the application.\"\"\"\n        await self.database.connect()\n        print(\"Layered Architecture Application started\")\n\n    async def run_demo(self):\n        \"\"\"Demonstrate layered architecture.\"\"\"\n        print(\"=== Layered Architecture Demo ===\\n\")\n\n        # Create a user\n        user_result = await self.user_controller.create_user_endpoint({\n            \"name\": \"John Doe\",\n            \"email\": \"john@example.com\"\n        })\n        print(f\"Created user: {user_result}\\n\")\n\n        # Create a product\n        product_result = await self.product_controller.create_product_endpoint({\n            \"name\": \"Laptop\",\n            \"base_price\": 999.99,\n            \"category_id\": \"electronics\"\n        })\n        print(f\"Created product: {product_result}\\n\")\n\n        # Try to create duplicate user\n        duplicate_result = await self.user_controller.create_user_endpoint({\n            \"name\": \"Jane Doe\",\n            \"email\": \"john@example.com\"  # Same email\n        })\n        print(f\"Duplicate user attempt: {duplicate_result}\")\n\nasync def layered_architecture_example():\n    container = InjectQ()\n    container.install(LayeredArchitectureModule())\n\n    app = container.get(LayeredApplication)\n    await app.start()\n    await app.run_demo()\n</code></pre>"},{"location":"best-practices/architectural-patterns/#hexagonal-architecture-ports-and-adapters","title":"\ud83c\udfaf Hexagonal Architecture (Ports and Adapters)","text":""},{"location":"best-practices/architectural-patterns/#domain-driven-hexagonal-architecture","title":"Domain-Driven Hexagonal Architecture","text":"<pre><code># hexagonal_architecture.py\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any, Protocol\nfrom injectq import InjectQ, inject, Module\nfrom enum import Enum\n\n# ==================== DOMAIN CORE ====================\n\nclass OrderStatus(Enum):\n    PENDING = \"pending\"\n    CONFIRMED = \"confirmed\"\n    SHIPPED = \"shipped\"\n    DELIVERED = \"delivered\"\n    CANCELLED = \"cancelled\"\n\n@dataclass\nclass OrderItem:\n    product_id: str\n    product_name: str\n    quantity: int\n    unit_price: float\n\n    @property\n    def total_price(self) -&gt; float:\n        return self.quantity * self.unit_price\n\n@dataclass\nclass Order:\n    id: Optional[str] = None\n    customer_id: str = \"\"\n    items: List[OrderItem] = None\n    status: OrderStatus = OrderStatus.PENDING\n    total_amount: float = 0.0\n\n    def __post_init__(self):\n        if self.items is None:\n            self.items = []\n\n    def add_item(self, item: OrderItem):\n        \"\"\"Domain behavior: Add item to order.\"\"\"\n        self.items.append(item)\n        self._calculate_total()\n\n    def remove_item(self, product_id: str):\n        \"\"\"Domain behavior: Remove item from order.\"\"\"\n        self.items = [item for item in self.items if item.product_id != product_id]\n        self._calculate_total()\n\n    def confirm(self):\n        \"\"\"Domain behavior: Confirm the order.\"\"\"\n        if not self.items:\n            raise ValueError(\"Cannot confirm empty order\")\n        if self.status != OrderStatus.PENDING:\n            raise ValueError(\"Order is not in pending status\")\n\n        self.status = OrderStatus.CONFIRMED\n\n    def cancel(self):\n        \"\"\"Domain behavior: Cancel the order.\"\"\"\n        if self.status in [OrderStatus.SHIPPED, OrderStatus.DELIVERED]:\n            raise ValueError(\"Cannot cancel shipped or delivered order\")\n\n        self.status = OrderStatus.CANCELLED\n\n    def _calculate_total(self):\n        \"\"\"Calculate total amount.\"\"\"\n        self.total_amount = sum(item.total_price for item in self.items)\n\n# ==================== PORTS (INTERFACES) ====================\n\n# Primary Ports (Driving Adapters)\nclass OrderManagementPort(ABC):\n    \"\"\"Primary port for order management operations.\"\"\"\n\n    @abstractmethod\n    async def create_order(self, customer_id: str) -&gt; Order:\n        pass\n\n    @abstractmethod\n    async def add_item_to_order(self, order_id: str, product_id: str, quantity: int) -&gt; Order:\n        pass\n\n    @abstractmethod\n    async def confirm_order(self, order_id: str) -&gt; Order:\n        pass\n\n    @abstractmethod\n    async def cancel_order(self, order_id: str) -&gt; Order:\n        pass\n\n    @abstractmethod\n    async def get_order(self, order_id: str) -&gt; Optional[Order]:\n        pass\n\n# Secondary Ports (Driven Adapters)\nclass OrderRepositoryPort(ABC):\n    \"\"\"Secondary port for order persistence.\"\"\"\n\n    @abstractmethod\n    async def save(self, order: Order) -&gt; Order:\n        pass\n\n    @abstractmethod\n    async def find_by_id(self, order_id: str) -&gt; Optional[Order]:\n        pass\n\n    @abstractmethod\n    async def find_by_customer(self, customer_id: str) -&gt; List[Order]:\n        pass\n\nclass ProductServicePort(ABC):\n    \"\"\"Secondary port for product information.\"\"\"\n\n    @abstractmethod\n    async def get_product(self, product_id: str) -&gt; Optional[Dict[str, Any]]:\n        pass\n\n    @abstractmethod\n    async def check_availability(self, product_id: str, quantity: int) -&gt; bool:\n        pass\n\nclass NotificationPort(ABC):\n    \"\"\"Secondary port for notifications.\"\"\"\n\n    @abstractmethod\n    async def send_order_confirmation(self, order: Order) -&gt; bool:\n        pass\n\n    @abstractmethod\n    async def send_cancellation_notice(self, order: Order) -&gt; bool:\n        pass\n\nclass PaymentPort(ABC):\n    \"\"\"Secondary port for payment processing.\"\"\"\n\n    @abstractmethod\n    async def process_payment(self, order: Order) -&gt; Dict[str, Any]:\n        pass\n\n    @abstractmethod\n    async def refund_payment(self, order: Order) -&gt; Dict[str, Any]:\n        pass\n\n# ==================== DOMAIN SERVICE (APPLICATION CORE) ====================\n\nclass OrderService(OrderManagementPort):\n    \"\"\"Core application service implementing the primary port.\"\"\"\n\n    @inject\n    def __init__(\n        self,\n        order_repository: OrderRepositoryPort,\n        product_service: ProductServicePort,\n        notification_service: NotificationPort,\n        payment_service: PaymentPort\n    ):\n        self.order_repository = order_repository\n        self.product_service = product_service\n        self.notification_service = notification_service\n        self.payment_service = payment_service\n\n    async def create_order(self, customer_id: str) -&gt; Order:\n        \"\"\"Create a new order.\"\"\"\n        order = Order(customer_id=customer_id)\n        return await self.order_repository.save(order)\n\n    async def add_item_to_order(self, order_id: str, product_id: str, quantity: int) -&gt; Order:\n        \"\"\"Add item to an existing order.\"\"\"\n        # Find the order\n        order = await self.order_repository.find_by_id(order_id)\n        if not order:\n            raise ValueError(\"Order not found\")\n\n        if order.status != OrderStatus.PENDING:\n            raise ValueError(\"Cannot modify non-pending order\")\n\n        # Check product availability\n        product = await self.product_service.get_product(product_id)\n        if not product:\n            raise ValueError(\"Product not found\")\n\n        available = await self.product_service.check_availability(product_id, quantity)\n        if not available:\n            raise ValueError(\"Product not available in requested quantity\")\n\n        # Add item to order\n        order_item = OrderItem(\n            product_id=product_id,\n            product_name=product[\"name\"],\n            quantity=quantity,\n            unit_price=product[\"price\"]\n        )\n\n        order.add_item(order_item)\n        return await self.order_repository.save(order)\n\n    async def confirm_order(self, order_id: str) -&gt; Order:\n        \"\"\"Confirm an order.\"\"\"\n        order = await self.order_repository.find_by_id(order_id)\n        if not order:\n            raise ValueError(\"Order not found\")\n\n        # Process payment\n        payment_result = await self.payment_service.process_payment(order)\n        if not payment_result.get(\"success\"):\n            raise ValueError(\"Payment processing failed\")\n\n        # Confirm the order\n        order.confirm()\n        saved_order = await self.order_repository.save(order)\n\n        # Send confirmation\n        await self.notification_service.send_order_confirmation(saved_order)\n\n        return saved_order\n\n    async def cancel_order(self, order_id: str) -&gt; Order:\n        \"\"\"Cancel an order.\"\"\"\n        order = await self.order_repository.find_by_id(order_id)\n        if not order:\n            raise ValueError(\"Order not found\")\n\n        # If confirmed, process refund\n        if order.status == OrderStatus.CONFIRMED:\n            refund_result = await self.payment_service.refund_payment(order)\n            if not refund_result.get(\"success\"):\n                raise ValueError(\"Refund processing failed\")\n\n        # Cancel the order\n        order.cancel()\n        saved_order = await self.order_repository.save(order)\n\n        # Send cancellation notice\n        await self.notification_service.send_cancellation_notice(saved_order)\n\n        return saved_order\n\n    async def get_order(self, order_id: str) -&gt; Optional[Order]:\n        \"\"\"Get order by ID.\"\"\"\n        return await self.order_repository.find_by_id(order_id)\n\n# ==================== ADAPTERS ====================\n\n# Primary Adapters (Driving)\nclass WebOrderController:\n    \"\"\"Web adapter for order operations.\"\"\"\n\n    @inject\n    def __init__(self, order_service: OrderManagementPort):\n        self.order_service = order_service\n\n    async def create_order_endpoint(self, request_data: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Handle POST /orders.\"\"\"\n        try:\n            order = await self.order_service.create_order(request_data[\"customer_id\"])\n            return {\n                \"status\": \"success\",\n                \"data\": {\n                    \"order_id\": order.id,\n                    \"customer_id\": order.customer_id,\n                    \"status\": order.status.value\n                }\n            }\n        except Exception as e:\n            return {\"status\": \"error\", \"message\": str(e)}\n\n    async def add_item_endpoint(self, order_id: str, request_data: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Handle POST /orders/{id}/items.\"\"\"\n        try:\n            order = await self.order_service.add_item_to_order(\n                order_id,\n                request_data[\"product_id\"],\n                request_data[\"quantity\"]\n            )\n            return {\n                \"status\": \"success\",\n                \"data\": {\n                    \"order_id\": order.id,\n                    \"total_amount\": order.total_amount,\n                    \"items_count\": len(order.items)\n                }\n            }\n        except Exception as e:\n            return {\"status\": \"error\", \"message\": str(e)}\n\nclass CLIOrderInterface:\n    \"\"\"Command-line adapter for order operations.\"\"\"\n\n    @inject\n    def __init__(self, order_service: OrderManagementPort):\n        self.order_service = order_service\n\n    async def create_order_command(self, customer_id: str):\n        \"\"\"CLI command to create order.\"\"\"\n        try:\n            order = await self.order_service.create_order(customer_id)\n            print(f\"Order created successfully: {order.id}\")\n        except Exception as e:\n            print(f\"Error creating order: {e}\")\n\n# Secondary Adapters (Driven)\nclass DatabaseOrderRepository(OrderRepositoryPort):\n    \"\"\"Database adapter for order persistence.\"\"\"\n\n    @inject\n    def __init__(self, database: Database):\n        self.database = database\n        self._orders: Dict[str, Order] = {}  # In-memory for demo\n        self._counter = 0\n\n    async def save(self, order: Order) -&gt; Order:\n        if not order.id:\n            self._counter += 1\n            order.id = f\"order_{self._counter}\"\n\n        self._orders[order.id] = order\n        return order\n\n    async def find_by_id(self, order_id: str) -&gt; Optional[Order]:\n        return self._orders.get(order_id)\n\n    async def find_by_customer(self, customer_id: str) -&gt; List[Order]:\n        return [order for order in self._orders.values() if order.customer_id == customer_id]\n\nclass ExternalProductService(ProductServicePort):\n    \"\"\"External service adapter for product information.\"\"\"\n\n    def __init__(self):\n        # Mock product data\n        self._products = {\n            \"prod1\": {\"name\": \"Laptop\", \"price\": 999.99, \"stock\": 10},\n            \"prod2\": {\"name\": \"Mouse\", \"price\": 29.99, \"stock\": 50},\n            \"prod3\": {\"name\": \"Keyboard\", \"price\": 79.99, \"stock\": 25}\n        }\n\n    async def get_product(self, product_id: str) -&gt; Optional[Dict[str, Any]]:\n        return self._products.get(product_id)\n\n    async def check_availability(self, product_id: str, quantity: int) -&gt; bool:\n        product = self._products.get(product_id)\n        return product and product[\"stock\"] &gt;= quantity\n\nclass EmailNotificationService(NotificationPort):\n    \"\"\"Email adapter for notifications.\"\"\"\n\n    async def send_order_confirmation(self, order: Order) -&gt; bool:\n        print(f\"Sending order confirmation email for order {order.id}\")\n        return True\n\n    async def send_cancellation_notice(self, order: Order) -&gt; bool:\n        print(f\"Sending cancellation notice for order {order.id}\")\n        return True\n\nclass StripePaymentService(PaymentPort):\n    \"\"\"Stripe adapter for payment processing.\"\"\"\n\n    async def process_payment(self, order: Order) -&gt; Dict[str, Any]:\n        # Mock payment processing\n        print(f\"Processing payment for order {order.id}, amount: ${order.total_amount}\")\n        return {\"success\": True, \"transaction_id\": f\"txn_{order.id}\"}\n\n    async def refund_payment(self, order: Order) -&gt; Dict[str, Any]:\n        # Mock refund processing\n        print(f\"Processing refund for order {order.id}, amount: ${order.total_amount}\")\n        return {\"success\": True, \"refund_id\": f\"refund_{order.id}\"}\n\n# ==================== CONFIGURATION ====================\n\nclass HexagonalArchitectureModule(Module):\n    \"\"\"Module configuration for hexagonal architecture.\"\"\"\n\n    def configure(self):\n        # Infrastructure\n        self.bind(Database, Database).singleton()\n\n        # Primary Ports (implemented by domain services)\n        self.bind(OrderManagementPort, OrderService).scoped()\n\n        # Secondary Ports (implemented by adapters)\n        self.bind(OrderRepositoryPort, DatabaseOrderRepository).singleton()\n        self.bind(ProductServicePort, ExternalProductService).singleton()\n        self.bind(NotificationPort, EmailNotificationService).singleton()\n        self.bind(PaymentPort, StripePaymentService).singleton()\n\n        # Primary Adapters\n        self.bind(WebOrderController, WebOrderController).scoped()\n        self.bind(CLIOrderInterface, CLIOrderInterface).scoped()\n\n# Demo Application\nclass HexagonalApplication:\n    @inject\n    def __init__(\n        self,\n        web_controller: WebOrderController,\n        cli_interface: CLIOrderInterface\n    ):\n        self.web_controller = web_controller\n        self.cli_interface = cli_interface\n\n    async def run_demo(self):\n        \"\"\"Demonstrate hexagonal architecture.\"\"\"\n        print(\"=== Hexagonal Architecture Demo ===\\n\")\n\n        # Web interface demo\n        print(\"1. Creating order via Web API:\")\n        web_result = await self.web_controller.create_order_endpoint({\n            \"customer_id\": \"customer123\"\n        })\n        print(f\"Result: {web_result}\\n\")\n\n        if web_result[\"status\"] == \"success\":\n            order_id = web_result[\"data\"][\"order_id\"]\n\n            # Add items via Web API\n            print(\"2. Adding items via Web API:\")\n            add_result = await self.web_controller.add_item_endpoint(order_id, {\n                \"product_id\": \"prod1\",\n                \"quantity\": 1\n            })\n            print(f\"Result: {add_result}\\n\")\n\n        # CLI interface demo\n        print(\"3. Creating order via CLI:\")\n        await self.cli_interface.create_order_command(\"customer456\")\n\nasync def hexagonal_architecture_example():\n    container = InjectQ()\n    container.install(HexagonalArchitectureModule())\n\n    app = container.get(HexagonalApplication)\n    await app.run_demo()\n</code></pre>"},{"location":"best-practices/architectural-patterns/#event-driven-architecture","title":"\ud83d\ude8c Event-Driven Architecture","text":""},{"location":"best-practices/architectural-patterns/#cqrs-with-event-sourcing","title":"CQRS with Event Sourcing","text":"<pre><code># event_driven_architecture.py\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Any, Optional, Type\nfrom datetime import datetime\nfrom enum import Enum\nimport json\nimport uuid\nfrom injectq import InjectQ, inject, Module\n\n# ==================== EVENTS ====================\n\n@dataclass\nclass DomainEvent:\n    event_id: str = field(default_factory=lambda: str(uuid.uuid4()))\n    event_type: str = \"\"\n    aggregate_id: str = \"\"\n    aggregate_version: int = 0\n    event_data: Dict[str, Any] = field(default_factory=dict)\n    timestamp: datetime = field(default_factory=datetime.utcnow)\n    metadata: Dict[str, Any] = field(default_factory=dict)\n\nclass AccountEvents:\n    \"\"\"Domain events for account aggregate.\"\"\"\n\n    @dataclass\n    class AccountCreated(DomainEvent):\n        event_type: str = \"account_created\"\n\n    @dataclass\n    class MoneyDeposited(DomainEvent):\n        event_type: str = \"money_deposited\"\n\n    @dataclass\n    class MoneyWithdrawn(DomainEvent):\n        event_type: str = \"money_withdrawn\"\n\n    @dataclass\n    class AccountClosed(DomainEvent):\n        event_type: str = \"account_closed\"\n\n# ==================== AGGREGATES ====================\n\nclass Account:\n    \"\"\"Account aggregate root with event sourcing.\"\"\"\n\n    def __init__(self, account_id: str):\n        self.id = account_id\n        self.balance = 0.0\n        self.is_closed = False\n        self.version = 0\n        self._uncommitted_events: List[DomainEvent] = []\n\n    def create_account(self, initial_balance: float = 0.0):\n        \"\"\"Create account business operation.\"\"\"\n        if self.version &gt; 0:\n            raise ValueError(\"Account already exists\")\n\n        event = AccountEvents.AccountCreated(\n            aggregate_id=self.id,\n            aggregate_version=self.version + 1,\n            event_data={\"initial_balance\": initial_balance}\n        )\n\n        self._apply_event(event)\n        self._uncommitted_events.append(event)\n\n    def deposit(self, amount: float):\n        \"\"\"Deposit money business operation.\"\"\"\n        if amount &lt;= 0:\n            raise ValueError(\"Deposit amount must be positive\")\n        if self.is_closed:\n            raise ValueError(\"Cannot deposit to closed account\")\n\n        event = AccountEvents.MoneyDeposited(\n            aggregate_id=self.id,\n            aggregate_version=self.version + 1,\n            event_data={\"amount\": amount, \"new_balance\": self.balance + amount}\n        )\n\n        self._apply_event(event)\n        self._uncommitted_events.append(event)\n\n    def withdraw(self, amount: float):\n        \"\"\"Withdraw money business operation.\"\"\"\n        if amount &lt;= 0:\n            raise ValueError(\"Withdrawal amount must be positive\")\n        if self.is_closed:\n            raise ValueError(\"Cannot withdraw from closed account\")\n        if self.balance &lt; amount:\n            raise ValueError(\"Insufficient funds\")\n\n        event = AccountEvents.MoneyWithdrawn(\n            aggregate_id=self.id,\n            aggregate_version=self.version + 1,\n            event_data={\"amount\": amount, \"new_balance\": self.balance - amount}\n        )\n\n        self._apply_event(event)\n        self._uncommitted_events.append(event)\n\n    def close_account(self):\n        \"\"\"Close account business operation.\"\"\"\n        if self.is_closed:\n            raise ValueError(\"Account already closed\")\n        if self.balance &gt; 0:\n            raise ValueError(\"Cannot close account with positive balance\")\n\n        event = AccountEvents.AccountClosed(\n            aggregate_id=self.id,\n            aggregate_version=self.version + 1,\n            event_data={}\n        )\n\n        self._apply_event(event)\n        self._uncommitted_events.append(event)\n\n    def _apply_event(self, event: DomainEvent):\n        \"\"\"Apply event to aggregate state.\"\"\"\n        if isinstance(event, AccountEvents.AccountCreated):\n            self.balance = event.event_data[\"initial_balance\"]\n        elif isinstance(event, AccountEvents.MoneyDeposited):\n            self.balance = event.event_data[\"new_balance\"]\n        elif isinstance(event, AccountEvents.MoneyWithdrawn):\n            self.balance = event.event_data[\"new_balance\"]\n        elif isinstance(event, AccountEvents.AccountClosed):\n            self.is_closed = True\n\n        self.version = event.aggregate_version\n\n    def get_uncommitted_events(self) -&gt; List[DomainEvent]:\n        \"\"\"Get uncommitted events for persistence.\"\"\"\n        return self._uncommitted_events.copy()\n\n    def mark_events_as_committed(self):\n        \"\"\"Mark events as committed after persistence.\"\"\"\n        self._uncommitted_events.clear()\n\n    @classmethod\n    def from_events(cls, account_id: str, events: List[DomainEvent]) -&gt; 'Account':\n        \"\"\"Reconstitute aggregate from events.\"\"\"\n        account = cls(account_id)\n        for event in events:\n            account._apply_event(event)\n        return account\n\n# ==================== COMMANDS ====================\n\n@dataclass\nclass Command:\n    command_id: str = field(default_factory=lambda: str(uuid.uuid4()))\n    aggregate_id: str = \"\"\n    timestamp: datetime = field(default_factory=datetime.utcnow)\n\n@dataclass\nclass CreateAccountCommand(Command):\n    initial_balance: float = 0.0\n\n@dataclass\nclass DepositMoneyCommand(Command):\n    amount: float = 0.0\n\n@dataclass\nclass WithdrawMoneyCommand(Command):\n    amount: float = 0.0\n\n@dataclass\nclass CloseAccountCommand(Command):\n    pass\n\n# ==================== QUERIES ====================\n\n@dataclass\nclass Query:\n    query_id: str = field(default_factory=lambda: str(uuid.uuid4()))\n    timestamp: datetime = field(default_factory=datetime.utcnow)\n\n@dataclass\nclass GetAccountBalanceQuery(Query):\n    account_id: str = \"\"\n\n@dataclass\nclass GetAccountHistoryQuery(Query):\n    account_id: str = \"\"\n\n# ==================== CQRS INTERFACES ====================\n\nclass ICommandHandler(ABC):\n    @abstractmethod\n    async def handle(self, command: Command):\n        pass\n\nclass IQueryHandler(ABC):\n    @abstractmethod\n    async def handle(self, query: Query) -&gt; Any:\n        pass\n\nclass IEventStore(ABC):\n    @abstractmethod\n    async def save_events(self, aggregate_id: str, events: List[DomainEvent], expected_version: int):\n        pass\n\n    @abstractmethod\n    async def get_events(self, aggregate_id: str) -&gt; List[DomainEvent]:\n        pass\n\nclass IEventBus(ABC):\n    @abstractmethod\n    async def publish(self, events: List[DomainEvent]):\n        pass\n\nclass IReadModelUpdater(ABC):\n    @abstractmethod\n    async def update(self, event: DomainEvent):\n        pass\n\n# ==================== COMMAND HANDLERS ====================\n\nclass AccountCommandHandler(ICommandHandler):\n    @inject\n    def __init__(self, event_store: IEventStore, event_bus: IEventBus):\n        self.event_store = event_store\n        self.event_bus = event_bus\n\n    async def handle(self, command: Command):\n        if isinstance(command, CreateAccountCommand):\n            await self._handle_create_account(command)\n        elif isinstance(command, DepositMoneyCommand):\n            await self._handle_deposit_money(command)\n        elif isinstance(command, WithdrawMoneyCommand):\n            await self._handle_withdraw_money(command)\n        elif isinstance(command, CloseAccountCommand):\n            await self._handle_close_account(command)\n        else:\n            raise ValueError(f\"Unknown command type: {type(command)}\")\n\n    async def _handle_create_account(self, command: CreateAccountCommand):\n        account = Account(command.aggregate_id)\n        account.create_account(command.initial_balance)\n\n        await self._save_and_publish(account)\n\n    async def _handle_deposit_money(self, command: DepositMoneyCommand):\n        account = await self._load_account(command.aggregate_id)\n        account.deposit(command.amount)\n\n        await self._save_and_publish(account)\n\n    async def _handle_withdraw_money(self, command: WithdrawMoneyCommand):\n        account = await self._load_account(command.aggregate_id)\n        account.withdraw(command.amount)\n\n        await self._save_and_publish(account)\n\n    async def _handle_close_account(self, command: CloseAccountCommand):\n        account = await self._load_account(command.aggregate_id)\n        account.close_account()\n\n        await self._save_and_publish(account)\n\n    async def _load_account(self, account_id: str) -&gt; Account:\n        events = await self.event_store.get_events(account_id)\n        if not events:\n            raise ValueError(f\"Account {account_id} not found\")\n        return Account.from_events(account_id, events)\n\n    async def _save_and_publish(self, account: Account):\n        events = account.get_uncommitted_events()\n        if events:\n            await self.event_store.save_events(account.id, events, account.version - len(events))\n            await self.event_bus.publish(events)\n            account.mark_events_as_committed()\n\n# ==================== QUERY HANDLERS ====================\n\n@dataclass\nclass AccountReadModel:\n    account_id: str\n    balance: float\n    is_closed: bool\n    last_updated: datetime\n\nclass AccountQueryHandler(IQueryHandler):\n    @inject\n    def __init__(self, read_model_store: Dict[str, AccountReadModel]):\n        self.read_model_store = read_model_store\n\n    async def handle(self, query: Query) -&gt; Any:\n        if isinstance(query, GetAccountBalanceQuery):\n            return await self._handle_get_balance(query)\n        elif isinstance(query, GetAccountHistoryQuery):\n            return await self._handle_get_history(query)\n        else:\n            raise ValueError(f\"Unknown query type: {type(query)}\")\n\n    async def _handle_get_balance(self, query: GetAccountBalanceQuery) -&gt; Dict[str, Any]:\n        read_model = self.read_model_store.get(query.account_id)\n        if not read_model:\n            return {\"error\": \"Account not found\"}\n\n        return {\n            \"account_id\": read_model.account_id,\n            \"balance\": read_model.balance,\n            \"is_closed\": read_model.is_closed\n        }\n\n    async def _handle_get_history(self, query: GetAccountHistoryQuery) -&gt; Dict[str, Any]:\n        # In a real implementation, this would query a separate history store\n        return {\n            \"account_id\": query.account_id,\n            \"transactions\": []  # Placeholder\n        }\n\n# ==================== READ MODEL UPDATER ====================\n\nclass AccountReadModelUpdater(IReadModelUpdater):\n    @inject\n    def __init__(self, read_model_store: Dict[str, AccountReadModel]):\n        self.read_model_store = read_model_store\n\n    async def update(self, event: DomainEvent):\n        if isinstance(event, AccountEvents.AccountCreated):\n            await self._handle_account_created(event)\n        elif isinstance(event, (AccountEvents.MoneyDeposited, AccountEvents.MoneyWithdrawn)):\n            await self._handle_balance_changed(event)\n        elif isinstance(event, AccountEvents.AccountClosed):\n            await self._handle_account_closed(event)\n\n    async def _handle_account_created(self, event: AccountEvents.AccountCreated):\n        read_model = AccountReadModel(\n            account_id=event.aggregate_id,\n            balance=event.event_data[\"initial_balance\"],\n            is_closed=False,\n            last_updated=event.timestamp\n        )\n        self.read_model_store[event.aggregate_id] = read_model\n\n    async def _handle_balance_changed(self, event: DomainEvent):\n        read_model = self.read_model_store.get(event.aggregate_id)\n        if read_model:\n            read_model.balance = event.event_data[\"new_balance\"]\n            read_model.last_updated = event.timestamp\n\n    async def _handle_account_closed(self, event: AccountEvents.AccountClosed):\n        read_model = self.read_model_store.get(event.aggregate_id)\n        if read_model:\n            read_model.is_closed = True\n            read_model.last_updated = event.timestamp\n\n# ==================== INFRASTRUCTURE ====================\n\nclass InMemoryEventStore(IEventStore):\n    def __init__(self):\n        self._events: Dict[str, List[DomainEvent]] = {}\n\n    async def save_events(self, aggregate_id: str, events: List[DomainEvent], expected_version: int):\n        current_events = self._events.get(aggregate_id, [])\n\n        if len(current_events) != expected_version:\n            raise ValueError(\"Concurrency conflict\")\n\n        if aggregate_id not in self._events:\n            self._events[aggregate_id] = []\n\n        self._events[aggregate_id].extend(events)\n\n    async def get_events(self, aggregate_id: str) -&gt; List[DomainEvent]:\n        return self._events.get(aggregate_id, [])\n\nclass InMemoryEventBus(IEventBus):\n    @inject\n    def __init__(self, read_model_updater: IReadModelUpdater):\n        self.read_model_updater = read_model_updater\n\n    async def publish(self, events: List[DomainEvent]):\n        for event in events:\n            await self.read_model_updater.update(event)\n            print(f\"Published event: {event.event_type} for aggregate {event.aggregate_id}\")\n\n# ==================== APPLICATION SERVICE ====================\n\nclass BankingApplicationService:\n    @inject\n    def __init__(\n        self,\n        command_handler: AccountCommandHandler,\n        query_handler: AccountQueryHandler\n    ):\n        self.command_handler = command_handler\n        self.query_handler = query_handler\n\n    async def create_account(self, account_id: str, initial_balance: float = 0.0):\n        command = CreateAccountCommand(\n            aggregate_id=account_id,\n            initial_balance=initial_balance\n        )\n        await self.command_handler.handle(command)\n\n    async def deposit_money(self, account_id: str, amount: float):\n        command = DepositMoneyCommand(\n            aggregate_id=account_id,\n            amount=amount\n        )\n        await self.command_handler.handle(command)\n\n    async def withdraw_money(self, account_id: str, amount: float):\n        command = WithdrawMoneyCommand(\n            aggregate_id=account_id,\n            amount=amount\n        )\n        await self.command_handler.handle(command)\n\n    async def get_account_balance(self, account_id: str) -&gt; Dict[str, Any]:\n        query = GetAccountBalanceQuery(account_id=account_id)\n        return await self.query_handler.handle(query)\n\n# ==================== CONFIGURATION ====================\n\nclass EventDrivenModule(Module):\n    def configure(self):\n        # Shared read model store\n        read_model_store: Dict[str, AccountReadModel] = {}\n        self.bind(Dict[str, AccountReadModel], read_model_store).singleton()\n\n        # Infrastructure\n        self.bind(IEventStore, InMemoryEventStore).singleton()\n        self.bind(IReadModelUpdater, AccountReadModelUpdater).singleton()\n        self.bind(IEventBus, InMemoryEventBus).singleton()\n\n        # CQRS handlers\n        self.bind(AccountCommandHandler, AccountCommandHandler).singleton()\n        self.bind(AccountQueryHandler, AccountQueryHandler).singleton()\n\n        # Application service\n        self.bind(BankingApplicationService, BankingApplicationService).singleton()\n\n# Demo Application\nclass EventDrivenApplication:\n    @inject\n    def __init__(self, banking_service: BankingApplicationService):\n        self.banking_service = banking_service\n\n    async def run_demo(self):\n        \"\"\"Demonstrate event-driven architecture.\"\"\"\n        print(\"=== Event-Driven Architecture (CQRS + Event Sourcing) Demo ===\\n\")\n\n        account_id = \"account123\"\n\n        # Create account\n        print(\"1. Creating account...\")\n        await self.banking_service.create_account(account_id, 100.0)\n\n        # Check balance\n        print(\"2. Checking initial balance...\")\n        balance = await self.banking_service.get_account_balance(account_id)\n        print(f\"Balance: {balance}\\n\")\n\n        # Deposit money\n        print(\"3. Depositing $50...\")\n        await self.banking_service.deposit_money(account_id, 50.0)\n\n        # Check balance\n        balance = await self.banking_service.get_account_balance(account_id)\n        print(f\"Balance after deposit: {balance}\\n\")\n\n        # Withdraw money\n        print(\"4. Withdrawing $30...\")\n        await self.banking_service.withdraw_money(account_id, 30.0)\n\n        # Check final balance\n        balance = await self.banking_service.get_account_balance(account_id)\n        print(f\"Final balance: {balance}\")\n\nasync def event_driven_architecture_example():\n    container = InjectQ()\n    container.install(EventDrivenModule())\n\n    app = container.get(EventDrivenApplication)\n    await app.run_demo()\n\n# Usage Examples\nasync def main():\n    print(\"Running architectural pattern examples...\\n\")\n\n    await layered_architecture_example()\n    print(\"\\n\" + \"=\"*60 + \"\\n\")\n\n    await hexagonal_architecture_example()\n    print(\"\\n\" + \"=\"*60 + \"\\n\")\n\n    await event_driven_architecture_example()\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())\n</code></pre> <p>This architectural design patterns guide demonstrates:</p> <ol> <li>Layered Architecture: Traditional three-layer pattern with proper separation of concerns</li> <li>Hexagonal Architecture: Ports and adapters pattern with domain isolation</li> <li>Event-Driven Architecture: CQRS with event sourcing for scalable systems</li> </ol> <p>Key architectural principles shown: - Dependency inversion and interface segregation - Separation of business logic from infrastructure - Clean boundaries between layers/components - Testable and maintainable design - Scalable patterns for complex applications</p> <p>Each pattern includes complete implementations with proper dependency injection configuration using InjectQ, demonstrating how to build robust, maintainable applications with clear architectural boundaries.</p> <p>Ready to continue with the final sections of the best practices documentation?</p>"},{"location":"best-practices/performance/","title":"Performance Best Practices","text":"<p>This guide provides comprehensive recommendations for optimizing performance when using InjectQ in production applications.</p>"},{"location":"best-practices/performance/#container-configuration-optimization","title":"\ud83d\ude80 Container Configuration Optimization","text":""},{"location":"best-practices/performance/#use-appropriate-lifecycles","title":"Use Appropriate Lifecycles","text":"<p>Choosing the right lifecycle for your dependencies is crucial for performance:</p> <pre><code>from injectq import InjectQ, Module, inject\n\nclass PerformanceOptimizedModule(Module):\n    def configure(self):\n        # Singleton for expensive-to-create objects\n        self.bind(DatabaseConnection, DatabaseConnection).singleton()\n        self.bind(CacheService, RedisCache).singleton()\n        self.bind(LoggingService, LoggingService).singleton()\n\n        # Scoped for stateful services within request boundaries\n        self.bind(UserService, UserService).scoped()\n        self.bind(OrderService, OrderService).scoped()\n\n        # Transient only when necessary (stateless, lightweight)\n        self.bind(ValidationService, ValidationService).transient()\n        self.bind(CalculationEngine, CalculationEngine).transient()\n\n# \u274c Bad: Everything as transient\nclass IneffientModule(Module):\n    def configure(self):\n        self.bind(DatabaseConnection, DatabaseConnection).transient()  # Expensive!\n        self.bind(CacheService, RedisCache).transient()  # Unnecessary overhead!\n        self.bind(UserService, UserService).transient()\n\n# \u2705 Good: Appropriate lifecycles\nclass OptimizedModule(Module):\n    def configure(self):\n        # Expensive resources as singletons\n        self.bind(DatabaseConnection, DatabaseConnection).singleton()\n        self.bind(CacheService, RedisCache).singleton()\n\n        # Request-scoped services\n        self.bind(UserService, UserService).scoped()\n</code></pre>"},{"location":"best-practices/performance/#minimize-container-lookups","title":"Minimize Container Lookups","text":"<p>Cache frequently accessed dependencies instead of repeated container lookups:</p> <pre><code># \u274c Bad: Repeated container lookups\nclass IneffientService:\n    @inject\n    def __init__(self, container: InjectQ):\n        self.container = container\n\n    def process_data(self, data):\n        # Expensive lookup every time\n        validator = self.container.get(DataValidator)\n        processor = self.container.get(DataProcessor)\n        logger = self.container.get(Logger)\n\n        # Process data...\n\n# \u2705 Good: Inject dependencies directly\nclass EfficientService:\n    @inject\n    def __init__(\n        self,\n        validator: DataValidator,\n        processor: DataProcessor,\n        logger: Logger\n    ):\n        self.validator = validator\n        self.processor = processor\n        self.logger = logger\n\n    def process_data(self, data):\n        # Direct access, no container lookups\n        self.validator.validate(data)\n        result = self.processor.process(data)\n        self.logger.log(f\"Processed {len(data)} items\")\n        return result\n\n# \u2705 Good: Cache for dynamic lookups\nclass CachedDynamicService:\n    @inject\n    def __init__(self, container: InjectQ):\n        self.container = container\n        self._handler_cache = {}\n\n    def get_handler(self, handler_type: str):\n        if handler_type not in self._handler_cache:\n            self._handler_cache[handler_type] = self.container.get(\n                IHandler, name=handler_type\n            )\n        return self._handler_cache[handler_type]\n</code></pre>"},{"location":"best-practices/performance/#optimize-module-registration","title":"Optimize Module Registration","text":"<pre><code># \u2705 Efficient module registration\nclass ProductionModule(Module):\n    def configure(self):\n        # Group related bindings\n        self._configure_data_layer()\n        self._configure_services()\n        self._configure_external_apis()\n\n    def _configure_data_layer(self):\n        \"\"\"Configure data access layer efficiently.\"\"\"\n        # Connection pool as singleton\n        self.bind(ConnectionPool, self._create_connection_pool()).singleton()\n\n        # Repository base class with shared dependencies\n        self.bind(IRepository, BaseRepository, name=\"base\").singleton()\n\n        # Specific repositories inheriting base\n        self.bind(UserRepository, UserRepository).scoped()\n        self.bind(OrderRepository, OrderRepository).scoped()\n\n    def _create_connection_pool(self) -&gt; ConnectionPool:\n        \"\"\"Factory method for expensive resource creation.\"\"\"\n        return ConnectionPool(\n            host=\"db.example.com\",\n            port=5432,\n            min_connections=5,\n            max_connections=20\n        )\n</code></pre>"},{"location":"best-practices/performance/#runtime-performance-optimization","title":"\ud83c\udfc3\u200d\u2642\ufe0f Runtime Performance Optimization","text":""},{"location":"best-practices/performance/#asyncawait-best-practices","title":"Async/Await Best Practices","text":"<pre><code>import asyncio\nfrom injectq import InjectQ, inject\nfrom typing import List\n\nclass AsyncOptimizedService:\n    @inject\n    def __init__(\n        self,\n        database: AsyncDatabase,\n        cache: AsyncCache,\n        api_client: AsyncAPIClient\n    ):\n        self.database = database\n        self.cache = cache\n        self.api_client = api_client\n\n    async def process_user_data(self, user_ids: List[str]) -&gt; List[dict]:\n        \"\"\"Optimized async processing with concurrency.\"\"\"\n\n        # \u2705 Good: Concurrent cache lookups\n        cache_tasks = [\n            self.cache.get(f\"user:{user_id}\")\n            for user_id in user_ids\n        ]\n        cache_results = await asyncio.gather(*cache_tasks, return_exceptions=True)\n\n        # Identify cache misses\n        missing_users = []\n        cached_users = {}\n\n        for user_id, result in zip(user_ids, cache_results):\n            if isinstance(result, Exception) or result is None:\n                missing_users.append(user_id)\n            else:\n                cached_users[user_id] = result\n\n        # \u2705 Good: Batch database query for missing users\n        if missing_users:\n            db_users = await self.database.get_users_batch(missing_users)\n\n            # \u2705 Good: Concurrent cache updates\n            cache_updates = [\n                self.cache.set(f\"user:{user['id']}\", user, ttl=300)\n                for user in db_users\n            ]\n            await asyncio.gather(*cache_updates, return_exceptions=True)\n\n            # Update cached users\n            for user in db_users:\n                cached_users[user['id']] = user\n\n        return [cached_users[user_id] for user_id in user_ids if user_id in cached_users]\n\n# \u274c Bad: Sequential processing\nclass SequentialService:\n    @inject\n    def __init__(self, database: AsyncDatabase, cache: AsyncCache):\n        self.database = database\n        self.cache = cache\n\n    async def process_user_data(self, user_ids: List[str]) -&gt; List[dict]:\n        users = []\n        for user_id in user_ids:  # Sequential - slow!\n            user = await self.cache.get(f\"user:{user_id}\")\n            if not user:\n                user = await self.database.get_user(user_id)  # N+1 queries!\n                await self.cache.set(f\"user:{user_id}\", user)\n            users.append(user)\n        return users\n</code></pre>"},{"location":"best-practices/performance/#memory-management","title":"Memory Management","text":"<pre><code>import weakref\nfrom typing import Dict, Any\nfrom injectq import inject, Module\n\nclass MemoryEfficientService:\n    \"\"\"Service that manages memory efficiently.\"\"\"\n\n    @inject\n    def __init__(self, cache_service: CacheService):\n        self.cache = cache_service\n        self._weak_refs: Dict[str, weakref.ref] = {}\n        self._memory_threshold = 100 * 1024 * 1024  # 100MB\n\n    def get_large_object(self, key: str) -&gt; Any:\n        \"\"\"Get large object with memory management.\"\"\"\n        # Check weak reference first\n        if key in self._weak_refs:\n            obj = self._weak_refs[key]()\n            if obj is not None:\n                return obj\n            else:\n                # Object was garbage collected\n                del self._weak_refs[key]\n\n        # Load from cache or create\n        obj = self.cache.get(key)\n        if obj is None:\n            obj = self._create_large_object(key)\n            self.cache.set(key, obj)\n\n        # Store weak reference\n        self._weak_refs[key] = weakref.ref(obj)\n\n        return obj\n\n    def cleanup_memory(self):\n        \"\"\"Periodic memory cleanup.\"\"\"\n        import gc\n        import psutil\n        import os\n\n        # Check memory usage\n        process = psutil.Process(os.getpid())\n        memory_usage = process.memory_info().rss\n\n        if memory_usage &gt; self._memory_threshold:\n            # Force garbage collection\n            gc.collect()\n\n            # Clear weak references to dead objects\n            dead_refs = [\n                key for key, ref in self._weak_refs.items()\n                if ref() is None\n            ]\n            for key in dead_refs:\n                del self._weak_refs[key]\n\n# Module with memory optimization\nclass MemoryOptimizedModule(Module):\n    def configure(self):\n        # Use scoped lifecycle for memory-intensive services\n        self.bind(DataProcessingService, DataProcessingService).scoped()\n\n        # Singleton for lightweight services\n        self.bind(MemoryEfficientService, MemoryEfficientService).singleton()\n</code></pre>"},{"location":"best-practices/performance/#monitoring-and-profiling","title":"\ud83d\udcca Monitoring and Profiling","text":""},{"location":"best-practices/performance/#performance-monitoring","title":"Performance Monitoring","text":"<pre><code>import time\nimport functools\nfrom dataclasses import dataclass\nfrom typing import Dict, List\nfrom injectq import inject\n\n@dataclass\nclass PerformanceMetric:\n    method_name: str\n    execution_time: float\n    memory_usage: int\n    call_count: int\n\nclass PerformanceMonitor:\n    \"\"\"Monitor service performance.\"\"\"\n\n    def __init__(self):\n        self.metrics: Dict[str, List[float]] = {}\n        self.call_counts: Dict[str, int] = {}\n\n    def record_execution(self, method_name: str, execution_time: float):\n        \"\"\"Record method execution time.\"\"\"\n        if method_name not in self.metrics:\n            self.metrics[method_name] = []\n            self.call_counts[method_name] = 0\n\n        self.metrics[method_name].append(execution_time)\n        self.call_counts[method_name] += 1\n\n    def get_performance_report(self) -&gt; List[PerformanceMetric]:\n        \"\"\"Generate performance report.\"\"\"\n        report = []\n\n        for method_name, times in self.metrics.items():\n            avg_time = sum(times) / len(times)\n            call_count = self.call_counts[method_name]\n\n            report.append(PerformanceMetric(\n                method_name=method_name,\n                execution_time=avg_time,\n                memory_usage=0,  # Would need psutil for actual memory tracking\n                call_count=call_count\n            ))\n\n        return sorted(report, key=lambda x: x.execution_time, reverse=True)\n\ndef monitor_performance(monitor: PerformanceMonitor):\n    \"\"\"Decorator to monitor method performance.\"\"\"\n    def decorator(func):\n        @functools.wraps(func)\n        async def async_wrapper(*args, **kwargs):\n            start_time = time.perf_counter()\n            try:\n                result = await func(*args, **kwargs)\n                return result\n            finally:\n                end_time = time.perf_counter()\n                execution_time = end_time - start_time\n                monitor.record_execution(\n                    f\"{func.__module__}.{func.__qualname__}\",\n                    execution_time\n                )\n\n        @functools.wraps(func)\n        def sync_wrapper(*args, **kwargs):\n            start_time = time.perf_counter()\n            try:\n                result = func(*args, **kwargs)\n                return result\n            finally:\n                end_time = time.perf_counter()\n                execution_time = end_time - start_time\n                monitor.record_execution(\n                    f\"{func.__module__}.{func.__qualname__}\",\n                    execution_time\n                )\n\n        return async_wrapper if asyncio.iscoroutinefunction(func) else sync_wrapper\n\n    return decorator\n\nclass MonitoredService:\n    @inject\n    def __init__(self, database: Database, monitor: PerformanceMonitor):\n        self.database = database\n        self.monitor = monitor\n\n    @monitor_performance\n    async def process_data(self, data: List[dict]) -&gt; List[dict]:\n        \"\"\"Monitored data processing method.\"\"\"\n        results = []\n        for item in data:\n            processed = await self._process_item(item)\n            results.append(processed)\n        return results\n\n    async def _process_item(self, item: dict) -&gt; dict:\n        # Processing logic here\n        await asyncio.sleep(0.01)  # Simulate work\n        return {\"processed\": True, **item}\n</code></pre>"},{"location":"best-practices/performance/#database-connection-optimization","title":"Database Connection Optimization","text":"<pre><code>import asyncpg\nfrom contextlib import asynccontextmanager\nfrom injectq import inject, Module\n\nclass OptimizedDatabaseService:\n    \"\"\"Database service with connection pooling and optimization.\"\"\"\n\n    @inject\n    def __init__(self, connection_pool: asyncpg.Pool):\n        self.pool = connection_pool\n\n    @asynccontextmanager\n    async def get_connection(self):\n        \"\"\"Context manager for database connections.\"\"\"\n        async with self.pool.acquire() as connection:\n            yield connection\n\n    async def execute_batch_query(self, queries: List[str]) -&gt; List[Any]:\n        \"\"\"Execute multiple queries efficiently.\"\"\"\n        async with self.get_connection() as conn:\n            async with conn.transaction():\n                results = []\n                for query in queries:\n                    result = await conn.fetch(query)\n                    results.append(result)\n                return results\n\n    async def bulk_insert(self, table: str, data: List[Dict]) -&gt; int:\n        \"\"\"Optimized bulk insert operation.\"\"\"\n        if not data:\n            return 0\n\n        # Prepare column names and placeholders\n        columns = list(data[0].keys())\n        column_names = \", \".join(columns)\n        placeholders = \", \".join(f\"${i+1}\" for i in range(len(columns)))\n\n        query = f\"INSERT INTO {table} ({column_names}) VALUES ({placeholders})\"\n\n        async with self.get_connection() as conn:\n            # Use executemany for bulk operations\n            values = [[row[col] for col in columns] for row in data]\n            await conn.executemany(query, values)\n            return len(data)\n\nclass DatabaseModule(Module):\n    def configure(self):\n        # Connection pool configuration\n        self.bind(asyncpg.Pool, self._create_pool()).singleton()\n        self.bind(OptimizedDatabaseService, OptimizedDatabaseService).singleton()\n\n    async def _create_pool(self) -&gt; asyncpg.Pool:\n        \"\"\"Create optimized connection pool.\"\"\"\n        return await asyncpg.create_pool(\n            \"postgresql://user:pass@localhost/db\",\n            min_size=5,\n            max_size=20,\n            command_timeout=60,\n            server_settings={\n                'application_name': 'injectq_app',\n                'jit': 'off'  # Disable JIT for small queries\n            }\n        )\n</code></pre>"},{"location":"best-practices/performance/#caching-strategies","title":"\ud83c\udfaf Caching Strategies","text":""},{"location":"best-practices/performance/#multi-level-caching","title":"Multi-Level Caching","text":"<pre><code>from abc import ABC, abstractmethod\nfrom typing import Optional, Any\nimport asyncio\nimport json\nimport hashlib\n\nclass ICacheLayer(ABC):\n    @abstractmethod\n    async def get(self, key: str) -&gt; Optional[Any]:\n        pass\n\n    @abstractmethod\n    async def set(self, key: str, value: Any, ttl: int = 300) -&gt; bool:\n        pass\n\n    @abstractmethod\n    async def delete(self, key: str) -&gt; bool:\n        pass\n\nclass MemoryCache(ICacheLayer):\n    \"\"\"In-memory cache layer (L1).\"\"\"\n\n    def __init__(self, max_size: int = 1000):\n        self._cache: Dict[str, Any] = {}\n        self._max_size = max_size\n\n    async def get(self, key: str) -&gt; Optional[Any]:\n        return self._cache.get(key)\n\n    async def set(self, key: str, value: Any, ttl: int = 300) -&gt; bool:\n        if len(self._cache) &gt;= self._max_size:\n            # Simple LRU eviction (remove first item)\n            oldest_key = next(iter(self._cache))\n            del self._cache[oldest_key]\n\n        self._cache[key] = value\n        return True\n\n    async def delete(self, key: str) -&gt; bool:\n        self._cache.pop(key, None)\n        return True\n\nclass RedisCache(ICacheLayer):\n    \"\"\"Redis cache layer (L2).\"\"\"\n\n    @inject\n    def __init__(self, redis_client: RedisClient):\n        self.redis = redis_client\n\n    async def get(self, key: str) -&gt; Optional[Any]:\n        data = await self.redis.get(key)\n        if data:\n            return json.loads(data)\n        return None\n\n    async def set(self, key: str, value: Any, ttl: int = 300) -&gt; bool:\n        data = json.dumps(value, default=str)\n        return await self.redis.setex(key, ttl, data)\n\n    async def delete(self, key: str) -&gt; bool:\n        return await self.redis.delete(key) &gt; 0\n\nclass MultiLevelCache:\n    \"\"\"Multi-level caching system.\"\"\"\n\n    @inject\n    def __init__(self, l1_cache: MemoryCache, l2_cache: RedisCache):\n        self.l1 = l1_cache\n        self.l2 = l2_cache\n\n    async def get(self, key: str) -&gt; Optional[Any]:\n        # Try L1 cache first\n        value = await self.l1.get(key)\n        if value is not None:\n            return value\n\n        # Try L2 cache\n        value = await self.l2.get(key)\n        if value is not None:\n            # Populate L1 cache\n            await self.l1.set(key, value, ttl=60)  # Shorter TTL for L1\n            return value\n\n        return None\n\n    async def set(self, key: str, value: Any, ttl: int = 300) -&gt; bool:\n        # Set in both layers\n        l1_result = await self.l1.set(key, value, min(ttl, 60))\n        l2_result = await self.l2.set(key, value, ttl)\n        return l1_result and l2_result\n\n    async def delete(self, key: str) -&gt; bool:\n        # Delete from both layers\n        l1_result = await self.l1.delete(key)\n        l2_result = await self.l2.delete(key)\n        return l1_result or l2_result\n\nclass CachedDataService:\n    \"\"\"Service with intelligent caching.\"\"\"\n\n    @inject\n    def __init__(\n        self,\n        database: DatabaseService,\n        cache: MultiLevelCache\n    ):\n        self.database = database\n        self.cache = cache\n\n    async def get_user_profile(self, user_id: str) -&gt; Optional[dict]:\n        \"\"\"Get user profile with caching.\"\"\"\n        cache_key = f\"user_profile:{user_id}\"\n\n        # Try cache first\n        cached_profile = await self.cache.get(cache_key)\n        if cached_profile:\n            return cached_profile\n\n        # Load from database\n        profile = await self.database.get_user_profile(user_id)\n        if profile:\n            # Cache with appropriate TTL\n            await self.cache.set(cache_key, profile, ttl=1800)  # 30 minutes\n\n        return profile\n\n    async def update_user_profile(self, user_id: str, updates: dict) -&gt; bool:\n        \"\"\"Update user profile and invalidate cache.\"\"\"\n        success = await self.database.update_user_profile(user_id, updates)\n\n        if success:\n            # Invalidate cache\n            cache_key = f\"user_profile:{user_id}\"\n            await self.cache.delete(cache_key)\n\n        return success\n\n    def _generate_cache_key(self, prefix: str, **kwargs) -&gt; str:\n        \"\"\"Generate consistent cache key.\"\"\"\n        key_data = f\"{prefix}:\" + \":\".join(f\"{k}={v}\" for k, v in sorted(kwargs.items()))\n        return hashlib.md5(key_data.encode()).hexdigest()\n</code></pre>"},{"location":"best-practices/performance/#production-performance-checklist","title":"\ud83d\udd25 Production Performance Checklist","text":""},{"location":"best-practices/performance/#container-setup","title":"Container Setup","text":"<ul> <li> Use appropriate lifecycles: Singletons for expensive resources, scoped for request-bound services</li> <li> Minimize container lookups: Inject dependencies directly instead of container access</li> <li> Cache dynamic lookups: Store frequently accessed named dependencies</li> <li> Avoid circular dependencies: Design clean dependency graphs</li> <li> Use lazy loading: Only create dependencies when needed</li> </ul>"},{"location":"best-practices/performance/#async-performance","title":"Async Performance","text":"<ul> <li> Use concurrent operations: Batch operations with <code>asyncio.gather()</code></li> <li> Implement connection pooling: Reuse database and HTTP connections</li> <li> Optimize database queries: Use bulk operations and prepared statements</li> <li> Add circuit breakers: Prevent cascade failures in external service calls</li> <li> Implement timeouts: Set appropriate timeouts for all async operations</li> </ul>"},{"location":"best-practices/performance/#memory-management_1","title":"Memory Management","text":"<ul> <li> Monitor memory usage: Track memory consumption in production</li> <li> Use weak references: For large objects that can be garbage collected</li> <li> Implement cleanup routines: Periodic memory cleanup for long-running services</li> <li> Profile memory leaks: Regular memory profiling to identify leaks</li> <li> Configure garbage collection: Tune Python GC settings for your workload</li> </ul>"},{"location":"best-practices/performance/#caching-strategy","title":"Caching Strategy","text":"<ul> <li> Multi-level caching: Implement L1 (memory) and L2 (Redis) caching</li> <li> Cache invalidation: Clear cache when data changes</li> <li> TTL optimization: Set appropriate cache expiration times</li> <li> Cache warming: Pre-populate cache for frequently accessed data</li> <li> Monitor cache hit rates: Track and optimize cache effectiveness</li> </ul>"},{"location":"best-practices/performance/#monitoring-and-observability","title":"Monitoring and Observability","text":"<ul> <li> Performance metrics: Track response times and throughput</li> <li> Error monitoring: Log and alert on errors and exceptions</li> <li> Resource utilization: Monitor CPU, memory, and I/O usage</li> <li> Dependency health: Monitor external service health</li> <li> Custom metrics: Track business-specific performance indicators</li> </ul>"},{"location":"best-practices/performance/#example-production-configuration","title":"Example Production Configuration","text":"<pre><code># production_config.py\nfrom injectq import InjectQ, Module\nimport asyncio\nimport logging\n\nclass ProductionModule(Module):\n    def configure(self):\n        # Performance optimized bindings\n        self._configure_database()\n        self._configure_caching()\n        self._configure_monitoring()\n\n    def _configure_database(self):\n        \"\"\"Configure optimized database connections.\"\"\"\n        self.bind(DatabaseConfig, DatabaseConfig(\n            max_connections=20,\n            min_connections=5,\n            connection_timeout=30,\n            command_timeout=60\n        )).singleton()\n\n        self.bind(ConnectionPool, self._create_connection_pool()).singleton()\n        self.bind(DatabaseService, OptimizedDatabaseService).singleton()\n\n    def _configure_caching(self):\n        \"\"\"Configure multi-level caching.\"\"\"\n        self.bind(MemoryCache, MemoryCache(max_size=1000)).singleton()\n        self.bind(RedisCache, RedisCache).singleton()\n        self.bind(MultiLevelCache, MultiLevelCache).singleton()\n\n    def _configure_monitoring(self):\n        \"\"\"Configure performance monitoring.\"\"\"\n        self.bind(PerformanceMonitor, PerformanceMonitor).singleton()\n        self.bind(MetricsCollector, MetricsCollector).singleton()\n\n# Usage in production\nasync def main():\n    # Setup container with production optimizations\n    container = InjectQ()\n    container.install(ProductionModule())\n\n    # Pre-warm critical services\n    database = container.get(DatabaseService)\n    cache = container.get(MultiLevelCache)\n\n    # Start performance monitoring\n    monitor = container.get(PerformanceMonitor)\n\n    # Application startup\n    app = container.get(Application)\n    await app.start()\n\nif __name__ == \"__main__\":\n    # Configure logging for production\n    logging.basicConfig(\n        level=logging.INFO,\n        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n    )\n\n    asyncio.run(main())\n</code></pre> <p>Following these performance best practices will ensure your InjectQ applications run efficiently in production environments with optimal resource utilization and response times.</p>"},{"location":"best-practices/security/","title":"Security Best Practices","text":"<p>This guide covers essential security considerations when using InjectQ in production applications, including dependency validation, secure configuration management, and protection against common vulnerabilities.</p>"},{"location":"best-practices/security/#dependency-validation-and-security","title":"\ud83d\udd12 Dependency Validation and Security","text":""},{"location":"best-practices/security/#secure-dependency-registration","title":"Secure Dependency Registration","text":"<pre><code>from abc import ABC, abstractmethod\nfrom typing import Any, Dict, List, Optional, Type\nfrom injectq import InjectQ, Module, inject\nimport hashlib\nimport secrets\nfrom dataclasses import dataclass\n\nclass ISecurityValidator(ABC):\n    \"\"\"Interface for dependency security validation.\"\"\"\n\n    @abstractmethod\n    def validate_dependency(self, dependency_type: Type, instance: Any) -&gt; bool:\n        pass\n\n    @abstractmethod\n    def validate_configuration(self, config: Dict[str, Any]) -&gt; bool:\n        pass\n\nclass DependencySecurityValidator(ISecurityValidator):\n    \"\"\"Validates dependencies for security compliance.\"\"\"\n\n    def __init__(self):\n        self.allowed_types: set = set()\n        self.forbidden_patterns: List[str] = [\n            \"eval\", \"exec\", \"compile\", \"__import__\"\n        ]\n\n    def validate_dependency(self, dependency_type: Type, instance: Any) -&gt; bool:\n        \"\"\"Validate that a dependency is safe to use.\"\"\"\n        # Check if type is explicitly allowed\n        if dependency_type in self.allowed_types:\n            return True\n\n        # Check for dangerous patterns in type name\n        type_name = dependency_type.__name__.lower()\n        module_name = getattr(dependency_type, \"__module__\", \"\").lower()\n\n        for pattern in self.forbidden_patterns:\n            if pattern in type_name or pattern in module_name:\n                return False\n\n        # Validate instance attributes\n        if hasattr(instance, \"__dict__\"):\n            for attr_name in instance.__dict__:\n                if any(pattern in attr_name.lower() for pattern in self.forbidden_patterns):\n                    return False\n\n        return True\n\n    def validate_configuration(self, config: Dict[str, Any]) -&gt; bool:\n        \"\"\"Validate configuration for security issues.\"\"\"\n        dangerous_keys = [\"password\", \"secret\", \"key\", \"token\"]\n\n        for key, value in config.items():\n            # Check for credentials in plain text\n            if any(dangerous in key.lower() for dangerous in dangerous_keys):\n                if isinstance(value, str) and len(value) &gt; 0:\n                    # Should not be plain text\n                    if not self._is_encrypted_or_env_var(value):\n                        return False\n\n        return True\n\n    def _is_encrypted_or_env_var(self, value: str) -&gt; bool:\n        \"\"\"Check if value is encrypted or environment variable reference.\"\"\"\n        return (\n            value.startswith(\"${\") and value.endswith(\"}\") or  # Environment variable\n            value.startswith(\"enc:\") or  # Encrypted value\n            len(value) &gt; 32 and all(c in \"0123456789abcdef\" for c in value.lower())  # Hash\n        )\n\nclass SecureModule(Module):\n    \"\"\"Base module with security validation.\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.security_validator = DependencySecurityValidator()\n\n    def configure(self):\n        \"\"\"Configure module with security checks.\"\"\"\n        self._configure_dependencies()\n        self._validate_security()\n\n    def _configure_dependencies(self):\n        \"\"\"Override in subclasses.\"\"\"\n        pass\n\n    def _validate_security(self):\n        \"\"\"Validate all configured dependencies.\"\"\"\n        # This would be called after dependency configuration\n        pass\n\n    def bind(self, interface: Type, implementation: Type, **kwargs):\n        \"\"\"Secure binding with validation.\"\"\"\n        # Validate the implementation type\n        if hasattr(implementation, \"__init__\"):\n            temp_instance = object.__new__(implementation)\n            if not self.security_validator.validate_dependency(implementation, temp_instance):\n                raise SecurityError(f\"Dependency {implementation} failed security validation\")\n\n        return super().bind(interface, implementation, **kwargs)\n\nclass SecurityError(Exception):\n    \"\"\"Raised when security validation fails.\"\"\"\n    pass\n</code></pre>"},{"location":"best-practices/security/#input-validation-and-sanitization","title":"Input Validation and Sanitization","text":"<pre><code>import re\nfrom typing import Any, Dict, Union\nfrom html import escape\nimport bleach\n\nclass InputValidator:\n    \"\"\"Validates and sanitizes user inputs.\"\"\"\n\n    def __init__(self):\n        self.sql_injection_patterns = [\n            r\"(\\'|(\\')+|(;)+|(\\-\\-)+|(\\s)+(\\-\\-)+)\",\n            r\"((\\%27)|(\\'))((\\%6F)|o|(\\%4F))((\\%72)|r|(\\%52))\",\n            r\"((\\%27)|(\\'))union\",\n            r\"exec(\\s|\\+)+(s|x)p\\w+\",\n            r\"select.*from\",\n            r\"insert.*into\",\n            r\"update.*set\",\n            r\"delete.*from\",\n            r\"drop.*table\",\n            r\"create.*table\"\n        ]\n\n        self.xss_patterns = [\n            r\"&lt;script\\b[^&lt;]*(?:(?!&lt;\\/script&gt;)&lt;[^&lt;]*)*&lt;\\/script&gt;\",\n            r\"javascript:\",\n            r\"vbscript:\",\n            r\"onload=\",\n            r\"onerror=\",\n            r\"onclick=\"\n        ]\n\n    def validate_sql_injection(self, value: str) -&gt; bool:\n        \"\"\"Check for SQL injection patterns.\"\"\"\n        if not isinstance(value, str):\n            return True\n\n        value_lower = value.lower()\n        for pattern in self.sql_injection_patterns:\n            if re.search(pattern, value_lower, re.IGNORECASE):\n                return False\n        return True\n\n    def validate_xss(self, value: str) -&gt; bool:\n        \"\"\"Check for XSS patterns.\"\"\"\n        if not isinstance(value, str):\n            return True\n\n        for pattern in self.xss_patterns:\n            if re.search(pattern, value, re.IGNORECASE):\n                return False\n        return True\n\n    def sanitize_html(self, value: str) -&gt; str:\n        \"\"\"Sanitize HTML content.\"\"\"\n        if not isinstance(value, str):\n            return str(value)\n\n        # Allow only safe HTML tags\n        allowed_tags = ['p', 'br', 'strong', 'em', 'u', 'ol', 'ul', 'li']\n        allowed_attributes = {}\n\n        return bleach.clean(value, tags=allowed_tags, attributes=allowed_attributes)\n\n    def sanitize_input(self, value: Any) -&gt; Any:\n        \"\"\"General input sanitization.\"\"\"\n        if isinstance(value, str):\n            # Basic sanitization\n            value = escape(value)  # HTML escape\n            value = value.strip()  # Remove whitespace\n\n            # Validate for common attacks\n            if not self.validate_sql_injection(value):\n                raise SecurityError(\"Potential SQL injection detected\")\n\n            if not self.validate_xss(value):\n                raise SecurityError(\"Potential XSS attack detected\")\n\n            return value\n\n        elif isinstance(value, dict):\n            return {k: self.sanitize_input(v) for k, v in value.items()}\n\n        elif isinstance(value, list):\n            return [self.sanitize_input(item) for item in value]\n\n        return value\n\nclass SecureDataService:\n    \"\"\"Service that handles data securely.\"\"\"\n\n    @inject\n    def __init__(\n        self,\n        database: Database,\n        input_validator: InputValidator,\n        audit_logger: AuditLogger\n    ):\n        self.database = database\n        self.validator = input_validator\n        self.audit_logger = audit_logger\n\n    async def create_user(self, user_data: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Create user with input validation.\"\"\"\n        # Log the operation\n        self.audit_logger.log_operation(\"create_user\", user_data.get(\"email\", \"unknown\"))\n\n        try:\n            # Validate and sanitize inputs\n            sanitized_data = self.validator.sanitize_input(user_data)\n\n            # Additional business validation\n            if not self._validate_user_data(sanitized_data):\n                raise ValueError(\"Invalid user data\")\n\n            # Create user in database\n            user = await self.database.create_user(sanitized_data)\n\n            # Remove sensitive data from response\n            safe_user = self._remove_sensitive_fields(user)\n\n            return {\"success\": True, \"user\": safe_user}\n\n        except Exception as e:\n            self.audit_logger.log_error(\"create_user_failed\", str(e))\n            raise\n\n    def _validate_user_data(self, data: Dict[str, Any]) -&gt; bool:\n        \"\"\"Validate user data according to business rules.\"\"\"\n        required_fields = [\"email\", \"username\"]\n\n        for field in required_fields:\n            if field not in data or not data[field]:\n                return False\n\n        # Email validation\n        email = data[\"email\"]\n        email_pattern = r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\n        if not re.match(email_pattern, email):\n            return False\n\n        return True\n\n    def _remove_sensitive_fields(self, user: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Remove sensitive fields from user data.\"\"\"\n        sensitive_fields = [\"password\", \"password_hash\", \"salt\", \"api_key\"]\n        return {k: v for k, v in user.items() if k not in sensitive_fields}\n</code></pre>"},{"location":"best-practices/security/#configuration-security","title":"\ud83d\udd10 Configuration Security","text":""},{"location":"best-practices/security/#secure-configuration-management","title":"Secure Configuration Management","text":"<pre><code>import os\nimport base64\nfrom cryptography.fernet import Fernet\nfrom typing import Dict, Any, Optional\n\nclass SecureConfigManager:\n    \"\"\"Manages application configuration securely.\"\"\"\n\n    def __init__(self, encryption_key: Optional[bytes] = None):\n        if encryption_key is None:\n            # Get from environment or generate\n            key_str = os.getenv(\"CONFIG_ENCRYPTION_KEY\")\n            if key_str:\n                self.encryption_key = base64.urlsafe_b64decode(key_str.encode())\n            else:\n                self.encryption_key = Fernet.generate_key()\n        else:\n            self.encryption_key = encryption_key\n\n        self.cipher = Fernet(self.encryption_key)\n        self._config_cache: Dict[str, Any] = {}\n\n    def encrypt_value(self, value: str) -&gt; str:\n        \"\"\"Encrypt a configuration value.\"\"\"\n        encrypted = self.cipher.encrypt(value.encode())\n        return base64.urlsafe_b64encode(encrypted).decode()\n\n    def decrypt_value(self, encrypted_value: str) -&gt; str:\n        \"\"\"Decrypt a configuration value.\"\"\"\n        try:\n            encrypted_bytes = base64.urlsafe_b64decode(encrypted_value.encode())\n            decrypted = self.cipher.decrypt(encrypted_bytes)\n            return decrypted.decode()\n        except Exception:\n            raise SecurityError(\"Failed to decrypt configuration value\")\n\n    def get_config_value(self, key: str, default: Any = None) -&gt; Any:\n        \"\"\"Get configuration value with decryption if needed.\"\"\"\n        # Check cache first\n        if key in self._config_cache:\n            return self._config_cache[key]\n\n        # Get from environment\n        env_value = os.getenv(key, default)\n\n        if isinstance(env_value, str):\n            # Check if value is encrypted\n            if env_value.startswith(\"enc:\"):\n                encrypted_value = env_value[4:]  # Remove \"enc:\" prefix\n                decrypted_value = self.decrypt_value(encrypted_value)\n                self._config_cache[key] = decrypted_value\n                return decrypted_value\n            else:\n                self._config_cache[key] = env_value\n                return env_value\n\n        return env_value\n\n    def validate_configuration(self) -&gt; bool:\n        \"\"\"Validate that all required secure configurations are present.\"\"\"\n        required_configs = [\n            \"DATABASE_PASSWORD\",\n            \"JWT_SECRET_KEY\",\n            \"API_SECRET_KEY\"\n        ]\n\n        for config in required_configs:\n            value = self.get_config_value(config)\n            if not value:\n                return False\n\n            # Check if sensitive values are encrypted or strong enough\n            if not self._is_secure_value(value):\n                return False\n\n        return True\n\n    def _is_secure_value(self, value: str) -&gt; bool:\n        \"\"\"Check if a value meets security requirements.\"\"\"\n        if len(value) &lt; 12:  # Minimum length\n            return False\n\n        # Should have complexity (letters, numbers, symbols)\n        has_lower = any(c.islower() for c in value)\n        has_upper = any(c.isupper() for c in value)\n        has_digit = any(c.isdigit() for c in value)\n        has_symbol = any(not c.isalnum() for c in value)\n\n        return sum([has_lower, has_upper, has_digit, has_symbol]) &gt;= 3\n\n@dataclass\nclass DatabaseConfig:\n    host: str\n    port: int\n    database: str\n    username: str\n    password: str\n    ssl_mode: str = \"require\"\n\n    def __post_init__(self):\n        # Validate that password is not empty\n        if not self.password:\n            raise SecurityError(\"Database password cannot be empty\")\n\n@dataclass\nclass JWTConfig:\n    secret_key: str\n    algorithm: str = \"HS256\"\n    expiration_hours: int = 24\n\n    def __post_init__(self):\n        if len(self.secret_key) &lt; 32:\n            raise SecurityError(\"JWT secret key must be at least 32 characters\")\n\nclass SecureConfigModule(Module):\n    \"\"\"Module that provides secure configuration.\"\"\"\n\n    def configure(self):\n        config_manager = SecureConfigManager()\n\n        # Validate configuration\n        if not config_manager.validate_configuration():\n            raise SecurityError(\"Configuration validation failed\")\n\n        # Database configuration\n        db_config = DatabaseConfig(\n            host=config_manager.get_config_value(\"DATABASE_HOST\", \"localhost\"),\n            port=int(config_manager.get_config_value(\"DATABASE_PORT\", \"5432\")),\n            database=config_manager.get_config_value(\"DATABASE_NAME\", \"app\"),\n            username=config_manager.get_config_value(\"DATABASE_USER\", \"app\"),\n            password=config_manager.get_config_value(\"DATABASE_PASSWORD\"),\n            ssl_mode=config_manager.get_config_value(\"DATABASE_SSL_MODE\", \"require\")\n        )\n\n        # JWT configuration\n        jwt_config = JWTConfig(\n            secret_key=config_manager.get_config_value(\"JWT_SECRET_KEY\"),\n            algorithm=config_manager.get_config_value(\"JWT_ALGORITHM\", \"HS256\"),\n            expiration_hours=int(config_manager.get_config_value(\"JWT_EXPIRATION_HOURS\", \"24\"))\n        )\n\n        # Bind configurations\n        self.bind(SecureConfigManager, config_manager).singleton()\n        self.bind(DatabaseConfig, db_config).singleton()\n        self.bind(JWTConfig, jwt_config).singleton()\n\n        # Input validation\n        self.bind(InputValidator, InputValidator).singleton()\n</code></pre>"},{"location":"best-practices/security/#authentication-and-authorization","title":"\ud83d\udee1\ufe0f Authentication and Authorization","text":""},{"location":"best-practices/security/#secure-authentication-service","title":"Secure Authentication Service","text":"<pre><code>import jwt\nimport bcrypt\nfrom datetime import datetime, timedelta\nfrom typing import Optional, Dict, Any, List\n\nclass AuthenticationService:\n    \"\"\"Handles user authentication securely.\"\"\"\n\n    @inject\n    def __init__(\n        self,\n        jwt_config: JWTConfig,\n        user_repository: IUserRepository,\n        audit_logger: AuditLogger\n    ):\n        self.jwt_config = jwt_config\n        self.user_repository = user_repository\n        self.audit_logger = audit_logger\n        self.failed_attempts: Dict[str, int] = {}\n        self.lockout_threshold = 5\n        self.lockout_duration = timedelta(minutes=15)\n\n    async def authenticate_user(\n        self,\n        username: str,\n        password: str,\n        client_ip: str\n    ) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Authenticate user with rate limiting and audit logging.\"\"\"\n\n        # Check for account lockout\n        if self._is_account_locked(username):\n            self.audit_logger.log_security_event(\n                \"authentication_blocked_lockout\",\n                username,\n                client_ip\n            )\n            raise SecurityError(\"Account temporarily locked due to multiple failed attempts\")\n\n        try:\n            # Find user\n            user = await self.user_repository.find_by_username(username)\n            if not user:\n                self._record_failed_attempt(username)\n                self.audit_logger.log_security_event(\n                    \"authentication_failed_user_not_found\",\n                    username,\n                    client_ip\n                )\n                return None\n\n            # Verify password\n            if not self._verify_password(password, user.password_hash):\n                self._record_failed_attempt(username)\n                self.audit_logger.log_security_event(\n                    \"authentication_failed_invalid_password\",\n                    username,\n                    client_ip\n                )\n                return None\n\n            # Check if account is active\n            if not user.is_active:\n                self.audit_logger.log_security_event(\n                    \"authentication_failed_inactive_account\",\n                    username,\n                    client_ip\n                )\n                return None\n\n            # Reset failed attempts on successful login\n            self._reset_failed_attempts(username)\n\n            # Generate JWT token\n            token = self._generate_jwt_token(user)\n\n            # Log successful authentication\n            self.audit_logger.log_security_event(\n                \"authentication_successful\",\n                username,\n                client_ip\n            )\n\n            return {\n                \"token\": token,\n                \"user_id\": user.id,\n                \"username\": user.username,\n                \"expires_at\": datetime.utcnow() + timedelta(hours=self.jwt_config.expiration_hours)\n            }\n\n        except Exception as e:\n            self.audit_logger.log_error(\"authentication_error\", str(e))\n            raise\n\n    def _verify_password(self, password: str, password_hash: str) -&gt; bool:\n        \"\"\"Verify password using secure hashing.\"\"\"\n        try:\n            return bcrypt.checkpw(password.encode('utf-8'), password_hash.encode('utf-8'))\n        except Exception:\n            return False\n\n    def _generate_jwt_token(self, user: Any) -&gt; str:\n        \"\"\"Generate JWT token for authenticated user.\"\"\"\n        payload = {\n            \"user_id\": user.id,\n            \"username\": user.username,\n            \"email\": user.email,\n            \"roles\": user.roles,\n            \"iat\": datetime.utcnow(),\n            \"exp\": datetime.utcnow() + timedelta(hours=self.jwt_config.expiration_hours)\n        }\n\n        return jwt.encode(\n            payload,\n            self.jwt_config.secret_key,\n            algorithm=self.jwt_config.algorithm\n        )\n\n    def verify_jwt_token(self, token: str) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Verify JWT token and return payload.\"\"\"\n        try:\n            payload = jwt.decode(\n                token,\n                self.jwt_config.secret_key,\n                algorithms=[self.jwt_config.algorithm]\n            )\n            return payload\n        except jwt.ExpiredSignatureError:\n            raise SecurityError(\"Token has expired\")\n        except jwt.InvalidTokenError:\n            raise SecurityError(\"Invalid token\")\n\n    def _is_account_locked(self, username: str) -&gt; bool:\n        \"\"\"Check if account is locked due to failed attempts.\"\"\"\n        if username not in self.failed_attempts:\n            return False\n\n        attempts, last_attempt = self.failed_attempts[username]\n        if attempts &gt;= self.lockout_threshold:\n            if datetime.now() - last_attempt &lt; self.lockout_duration:\n                return True\n            else:\n                # Lockout period expired, reset attempts\n                self._reset_failed_attempts(username)\n\n        return False\n\n    def _record_failed_attempt(self, username: str):\n        \"\"\"Record a failed authentication attempt.\"\"\"\n        if username not in self.failed_attempts:\n            self.failed_attempts[username] = [1, datetime.now()]\n        else:\n            attempts, _ = self.failed_attempts[username]\n            self.failed_attempts[username] = [attempts + 1, datetime.now()]\n\n    def _reset_failed_attempts(self, username: str):\n        \"\"\"Reset failed attempts for a user.\"\"\"\n        self.failed_attempts.pop(username, None)\n\nclass AuthorizationService:\n    \"\"\"Handles user authorization and permissions.\"\"\"\n\n    @inject\n    def __init__(self, auth_service: AuthenticationService):\n        self.auth_service = auth_service\n\n    def check_permission(self, token: str, required_permission: str) -&gt; bool:\n        \"\"\"Check if user has required permission.\"\"\"\n        try:\n            payload = self.auth_service.verify_jwt_token(token)\n            user_roles = payload.get(\"roles\", [])\n\n            # Check if user has required permission\n            return self._has_permission(user_roles, required_permission)\n\n        except SecurityError:\n            return False\n\n    def require_permission(self, required_permission: str):\n        \"\"\"Decorator to require specific permission.\"\"\"\n        def decorator(func):\n            @functools.wraps(func)\n            async def wrapper(*args, **kwargs):\n                # Extract token from request context (implementation depends on framework)\n                token = self._extract_token_from_context()\n\n                if not self.check_permission(token, required_permission):\n                    raise SecurityError(f\"Permission denied: {required_permission} required\")\n\n                return await func(*args, **kwargs)\n            return wrapper\n        return decorator\n\n    def _has_permission(self, user_roles: List[str], required_permission: str) -&gt; bool:\n        \"\"\"Check if user roles include required permission.\"\"\"\n        # Define role permissions (in production, this would be in a database)\n        role_permissions = {\n            \"admin\": [\"*\"],  # Admin has all permissions\n            \"user\": [\"read_profile\", \"update_profile\"],\n            \"moderator\": [\"read_profile\", \"update_profile\", \"moderate_content\"],\n            \"editor\": [\"read_profile\", \"update_profile\", \"create_content\", \"edit_content\"]\n        }\n\n        for role in user_roles:\n            permissions = role_permissions.get(role, [])\n            if \"*\" in permissions or required_permission in permissions:\n                return True\n\n        return False\n\n    def _extract_token_from_context(self) -&gt; Optional[str]:\n        \"\"\"Extract JWT token from request context.\"\"\"\n        # Implementation depends on web framework\n        # This is a placeholder\n        return None\n</code></pre>"},{"location":"best-practices/security/#audit-logging-and-monitoring","title":"\ud83d\udea8 Audit Logging and Monitoring","text":""},{"location":"best-practices/security/#security-audit-system","title":"Security Audit System","text":"<pre><code>import json\nimport uuid\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, Optional\n\nclass SecurityEventType(Enum):\n    AUTHENTICATION_SUCCESS = \"authentication_success\"\n    AUTHENTICATION_FAILURE = \"authentication_failure\"\n    AUTHORIZATION_FAILURE = \"authorization_failure\"\n    SUSPICIOUS_ACTIVITY = \"suspicious_activity\"\n    DATA_ACCESS = \"data_access\"\n    CONFIGURATION_CHANGE = \"configuration_change\"\n    SECURITY_VIOLATION = \"security_violation\"\n\n@dataclass\nclass SecurityEvent:\n    event_id: str\n    event_type: SecurityEventType\n    timestamp: datetime\n    user_id: Optional[str]\n    username: Optional[str]\n    client_ip: str\n    user_agent: Optional[str]\n    resource: Optional[str]\n    action: str\n    result: str\n    details: Dict[str, Any]\n    risk_score: int  # 1-10, where 10 is highest risk\n\nclass AuditLogger:\n    \"\"\"Comprehensive security audit logging.\"\"\"\n\n    @inject\n    def __init__(self, log_storage: ILogStorage, alert_service: IAlertService):\n        self.log_storage = log_storage\n        self.alert_service = alert_service\n        self.high_risk_threshold = 7\n\n    def log_security_event(\n        self,\n        event_type: str,\n        username: Optional[str] = None,\n        client_ip: str = \"unknown\",\n        user_agent: Optional[str] = None,\n        resource: Optional[str] = None,\n        action: str = \"\",\n        result: str = \"\",\n        details: Optional[Dict[str, Any]] = None,\n        risk_score: int = 5\n    ):\n        \"\"\"Log a security event.\"\"\"\n        event = SecurityEvent(\n            event_id=str(uuid.uuid4()),\n            event_type=SecurityEventType(event_type),\n            timestamp=datetime.utcnow(),\n            user_id=None,  # Would be extracted from context\n            username=username,\n            client_ip=client_ip,\n            user_agent=user_agent,\n            resource=resource,\n            action=action,\n            result=result,\n            details=details or {},\n            risk_score=risk_score\n        )\n\n        # Store the event\n        self._store_event(event)\n\n        # Check if high-risk event requires immediate alerting\n        if risk_score &gt;= self.high_risk_threshold:\n            self._send_security_alert(event)\n\n        # Check for suspicious patterns\n        self._analyze_suspicious_patterns(event)\n\n    def log_operation(self, operation: str, target: str, **kwargs):\n        \"\"\"Log a general operation for audit purposes.\"\"\"\n        self.log_security_event(\n            event_type=\"data_access\",\n            action=operation,\n            resource=target,\n            details=kwargs,\n            risk_score=3\n        )\n\n    def log_error(self, operation: str, error_message: str, **kwargs):\n        \"\"\"Log an error for security analysis.\"\"\"\n        self.log_security_event(\n            event_type=\"security_violation\",\n            action=operation,\n            result=\"error\",\n            details={\"error\": error_message, **kwargs},\n            risk_score=6\n        )\n\n    def _store_event(self, event: SecurityEvent):\n        \"\"\"Store security event in persistent storage.\"\"\"\n        event_data = {\n            \"event_id\": event.event_id,\n            \"event_type\": event.event_type.value,\n            \"timestamp\": event.timestamp.isoformat(),\n            \"user_id\": event.user_id,\n            \"username\": event.username,\n            \"client_ip\": event.client_ip,\n            \"user_agent\": event.user_agent,\n            \"resource\": event.resource,\n            \"action\": event.action,\n            \"result\": event.result,\n            \"details\": event.details,\n            \"risk_score\": event.risk_score\n        }\n\n        self.log_storage.store_event(event_data)\n\n    def _send_security_alert(self, event: SecurityEvent):\n        \"\"\"Send immediate alert for high-risk events.\"\"\"\n        alert_message = {\n            \"alert_type\": \"security_event\",\n            \"severity\": \"high\",\n            \"event_id\": event.event_id,\n            \"event_type\": event.event_type.value,\n            \"timestamp\": event.timestamp.isoformat(),\n            \"username\": event.username,\n            \"client_ip\": event.client_ip,\n            \"risk_score\": event.risk_score,\n            \"details\": event.details\n        }\n\n        self.alert_service.send_alert(alert_message)\n\n    def _analyze_suspicious_patterns(self, event: SecurityEvent):\n        \"\"\"Analyze event for suspicious patterns.\"\"\"\n        # Check for brute force attacks\n        if event.event_type == SecurityEventType.AUTHENTICATION_FAILURE:\n            recent_failures = self._get_recent_failures(event.client_ip, minutes=10)\n            if len(recent_failures) &gt;= 5:\n                self._send_security_alert(SecurityEvent(\n                    event_id=str(uuid.uuid4()),\n                    event_type=SecurityEventType.SUSPICIOUS_ACTIVITY,\n                    timestamp=datetime.utcnow(),\n                    user_id=None,\n                    username=event.username,\n                    client_ip=event.client_ip,\n                    user_agent=event.user_agent,\n                    resource=None,\n                    action=\"brute_force_detected\",\n                    result=\"blocked\",\n                    details={\"failure_count\": len(recent_failures)},\n                    risk_score=9\n                ))\n\n        # Check for unusual access patterns\n        if event.event_type == SecurityEventType.DATA_ACCESS:\n            if self._is_unusual_access_pattern(event):\n                event.risk_score = min(event.risk_score + 3, 10)\n\n    def _get_recent_failures(self, client_ip: str, minutes: int) -&gt; List[Dict]:\n        \"\"\"Get recent authentication failures from this IP.\"\"\"\n        # This would query the log storage\n        return []\n\n    def _is_unusual_access_pattern(self, event: SecurityEvent) -&gt; bool:\n        \"\"\"Check if access pattern is unusual.\"\"\"\n        # Implement pattern analysis logic\n        return False\n\nclass ILogStorage(ABC):\n    @abstractmethod\n    def store_event(self, event_data: Dict[str, Any]):\n        pass\n\nclass IAlertService(ABC):\n    @abstractmethod\n    def send_alert(self, alert_data: Dict[str, Any]):\n        pass\n\nclass DatabaseLogStorage(ILogStorage):\n    @inject\n    def __init__(self, database: Database):\n        self.database = database\n\n    def store_event(self, event_data: Dict[str, Any]):\n        \"\"\"Store security event in database.\"\"\"\n        # Insert into security_events table\n        pass\n\nclass EmailAlertService(IAlertService):\n    @inject\n    def __init__(self, email_service: EmailService, config: AlertConfig):\n        self.email_service = email_service\n        self.config = config\n\n    def send_alert(self, alert_data: Dict[str, Any]):\n        \"\"\"Send security alert via email.\"\"\"\n        subject = f\"Security Alert: {alert_data['event_type']}\"\n        body = json.dumps(alert_data, indent=2)\n\n        self.email_service.send_email(\n            to=self.config.security_team_email,\n            subject=subject,\n            body=body\n        )\n</code></pre>"},{"location":"best-practices/security/#security-testing","title":"\ud83d\udee0\ufe0f Security Testing","text":""},{"location":"best-practices/security/#security-test-suite","title":"Security Test Suite","text":"<pre><code>import pytest\nfrom unittest.mock import Mock, patch\nfrom injectq import InjectQ\n\nclass SecurityTestSuite:\n    \"\"\"Comprehensive security test suite.\"\"\"\n\n    def __init__(self, container: InjectQ):\n        self.container = container\n\n    def test_input_validation(self):\n        \"\"\"Test input validation against common attacks.\"\"\"\n        validator = self.container.get(InputValidator)\n\n        # SQL injection tests\n        sql_payloads = [\n            \"'; DROP TABLE users; --\",\n            \"1' OR '1'='1\",\n            \"admin'--\",\n            \"1; DELETE FROM users WHERE 1=1; --\"\n        ]\n\n        for payload in sql_payloads:\n            assert not validator.validate_sql_injection(payload), f\"SQL injection not detected: {payload}\"\n\n        # XSS tests\n        xss_payloads = [\n            \"&lt;script&gt;alert('xss')&lt;/script&gt;\",\n            \"javascript:alert('xss')\",\n            \"&lt;img src=x onerror=alert('xss')&gt;\",\n            \"&lt;svg onload=alert('xss')&gt;\"\n        ]\n\n        for payload in xss_payloads:\n            assert not validator.validate_xss(payload), f\"XSS not detected: {payload}\"\n\n    def test_authentication_security(self):\n        \"\"\"Test authentication security measures.\"\"\"\n        auth_service = self.container.get(AuthenticationService)\n\n        # Test rate limiting\n        for i in range(6):  # Exceed lockout threshold\n            try:\n                auth_service.authenticate_user(\"testuser\", \"wrongpassword\", \"127.0.0.1\")\n            except SecurityError:\n                pass\n\n        # Next attempt should be blocked\n        with pytest.raises(SecurityError, match=\"Account temporarily locked\"):\n            auth_service.authenticate_user(\"testuser\", \"wrongpassword\", \"127.0.0.1\")\n\n    def test_configuration_security(self):\n        \"\"\"Test configuration security.\"\"\"\n        config_manager = self.container.get(SecureConfigManager)\n\n        # Test that sensitive values are properly encrypted\n        assert config_manager.validate_configuration()\n\n        # Test encryption/decryption\n        test_value = \"sensitive_password_123\"\n        encrypted = config_manager.encrypt_value(test_value)\n        decrypted = config_manager.decrypt_value(encrypted)\n\n        assert test_value == decrypted\n        assert encrypted != test_value\n\n    def test_audit_logging(self):\n        \"\"\"Test audit logging functionality.\"\"\"\n        audit_logger = self.container.get(AuditLogger)\n\n        with patch.object(audit_logger.log_storage, 'store_event') as mock_store:\n            audit_logger.log_security_event(\n                \"authentication_failure\",\n                username=\"testuser\",\n                client_ip=\"127.0.0.1\",\n                risk_score=8\n            )\n\n            # Verify event was stored\n            mock_store.assert_called_once()\n\n            # Verify high-risk alert was sent\n            with patch.object(audit_logger.alert_service, 'send_alert') as mock_alert:\n                audit_logger.log_security_event(\n                    \"suspicious_activity\",\n                    risk_score=9\n                )\n                mock_alert.assert_called_once()\n\n# Security test fixtures\n@pytest.fixture\ndef secure_container():\n    \"\"\"Create container with security modules.\"\"\"\n    container = InjectQ()\n    container.install(SecureConfigModule())\n    container.install(SecurityModule())\n    return container\n\nclass SecurityModule(Module):\n    def configure(self):\n        # Security services\n        self.bind(InputValidator, InputValidator).singleton()\n        self.bind(AuthenticationService, AuthenticationService).singleton()\n        self.bind(AuthorizationService, AuthorizationService).singleton()\n        self.bind(AuditLogger, AuditLogger).singleton()\n\n        # Mock implementations for testing\n        self.bind(ILogStorage, Mock()).singleton()\n        self.bind(IAlertService, Mock()).singleton()\n        self.bind(IUserRepository, Mock()).singleton()\n\n# Usage\ndef test_security_suite(secure_container):\n    \"\"\"Run complete security test suite.\"\"\"\n    test_suite = SecurityTestSuite(secure_container)\n\n    test_suite.test_input_validation()\n    test_suite.test_authentication_security()\n    test_suite.test_configuration_security()\n    test_suite.test_audit_logging()\n</code></pre>"},{"location":"best-practices/security/#security-checklist","title":"\ud83d\udd12 Security Checklist","text":""},{"location":"best-practices/security/#pre-production-security-review","title":"Pre-Production Security Review","text":"<ul> <li> Input Validation</li> <li> All user inputs are validated and sanitized</li> <li> SQL injection protection is implemented</li> <li> XSS protection is in place</li> <li> <p> File upload validation is secure</p> </li> <li> <p> Authentication &amp; Authorization</p> </li> <li> Strong password policies are enforced</li> <li> Account lockout mechanisms are implemented</li> <li> JWT tokens use secure algorithms and keys</li> <li> Session management is secure</li> <li> <p> Role-based access control is properly implemented</p> </li> <li> <p> Configuration Security</p> </li> <li> Sensitive configuration is encrypted</li> <li> No credentials are hardcoded</li> <li> Environment variables are used for secrets</li> <li> <p> Configuration validation is implemented</p> </li> <li> <p> Data Protection</p> </li> <li> Personal data is encrypted at rest</li> <li> Data transmission uses TLS/SSL</li> <li> Database connections are encrypted</li> <li> <p> Sensitive data is not logged</p> </li> <li> <p> Audit &amp; Monitoring</p> </li> <li> Security events are logged</li> <li> Failed authentication attempts are tracked</li> <li> Suspicious activities trigger alerts</li> <li> <p> Audit logs are tamper-proof</p> </li> <li> <p> Dependency Security</p> </li> <li> Dependencies are validated for security</li> <li> Dependency injection is secure</li> <li> Third-party libraries are up to date</li> <li> <p> Vulnerable dependencies are avoided</p> </li> <li> <p> Infrastructure Security</p> </li> <li> Network security is properly configured</li> <li> Database access is restricted</li> <li> API endpoints are secured</li> <li> Error messages don't leak sensitive information</li> </ul> <p>Following these security best practices ensures your InjectQ applications are protected against common vulnerabilities and maintain high security standards in production environments.</p>"},{"location":"best-practices/testing-strategies/","title":"Testing Best Practices","text":"<p>This guide covers comprehensive testing strategies for InjectQ applications, including unit testing, integration testing, and advanced testing patterns.</p>"},{"location":"best-practices/testing-strategies/#unit-testing-with-injectq","title":"\ud83e\uddea Unit Testing with InjectQ","text":""},{"location":"best-practices/testing-strategies/#basic-unit-testing-setup","title":"Basic Unit Testing Setup","text":"<pre><code># test_unit_basics.py\nimport pytest\nfrom unittest.mock import Mock, AsyncMock\nfrom injectq import InjectQ, inject, Module\nfrom injectq.testing import TestModule, mock_service\n\n# Example service to test\nclass EmailService:\n    @inject\n    def __init__(self, smtp_client: SMTPClient, config: EmailConfig):\n        self.smtp_client = smtp_client\n        self.config = config\n        self.sent_emails = []\n\n    async def send_email(self, to: str, subject: str, body: str) -&gt; bool:\n        \"\"\"Send email and return success status.\"\"\"\n        try:\n            await self.smtp_client.send(\n                to=to,\n                subject=subject,\n                body=body,\n                from_addr=self.config.from_address\n            )\n            self.sent_emails.append({\n                \"to\": to,\n                \"subject\": subject,\n                \"body\": body\n            })\n            return True\n        except Exception:\n            return False\n\n    async def send_bulk_emails(self, recipients: list, subject: str, body: str) -&gt; dict:\n        \"\"\"Send emails to multiple recipients.\"\"\"\n        results = {\"sent\": 0, \"failed\": 0, \"errors\": []}\n\n        for recipient in recipients:\n            try:\n                success = await self.send_email(recipient, subject, body)\n                if success:\n                    results[\"sent\"] += 1\n                else:\n                    results[\"failed\"] += 1\n            except Exception as e:\n                results[\"failed\"] += 1\n                results[\"errors\"].append(str(e))\n\n        return results\n\nclass SMTPClient:\n    @inject\n    def __init__(self, host: str, port: int):\n        self.host = host\n        self.port = port\n        self.connected = False\n\n    async def connect(self):\n        self.connected = True\n\n    async def send(self, to: str, subject: str, body: str, from_addr: str):\n        if not self.connected:\n            raise ConnectionError(\"SMTP client not connected\")\n\n        # Simulate sending email\n        print(f\"Sending email to {to}: {subject}\")\n\n@dataclass\nclass EmailConfig:\n    from_address: str\n    reply_to: str = \"\"\n\n# Test module with mocks\nclass EmailTestModule(TestModule):\n    def configure(self):\n        # Mock SMTP client\n        mock_smtp = Mock(spec=SMTPClient)\n        mock_smtp.send = AsyncMock()\n        mock_smtp.connected = True\n        self.bind(SMTPClient, mock_smtp).singleton()\n\n        # Real config for testing\n        self.bind(EmailConfig, EmailConfig(\n            from_address=\"test@example.com\",\n            reply_to=\"noreply@example.com\"\n        )).singleton()\n\n        # Service under test\n        self.bind(EmailService, EmailService).scoped()\n\n# Basic unit tests\nclass TestEmailService:\n    @pytest.fixture\n    def container(self):\n        \"\"\"Create test container with mocked dependencies.\"\"\"\n        container = InjectQ()\n        container.install(EmailTestModule())\n        return container\n\n    @pytest.fixture\n    def email_service(self, container):\n        \"\"\"Get email service instance.\"\"\"\n        return container.get(EmailService)\n\n    @pytest.fixture\n    def mock_smtp(self, container):\n        \"\"\"Get mock SMTP client.\"\"\"\n        return container.get(SMTPClient)\n\n    @pytest.mark.asyncio\n    async def test_send_email_success(self, email_service, mock_smtp):\n        \"\"\"Test successful email sending.\"\"\"\n        # Arrange\n        to = \"user@example.com\"\n        subject = \"Test Subject\"\n        body = \"Test Body\"\n\n        # Act\n        result = await email_service.send_email(to, subject, body)\n\n        # Assert\n        assert result is True\n        mock_smtp.send.assert_called_once_with(\n            to=to,\n            subject=subject,\n            body=body,\n            from_addr=\"test@example.com\"\n        )\n        assert len(email_service.sent_emails) == 1\n        assert email_service.sent_emails[0][\"to\"] == to\n\n    @pytest.mark.asyncio\n    async def test_send_email_failure(self, email_service, mock_smtp):\n        \"\"\"Test email sending failure.\"\"\"\n        # Arrange\n        mock_smtp.send.side_effect = Exception(\"SMTP Error\")\n\n        # Act\n        result = await email_service.send_email(\"user@example.com\", \"Test\", \"Body\")\n\n        # Assert\n        assert result is False\n        assert len(email_service.sent_emails) == 0\n\n    @pytest.mark.asyncio\n    async def test_bulk_email_mixed_results(self, email_service, mock_smtp):\n        \"\"\"Test bulk email with mixed success/failure.\"\"\"\n        # Arrange\n        recipients = [\"user1@example.com\", \"user2@example.com\", \"user3@example.com\"]\n\n        # Mock SMTP to fail on second email\n        def mock_send(to, **kwargs):\n            if to == \"user2@example.com\":\n                raise Exception(\"SMTP Error\")\n\n        mock_smtp.send.side_effect = mock_send\n\n        # Act\n        result = await email_service.send_bulk_emails(recipients, \"Test\", \"Body\")\n\n        # Assert\n        assert result[\"sent\"] == 2\n        assert result[\"failed\"] == 1\n        assert len(result[\"errors\"]) == 1\n\n# Advanced testing with dependency injection\nclass TestAdvancedMocking:\n    @pytest.fixture\n    def container_with_custom_mocks(self):\n        \"\"\"Create container with custom mock configurations.\"\"\"\n        container = InjectQ()\n\n        # Create sophisticated mock\n        smtp_mock = Mock(spec=SMTPClient)\n        smtp_mock.connected = True\n\n        # Configure mock behavior based on email content\n        async def smart_send(to, subject, body, from_addr):\n            if \"spam\" in subject.lower():\n                raise ValueError(\"Spam detected\")\n            if \"@invalid.com\" in to:\n                raise ConnectionError(\"Invalid domain\")\n            return True\n\n        smtp_mock.send = AsyncMock(side_effect=smart_send)\n\n        class CustomTestModule(TestModule):\n            def configure(self):\n                self.bind(SMTPClient, smtp_mock).singleton()\n                self.bind(EmailConfig, EmailConfig(\n                    from_address=\"test@company.com\"\n                )).singleton()\n                self.bind(EmailService, EmailService).scoped()\n\n        container.install(CustomTestModule())\n        return container\n\n    @pytest.mark.asyncio\n    async def test_spam_detection(self, container_with_custom_mocks):\n        \"\"\"Test spam detection in mock.\"\"\"\n        email_service = container_with_custom_mocks.get(EmailService)\n\n        # This should fail due to spam detection\n        result = await email_service.send_email(\n            \"user@example.com\", \n            \"SPAM: Buy now!\", \n            \"Spam content\"\n        )\n\n        assert result is False\n\n    @pytest.mark.asyncio\n    async def test_invalid_domain(self, container_with_custom_mocks):\n        \"\"\"Test invalid domain handling.\"\"\"\n        email_service = container_with_custom_mocks.get(EmailService)\n\n        result = await email_service.send_email(\n            \"user@invalid.com\", \n            \"Valid Subject\", \n            \"Valid content\"\n        )\n\n        assert result is False\n</code></pre>"},{"location":"best-practices/testing-strategies/#testing-with-scopes-and-lifecycle","title":"Testing with Scopes and Lifecycle","text":"<pre><code># test_scopes_lifecycle.py\nimport pytest\nimport asyncio\nfrom injectq import InjectQ, inject, Module, Scope\nfrom injectq.testing import TestModule\n\nclass DatabaseConnection:\n    \"\"\"Database connection that tracks lifecycle.\"\"\"\n\n    def __init__(self, connection_id: str):\n        self.connection_id = connection_id\n        self.is_open = False\n        self.transaction_count = 0\n\n    async def open(self):\n        self.is_open = True\n        print(f\"Database connection {self.connection_id} opened\")\n\n    async def close(self):\n        self.is_open = False\n        print(f\"Database connection {self.connection_id} closed\")\n\n    async def begin_transaction(self):\n        if not self.is_open:\n            raise RuntimeError(\"Connection not open\")\n        self.transaction_count += 1\n\nclass UserRepository:\n    @inject\n    def __init__(self, db_connection: DatabaseConnection):\n        self.db_connection = db_connection\n        self.users = {}\n\n    async def save_user(self, user_id: str, data: dict):\n        await self.db_connection.begin_transaction()\n        self.users[user_id] = data\n        return user_id\n\n    async def get_user(self, user_id: str):\n        return self.users.get(user_id)\n\nclass UserService:\n    @inject\n    def __init__(self, user_repository: UserRepository):\n        self.user_repository = user_repository\n\n    async def create_user(self, name: str, email: str) -&gt; str:\n        user_data = {\"name\": name, \"email\": email}\n        return await self.user_repository.save_user(f\"user_{len(self.user_repository.users) + 1}\", user_data)\n\n# Testing different scopes\nclass ScopeTestModule(TestModule):\n    def configure(self):\n        # Singleton database connection\n        self.bind(DatabaseConnection, lambda: DatabaseConnection(\"test_conn\")).singleton()\n\n        # Scoped repository (new instance per scope)\n        self.bind(UserRepository, UserRepository).scoped()\n\n        # Transient service (new instance every time)\n        self.bind(UserService, UserService).transient()\n\nclass TestScopeBehavior:\n    @pytest.fixture\n    def container(self):\n        container = InjectQ()\n        container.install(ScopeTestModule())\n        return container\n\n    @pytest.mark.asyncio\n    async def test_singleton_behavior(self, container):\n        \"\"\"Test that singleton instances are shared.\"\"\"\n        # Get database connection multiple times\n        db1 = container.get(DatabaseConnection)\n        db2 = container.get(DatabaseConnection)\n\n        # Should be the same instance\n        assert db1 is db2\n        assert db1.connection_id == db2.connection_id\n\n    @pytest.mark.asyncio\n    async def test_scoped_behavior(self, container):\n        \"\"\"Test scoped instance behavior.\"\"\"\n        # First scope\n        with container.create_scope() as scope1:\n            repo1a = scope1.get(UserRepository)\n            repo1b = scope1.get(UserRepository)\n\n            # Same instance within scope\n            assert repo1a is repo1b\n\n            # Should use same database connection\n            assert repo1a.db_connection is repo1b.db_connection\n\n        # Second scope\n        with container.create_scope() as scope2:\n            repo2 = scope2.get(UserRepository)\n\n            # Different instance in different scope\n            assert repo2 is not repo1a\n\n            # But same database connection (singleton)\n            assert repo2.db_connection is repo1a.db_connection\n\n    @pytest.mark.asyncio\n    async def test_transient_behavior(self, container):\n        \"\"\"Test transient instance behavior.\"\"\"\n        with container.create_scope() as scope:\n            service1 = scope.get(UserService)\n            service2 = scope.get(UserService)\n\n            # Different instances each time\n            assert service1 is not service2\n\n            # But same repository (scoped)\n            assert service1.user_repository is service2.user_repository\n\n    @pytest.mark.asyncio\n    async def test_lifecycle_management(self, container):\n        \"\"\"Test proper lifecycle management in scopes.\"\"\"\n        db_conn = container.get(DatabaseConnection)\n        await db_conn.open()\n\n        initial_transaction_count = db_conn.transaction_count\n\n        # Create multiple services and use them\n        async with container.create_async_scope() as scope:\n            service = scope.get(UserService)\n\n            await service.create_user(\"John\", \"john@example.com\")\n            await service.create_user(\"Jane\", \"jane@example.com\")\n\n        # Database should have been used\n        assert db_conn.transaction_count &gt; initial_transaction_count\n</code></pre>"},{"location":"best-practices/testing-strategies/#integration-testing","title":"\ud83d\udd2c Integration Testing","text":""},{"location":"best-practices/testing-strategies/#testing-real-dependencies","title":"Testing Real Dependencies","text":"<pre><code># test_integration.py\nimport pytest\nimport tempfile\nimport sqlite3\nimport aiofiles\nimport os\nfrom pathlib import Path\nfrom injectq import InjectQ, inject, Module\n\n# Real implementations for integration testing\nclass SQLiteDatabase:\n    @inject\n    def __init__(self, database_path: str):\n        self.database_path = database_path\n        self.connection = None\n\n    async def connect(self):\n        self.connection = sqlite3.connect(self.database_path)\n        await self._create_tables()\n\n    async def close(self):\n        if self.connection:\n            self.connection.close()\n\n    async def _create_tables(self):\n        self.connection.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS users (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                name TEXT NOT NULL,\n                email TEXT UNIQUE NOT NULL,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        \"\"\")\n        self.connection.commit()\n\nclass SQLiteUserRepository:\n    @inject\n    def __init__(self, database: SQLiteDatabase):\n        self.database = database\n\n    async def save_user(self, name: str, email: str) -&gt; int:\n        cursor = self.database.connection.execute(\n            \"INSERT INTO users (name, email) VALUES (?, ?)\",\n            (name, email)\n        )\n        self.database.connection.commit()\n        return cursor.lastrowid\n\n    async def get_user(self, user_id: int) -&gt; dict:\n        cursor = self.database.connection.execute(\n            \"SELECT id, name, email, created_at FROM users WHERE id = ?\",\n            (user_id,)\n        )\n        row = cursor.fetchone()\n\n        if row:\n            return {\n                \"id\": row[0],\n                \"name\": row[1],\n                \"email\": row[2],\n                \"created_at\": row[3]\n            }\n        return None\n\n    async def find_by_email(self, email: str) -&gt; dict:\n        cursor = self.database.connection.execute(\n            \"SELECT id, name, email, created_at FROM users WHERE email = ?\",\n            (email,)\n        )\n        row = cursor.fetchone()\n\n        if row:\n            return {\n                \"id\": row[0],\n                \"name\": row[1],\n                \"email\": row[2],\n                \"created_at\": row[3]\n            }\n        return None\n\nclass FileLoggerService:\n    @inject\n    def __init__(self, log_file_path: str):\n        self.log_file_path = log_file_path\n\n    async def log(self, level: str, message: str):\n        async with aiofiles.open(self.log_file_path, 'a') as f:\n            await f.write(f\"[{level}] {message}\\n\")\n\nclass UserRegistrationService:\n    @inject\n    def __init__(\n        self, \n        user_repository: SQLiteUserRepository,\n        logger: FileLoggerService\n    ):\n        self.user_repository = user_repository\n        self.logger = logger\n\n    async def register_user(self, name: str, email: str) -&gt; dict:\n        \"\"\"Register a new user with validation and logging.\"\"\"\n        await self.logger.log(\"INFO\", f\"Attempting to register user: {email}\")\n\n        # Check if user already exists\n        existing_user = await self.user_repository.find_by_email(email)\n        if existing_user:\n            await self.logger.log(\"ERROR\", f\"User already exists: {email}\")\n            raise ValueError(\"User with this email already exists\")\n\n        # Validate email format (simple check)\n        if \"@\" not in email:\n            await self.logger.log(\"ERROR\", f\"Invalid email format: {email}\")\n            raise ValueError(\"Invalid email format\")\n\n        # Save user\n        user_id = await self.user_repository.save_user(name, email)\n        user = await self.user_repository.get_user(user_id)\n\n        await self.logger.log(\"INFO\", f\"User registered successfully: {email} (ID: {user_id})\")\n        return user\n\n# Integration test module\nclass IntegrationTestModule(Module):\n    def __init__(self, temp_dir: str):\n        self.temp_dir = temp_dir\n\n    def configure(self):\n        # Real file paths in temp directory\n        db_path = os.path.join(self.temp_dir, \"test.db\")\n        log_path = os.path.join(self.temp_dir, \"test.log\")\n\n        self.bind(str, db_path, name=\"database_path\")\n        self.bind(str, log_path, name=\"log_file_path\")\n\n        # Real implementations\n        self.bind(SQLiteDatabase, SQLiteDatabase).singleton()\n        self.bind(SQLiteUserRepository, SQLiteUserRepository).singleton()\n        self.bind(FileLoggerService, FileLoggerService).singleton()\n        self.bind(UserRegistrationService, UserRegistrationService).singleton()\n\nclass TestUserRegistrationIntegration:\n    @pytest.fixture\n    async def temp_container(self):\n        \"\"\"Create container with real dependencies in temp directory.\"\"\"\n        with tempfile.TemporaryDirectory() as temp_dir:\n            container = InjectQ()\n            container.install(IntegrationTestModule(temp_dir))\n\n            # Initialize database\n            database = container.get(SQLiteDatabase)\n            await database.connect()\n\n            yield container, temp_dir\n\n            # Cleanup\n            await database.close()\n\n    @pytest.mark.asyncio\n    async def test_complete_user_registration_flow(self, temp_container):\n        \"\"\"Test complete user registration with real database and file logging.\"\"\"\n        container, temp_dir = temp_container\n\n        registration_service = container.get(UserRegistrationService)\n\n        # Register a user\n        user = await registration_service.register_user(\"John Doe\", \"john@example.com\")\n\n        # Verify user was saved\n        assert user[\"id\"] is not None\n        assert user[\"name\"] == \"John Doe\"\n        assert user[\"email\"] == \"john@example.com\"\n        assert user[\"created_at\"] is not None\n\n        # Verify logging occurred\n        log_path = os.path.join(temp_dir, \"test.log\")\n        assert os.path.exists(log_path)\n\n        with open(log_path, 'r') as f:\n            log_content = f.read()\n            assert \"Attempting to register user: john@example.com\" in log_content\n            assert \"User registered successfully: john@example.com\" in log_content\n\n    @pytest.mark.asyncio\n    async def test_duplicate_user_registration(self, temp_container):\n        \"\"\"Test duplicate user registration prevention.\"\"\"\n        container, temp_dir = temp_container\n\n        registration_service = container.get(UserRegistrationService)\n\n        # Register first user\n        await registration_service.register_user(\"John Doe\", \"john@example.com\")\n\n        # Try to register duplicate user\n        with pytest.raises(ValueError, match=\"User with this email already exists\"):\n            await registration_service.register_user(\"Jane Doe\", \"john@example.com\")\n\n        # Verify error was logged\n        log_path = os.path.join(temp_dir, \"test.log\")\n        with open(log_path, 'r') as f:\n            log_content = f.read()\n            assert \"User already exists: john@example.com\" in log_content\n\n    @pytest.mark.asyncio\n    async def test_invalid_email_validation(self, temp_container):\n        \"\"\"Test email validation.\"\"\"\n        container, temp_dir = temp_container\n\n        registration_service = container.get(UserRegistrationService)\n\n        # Try to register user with invalid email\n        with pytest.raises(ValueError, match=\"Invalid email format\"):\n            await registration_service.register_user(\"John Doe\", \"invalid-email\")\n\n        # Verify error was logged\n        log_path = os.path.join(temp_dir, \"test.log\")\n        with open(log_path, 'r') as f:\n            log_content = f.read()\n            assert \"Invalid email format: invalid-email\" in log_content\n\n    @pytest.mark.asyncio\n    async def test_database_persistence(self, temp_container):\n        \"\"\"Test that data persists in database.\"\"\"\n        container, temp_dir = temp_container\n\n        # Get services\n        registration_service = container.get(UserRegistrationService)\n        user_repository = container.get(SQLiteUserRepository)\n\n        # Register multiple users\n        user1 = await registration_service.register_user(\"User One\", \"user1@example.com\")\n        user2 = await registration_service.register_user(\"User Two\", \"user2@example.com\")\n\n        # Verify both users can be retrieved directly from repository\n        retrieved_user1 = await user_repository.get_user(user1[\"id\"])\n        retrieved_user2 = await user_repository.get_user(user2[\"id\"])\n\n        assert retrieved_user1[\"email\"] == \"user1@example.com\"\n        assert retrieved_user2[\"email\"] == \"user2@example.com\"\n\n        # Test find by email\n        found_user = await user_repository.find_by_email(\"user1@example.com\")\n        assert found_user[\"id\"] == user1[\"id\"]\n</code></pre>"},{"location":"best-practices/testing-strategies/#mock-strategies-and-patterns","title":"\ud83c\udfad Mock Strategies and Patterns","text":""},{"location":"best-practices/testing-strategies/#advanced-mocking-techniques","title":"Advanced Mocking Techniques","text":"<pre><code># test_advanced_mocking.py\nimport pytest\nfrom unittest.mock import Mock, AsyncMock, MagicMock, patch\nfrom contextlib import contextmanager\nfrom typing import Dict, Any, List\nfrom injectq import InjectQ, inject, Module\nfrom injectq.testing import TestModule, mock_service\n\n# Complex service with multiple dependencies\nclass PaymentGateway:\n    async def charge(self, amount: float, card_token: str) -&gt; Dict[str, Any]:\n        \"\"\"Charge payment method.\"\"\"\n        pass\n\n    async def refund(self, charge_id: str) -&gt; Dict[str, Any]:\n        \"\"\"Refund a charge.\"\"\"\n        pass\n\nclass InventoryService:\n    async def check_stock(self, product_id: str) -&gt; int:\n        \"\"\"Check available stock.\"\"\"\n        pass\n\n    async def reserve_items(self, product_id: str, quantity: int) -&gt; str:\n        \"\"\"Reserve items and return reservation ID.\"\"\"\n        pass\n\n    async def release_reservation(self, reservation_id: str):\n        \"\"\"Release a reservation.\"\"\"\n        pass\n\nclass NotificationService:\n    async def send_order_confirmation(self, user_id: str, order_data: Dict[str, Any]):\n        \"\"\"Send order confirmation.\"\"\"\n        pass\n\n    async def send_payment_failure(self, user_id: str, error: str):\n        \"\"\"Send payment failure notification.\"\"\"\n        pass\n\nclass OrderProcessingService:\n    @inject\n    def __init__(\n        self,\n        payment_gateway: PaymentGateway,\n        inventory_service: InventoryService,\n        notification_service: NotificationService\n    ):\n        self.payment_gateway = payment_gateway\n        self.inventory_service = inventory_service\n        self.notification_service = notification_service\n\n    async def process_order(\n        self, \n        user_id: str, \n        product_id: str, \n        quantity: int, \n        card_token: str, \n        unit_price: float\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Process complete order workflow.\"\"\"\n\n        # Check inventory\n        available_stock = await self.inventory_service.check_stock(product_id)\n        if available_stock &lt; quantity:\n            return {\n                \"status\": \"failed\",\n                \"reason\": \"insufficient_stock\",\n                \"available\": available_stock\n            }\n\n        # Reserve inventory\n        try:\n            reservation_id = await self.inventory_service.reserve_items(product_id, quantity)\n        except Exception as e:\n            return {\n                \"status\": \"failed\",\n                \"reason\": \"reservation_failed\",\n                \"error\": str(e)\n            }\n\n        # Process payment\n        total_amount = quantity * unit_price\n        try:\n            payment_result = await self.payment_gateway.charge(total_amount, card_token)\n\n            if not payment_result.get(\"success\"):\n                # Release reservation on payment failure\n                await self.inventory_service.release_reservation(reservation_id)\n                await self.notification_service.send_payment_failure(\n                    user_id, \n                    payment_result.get(\"error\", \"Payment failed\")\n                )\n                return {\n                    \"status\": \"failed\",\n                    \"reason\": \"payment_failed\",\n                    \"error\": payment_result.get(\"error\")\n                }\n\n            # Send confirmation\n            order_data = {\n                \"product_id\": product_id,\n                \"quantity\": quantity,\n                \"total_amount\": total_amount,\n                \"charge_id\": payment_result[\"charge_id\"]\n            }\n\n            await self.notification_service.send_order_confirmation(user_id, order_data)\n\n            return {\n                \"status\": \"success\",\n                \"order_data\": order_data,\n                \"reservation_id\": reservation_id\n            }\n\n        except Exception as e:\n            # Release reservation on any error\n            await self.inventory_service.release_reservation(reservation_id)\n            return {\n                \"status\": \"failed\",\n                \"reason\": \"processing_error\",\n                \"error\": str(e)\n            }\n\n# Smart mock factory\nclass SmartMockFactory:\n    \"\"\"Factory for creating intelligent mocks with realistic behavior.\"\"\"\n\n    @staticmethod\n    def create_payment_gateway_mock(scenarios: Dict[str, Any] = None) -&gt; Mock:\n        \"\"\"Create payment gateway mock with configurable scenarios.\"\"\"\n        mock = Mock(spec=PaymentGateway)\n\n        # Default scenarios\n        default_scenarios = {\n            \"success\": {\"success\": True, \"charge_id\": \"charge_123\"},\n            \"insufficient_funds\": {\"success\": False, \"error\": \"Insufficient funds\"},\n            \"invalid_card\": {\"success\": False, \"error\": \"Invalid card\"},\n            \"network_error\": Exception(\"Network timeout\")\n        }\n\n        scenarios = scenarios or default_scenarios\n\n        async def charge_side_effect(amount: float, card_token: str):\n            # Simulate different responses based on card token\n            if card_token == \"invalid_card\":\n                return scenarios.get(\"invalid_card\", default_scenarios[\"invalid_card\"])\n            elif card_token == \"insufficient_funds\":\n                return scenarios.get(\"insufficient_funds\", default_scenarios[\"insufficient_funds\"])\n            elif card_token == \"network_error\":\n                raise scenarios.get(\"network_error\", default_scenarios[\"network_error\"])\n            else:\n                return scenarios.get(\"success\", default_scenarios[\"success\"])\n\n        mock.charge = AsyncMock(side_effect=charge_side_effect)\n        mock.refund = AsyncMock(return_value={\"success\": True, \"refund_id\": \"refund_123\"})\n\n        return mock\n\n    @staticmethod\n    def create_inventory_mock(stock_levels: Dict[str, int] = None) -&gt; Mock:\n        \"\"\"Create inventory service mock with configurable stock levels.\"\"\"\n        mock = Mock(spec=InventoryService)\n\n        stock_levels = stock_levels or {}\n        reservations = {}\n        reservation_counter = 0\n\n        async def check_stock_side_effect(product_id: str):\n            return stock_levels.get(product_id, 0)\n\n        async def reserve_items_side_effect(product_id: str, quantity: int):\n            nonlocal reservation_counter\n\n            available = stock_levels.get(product_id, 0)\n            if available &lt; quantity:\n                raise ValueError(f\"Insufficient stock: {available} &lt; {quantity}\")\n\n            reservation_counter += 1\n            reservation_id = f\"reservation_{reservation_counter}\"\n\n            reservations[reservation_id] = {\n                \"product_id\": product_id,\n                \"quantity\": quantity\n            }\n\n            # Update stock\n            stock_levels[product_id] = available - quantity\n\n            return reservation_id\n\n        async def release_reservation_side_effect(reservation_id: str):\n            if reservation_id in reservations:\n                reservation = reservations.pop(reservation_id)\n                # Restore stock\n                product_id = reservation[\"product_id\"]\n                quantity = reservation[\"quantity\"]\n                stock_levels[product_id] = stock_levels.get(product_id, 0) + quantity\n\n        mock.check_stock = AsyncMock(side_effect=check_stock_side_effect)\n        mock.reserve_items = AsyncMock(side_effect=reserve_items_side_effect)\n        mock.release_reservation = AsyncMock(side_effect=release_reservation_side_effect)\n\n        return mock\n\n    @staticmethod\n    def create_notification_mock(capture_calls: bool = True) -&gt; Mock:\n        \"\"\"Create notification service mock that captures calls.\"\"\"\n        mock = Mock(spec=NotificationService)\n\n        if capture_calls:\n            mock.sent_confirmations = []\n            mock.sent_failures = []\n\n            async def capture_confirmation(user_id: str, order_data: Dict[str, Any]):\n                mock.sent_confirmations.append({\n                    \"user_id\": user_id,\n                    \"order_data\": order_data\n                })\n\n            async def capture_failure(user_id: str, error: str):\n                mock.sent_failures.append({\n                    \"user_id\": user_id,\n                    \"error\": error\n                })\n\n            mock.send_order_confirmation = AsyncMock(side_effect=capture_confirmation)\n            mock.send_payment_failure = AsyncMock(side_effect=capture_failure)\n        else:\n            mock.send_order_confirmation = AsyncMock()\n            mock.send_payment_failure = AsyncMock()\n\n        return mock\n\n# Advanced test class with sophisticated mock scenarios\nclass TestOrderProcessingAdvanced:\n    @pytest.fixture\n    def success_scenario_container(self):\n        \"\"\"Container configured for successful order processing.\"\"\"\n        container = InjectQ()\n\n        class SuccessTestModule(TestModule):\n            def configure(self):\n                # Configure mocks for success scenario\n                payment_mock = SmartMockFactory.create_payment_gateway_mock()\n                inventory_mock = SmartMockFactory.create_inventory_mock({\"product_1\": 10})\n                notification_mock = SmartMockFactory.create_notification_mock()\n\n                self.bind(PaymentGateway, payment_mock).singleton()\n                self.bind(InventoryService, inventory_mock).singleton()\n                self.bind(NotificationService, notification_mock).singleton()\n                self.bind(OrderProcessingService, OrderProcessingService).scoped()\n\n        container.install(SuccessTestModule())\n        return container\n\n    @pytest.fixture\n    def failure_scenario_container(self):\n        \"\"\"Container configured for various failure scenarios.\"\"\"\n        container = InjectQ()\n\n        class FailureTestModule(TestModule):\n            def configure(self):\n                # Configure mocks for failure scenarios\n                payment_mock = SmartMockFactory.create_payment_gateway_mock()\n                inventory_mock = SmartMockFactory.create_inventory_mock({\"product_1\": 2})  # Low stock\n                notification_mock = SmartMockFactory.create_notification_mock()\n\n                self.bind(PaymentGateway, payment_mock).singleton()\n                self.bind(InventoryService, inventory_mock).singleton()\n                self.bind(NotificationService, notification_mock).singleton()\n                self.bind(OrderProcessingService, OrderProcessingService).scoped()\n\n        container.install(FailureTestModule())\n        return container\n\n    @pytest.mark.asyncio\n    async def test_successful_order_processing(self, success_scenario_container):\n        \"\"\"Test complete successful order processing flow.\"\"\"\n        order_service = success_scenario_container.get(OrderProcessingService)\n        notification_mock = success_scenario_container.get(NotificationService)\n\n        result = await order_service.process_order(\n            user_id=\"user123\",\n            product_id=\"product_1\",\n            quantity=2,\n            card_token=\"valid_card\",\n            unit_price=25.99\n        )\n\n        # Verify success\n        assert result[\"status\"] == \"success\"\n        assert result[\"order_data\"][\"total_amount\"] == 51.98\n        assert \"reservation_id\" in result\n\n        # Verify notification was sent\n        assert len(notification_mock.sent_confirmations) == 1\n        assert notification_mock.sent_confirmations[0][\"user_id\"] == \"user123\"\n        assert len(notification_mock.sent_failures) == 0\n\n    @pytest.mark.asyncio\n    async def test_insufficient_stock_scenario(self, failure_scenario_container):\n        \"\"\"Test handling of insufficient stock.\"\"\"\n        order_service = failure_scenario_container.get(OrderProcessingService)\n\n        result = await order_service.process_order(\n            user_id=\"user123\",\n            product_id=\"product_1\",\n            quantity=5,  # More than available (2)\n            card_token=\"valid_card\",\n            unit_price=25.99\n        )\n\n        # Verify failure\n        assert result[\"status\"] == \"failed\"\n        assert result[\"reason\"] == \"insufficient_stock\"\n        assert result[\"available\"] == 2\n\n    @pytest.mark.asyncio\n    async def test_payment_failure_with_reservation_cleanup(self, success_scenario_container):\n        \"\"\"Test payment failure and proper reservation cleanup.\"\"\"\n        order_service = success_scenario_container.get(OrderProcessingService)\n        inventory_mock = success_scenario_container.get(InventoryService)\n        notification_mock = success_scenario_container.get(NotificationService)\n\n        # Process order with invalid card\n        result = await order_service.process_order(\n            user_id=\"user123\",\n            product_id=\"product_1\",\n            quantity=2,\n            card_token=\"insufficient_funds\",  # Will trigger payment failure\n            unit_price=25.99\n        )\n\n        # Verify failure\n        assert result[\"status\"] == \"failed\"\n        assert result[\"reason\"] == \"payment_failed\"\n\n        # Verify reservation was released (stock should be back to original)\n        remaining_stock = await inventory_mock.check_stock(\"product_1\")\n        assert remaining_stock == 10  # Should be restored\n\n        # Verify failure notification was sent\n        assert len(notification_mock.sent_failures) == 1\n        assert notification_mock.sent_failures[0][\"error\"] == \"Insufficient funds\"\n\n    @pytest.mark.asyncio\n    async def test_network_error_handling(self, success_scenario_container):\n        \"\"\"Test handling of network errors during payment.\"\"\"\n        order_service = success_scenario_container.get(OrderProcessingService)\n        inventory_mock = success_scenario_container.get(InventoryService)\n\n        result = await order_service.process_order(\n            user_id=\"user123\",\n            product_id=\"product_1\",\n            quantity=2,\n            card_token=\"network_error\",  # Will trigger exception\n            unit_price=25.99\n        )\n\n        # Verify error handling\n        assert result[\"status\"] == \"failed\"\n        assert result[\"reason\"] == \"processing_error\"\n        assert \"Network timeout\" in result[\"error\"]\n\n        # Verify reservation was cleaned up\n        remaining_stock = await inventory_mock.check_stock(\"product_1\")\n        assert remaining_stock == 10\n\n# Parameterized testing with mocks\nclass TestParameterizedMockScenarios:\n    @pytest.mark.parametrize(\"card_token,expected_status,expected_reason\", [\n        (\"valid_card\", \"success\", None),\n        (\"insufficient_funds\", \"failed\", \"payment_failed\"),\n        (\"invalid_card\", \"failed\", \"payment_failed\"),\n        (\"network_error\", \"failed\", \"processing_error\"),\n    ])\n    @pytest.mark.asyncio\n    async def test_payment_scenarios(self, card_token, expected_status, expected_reason):\n        \"\"\"Test various payment scenarios using parameterized testing.\"\"\"\n        container = InjectQ()\n\n        class ScenarioTestModule(TestModule):\n            def configure(self):\n                payment_mock = SmartMockFactory.create_payment_gateway_mock()\n                inventory_mock = SmartMockFactory.create_inventory_mock({\"product_1\": 10})\n                notification_mock = SmartMockFactory.create_notification_mock()\n\n                self.bind(PaymentGateway, payment_mock).singleton()\n                self.bind(InventoryService, inventory_mock).singleton()\n                self.bind(NotificationService, notification_mock).singleton()\n                self.bind(OrderProcessingService, OrderProcessingService).scoped()\n\n        container.install(ScenarioTestModule())\n        order_service = container.get(OrderProcessingService)\n\n        result = await order_service.process_order(\n            user_id=\"user123\",\n            product_id=\"product_1\",\n            quantity=2,\n            card_token=card_token,\n            unit_price=25.99\n        )\n\n        assert result[\"status\"] == expected_status\n        if expected_reason:\n            assert result[\"reason\"] == expected_reason\n</code></pre>"},{"location":"best-practices/testing-strategies/#performance-testing","title":"\ud83d\udcca Performance Testing","text":""},{"location":"best-practices/testing-strategies/#load-testing-with-injectq","title":"Load Testing with InjectQ","text":"<pre><code># test_performance.py\nimport pytest\nimport asyncio\nimport time\nimport statistics\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import List, Dict, Any\nfrom injectq import InjectQ, inject, Module\n\n# Service for performance testing\nclass CacheService:\n    def __init__(self):\n        self.cache: Dict[str, Any] = {}\n        self.hit_count = 0\n        self.miss_count = 0\n\n    async def get(self, key: str) -&gt; Any:\n        if key in self.cache:\n            self.hit_count += 1\n            return self.cache[key]\n        else:\n            self.miss_count += 1\n            return None\n\n    async def set(self, key: str, value: Any):\n        self.cache[key] = value\n\n    def get_stats(self) -&gt; Dict[str, int]:\n        return {\n            \"hits\": self.hit_count,\n            \"misses\": self.miss_count,\n            \"total_keys\": len(self.cache)\n        }\n\nclass DataProcessor:\n    @inject\n    def __init__(self, cache_service: CacheService):\n        self.cache_service = cache_service\n\n    async def process_data(self, data_id: str, data: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Process data with caching.\"\"\"\n        # Check cache first\n        cached_result = await self.cache_service.get(f\"processed_{data_id}\")\n        if cached_result:\n            return cached_result\n\n        # Simulate processing time\n        await asyncio.sleep(0.01)  # 10ms processing time\n\n        # Process data\n        result = {\n            \"id\": data_id,\n            \"processed_data\": {k: v * 2 if isinstance(v, (int, float)) else v for k, v in data.items()},\n            \"timestamp\": time.time()\n        }\n\n        # Cache result\n        await self.cache_service.set(f\"processed_{data_id}\", result)\n\n        return result\n\nclass PerformanceTestModule(Module):\n    def configure(self):\n        self.bind(CacheService, CacheService).singleton()\n        self.bind(DataProcessor, DataProcessor).scoped()\n\nclass TestPerformance:\n    @pytest.fixture\n    def container(self):\n        container = InjectQ()\n        container.install(PerformanceTestModule())\n        return container\n\n    @pytest.mark.asyncio\n    async def test_dependency_injection_overhead(self, container):\n        \"\"\"Test performance overhead of dependency injection.\"\"\"\n\n        # Test direct instantiation vs DI\n        direct_times = []\n        di_times = []\n\n        # Direct instantiation timing\n        for _ in range(1000):\n            start = time.perf_counter()\n            cache_service = CacheService()\n            processor = DataProcessor(cache_service)\n            end = time.perf_counter()\n            direct_times.append(end - start)\n\n        # DI instantiation timing\n        for _ in range(1000):\n            start = time.perf_counter()\n            processor = container.get(DataProcessor)\n            end = time.perf_counter()\n            di_times.append(end - start)\n\n        # Calculate statistics\n        direct_avg = statistics.mean(direct_times)\n        di_avg = statistics.mean(di_times)\n        overhead_ratio = di_avg / direct_avg\n\n        print(f\"\\nDirect instantiation avg: {direct_avg*1000:.3f}ms\")\n        print(f\"DI instantiation avg: {di_avg*1000:.3f}ms\")\n        print(f\"Overhead ratio: {overhead_ratio:.2f}x\")\n\n        # Assert reasonable overhead (should be less than 10x)\n        assert overhead_ratio &lt; 10.0\n\n    @pytest.mark.asyncio\n    async def test_concurrent_access_performance(self, container):\n        \"\"\"Test performance under concurrent access.\"\"\"\n\n        async def process_batch(processor: DataProcessor, batch_id: int, batch_size: int):\n            \"\"\"Process a batch of data items.\"\"\"\n            tasks = []\n            for i in range(batch_size):\n                data_id = f\"batch_{batch_id}_item_{i}\"\n                data = {\"value\": i, \"batch\": batch_id}\n                tasks.append(processor.process_data(data_id, data))\n\n            return await asyncio.gather(*tasks)\n\n        # Test with increasing concurrency\n        concurrency_levels = [1, 5, 10, 20]\n        batch_size = 50\n\n        results = {}\n\n        for concurrency in concurrency_levels:\n            start_time = time.perf_counter()\n\n            # Create tasks for concurrent execution\n            tasks = []\n            for batch_id in range(concurrency):\n                # Each batch gets its own processor instance (scoped)\n                with container.create_scope() as scope:\n                    processor = scope.get(DataProcessor)\n                    tasks.append(process_batch(processor, batch_id, batch_size))\n\n            # Execute all batches concurrently\n            batch_results = await asyncio.gather(*tasks)\n\n            end_time = time.perf_counter()\n\n            total_items = concurrency * batch_size\n            duration = end_time - start_time\n            throughput = total_items / duration\n\n            results[concurrency] = {\n                \"duration\": duration,\n                \"throughput\": throughput,\n                \"total_items\": total_items\n            }\n\n            print(f\"\\nConcurrency {concurrency}: {total_items} items in {duration:.3f}s ({throughput:.1f} items/s)\")\n\n        # Verify that higher concurrency improves throughput (to a point)\n        assert results[5][\"throughput\"] &gt; results[1][\"throughput\"]\n\n    @pytest.mark.asyncio\n    async def test_scope_creation_performance(self, container):\n        \"\"\"Test performance of scope creation and cleanup.\"\"\"\n\n        scope_creation_times = []\n        scope_usage_times = []\n\n        for _ in range(1000):\n            # Test scope creation time\n            start = time.perf_counter()\n            scope = container.create_scope()\n            scope_created = time.perf_counter()\n\n            # Test service resolution time within scope\n            processor = scope.get(DataProcessor)\n            scope_used = time.perf_counter()\n\n            # Cleanup\n            scope.dispose()\n            end = time.perf_counter()\n\n            scope_creation_times.append(scope_created - start)\n            scope_usage_times.append(scope_used - scope_created)\n\n        creation_avg = statistics.mean(scope_creation_times) * 1000  # Convert to ms\n        usage_avg = statistics.mean(scope_usage_times) * 1000\n\n        print(f\"\\nScope creation avg: {creation_avg:.3f}ms\")\n        print(f\"Service resolution avg: {usage_avg:.3f}ms\")\n\n        # Assert reasonable performance\n        assert creation_avg &lt; 1.0  # Less than 1ms for scope creation\n        assert usage_avg &lt; 1.0     # Less than 1ms for service resolution\n\n    @pytest.mark.asyncio\n    async def test_memory_usage_stability(self, container):\n        \"\"\"Test memory usage stability over many operations.\"\"\"\n        import gc\n        import psutil\n        import os\n\n        process = psutil.Process(os.getpid())\n        initial_memory = process.memory_info().rss\n\n        # Perform many operations\n        for i in range(100):\n            with container.create_scope() as scope:\n                processor = scope.get(DataProcessor)\n\n                # Process multiple items\n                tasks = []\n                for j in range(10):\n                    data_id = f\"memory_test_{i}_{j}\"\n                    data = {\"value\": j, \"iteration\": i}\n                    tasks.append(processor.process_data(data_id, data))\n\n                await asyncio.gather(*tasks)\n\n            # Force garbage collection every 10 iterations\n            if i % 10 == 0:\n                gc.collect()\n\n        final_memory = process.memory_info().rss\n        memory_increase = final_memory - initial_memory\n        memory_increase_mb = memory_increase / (1024 * 1024)\n\n        print(f\"\\nMemory increase: {memory_increase_mb:.2f} MB\")\n\n        # Assert reasonable memory usage (less than 50MB increase)\n        assert memory_increase_mb &lt; 50.0\n\n# Stress testing\nclass TestStress:\n    @pytest.mark.asyncio\n    async def test_high_load_stress(self, container):\n        \"\"\"Stress test with high load.\"\"\"\n\n        async def stress_worker(worker_id: int, operations: int):\n            \"\"\"Worker that performs many operations.\"\"\"\n            for i in range(operations):\n                with container.create_scope() as scope:\n                    processor = scope.get(DataProcessor)\n\n                    data_id = f\"stress_{worker_id}_{i}\"\n                    data = {\"worker\": worker_id, \"operation\": i}\n\n                    await processor.process_data(data_id, data)\n\n        # Create many concurrent workers\n        num_workers = 50\n        operations_per_worker = 100\n\n        start_time = time.perf_counter()\n\n        tasks = [\n            stress_worker(worker_id, operations_per_worker) \n            for worker_id in range(num_workers)\n        ]\n\n        await asyncio.gather(*tasks)\n\n        end_time = time.perf_counter()\n\n        total_operations = num_workers * operations_per_worker\n        duration = end_time - start_time\n        throughput = total_operations / duration\n\n        print(f\"\\nStress test: {total_operations} operations in {duration:.3f}s\")\n        print(f\"Throughput: {throughput:.1f} operations/s\")\n\n        # Verify system handled the load\n        assert duration &lt; 60.0  # Should complete within 60 seconds\n        assert throughput &gt; 100  # Should handle at least 100 ops/sec\n</code></pre> <p>This comprehensive testing guide covers:</p> <ol> <li>Unit Testing: Basic mocking, dependency injection testing, scope behavior</li> <li>Integration Testing: Real dependencies, file/database integration, end-to-end flows</li> <li>Advanced Mocking: Smart mock factories, sophisticated scenarios, parameterized testing</li> <li>Performance Testing: Load testing, memory usage, concurrent access, stress testing</li> </ol> <p>Key testing principles demonstrated: - Proper mock configuration and behavior - Scope lifecycle management in tests - Real vs. mocked dependency strategies - Performance benchmarking and validation - Memory leak detection and prevention - Concurrent access patterns</p> <p>Ready to add the debugging and troubleshooting best practices to complete the section?</p>"},{"location":"core-concepts/auto-registration-override-control/","title":"Auto-Registration and Override Control","text":"<p>InjectQ provides two powerful features for managing service registrations: allow_concrete and allow_override. These features give you fine-grained control over how services are registered and managed in your dependency injection container.</p>"},{"location":"core-concepts/auto-registration-override-control/#allow-concrete-auto-registration","title":"Allow Concrete Auto-Registration","text":"<p>The <code>allow_concrete</code> parameter controls whether InjectQ automatically registers concrete types when you register an instance to its base type.</p>"},{"location":"core-concepts/auto-registration-override-control/#how-it-works","title":"How It Works","text":"<p>When you register an instance to a base class or interface, InjectQ can optionally also register the same instance to its concrete type:</p> <pre><code>from abc import ABC, abstractmethod\nfrom injectq import InjectQ\n\nclass BaseService(ABC):\n    @abstractmethod\n    def method(self) -&gt; str:\n        pass\n\nclass ConcreteService(BaseService):\n    def method(self) -&gt; str:\n        return \"Implementation\"\n\n# Create container and instance\ncontainer = InjectQ()\ninstance = ConcreteService()\n\n# Register to base type with allow_concrete=True (default)\ncontainer[BaseService] = instance\n\n# Both types are now registered\nbase_result = container.get(BaseService)      # Returns the instance\nconcrete_result = container.get(ConcreteService)  # Returns the same instance\nassert base_result is concrete_result  # True\n</code></pre>"},{"location":"core-concepts/auto-registration-override-control/#usage-in-different-methods","title":"Usage in Different Methods","text":"<p>The <code>allow_concrete</code> parameter is available in all registration methods:</p>"},{"location":"core-concepts/auto-registration-override-control/#dict-like-syntax-always-true","title":"Dict-like syntax (always True)","text":"<pre><code>container[BaseService] = instance  # allow_concrete=True by default\n</code></pre>"},{"location":"core-concepts/auto-registration-override-control/#bind_instance-method","title":"bind_instance method","text":"<pre><code># Auto-register concrete type (default)\ncontainer.bind_instance(BaseService, instance, allow_concrete=True)\n\n# Don't auto-register concrete type\ncontainer.bind_instance(BaseService, instance, allow_concrete=False)\n</code></pre>"},{"location":"core-concepts/auto-registration-override-control/#bind-method","title":"bind method","text":"<pre><code># Auto-register concrete type (default)\ncontainer.bind(BaseService, instance, allow_concrete=True)\n\n# Don't auto-register concrete type\ncontainer.bind(BaseService, instance, allow_concrete=False)\n</code></pre>"},{"location":"core-concepts/auto-registration-override-control/#bind_factory-method","title":"bind_factory method","text":"<pre><code>def factory() -&gt; ConcreteService:\n    return ConcreteService()\n\n# Auto-register concrete type (default)\ncontainer.bind_factory(BaseService, factory, allow_concrete=True)\n\n# Don't auto-register concrete type\ncontainer.bind_factory(BaseService, factory, allow_concrete=False)\n</code></pre>"},{"location":"core-concepts/auto-registration-override-control/#when-to-use-allow_concretefalse","title":"When to Use allow_concrete=False","text":"<p>Use <code>allow_concrete=False</code> when:</p> <ol> <li>Multiple implementations: You have multiple implementations of the same base type and want to avoid conflicts</li> <li>Explicit registration: You want full control over which types are registered</li> <li>Interface segregation: You only want to expose the interface, not the implementation</li> </ol> <pre><code>class ServiceA(BaseService):\n    def method(self) -&gt; str:\n        return \"Service A\"\n\nclass ServiceB(BaseService):\n    def method(self) -&gt; str:\n        return \"Service B\"\n\n# Register multiple implementations without concrete auto-registration\ncontainer.bind_instance(\"serviceA\", ServiceA(), allow_concrete=False)\ncontainer.bind_instance(\"serviceB\", ServiceB(), allow_concrete=False)\ncontainer.bind_instance(BaseService, ServiceA(), allow_concrete=False)\n\n# Only the explicitly registered keys work\ncontainer.get(\"serviceA\")  # Works\ncontainer.get(\"serviceB\")  # Works\ncontainer.get(BaseService)  # Works\n# container.get(ServiceA)  # Would auto-resolve, not use registered instance\n</code></pre>"},{"location":"core-concepts/auto-registration-override-control/#allow-override-control","title":"Allow Override Control","text":"<p>The <code>allow_override</code> parameter controls whether existing service registrations can be overwritten.</p>"},{"location":"core-concepts/auto-registration-override-control/#container-level-configuration","title":"Container Level Configuration","text":"<p>Set the policy when creating the container:</p> <pre><code># Allow overrides (default behavior)\ncontainer = InjectQ(allow_override=True)\n\n# Prevent overrides\ncontainer = InjectQ(allow_override=False)\n</code></pre>"},{"location":"core-concepts/auto-registration-override-control/#how-it-works_1","title":"How It Works","text":"<p>With <code>allow_override=True</code> (default): <pre><code>container = InjectQ(allow_override=True)\n\ninstance1 = ConcreteService()\ninstance2 = ConcreteService()\n\ncontainer[BaseService] = instance1\ncontainer[BaseService] = instance2  # This works - overwrites first registration\n\nresult = container.get(BaseService)\nassert result is instance2  # True\n</code></pre></p> <p>With <code>allow_override=False</code>: <pre><code>from injectq.utils import AlreadyRegisteredError\n\ncontainer = InjectQ(allow_override=False)\n\ninstance1 = ConcreteService()\ninstance2 = ConcreteService()\n\ncontainer[BaseService] = instance1\ntry:\n    container[BaseService] = instance2  # Raises AlreadyRegisteredError\nexcept AlreadyRegisteredError as e:\n    print(f\"Cannot override: {e}\")\n</code></pre></p>"},{"location":"core-concepts/auto-registration-override-control/#override-control-with-auto-registration","title":"Override Control with Auto-Registration","text":"<p>When using <code>allow_concrete=True</code> and <code>allow_override=False</code>, be aware of potential conflicts:</p> <pre><code>container = InjectQ(allow_override=False)\ninstance1 = ConcreteService()\ninstance2 = ConcreteService()\n\n# This registers both BaseService and ConcreteService\ncontainer[BaseService] = instance1\n\n# This will fail because ConcreteService is already registered\ntry:\n    container[ConcreteService] = instance2  # Raises AlreadyRegisteredError\nexcept AlreadyRegisteredError:\n    print(\"ConcreteService already registered via auto-registration\")\n</code></pre>"},{"location":"core-concepts/auto-registration-override-control/#factory-override-control","title":"Factory Override Control","text":"<p>The same applies to factory registrations:</p> <pre><code>container = InjectQ(allow_override=False)\n\ndef factory1() -&gt; BaseService:\n    return ConcreteService()\n\ndef factory2() -&gt; BaseService:  \n    return ConcreteService()\n\ncontainer.bind_factory(BaseService, factory1)\n\ntry:\n    container.bind_factory(BaseService, factory2)  # Raises AlreadyRegisteredError\nexcept AlreadyRegisteredError:\n    print(\"Factory already registered\")\n</code></pre>"},{"location":"core-concepts/auto-registration-override-control/#best-practices","title":"Best Practices","text":""},{"location":"core-concepts/auto-registration-override-control/#1-use-allow_concretetrue-for-simple-hierarchies","title":"1. Use allow_concrete=True for Simple Hierarchies","text":"<p>When you have straightforward inheritance and want both interface and implementation access:</p> <pre><code>@inject\ndef use_interface(service: BaseService) -&gt; str:\n    return service.method()\n\n@inject  \ndef use_concrete(service: ConcreteService) -&gt; str:\n    return service.method()\n\ncontainer[BaseService] = ConcreteService()\n\n# Both work with the same instance\nresult1 = use_interface()\nresult2 = use_concrete()\n</code></pre>"},{"location":"core-concepts/auto-registration-override-control/#2-use-allow_concretefalse-for-multiple-implementations","title":"2. Use allow_concrete=False for Multiple Implementations","text":"<p>When managing multiple implementations of the same interface:</p> <pre><code>container.bind_instance(\"primary\", PrimaryService(), allow_concrete=False)\ncontainer.bind_instance(\"secondary\", SecondaryService(), allow_concrete=False)\ncontainer.bind_instance(BaseService, PrimaryService(), allow_concrete=False)\n</code></pre>"},{"location":"core-concepts/auto-registration-override-control/#3-use-allow_overridefalse-in-production","title":"3. Use allow_override=False in Production","text":"<p>For production environments where registration conflicts should be errors:</p> <pre><code># Production configuration\ncontainer = InjectQ(allow_override=False)\n\n# Registration errors are caught early\ncontainer.bind_instance(BaseService, service_instance)\n# Later accidental re-registration will fail immediately\n</code></pre>"},{"location":"core-concepts/auto-registration-override-control/#4-use-allow_overridetrue-for-testing","title":"4. Use allow_override=True for Testing","text":"<p>For test environments where you need to mock or replace services:</p> <pre><code># Test configuration  \ncontainer = InjectQ(allow_override=True)\n\n# Original service\ncontainer.bind_instance(BaseService, real_service)\n\n# Test can override with mock\ncontainer.bind_instance(BaseService, mock_service)\n</code></pre>"},{"location":"core-concepts/auto-registration-override-control/#error-handling","title":"Error Handling","text":""},{"location":"core-concepts/auto-registration-override-control/#alreadyregisterederror","title":"AlreadyRegisteredError","text":"<p>Thrown when <code>allow_override=False</code> and attempting to register an already registered type:</p> <pre><code>from injectq.utils import AlreadyRegisteredError\n\ntry:\n    container.bind_instance(BaseService, instance)\nexcept AlreadyRegisteredError as e:\n    print(f\"Type already registered: {e.dependency_type}\")\n</code></pre>"},{"location":"core-concepts/auto-registration-override-control/#summary","title":"Summary","text":"<ul> <li>allow_concrete=True: Automatically register concrete types when registering instances (default)</li> <li>allow_concrete=False: Only register the explicitly specified type</li> <li>allow_override=True: Allow overwriting existing registrations (default)</li> <li>allow_override=False: Prevent overwriting existing registrations</li> </ul> <p>These features provide flexible control over service registration behavior, enabling both simple auto-registration for common cases and strict control for complex scenarios.</p>"},{"location":"core-concepts/container-pattern/","title":"The Container Pattern","text":"<p>The Container Pattern is the heart of dependency injection frameworks. This guide explains how containers work, their benefits, and how InjectQ implements them.</p>"},{"location":"core-concepts/container-pattern/#what-is-a-container","title":"\ud83c\udfd7\ufe0f What is a Container?","text":"<p>A Dependency Injection Container (or DI Container) is an object that:</p> <ol> <li>Knows about all your services and their dependencies</li> <li>Creates service instances when needed</li> <li>Injects dependencies automatically</li> <li>Manages service lifetimes (scopes)</li> </ol>"},{"location":"core-concepts/container-pattern/#container-responsibilities","title":"\ud83d\udce6 Container Responsibilities","text":""},{"location":"core-concepts/container-pattern/#1-service-registration","title":"1. Service Registration","text":"<p>The container needs to know what services exist and how to create them:</p> <pre><code>from injectq import injectq\n# Register services\ninjectq.bind(Database, PostgreSQLDatabase)\ninjectq.bind(Cache, RedisCache)\ninjectq.bind(UserService, UserService)\n</code></pre>"},{"location":"core-concepts/container-pattern/#2-dependency-resolution","title":"2. Dependency Resolution","text":"<p>When a service is requested, the container:</p> <ol> <li>Looks up the service registration</li> <li>Analyzes the service's dependencies</li> <li>Recursively resolves all dependencies</li> <li>Creates the service instance</li> <li>Returns the fully configured instance</li> </ol> <pre><code># Container resolves this automatically\n@inject\ndef process_data(service: UserService):\n    # Container creates:\n    # 1. Database instance\n    # 2. Cache instance\n    # 3. UserService instance with Database and Cache injected\n    pass\n</code></pre>"},{"location":"core-concepts/container-pattern/#3-lifetime-management","title":"3. Lifetime Management","text":"<p>The container manages when services are created and destroyed:</p> <pre><code># Singleton - one instance for entire app\n@singleton\nclass Database:\n    pass\n\n# Transient - new instance every time\n@transient\nclass RequestHandler:\n    pass\n</code></pre>"},{"location":"core-concepts/container-pattern/#how-injectqs-container-works","title":"\ud83d\udd27 How InjectQ's Container Works","text":""},{"location":"core-concepts/container-pattern/#core-components","title":"Core Components","text":"<p>InjectQ's container consists of several key components:</p> <pre><code>class InjectQ:\n    def __init__(self):\n        self._registry = ServiceRegistry()        # Service registrations\n        self._resolver = DependencyResolver()     # Dependency resolution\n        self._scope_manager = ScopeManager()      # Lifetime management\n</code></pre>"},{"location":"core-concepts/container-pattern/#service-registry","title":"Service Registry","text":"<p>The registry stores information about all registered services:</p> <pre><code># Internal registry structure\n{\n    Database: {\n        \"implementation\": PostgreSQLDatabase,\n        \"scope\": \"singleton\",\n        \"factory\": None\n    },\n    UserService: {\n        \"implementation\": UserService,\n        \"scope\": \"singleton\",\n        \"factory\": None\n    }\n}\n</code></pre>"},{"location":"core-concepts/container-pattern/#dependency-resolver","title":"Dependency Resolver","text":"<p>The resolver analyzes dependencies and builds the dependency graph:</p> <pre><code># For UserService(Database, Cache)\n# Resolver determines:\n# UserService depends on Database and Cache\n# Database depends on DatabaseConfig\n# Cache depends on CacheConfig\n</code></pre>"},{"location":"core-concepts/container-pattern/#scope-manager","title":"Scope Manager","text":"<p>The scope manager controls service lifetimes:</p> <pre><code># Different scopes for different lifetimes\ninjectq.bind(AppConfig, scope=Scope.APP)        # Application lifetime\ninjectq.bind(RequestContext, scope=Scope.REQUEST)  # Per request\ninjectq.bind(TempData, scope=Scope.TRANSIENT)      # Always new\n</code></pre>"},{"location":"core-concepts/container-pattern/#container-patterns","title":"\ud83c\udfaf Container Patterns","text":""},{"location":"core-concepts/container-pattern/#1-singleton-container-default","title":"1. Singleton Container (Default)","text":"<p>One global container for the entire application (recommended pattern):</p> <pre><code>from injectq import injectq\n\n# Global convenience container\ncontainer = injectq\n\n# Register services\ncontainer.bind(Database, PostgreSQLDatabase)\ncontainer.bind(UserService, UserService)\n\n# Use anywhere in the app\n@inject\ndef handler(service: UserService):\n    pass\n</code></pre> <p>Pros: - Simple to use - Services available everywhere - Easy to set up</p> <p>Cons: - Global state - Harder to test in isolation - Can lead to tight coupling</p>"},{"location":"core-concepts/container-pattern/#2-composed-containers","title":"2. Composed Containers","text":"<p>Multiple containers that can inherit from each other:</p> <pre><code># Base container with common services\nbase_container = InjectQ()\nbase_container.bind(Database, PostgreSQLDatabase)\n\n# Web-specific container\nweb_container = InjectQ(modules=[WebModule()])\nweb_container.bind(WebConfig, WebConfig)\n\n# API-specific container\napi_container = InjectQ(modules=[ApiModule()])\napi_container.bind(ApiConfig, ApiConfig)\n</code></pre>"},{"location":"core-concepts/container-pattern/#3-scoped-containers","title":"3. Scoped Containers","text":"<p>Containers that create child scopes:</p> <pre><code># Main container\ncontainer = InjectQ()\n\n# Create a request scope\nasync with container.scope(\"request\"):\n    # Services in this scope are isolated\n    request_service = container.get(RequestService)\n</code></pre>"},{"location":"core-concepts/container-pattern/#container-configuration-patterns","title":"\ud83d\udccb Container Configuration Patterns","text":""},{"location":"core-concepts/container-pattern/#1-dict-like-configuration","title":"1. Dict-like Configuration","text":"<p>Simple key-value bindings:</p> <pre><code># Simple values\ninjectq[str] = \"postgresql://localhost/db\"\ninjectq[int] = 42\ninjectq[bool] = True\n\n# Complex objects\ninjectq[\"config\"] = AppConfig(host=\"localhost\", port=8080)\n</code></pre>"},{"location":"core-concepts/container-pattern/#2-type-based-configuration","title":"2. Type-based Configuration","text":"<p>Bind interfaces to implementations:</p> <pre><code># Interface to implementation\ncontainer.bind(IDatabase, PostgreSQLDatabase)\ncontainer.bind(ICache, RedisCache)\ncontainer.bind(IUserRepository, UserRepository)\n</code></pre>"},{"location":"core-concepts/container-pattern/#3-factory-based-configuration","title":"3. Factory-based Configuration","text":"<p>Use factories for complex creation logic:</p> <pre><code>def create_database(config: DatabaseConfig) -&gt; IDatabase:\n    if config.driver == \"postgres\":\n        return PostgreSQLDatabase(config)\n    elif config.driver == \"mysql\":\n        return MySQLDatabase(config)\n    else:\n        return SQLiteDatabase(config)\n\ncontainer.bind_factory(IDatabase, create_database)\n</code></pre>"},{"location":"core-concepts/container-pattern/#4-module-based-configuration","title":"4. Module-based Configuration","text":"<p>Organize configuration with modules:</p> <pre><code>from injectq import Module\n\nclass DatabaseModule(Module):\n    def configure(self, binder):\n        binder.bind(IDatabase, PostgreSQLDatabase)\n        binder.bind(DatabaseConfig, DatabaseConfig)\n\nclass ServiceModule(Module):\n    def configure(self, binder):\n        binder.bind(IUserService, UserService)\n        binder.bind(IOrderService, OrderService)\n\n# Compose modules\ncontainer = InjectQ([DatabaseModule(), ServiceModule()])\n</code></pre>"},{"location":"core-concepts/container-pattern/#container-lifecycle","title":"\ud83d\udd04 Container Lifecycle","text":""},{"location":"core-concepts/container-pattern/#1-registration-phase","title":"1. Registration Phase","text":"<p>Set up all service bindings:</p> <pre><code>container = InjectQ()\n\n# Register all services\ncontainer.bind(Database, PostgreSQLDatabase)\ncontainer.bind(Cache, RedisCache)\ncontainer.bind(UserService, UserService)\n\n# Validate configuration\ncontainer.validate()\n</code></pre>"},{"location":"core-concepts/container-pattern/#2-resolution-phase","title":"2. Resolution Phase","text":"<p>Resolve services as needed:</p> <pre><code># First resolution - creates instances\nuser_service = container.get(UserService)\n\n# Subsequent resolutions - returns cached instances (for singletons)\nanother_service = container.get(UserService)\nassert user_service is another_service  # True for singletons\n</code></pre>"},{"location":"core-concepts/container-pattern/#3-cleanup-phase","title":"3. Cleanup Phase","text":"<p>Clean up resources when the application shuts down:</p> <pre><code># Manual cleanup\ncontainer.clear()\n\n# Or use context manager\nwith InjectQ() as container:\n    # Use container\n    pass\n# Automatic cleanup\n</code></pre>"},{"location":"core-concepts/container-pattern/#advanced-container-features","title":"\ud83d\ude80 Advanced Container Features","text":""},{"location":"core-concepts/container-pattern/#1-lazy-resolution","title":"1. Lazy Resolution","text":"<p>Services are created only when first accessed:</p> <pre><code>container.bind(ExpensiveService, ExpensiveService)\n\n# Service not created yet\nprint(\"Container ready\")\n\n# Service created here\nservice = container.get(ExpensiveService)\n</code></pre>"},{"location":"core-concepts/container-pattern/#2-circular-dependency-detection","title":"2. Circular Dependency Detection","text":"<p>Container detects and prevents circular dependencies:</p> <pre><code>class A:\n    def __init__(self, b: B):\n        self.b = b\n\nclass B:\n    def __init__(self, a: A):  # Circular dependency!\n        self.a = a\n\ncontainer.bind(A, A)\ncontainer.bind(B, B)\n\n# This will raise CircularDependencyError\ncontainer.validate()\n</code></pre>"},{"location":"core-concepts/container-pattern/#3-conditional-registration","title":"3. Conditional Registration","text":"<p>Register services based on conditions:</p> <pre><code>if environment == \"production\":\n    container.bind(IDatabase, PostgreSQLDatabase)\nelse:\n    container.bind(IDatabase, SQLiteDatabase)\n</code></pre>"},{"location":"core-concepts/container-pattern/#4-named-bindings","title":"4. Named Bindings","text":"<p>Multiple implementations of the same interface:</p> <pre><code># Register multiple caches\ncontainer.bind(Cache, RedisCache, name=\"redis\")\ncontainer.bind(Cache, MemoryCache, name=\"memory\")\n\n# Resolve by name\nredis_cache = container.get(Cache, name=\"redis\")\nmemory_cache = container.get(Cache, name=\"memory\")\n</code></pre>"},{"location":"core-concepts/container-pattern/#testing-with-containers","title":"\ud83e\uddea Testing with Containers","text":""},{"location":"core-concepts/container-pattern/#1-test-containers","title":"1. Test Containers","text":"<p>Create isolated containers for testing:</p> <pre><code>from injectq.testing import test_container\n\ndef test_user_service():\n    with test_container() as container:\n        # Set up test dependencies\n        container.bind(IDatabase, MockDatabase)\n        container.bind(ICache, MockCache)\n\n        # Test the service\n        service = container.get(UserService)\n        result = service.get_user(1)\n        assert result is not None\n</code></pre>"},{"location":"core-concepts/container-pattern/#2-dependency-overrides","title":"2. Dependency Overrides","text":"<p>Temporarily override dependencies:</p> <pre><code>from injectq.testing import override_dependency\n\ndef test_with_override():\n    mock_db = MockDatabase()\n\n    with override_dependency(IDatabase, mock_db):\n        service = container.get(UserService)\n        # service now uses mock_db\n        result = service.get_user(1)\n        assert result.name == \"Mock User\"\n</code></pre>"},{"location":"core-concepts/container-pattern/#performance-considerations","title":"\ud83d\udcca Performance Considerations","text":""},{"location":"core-concepts/container-pattern/#1-compilation","title":"1. Compilation","text":"<p>Pre-compile dependency graphs for better performance:</p> <pre><code># Compile for production\ncontainer.compile()\n\n# Now resolutions are faster\nservice = container.get(UserService)  # Optimized resolution\n</code></pre>"},{"location":"core-concepts/container-pattern/#2-caching","title":"2. Caching","text":"<p>Container caches resolved instances based on scope:</p> <pre><code># Singleton services are cached\ndb1 = container.get(Database)\ndb2 = container.get(Database)\nassert db1 is db2  # Same instance\n</code></pre>"},{"location":"core-concepts/container-pattern/#3-lazy-loading","title":"3. Lazy Loading","text":"<p>Services are created only when needed:</p> <pre><code># No instances created yet\ncontainer.bind(HeavyService, HeavyService)\n\n# Instance created here\nservice = container.get(HeavyService)\n</code></pre>"},{"location":"core-concepts/container-pattern/#container-benefits","title":"\ud83c\udf89 Container Benefits","text":""},{"location":"core-concepts/container-pattern/#1-automatic-dependency-resolution","title":"1. Automatic Dependency Resolution","text":"<p>No manual wiring of dependencies:</p> <pre><code># Manual (error-prone)\ndef create_service():\n    config = DatabaseConfig()\n    db = Database(config)\n    cache = Cache()\n    logger = Logger()\n    return UserService(db, cache, logger)\n\n# Container (automatic)\n@inject\ndef use_service(service: UserService):\n    pass\n</code></pre>"},{"location":"core-concepts/container-pattern/#2-centralized-configuration","title":"2. Centralized Configuration","text":"<p>All service configuration in one place:</p> <pre><code>container = InjectQ()\n\n# All configuration here\ncontainer.bind(Database, PostgreSQLDatabase)\ncontainer.bind(Cache, RedisCache)\ncontainer.bind_all_from_module(MyModule)\n</code></pre>"},{"location":"core-concepts/container-pattern/#3-lifetime-management_1","title":"3. Lifetime Management","text":"<p>Automatic management of service lifetimes:</p> <pre><code># Container handles creation and cleanup\n@singleton\nclass Database:\n    def __init__(self):\n        # Set up connection\n\n    def close(self):\n        # Cleanup connection\n</code></pre>"},{"location":"core-concepts/container-pattern/#4-testability","title":"4. Testability","text":"<p>Easy to replace dependencies for testing:</p> <pre><code># Production\ncontainer.bind(IDatabase, PostgreSQLDatabase)\n\n# Testing\nwith override_dependency(IDatabase, MockDatabase):\n    # Test with mock\n    pass\n</code></pre>"},{"location":"core-concepts/container-pattern/#common-container-mistakes","title":"\ud83d\udea8 Common Container Mistakes","text":""},{"location":"core-concepts/container-pattern/#1-over-using-the-global-container","title":"1. Over-using the Global Container","text":"<pre><code># \u274c Global container everywhere\nfrom injectq import injectq\n\nclass MyClass:\n    def __init__(self):\n        self.service = injectq.get(UserService)  # Hidden dependency\n</code></pre>"},{"location":"core-concepts/container-pattern/#2-ignoring-scopes","title":"2. Ignoring Scopes","text":"<pre><code># \u274c Wrong scope usage\n@singleton\nclass RequestData:  # Should be scoped or transient\n    pass\n</code></pre>"},{"location":"core-concepts/container-pattern/#3-circular-dependencies","title":"3. Circular Dependencies","text":"<pre><code># \u274c Circular dependency\nclass A:\n    def __init__(self, b: B):\n        self.b = b\n\nclass B:\n    def __init__(self, a: A):\n        self.a = a\n</code></pre>"},{"location":"core-concepts/container-pattern/#best-practices","title":"\ud83c\udfc6 Best Practices","text":""},{"location":"core-concepts/container-pattern/#1-use-modules-for-organization","title":"1. Use Modules for Organization","text":"<pre><code># \u2705 Organize with modules\nclass DatabaseModule(Module):\n    def configure(self, binder):\n        binder.bind(IDatabase, PostgreSQLDatabase)\n\ncontainer = InjectQ([DatabaseModule()])\n</code></pre>"},{"location":"core-concepts/container-pattern/#2-validate-early","title":"2. Validate Early","text":"<pre><code># \u2705 Validate configuration\ncontainer.validate()  # Check for errors early\n</code></pre>"},{"location":"core-concepts/container-pattern/#3-use-appropriate-scopes","title":"3. Use Appropriate Scopes","text":"<pre><code># \u2705 Correct scope usage\n@singleton\nclass Database:  # Shared across app\n    pass\n\n@scoped(\"request\")\nclass RequestContext:  # Per request\n    pass\n\n@transient\nclass CommandHandler:  # New each time\n    pass\n</code></pre>"},{"location":"core-concepts/container-pattern/#4-handle-cleanup","title":"4. Handle Cleanup","text":"<pre><code># \u2705 Proper cleanup\n@resource\ndef database_connection():\n    conn = create_connection()\n    try:\n        yield conn\n    finally:\n        conn.close()\n</code></pre>"},{"location":"core-concepts/container-pattern/#summary","title":"\ud83c\udfaf Summary","text":"<p>The Container Pattern provides:</p> <ul> <li>Automatic dependency resolution - No manual wiring</li> <li>Centralized configuration - All setup in one place</li> <li>Lifetime management - Automatic creation/cleanup</li> <li>Testability - Easy dependency replacement</li> <li>Performance - Caching and optimization</li> <li>Maintainability - Clear separation of concerns</li> </ul> <p>InjectQ's container is designed to be: - Simple - Easy to get started - Powerful - Advanced features when needed - Fast - Optimized for performance - Testable - Built-in testing support</p> <p>Ready to explore service lifetimes?</p>"},{"location":"core-concepts/service-lifetimes/","title":"Service Lifetimes","text":"<p>Service lifetimes (also called scopes) control how long service instances live and when they are created. This guide explains the different lifetime options in InjectQ and when to use each one.</p>"},{"location":"core-concepts/service-lifetimes/#what-are-service-lifetimes","title":"\ud83c\udfaf What are Service Lifetimes?","text":"<p>Service lifetimes determine:</p> <ol> <li>When a service instance is created</li> <li>How long it lives</li> <li>When it gets cleaned up</li> <li>Whether instances are shared or unique</li> </ol>"},{"location":"core-concepts/service-lifetimes/#available-lifetimes","title":"\ud83d\udd04 Available Lifetimes","text":"<p>InjectQ provides several built-in lifetimes:</p>"},{"location":"core-concepts/service-lifetimes/#1-singleton-default","title":"1. Singleton (Default)","text":"<p>One instance for the entire application lifetime.</p> <pre><code>from injectq import InjectQ, singleton\n\n# Explicit singleton\n@singleton\nclass Database:\n    def __init__(self):\n        self.connection_id = id(self)\n        print(f\"Database created: {self.connection_id}\")\n\n# Or bind with scope\ncontainer = InjectQ()\ncontainer.bind(Database, Database, scope=\"singleton\")\n\n# Usage\ndb1 = container.get(Database)\ndb2 = container.get(Database)\nprint(f\"Same instance? {db1 is db2}\")  # True\n</code></pre> <p>When to use: - Database connections - Configuration objects - Caching services - Logging services - Any expensive resource that can be shared</p> <p>Pros: - Memory efficient (one instance) - Fast (no creation overhead) - Thread-safe sharing</p> <p>Cons: - Cannot store request-specific data - Harder to test in isolation</p>"},{"location":"core-concepts/service-lifetimes/#2-transient","title":"2. Transient","text":"<p>New instance every time the service is requested.</p> <pre><code>from injectq import transient\n\n@transient\nclass RequestProcessor:\n    def __init__(self):\n        self.instance_id = id(self)\n        print(f\"Processor created: {self.instance_id}\")\n\n# Usage\nproc1 = container.get(RequestProcessor)\nproc2 = container.get(RequestProcessor)\nprint(f\"Different instances? {proc1 is not proc2}\")  # True\n</code></pre> <p>When to use: - Request handlers - Command processors - Validators - Any service that needs to be stateless</p> <p>Pros: - Clean state for each use - Easy to test - No shared state issues</p> <p>Cons: - Memory overhead (many instances) - Creation overhead - Cannot cache data between calls</p>"},{"location":"core-concepts/service-lifetimes/#3-scoped","title":"3. Scoped","text":"<p>One instance per scope (request, session, etc.).</p> <pre><code>from injectq import InjectQ, scoped\n\n@scoped(\"request\")\nclass RequestContext:\n    def __init__(self):\n        self.request_id = id(self)\n        self.user_id = None\n        self.start_time = time.time()\n\n# Usage\ncontainer = InjectQ()\n\nasync with container.scope(\"request\"):\n    ctx1 = container.get(RequestContext)\n    # Do work...\n    ctx1.user_id = 123\n\n    # Same instance in same scope\n    ctx2 = container.get(RequestContext)\n    print(f\"Same context? {ctx1 is ctx2}\")  # True\n    print(f\"User ID: {ctx2.user_id}\")  # 123\n\n# New scope = new instance\nasync with container.scope(\"request\"):\n    ctx3 = container.get(RequestContext)\n    print(f\"New context? {ctx1 is not ctx3}\")  # True\n</code></pre> <p>When to use: - Request context data - User session data - Transaction contexts - Per-operation state</p> <p>Pros: - Shared within logical unit - Automatic cleanup - Request-scoped caching</p> <p>Cons: - More complex to manage - Requires scope management</p>"},{"location":"core-concepts/service-lifetimes/#built-in-scopes","title":"\ud83c\udfd7\ufe0f Built-in Scopes","text":"<p>InjectQ provides several built-in scopes:</p>"},{"location":"core-concepts/service-lifetimes/#application-scope","title":"Application Scope","text":"<p>Lives for the entire application lifetime (same as singleton):</p> <pre><code>from injectq import Scope\n\ncontainer.bind(AppConfig, scope=Scope.APP)\ncontainer.bind(Database, scope=Scope.APP)\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#request-scope","title":"Request Scope","text":"<p>Lives for the duration of a request:</p> <pre><code>container.bind(RequestContext, scope=Scope.REQUEST)\ncontainer.bind(UserSession, scope=Scope.REQUEST)\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#action-scope","title":"Action Scope","text":"<p>Lives for the duration of an action/method:</p> <pre><code>container.bind(ActionContext, scope=Scope.ACTION)\ncontainer.bind(ValidationContext, scope=Scope.ACTION)\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#transient-scope","title":"Transient Scope","text":"<p>Always creates new instances (same as <code>@transient</code>):</p> <pre><code>container.bind(CommandHandler, scope=Scope.TRANSIENT)\ncontainer.bind(Validator, scope=Scope.TRANSIENT)\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#custom-scopes","title":"\ud83c\udfa8 Custom Scopes","text":"<p>You can create custom scopes for specific needs:</p> <pre><code>from injectq import Scope, ScopeManager\n\nclass TaskScope(Scope):\n    \"\"\"Scope that lives for the duration of a background task.\"\"\"\n\n    def __init__(self):\n        self.task_id = None\n        self.start_time = None\n\n    def enter(self):\n        \"\"\"Called when entering the scope.\"\"\"\n        self.task_id = f\"task_{uuid.uuid4().hex[:8]}\"\n        self.start_time = time.time()\n        print(f\"Starting task: {self.task_id}\")\n\n    def exit(self):\n        \"\"\"Called when exiting the scope.\"\"\"\n        duration = time.time() - self.start_time\n        print(f\"Task {self.task_id} completed in {duration:.2f}s\")\n\n# Register custom scope\nscope_manager = container._scope_manager\nscope_manager.register_scope(\"task\", TaskScope())\n\n# Use custom scope\n@scoped(\"task\")\nclass TaskProcessor:\n    def __init__(self):\n        self.task_id = None\n\n    def set_task_id(self, task_id: str):\n        self.task_id = task_id\n\n# Usage\nasync with container.scope(\"task\"):\n    processor = container.get(TaskProcessor)\n    processor.set_task_id(\"process_data\")\n    # Do task work...\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#lifetime-examples","title":"\ud83d\udd04 Lifetime Examples","text":""},{"location":"core-concepts/service-lifetimes/#example-1-web-application","title":"Example 1: Web Application","text":"<pre><code>from injectq import InjectQ, singleton, scoped, transient\n\ncontainer = InjectQ()\n\n# Application-wide services\n@singleton\nclass Database:\n    pass\n\n@singleton\nclass Cache:\n    pass\n\n# Request-scoped services\n@scoped(\"request\")\nclass RequestContext:\n    def __init__(self):\n        self.user_id = None\n        self.request_id = str(uuid.uuid4())\n\n@scoped(\"request\")\nclass UserSession:\n    def __init__(self, context: RequestContext):\n        self.context = context\n        self.user_data = {}\n\n# Transient services\n@transient\nclass EmailSender:\n    def send(self, to: str, subject: str, body: str):\n        print(f\"Sending email to {to}: {subject}\")\n\n# Usage in request handler\n@inject\nasync def handle_request(\n    db: Database,\n    cache: Cache,\n    context: RequestContext,\n    session: UserSession,\n    email_sender: EmailSender\n):\n    # db and cache are shared across all requests\n    # context and session are unique to this request\n    # email_sender is new for this handler\n\n    context.user_id = 123\n    session.user_data[\"last_login\"] = datetime.now()\n\n    # Each call gets a new email_sender\n    email_sender.send(\"user@example.com\", \"Welcome\", \"Hello!\")\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#example-2-background-job-processing","title":"Example 2: Background Job Processing","text":"<pre><code>@singleton\nclass JobQueue:\n    pass\n\n@scoped(\"job\")\nclass JobContext:\n    def __init__(self):\n        self.job_id = None\n        self.start_time = time.time()\n        self.progress = 0\n\n@transient\nclass FileProcessor:\n    def process(self, file_path: str) -&gt; dict:\n        # Process file and return results\n        return {\"processed\": True, \"file\": file_path}\n\n@inject\nasync def process_job(\n    queue: JobQueue,\n    context: JobContext,\n    processor: FileProcessor\n):\n    # queue is shared\n    # context is per-job\n    # processor is new each time\n\n    files = [\"file1.txt\", \"file2.txt\", \"file3.txt\"]\n\n    for file_path in files:\n        # Each iteration gets a new processor\n        result = processor.process(file_path)\n        context.progress += 1\n        print(f\"Processed {file_path}: {result}\")\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#performance-considerations","title":"\u26a1 Performance Considerations","text":""},{"location":"core-concepts/service-lifetimes/#memory-usage","title":"Memory Usage","text":"<pre><code># Singleton - Low memory usage\n@singleton\nclass HeavyService:\n    def __init__(self):\n        self.data = {}  # Large data structure\n\n# Transient - High memory usage\n@transient\nclass LightService:\n    def __init__(self):\n        self.temp_data = []  # Small data structure\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#creation-overhead","title":"Creation Overhead","text":"<pre><code># Singleton - Created once\n@singleton\nclass ExpensiveService:\n    def __init__(self):\n        time.sleep(1)  # Expensive initialization\n\n# Transient - Created every time\n@transient\nclass CheapService:\n    def __init__(self):\n        pass  # Cheap initialization\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#thread-safety","title":"Thread Safety","text":"<pre><code># Singleton - Must be thread-safe\n@singleton\nclass SharedCache:\n    def __init__(self):\n        self._data = {}\n        self._lock = threading.Lock()\n\n    def get(self, key):\n        with self._lock:\n            return self._data.get(key)\n\n    def set(self, key, value):\n        with self._lock:\n            self._data[key] = value\n\n# Transient - No thread safety concerns\n@transient\nclass RequestHandler:\n    def __init__(self):\n        self.request_data = {}\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#testing-different-lifetimes","title":"\ud83e\uddea Testing Different Lifetimes","text":""},{"location":"core-concepts/service-lifetimes/#testing-singletons","title":"Testing Singletons","text":"<pre><code>def test_singleton_behavior():\n    with test_container() as container:\n        container.bind(Database, MockDatabase)\n\n        # Should be same instance\n        db1 = container.get(Database)\n        db2 = container.get(Database)\n        assert db1 is db2\n\n        # Test the singleton\n        db1.connect()\n        assert db2.is_connected()\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#testing-scoped-services","title":"Testing Scoped Services","text":"<pre><code>def test_scoped_behavior():\n    with test_container() as container:\n        container.bind(RequestContext, RequestContext, scope=\"request\")\n\n        # Outside scope - should fail\n        with pytest.raises(DependencyNotFoundError):\n            container.get(RequestContext)\n\n        # Inside scope\n        with container.scope(\"request\"):\n            ctx1 = container.get(RequestContext)\n            ctx2 = container.get(RequestContext)\n            assert ctx1 is ctx2\n\n        # New scope - new instance\n        with container.scope(\"request\"):\n            ctx3 = container.get(RequestContext)\n            assert ctx1 is not ctx3\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#testing-transients","title":"Testing Transients","text":"<pre><code>def test_transient_behavior():\n    with test_container() as container:\n        container.bind(Processor, Processor, scope=\"transient\")\n\n        proc1 = container.get(Processor)\n        proc2 = container.get(Processor)\n\n        # Should be different instances\n        assert proc1 is not proc2\n        assert proc1.instance_id != proc2.instance_id\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#common-lifetime-mistakes","title":"\ud83d\udea8 Common Lifetime Mistakes","text":""},{"location":"core-concepts/service-lifetimes/#1-wrong-scope-for-shared-data","title":"1. Wrong Scope for Shared Data","text":"<pre><code># \u274c Wrong - request data in singleton\n@singleton\nclass UserContext:\n    def __init__(self):\n        self.user_id = None  # Will be shared across requests!\n\n# \u2705 Correct - request-scoped\n@scoped(\"request\")\nclass UserContext:\n    def __init__(self):\n        self.user_id = None  # Unique per request\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#2-expensive-operations-in-transient","title":"2. Expensive Operations in Transient","text":"<pre><code># \u274c Wrong - expensive operation in transient\n@transient\nclass DatabaseConnection:\n    def __init__(self):\n        self.connection = create_expensive_connection()  # Called every time!\n\n# \u2705 Correct - singleton for expensive resources\n@singleton\nclass DatabaseConnection:\n    def __init__(self):\n        self.connection = create_expensive_connection()  # Called once\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#3-state-in-singletons","title":"3. State in Singletons","text":"<pre><code># \u274c Wrong - mutable state in singleton\n@singleton\nclass Cache:\n    def __init__(self):\n        self._data = {}  # Shared mutable state\n\n    def set_user_data(self, user_id, data):\n        self._data[user_id] = data  # Race conditions!\n\n# \u2705 Correct - thread-safe or scoped\n@singleton\nclass Cache:\n    def __init__(self):\n        self._data = {}\n        self._lock = threading.Lock()\n\n    def set_user_data(self, user_id, data):\n        with self._lock:\n            self._data[user_id] = data\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#best-practices","title":"\ud83c\udfc6 Best Practices","text":""},{"location":"core-concepts/service-lifetimes/#1-choose-the-right-lifetime","title":"1. Choose the Right Lifetime","text":"<pre><code># Singleton for shared resources\n@singleton\nclass DatabaseConnection:\n    pass\n\n# Scoped for request-specific data\n@scoped(\"request\")\nclass RequestContext:\n    pass\n\n# Transient for stateless operations\n@transient\nclass EmailValidator:\n    pass\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#2-consider-thread-safety","title":"2. Consider Thread Safety","text":"<pre><code># Make singletons thread-safe\n@singleton\nclass SharedService:\n    def __init__(self):\n        self._lock = threading.Lock()\n\n    def do_work(self):\n        with self._lock:\n            # Thread-safe operations\n            pass\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#3-use-appropriate-scopes","title":"3. Use Appropriate Scopes","text":"<pre><code># Web application scopes\ncontainer.bind(UserSession, scope=Scope.REQUEST)\ncontainer.bind(Transaction, scope=Scope.REQUEST)\n\n# Background job scopes\ncontainer.bind(JobContext, scope=\"job\")\ncontainer.bind(TaskProgress, scope=\"job\")\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#4-handle-cleanup","title":"4. Handle Cleanup","text":"<pre><code># Use resource management for cleanup\n@resource\ndef database_connection():\n    conn = create_connection()\n    try:\n        yield conn\n    finally:\n        conn.close()\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#5-test-lifetime-behavior","title":"5. Test Lifetime Behavior","text":"<pre><code>def test_lifetimes():\n    # Test singleton behavior\n    # Test scoped behavior\n    # Test transient behavior\n    pass\n</code></pre>"},{"location":"core-concepts/service-lifetimes/#summary","title":"\ud83c\udfaf Summary","text":"<p>Service lifetimes control:</p> <ul> <li>Singleton: One instance for the entire application</li> <li>Transient: New instance every time</li> <li>Scoped: One instance per scope (request, session, etc.)</li> <li>Custom: User-defined scopes for specific needs</li> </ul> <p>Choose the right lifetime based on:</p> <ul> <li>Sharing needs: Shared vs. isolated state</li> <li>Performance: Creation overhead vs. memory usage</li> <li>Thread safety: Concurrent access patterns</li> <li>Testing: Isolation requirements</li> </ul> <p>Key principles:</p> <ul> <li>Use singleton for expensive shared resources</li> <li>Use scoped for request/session specific data</li> <li>Use transient for stateless operations</li> <li>Always consider thread safety for singletons</li> <li>Test your lifetime choices</li> </ul> <p>Ready to explore type safety in InjectQ?</p>"},{"location":"core-concepts/type-safety/","title":"Type Safety","text":"<p>InjectQ is designed with type safety as a first-class concern. This guide explains how InjectQ ensures type safety, provides early error detection, and works seamlessly with mypy and other type checkers.</p>"},{"location":"core-concepts/type-safety/#what-is-type-safety","title":"\ud83c\udfaf What is Type Safety?","text":"<p>Type safety means that the type system prevents type-related errors at compile time rather than runtime.</p>"},{"location":"core-concepts/type-safety/#without-type-safety","title":"Without Type Safety","text":"<pre><code># \u274c Runtime errors possible\ndef process_user(user_data):\n    return user_data[\"name\"]  # What if user_data is None?\n\nuser = None\nresult = process_user(user)  # Runtime error: NoneType has no key \"name\"\n</code></pre>"},{"location":"core-concepts/type-safety/#with-type-safety","title":"With Type Safety","text":"<pre><code># \u2705 Compile-time error detection\nfrom typing import Optional\n\ndef process_user(user_data: Optional[dict]) -&gt; str:\n    if user_data is None:\n        return \"Unknown User\"\n    return user_data[\"name\"]  # Type checker warns about potential KeyError\n\nuser: Optional[dict] = None\nresult = process_user(user)  # \u2705 Safe at runtime\n</code></pre>"},{"location":"core-concepts/type-safety/#injectqs-type-safety-features","title":"\ud83d\udd27 InjectQ's Type Safety Features","text":""},{"location":"core-concepts/type-safety/#1-full-type-hints-support","title":"1. Full Type Hints Support","text":"<p>InjectQ uses Python's type hints extensively:</p> <pre><code>from typing import Protocol, List, Optional\nfrom injectq import InjectQ, inject\n\nclass IUserRepository(Protocol):\n    def get_by_id(self, user_id: int) -&gt; Optional[User]:\n        ...\n\nclass UserService:\n    def __init__(self, repository: IUserRepository):\n        self.repository = repository\n\n    def get_user(self, user_id: int) -&gt; Optional[User]:\n        return self.repository.get_by_id(user_id)\n\n# Type-safe injection\n@inject\ndef process_user(service: UserService, user_id: int) -&gt; Optional[User]:\n    return service.get_user(user_id)\n</code></pre>"},{"location":"core-concepts/type-safety/#2-generic-type-support","title":"2. Generic Type Support","text":"<p>InjectQ supports generic types:</p> <pre><code>from typing import Generic, TypeVar, List\nfrom injectq import singleton\n\nT = TypeVar('T')\nK = TypeVar('K')\n\n@singleton\nclass Cache(Generic[T]):\n    def __init__(self):\n        self._data: dict[str, T] = {}\n\n    def get(self, key: str) -&gt; Optional[T]:\n        return self._data.get(key)\n\n    def set(self, key: str, value: T) -&gt; None:\n        self._data[key] = value\n\n# Type-safe usage\n@inject\ndef use_cache(cache: Cache[User]) -&gt; None:\n    cache.set(\"user_123\", User(id=123, name=\"John\"))\n    user = cache.get(\"user_123\")  # Type: Optional[User]\n</code></pre>"},{"location":"core-concepts/type-safety/#3-protocol-support","title":"3. Protocol Support","text":"<p>Use protocols for interface-based design:</p> <pre><code>from typing import Protocol\n\nclass LoggerProtocol(Protocol):\n    def log(self, message: str, level: str = \"INFO\") -&gt; None:\n        ...\n\nclass DatabaseProtocol(Protocol):\n    def connect(self) -&gt; None:\n        ...\n\n    def disconnect(self) -&gt; None:\n        ...\n\n    def execute(self, query: str) -&gt; List[dict]:\n        ...\n\n# Implementation\n@singleton\nclass PostgreSQLDatabase:\n    def connect(self) -&gt; None:\n        pass\n\n    def disconnect(self) -&gt; None:\n        pass\n\n    def execute(self, query: str) -&gt; List[dict]:\n        return []\n\n# Type-safe binding\ncontainer = InjectQ()\ncontainer.bind(DatabaseProtocol, PostgreSQLDatabase)\n\n@inject\ndef use_database(db: DatabaseProtocol) -&gt; None:\n    db.connect()\n    results = db.execute(\"SELECT * FROM users\")\n    db.disconnect()\n</code></pre>"},{"location":"core-concepts/type-safety/#early-error-detection","title":"\ud83d\udee1\ufe0f Early Error Detection","text":"<p>InjectQ catches type-related errors early:</p>"},{"location":"core-concepts/type-safety/#1-missing-dependencies","title":"1. Missing Dependencies","text":"<pre><code>class UserService:\n    def __init__(self, repository: IUserRepository, cache: ICache):\n        self.repository = repository\n        self.cache = cache\n\ncontainer = InjectQ()\ncontainer.bind(UserService, UserService)\n# \u274c Missing IUserRepository and ICache bindings\n\n# This will raise an error during validation\ntry:\n    container.validate()\nexcept DependencyNotFoundError as e:\n    print(f\"Missing dependency: {e}\")\n</code></pre>"},{"location":"core-concepts/type-safety/#2-circular-dependencies","title":"2. Circular Dependencies","text":"<pre><code>class A:\n    def __init__(self, b: B):\n        self.b = b\n\nclass B:\n    def __init__(self, a: A):  # \u274c Circular dependency\n        self.a = a\n\ncontainer.bind(A, A)\ncontainer.bind(B, B)\n\n# Detected during validation\ncontainer.validate()  # Raises CircularDependencyError\n</code></pre>"},{"location":"core-concepts/type-safety/#3-type-mismatches","title":"3. Type Mismatches","text":"<pre><code>class Database:\n    def execute(self, query: str) -&gt; List[dict]:\n        return []\n\nclass WrongDatabase:\n    def execute(self, query: int) -&gt; str:  # \u274c Wrong signature\n        return \"result\"\n\ncontainer = InjectQ()\ncontainer.bind(Database, WrongDatabase)\n\n# Type checker will warn about incompatible types\n@inject\ndef use_db(db: Database) -&gt; None:\n    result = db.execute(\"SELECT * FROM users\")  # Type checker warning\n</code></pre>"},{"location":"core-concepts/type-safety/#integration-with-type-checkers","title":"\ud83d\udd0d Integration with Type Checkers","text":""},{"location":"core-concepts/type-safety/#mypy-configuration","title":"MyPy Configuration","text":"<p>InjectQ works seamlessly with mypy:</p> <pre><code># mypy.ini\n[mypy]\npython_version = 3.10\nwarn_return_any = true\nwarn_unused_configs = true\ndisallow_untyped_defs = true\ndisallow_incomplete_defs = true\ncheck_untyped_defs = true\ndisallow_untyped_decorators = true\nno_implicit_optional = true\nwarn_redundant_casts = true\nwarn_unused_ignores = true\nwarn_no_return = true\nwarn_unreachable = true\nstrict_equality = true\nstrict = true\nshow_error_codes = true\n\n# InjectQ specific\n[[tool.mypy.overrides]]\nmodule = \"injectq.*\"\ndisallow_untyped_defs = false  # Allow some flexibility for DI patterns\n</code></pre>"},{"location":"core-concepts/type-safety/#pycharmide-integration","title":"PyCharm/IDE Integration","text":"<p>InjectQ provides excellent IDE support:</p> <pre><code>@inject\ndef process_data(service: UserService) -&gt; None:\n    # IDE shows:\n    # - service parameter type: UserService\n    # - Available methods on service\n    # - Type hints for return values\n    pass\n</code></pre>"},{"location":"core-concepts/type-safety/#advanced-type-patterns","title":"\ud83c\udfa8 Advanced Type Patterns","text":""},{"location":"core-concepts/type-safety/#1-factory-types","title":"1. Factory Types","text":"<pre><code>from typing import Callable, TypeVar\n\nT = TypeVar('T')\n\nclass IServiceFactory(Protocol[T]):\n    def create(self) -&gt; T:\n        ...\n\n@singleton\nclass UserServiceFactory:\n    def __init__(self, repository: IUserRepository):\n        self.repository = repository\n\n    def create(self) -&gt; UserService:\n        return UserService(self.repository)\n\n# Type-safe factory binding\ncontainer.bind(IServiceFactory[UserService], UserServiceFactory)\n\n@inject\ndef create_service(factory: IServiceFactory[UserService]) -&gt; UserService:\n    return factory.create()\n</code></pre>"},{"location":"core-concepts/type-safety/#2-async-types","title":"2. Async Types","text":"<pre><code>from typing import Coroutine, Any\n\nclass IAsyncRepository(Protocol):\n    async def get_by_id(self, id: int) -&gt; Optional[User]:\n        ...\n\n@singleton\nclass AsyncUserService:\n    def __init__(self, repository: IAsyncRepository):\n        self.repository = repository\n\n    async def get_user(self, user_id: int) -&gt; Optional[User]:\n        return await self.repository.get_by_id(user_id)\n\n# Type-safe async injection\n@inject\nasync def process_user(service: AsyncUserService, user_id: int) -&gt; None:\n    user = await service.get_user(user_id)\n    if user:\n        print(f\"Found user: {user.name}\")\n</code></pre>"},{"location":"core-concepts/type-safety/#3-union-types","title":"3. Union Types","text":"<pre><code>from typing import Union\n\nclass FileStorage:\n    def save(self, data: bytes) -&gt; str:\n        return \"file://path/to/file\"\n\nclass S3Storage:\n    def save(self, data: bytes) -&gt; str:\n        return \"s3://bucket/key\"\n\n# Union type for multiple implementations\nStorageService = Union[FileStorage, S3Storage]\n\n@inject\ndef save_data(storage: StorageService, data: bytes) -&gt; str:\n    return storage.save(data)\n</code></pre>"},{"location":"core-concepts/type-safety/#testing-with-type-safety","title":"\ud83e\uddea Testing with Type Safety","text":""},{"location":"core-concepts/type-safety/#1-mock-protocols","title":"1. Mock Protocols","text":"<pre><code>from typing import Protocol\n\nclass IUserRepository(Protocol):\n    def get_by_id(self, user_id: int) -&gt; Optional[User]:\n        ...\n\nclass MockUserRepository:\n    def __init__(self):\n        self.users = {\n            1: User(id=1, name=\"John\"),\n            2: User(id=2, name=\"Jane\")\n        }\n\n    def get_by_id(self, user_id: int) -&gt; Optional[User]:\n        return self.users.get(user_id)\n\n# Type-safe mocking\ndef test_user_service():\n    with test_container() as container:\n        container.bind(IUserRepository, MockUserRepository)\n\n        service = container.get(UserService)\n        user = service.get_user(1)\n\n        assert user is not None\n        assert user.name == \"John\"  # Type checker knows user is User\n</code></pre>"},{"location":"core-concepts/type-safety/#2-type-safe-overrides","title":"2. Type-Safe Overrides","text":"<pre><code>from injectq.testing import override_dependency\n\ndef test_with_override():\n    mock_repo = MockUserRepository()\n\n    with override_dependency(IUserRepository, mock_repo):\n        service = container.get(UserService)\n        user = service.get_user(1)\n\n        # Type checker ensures user is Optional[User]\n        if user:\n            assert isinstance(user, User)\n            assert user.id == 1\n</code></pre>"},{"location":"core-concepts/type-safety/#common-type-safety-issues","title":"\ud83d\udea8 Common Type Safety Issues","text":""},{"location":"core-concepts/type-safety/#1-missing-type-hints","title":"1. Missing Type Hints","text":"<pre><code># \u274c Missing type hints\nclass UserService:\n    def __init__(self, repository):  # No type hint\n        self.repository = repository\n\n    def get_user(self, user_id):  # No type hints\n        return self.repository.get_by_id(user_id)\n\n# \u2705 With type hints\nclass UserService:\n    def __init__(self, repository: IUserRepository):\n        self.repository = repository\n\n    def get_user(self, user_id: int) -&gt; Optional[User]:\n        return self.repository.get_by_id(user_id)\n</code></pre>"},{"location":"core-concepts/type-safety/#2-any-types","title":"2. Any Types","text":"<pre><code># \u274c Using Any loses type safety\nfrom typing import Any\n\nclass UserService:\n    def __init__(self, repository: Any):  # Loses type checking\n        self.repository = repository\n\n# \u2705 Use proper protocols\nclass UserService:\n    def __init__(self, repository: IUserRepository):\n        self.repository = repository\n</code></pre>"},{"location":"core-concepts/type-safety/#3-optional-types","title":"3. Optional Types","text":"<pre><code># \u274c Not handling None properly\nclass UserService:\n    def __init__(self, repository: IUserRepository):\n        self.repository = repository\n\n    def get_user(self, user_id: int) -&gt; Optional[User]:\n        return self.repository.get_by_id(user_id)\n\n    def get_user_name(self, user_id: int) -&gt; str:\n        user = self.get_user(user_id)\n        return user.name  # \u274c user could be None\n\n# \u2705 Handle None properly\nclass UserService:\n    def get_user_name(self, user_id: int) -&gt; str:\n        user = self.get_user(user_id)\n        return user.name if user else \"Unknown User\"\n</code></pre>"},{"location":"core-concepts/type-safety/#best-practices","title":"\ud83c\udfc6 Best Practices","text":""},{"location":"core-concepts/type-safety/#1-use-protocols-for-interfaces","title":"1. Use Protocols for Interfaces","text":"<pre><code># \u2705 Good - protocol-based design\nclass IUserRepository(Protocol):\n    def get_by_id(self, user_id: int) -&gt; Optional[User]:\n        ...\n\nclass ICache(Protocol):\n    def get(self, key: str) -&gt; Optional[Any]:\n        ...\n\n    def set(self, key: str, value: Any) -&gt; None:\n        ...\n</code></pre>"},{"location":"core-concepts/type-safety/#2-enable-strict-mypy","title":"2. Enable Strict MyPy","text":"<pre><code># \u2705 Enable strict type checking\nclass UserService:\n    def __init__(self, repository: IUserRepository) -&gt; None:\n        self.repository = repository\n\n    def get_user(self, user_id: int) -&gt; Optional[User]:\n        if user_id &lt;= 0:\n            return None\n        return self.repository.get_by_id(user_id)\n</code></pre>"},{"location":"core-concepts/type-safety/#3-use-generic-types","title":"3. Use Generic Types","text":"<pre><code># \u2705 Generic repository pattern\nfrom typing import Generic, TypeVar\n\nT = TypeVar('T')\n\nclass IRepository(Protocol, Generic[T]):\n    def get_by_id(self, id: int) -&gt; Optional[T]:\n        ...\n\n    def save(self, entity: T) -&gt; T:\n        ...\n\nclass UserRepository(IRepository[User]):\n    # Implementation\n    pass\n</code></pre>"},{"location":"core-concepts/type-safety/#4-validate-at-startup","title":"4. Validate at Startup","text":"<pre><code># \u2705 Validate container configuration\ncontainer = InjectQ([DatabaseModule(), ServiceModule()])\n\n# Validate early\ntry:\n    container.validate()\n    print(\"\u2705 Container configuration is valid\")\nexcept Exception as e:\n    print(f\"\u274c Configuration error: {e}\")\n    exit(1)\n</code></pre>"},{"location":"core-concepts/type-safety/#5-use-type-guards","title":"5. Use Type Guards","text":"<pre><code># \u2705 Type guards for runtime safety\nfrom typing import TypeGuard\n\ndef is_user(obj: Any) -&gt; TypeGuard[User]:\n    return hasattr(obj, 'id') and hasattr(obj, 'name')\n\nclass UserService:\n    def process_user(self, data: Any) -&gt; str:\n        if is_user(data):\n            return f\"Processing user: {data.name}\"\n        return \"Invalid user data\"\n</code></pre>"},{"location":"core-concepts/type-safety/#summary","title":"\ud83c\udfaf Summary","text":"<p>InjectQ's type safety features:</p> <ul> <li>Full type hints support - Works with mypy, PyCharm, and other tools</li> <li>Protocol support - Interface-based design</li> <li>Generic types - Type-safe generic programming</li> <li>Early error detection - Catch issues at startup</li> <li>IDE integration - Excellent autocomplete and error detection</li> </ul> <p>Key principles:</p> <ul> <li>Always use type hints</li> <li>Prefer protocols over concrete classes</li> <li>Enable strict mypy checking</li> <li>Validate configuration early</li> <li>Use generics for reusable patterns</li> <li>Handle Optional types properly</li> </ul> <p>Benefits:</p> <ul> <li>Compile-time error detection - Catch bugs before runtime</li> <li>Better IDE support - Autocomplete, refactoring, navigation</li> <li>Self-documenting code - Types serve as documentation</li> <li>Easier refactoring - Type system guides changes</li> <li>Team productivity - Less debugging, more coding</li> </ul> <p>Ready to explore injection patterns?</p>"},{"location":"core-concepts/what-is-di/","title":"What is Dependency Injection?","text":"<p>Dependency Injection (DI) is a design pattern that helps you write more maintainable, testable, and flexible code. This guide explains what DI is, why it's useful, and how InjectQ implements it.</p>"},{"location":"core-concepts/what-is-di/#what-is-dependency-injection_1","title":"\ud83c\udfaf What is Dependency Injection?","text":"<p>Dependency Injection is a technique where objects receive their dependencies from an external source rather than creating them internally.</p>"},{"location":"core-concepts/what-is-di/#without-dependency-injection","title":"Without Dependency Injection","text":"<pre><code>class UserService:\n    def __init__(self):\n        # Service creates its own dependencies\n        self.db = Database()  # \u274c Tight coupling\n        self.cache = Cache()  # \u274c Hard to test\n\n    def get_user(self, user_id):\n        return self.db.query(f\"SELECT * FROM users WHERE id = {user_id}\")\n</code></pre> <p>Problems: - Hard to test (can't mock dependencies) - Hard to change implementations - Tight coupling between classes - Difficult to reuse in different contexts</p>"},{"location":"core-concepts/what-is-di/#with-dependency-injection","title":"With Dependency Injection","text":"<pre><code>class UserService:\n    def __init__(self, db: Database, cache: Cache):\n        # Dependencies are injected\n        self.db = db\n        self.cache = cache\n\n# Somewhere else (composition root)\ndb = Database()\ncache = Cache()\nuser_service = UserService(db, cache)  # \u2705 Loose coupling\n</code></pre> <p>Benefits: - Easy to test (can inject mocks) - Easy to change implementations - Loose coupling between classes - Highly reusable components</p>"},{"location":"core-concepts/what-is-di/#the-dependency-injection-container","title":"\ud83c\udfd7\ufe0f The Dependency Injection Container","text":"<p>A DI Container is a framework that automatically manages dependency resolution and injection.</p>"},{"location":"core-concepts/what-is-di/#manual-dependency-resolution","title":"Manual Dependency Resolution","text":"<pre><code># Without a container - manual wiring\ndef create_user_service():\n    config = DatabaseConfig(\"postgresql://...\")\n    db = Database(config)\n    cache = RedisCache(\"redis://...\")\n    logger = Logger(\"user_service\")\n    return UserService(db, cache, logger)\n\n# Usage\nservice = create_user_service()\n</code></pre> <p>Problems: - Repetitive boilerplate code - Error-prone manual wiring - Hard to maintain as dependencies grow</p>"},{"location":"core-concepts/what-is-di/#with-a-di-container","title":"With a DI Container","text":"<pre><code>from injectq import injectq, inject\n\n# Container automatically wires dependencies\ncontainer = injectq\n\n# Bind implementations\ncontainer.bind(DatabaseConfig, DatabaseConfig)\ncontainer.bind(Database, Database)\ncontainer.bind(Cache, RedisCache)\n\n# Usage - automatic resolution\n@inject\ndef process_user(service: UserService):\n    # All dependencies automatically injected\n    pass\n\nprocess_user()  # No manual wiring needed!\n</code></pre>"},{"location":"core-concepts/what-is-di/#types-of-dependency-injection","title":"\ud83c\udfad Types of Dependency Injection","text":""},{"location":"core-concepts/what-is-di/#1-constructor-injection-recommended","title":"1. Constructor Injection (Recommended)","text":"<p>Dependencies are passed through the constructor:</p> <pre><code>class UserService:\n    def __init__(self, db: Database, cache: Cache):\n        self.db = db\n        self.cache = cache\n</code></pre> <p>Pros: - Dependencies are explicit and clear - Immutable after construction - Easy to test - Fail fast if dependencies are missing</p>"},{"location":"core-concepts/what-is-di/#2-property-injection","title":"2. Property Injection","text":"<p>Dependencies are set via properties:</p> <pre><code>class UserService:\n    def __init__(self):\n        self._db = None\n        self._cache = None\n\n    @property\n    def db(self):\n        return self._db\n\n    @db.setter\n    def db(self, value):\n        self._db = value\n</code></pre> <p>Pros: - Can change dependencies at runtime - Optional dependencies possible</p> <p>Cons: - Dependencies not guaranteed to be set - Harder to test - Less explicit</p>"},{"location":"core-concepts/what-is-di/#3-method-injection","title":"3. Method Injection","text":"<p>Dependencies are passed to specific methods:</p> <pre><code>class UserService:\n    def process_user(self, user_id: int, db: Database):\n        # db is injected only for this method\n        pass\n</code></pre> <p>Pros: - Fine-grained control - Dependencies only where needed</p> <p>Cons: - Verbose - Easy to forget to pass dependencies</p>"},{"location":"core-concepts/what-is-di/#inversion-of-control-ioc","title":"\ud83d\udd04 Inversion of Control (IoC)","text":"<p>Inversion of Control is the principle behind DI. Instead of your code controlling dependency creation, the container controls it.</p>"},{"location":"core-concepts/what-is-di/#traditional-control-flow","title":"Traditional Control Flow","text":"<pre><code>Your Code \u2192 Creates Database \u2192 Creates Cache \u2192 Creates Service\n</code></pre>"},{"location":"core-concepts/what-is-di/#inverted-control-flow","title":"Inverted Control Flow","text":"<pre><code>Container \u2192 Creates Database \u2192 Creates Cache \u2192 Injects into Service \u2192 Your Code\n</code></pre>"},{"location":"core-concepts/what-is-di/#benefits-of-dependency-injection","title":"\ud83c\udfaf Benefits of Dependency Injection","text":""},{"location":"core-concepts/what-is-di/#1-testability","title":"1. Testability","text":"<pre><code>def test_user_service():\n    # Easy to inject mocks\n    mock_db = MockDatabase()\n    mock_cache = MockCache()\n\n    service = UserService(mock_db, mock_cache)\n\n    # Test the service in isolation\n    result = service.get_user(1)\n    assert result is not None\n</code></pre>"},{"location":"core-concepts/what-is-di/#2-flexibility","title":"2. Flexibility","text":"<pre><code># Easy to swap implementations\nif environment == \"production\":\n    container.bind(Database, PostgreSQLDatabase)\nelif environment == \"testing\":\n    container.bind(Database, InMemoryDatabase)\nelse:\n    container.bind(Database, SQLiteDatabase)\n</code></pre>"},{"location":"core-concepts/what-is-di/#3-maintainability","title":"3. Maintainability","text":"<pre><code># Adding a new dependency is easy\nclass UserService:\n    def __init__(self, db: Database, cache: Cache, logger: Logger):\n        self.db = db\n        self.cache = cache\n        self.logger = logger  # New dependency\n</code></pre>"},{"location":"core-concepts/what-is-di/#4-separation-of-concerns","title":"4. Separation of Concerns","text":"<p>Each class focuses on its single responsibility:</p> <pre><code>class UserService:      # Business logic\nclass Database:         # Data persistence\nclass Cache:           # Caching\nclass Logger:          # Logging\n</code></pre>"},{"location":"core-concepts/what-is-di/#5-reusability","title":"5. Reusability","text":"<p>Components can be reused in different contexts:</p> <pre><code># Same UserService can be used in:\n# - Web API\n# - Background worker\n# - CLI tool\n# - Tests\n</code></pre>"},{"location":"core-concepts/what-is-di/#common-anti-patterns","title":"\ud83d\udea8 Common Anti-Patterns","text":""},{"location":"core-concepts/what-is-di/#1-service-locator","title":"1. Service Locator","text":"<pre><code>class UserService:\n    def __init__(self):\n        self.db = ServiceLocator.get(Database)  # \u274c Hidden dependency\n</code></pre> <p>Problems: - Dependencies not explicit - Harder to test - Tightly coupled to locator</p>"},{"location":"core-concepts/what-is-di/#2-factory-overload","title":"2. Factory Overload","text":"<pre><code>class UserServiceFactory:\n    def create(self):\n        db = DatabaseFactory.create()\n        cache = CacheFactory.create()\n        return UserService(db, cache)  # \u274c Manual wiring everywhere\n</code></pre> <p>Problems: - Boilerplate code - Error-prone - Hard to maintain</p>"},{"location":"core-concepts/what-is-di/#3-circular-dependencies","title":"3. Circular Dependencies","text":"<pre><code>class A:\n    def __init__(self, b: B):\n        self.b = b\n\nclass B:\n    def __init__(self, a: A):  # \u274c Circular dependency\n        self.a = a\n</code></pre> <p>Problems: - Impossible to resolve - Indicates poor design</p>"},{"location":"core-concepts/what-is-di/#best-practices","title":"\ud83c\udfc6 Best Practices","text":""},{"location":"core-concepts/what-is-di/#1-use-constructor-injection","title":"1. Use Constructor Injection","text":"<pre><code># \u2705 Good\nclass UserService:\n    def __init__(self, db: Database, cache: Cache):\n        self.db = db\n        self.cache = cache\n</code></pre>"},{"location":"core-concepts/what-is-di/#2-depend-on-abstractions","title":"2. Depend on Abstractions","text":"<pre><code># \u2705 Good - depend on interface/protocol\nclass UserService:\n    def __init__(self, repository: IUserRepository):\n        self.repository = repository\n</code></pre>"},{"location":"core-concepts/what-is-di/#3-single-responsibility","title":"3. Single Responsibility","text":"<pre><code># \u2705 Good - one reason to change\nclass UserService:\n    def __init__(self, repository: IUserRepository):\n        self.repository = repository\n\n    def get_user(self, id: int):\n        return self.repository.get_by_id(id)\n</code></pre>"},{"location":"core-concepts/what-is-di/#4-explicit-dependencies","title":"4. Explicit Dependencies","text":"<pre><code># \u2705 Good - all dependencies visible\n@inject\ndef process_order(\n    order_service: OrderService,\n    payment_service: PaymentService,\n    notification_service: NotificationService\n):\n    pass\n</code></pre>"},{"location":"core-concepts/what-is-di/#summary","title":"\ud83c\udf89 Summary","text":"<p>Dependency Injection is a powerful pattern that:</p> <ul> <li>Improves testability by allowing easy mocking</li> <li>Increases flexibility by enabling easy implementation swaps</li> <li>Enhances maintainability by reducing coupling</li> <li>Promotes reusability by creating focused components</li> <li>Enables better architecture through clear separation of concerns</li> </ul> <p>InjectQ makes DI easy by providing: - Multiple injection patterns (<code>@inject</code>, dict-like, manual) - Automatic dependency resolution - Powerful scoping mechanisms - Framework integrations - Testing utilities</p> <p>Ready to dive deeper? Check out the container pattern next!</p>"},{"location":"examples/architectural-examples/","title":"Architectural Examples","text":"<p>This section demonstrates how to implement various architectural patterns and styles using InjectQ to create maintainable, scalable applications.</p>"},{"location":"examples/architectural-examples/#clean-architecture","title":"\ud83c\udfdb\ufe0f Clean Architecture","text":"<p>Clean Architecture separates concerns into distinct layers with dependency inversion. InjectQ makes this pattern natural through interface-based dependency injection.</p>"},{"location":"examples/architectural-examples/#complete-clean-architecture-implementation","title":"Complete Clean Architecture Implementation","text":"<pre><code># clean_architecture.py - Complete Clean Architecture implementation\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime\nfrom injectq import InjectQ, inject, Module\nimport asyncio\n\n# ==================== ENTITIES (Core Business Objects) ====================\n\n@dataclass\nclass User:\n    id: str\n    username: str\n    email: str\n    created_at: datetime\n    is_active: bool = True\n\n    def deactivate(self):\n        \"\"\"Business rule: User can be deactivated.\"\"\"\n        self.is_active = False\n\n    def can_create_post(self) -&gt; bool:\n        \"\"\"Business rule: Only active users can create posts.\"\"\"\n        return self.is_active\n\n@dataclass\nclass Post:\n    id: str\n    title: str\n    content: str\n    author_id: str\n    created_at: datetime\n    published: bool = False\n    view_count: int = 0\n\n    def publish(self):\n        \"\"\"Business rule: Post can be published.\"\"\"\n        if not self.title.strip():\n            raise ValueError(\"Post must have a title to be published\")\n        if not self.content.strip():\n            raise ValueError(\"Post must have content to be published\")\n        self.published = True\n\n    def increment_views(self):\n        \"\"\"Business rule: Track post views.\"\"\"\n        self.view_count += 1\n\n# ==================== USE CASES (Application Layer) ====================\n\n# Input/Output Models\n@dataclass\nclass CreateUserRequest:\n    username: str\n    email: str\n\n@dataclass\nclass CreateUserResponse:\n    user_id: str\n    username: str\n    email: str\n    success: bool\n    error_message: Optional[str] = None\n\n@dataclass\nclass CreatePostRequest:\n    title: str\n    content: str\n    author_id: str\n\n@dataclass\nclass CreatePostResponse:\n    post_id: str\n    title: str\n    success: bool\n    error_message: Optional[str] = None\n\n@dataclass\nclass GetPostResponse:\n    post: Optional[Post]\n    success: bool\n    error_message: Optional[str] = None\n\n# Repository Interfaces (Dependency Inversion)\nclass IUserRepository(ABC):\n    @abstractmethod\n    async def save(self, user: User) -&gt; User:\n        pass\n\n    @abstractmethod\n    async def find_by_id(self, user_id: str) -&gt; Optional[User]:\n        pass\n\n    @abstractmethod\n    async def find_by_username(self, username: str) -&gt; Optional[User]:\n        pass\n\n    @abstractmethod\n    async def find_by_email(self, email: str) -&gt; Optional[User]:\n        pass\n\nclass IPostRepository(ABC):\n    @abstractmethod\n    async def save(self, post: Post) -&gt; Post:\n        pass\n\n    @abstractmethod\n    async def find_by_id(self, post_id: str) -&gt; Optional[Post]:\n        pass\n\n    @abstractmethod\n    async def find_by_author(self, author_id: str) -&gt; List[Post]:\n        pass\n\n# External Service Interfaces\nclass IEmailService(ABC):\n    @abstractmethod\n    async def send_welcome_email(self, user: User) -&gt; bool:\n        pass\n\nclass IIdGenerator(ABC):\n    @abstractmethod\n    def generate_id(self) -&gt; str:\n        pass\n\n# Use Case Classes\nclass CreateUserUseCase:\n    @inject\n    def __init__(\n        self,\n        user_repository: IUserRepository,\n        email_service: IEmailService,\n        id_generator: IIdGenerator\n    ):\n        self.user_repository = user_repository\n        self.email_service = email_service\n        self.id_generator = id_generator\n\n    async def execute(self, request: CreateUserRequest) -&gt; CreateUserResponse:\n        try:\n            # Validate business rules\n            if not request.username.strip():\n                return CreateUserResponse(\n                    user_id=\"\",\n                    username=request.username,\n                    email=request.email,\n                    success=False,\n                    error_message=\"Username cannot be empty\"\n                )\n\n            if not request.email.strip() or \"@\" not in request.email:\n                return CreateUserResponse(\n                    user_id=\"\",\n                    username=request.username,\n                    email=request.email,\n                    success=False,\n                    error_message=\"Invalid email address\"\n                )\n\n            # Check if user already exists\n            existing_user = await self.user_repository.find_by_username(request.username)\n            if existing_user:\n                return CreateUserResponse(\n                    user_id=\"\",\n                    username=request.username,\n                    email=request.email,\n                    success=False,\n                    error_message=\"Username already exists\"\n                )\n\n            existing_email = await self.user_repository.find_by_email(request.email)\n            if existing_email:\n                return CreateUserResponse(\n                    user_id=\"\",\n                    username=request.username,\n                    email=request.email,\n                    success=False,\n                    error_message=\"Email already exists\"\n                )\n\n            # Create user entity\n            user = User(\n                id=self.id_generator.generate_id(),\n                username=request.username,\n                email=request.email,\n                created_at=datetime.now()\n            )\n\n            # Save user\n            saved_user = await self.user_repository.save(user)\n\n            # Send welcome email (external service)\n            await self.email_service.send_welcome_email(saved_user)\n\n            return CreateUserResponse(\n                user_id=saved_user.id,\n                username=saved_user.username,\n                email=saved_user.email,\n                success=True\n            )\n\n        except Exception as e:\n            return CreateUserResponse(\n                user_id=\"\",\n                username=request.username,\n                email=request.email,\n                success=False,\n                error_message=f\"Unexpected error: {str(e)}\"\n            )\n\nclass CreatePostUseCase:\n    @inject\n    def __init__(\n        self,\n        post_repository: IPostRepository,\n        user_repository: IUserRepository,\n        id_generator: IIdGenerator\n    ):\n        self.post_repository = post_repository\n        self.user_repository = user_repository\n        self.id_generator = id_generator\n\n    async def execute(self, request: CreatePostRequest) -&gt; CreatePostResponse:\n        try:\n            # Find the author\n            author = await self.user_repository.find_by_id(request.author_id)\n            if not author:\n                return CreatePostResponse(\n                    post_id=\"\",\n                    title=request.title,\n                    success=False,\n                    error_message=\"Author not found\"\n                )\n\n            # Check business rules\n            if not author.can_create_post():\n                return CreatePostResponse(\n                    post_id=\"\",\n                    title=request.title,\n                    success=False,\n                    error_message=\"User is not active and cannot create posts\"\n                )\n\n            # Create post entity\n            post = Post(\n                id=self.id_generator.generate_id(),\n                title=request.title,\n                content=request.content,\n                author_id=request.author_id,\n                created_at=datetime.now()\n            )\n\n            # Save post\n            saved_post = await self.post_repository.save(post)\n\n            return CreatePostResponse(\n                post_id=saved_post.id,\n                title=saved_post.title,\n                success=True\n            )\n\n        except Exception as e:\n            return CreatePostResponse(\n                post_id=\"\",\n                title=request.title,\n                success=False,\n                error_message=f\"Unexpected error: {str(e)}\"\n            )\n\nclass GetPostUseCase:\n    @inject\n    def __init__(self, post_repository: IPostRepository):\n        self.post_repository = post_repository\n\n    async def execute(self, post_id: str) -&gt; GetPostResponse:\n        try:\n            post = await self.post_repository.find_by_id(post_id)\n\n            if not post:\n                return GetPostResponse(\n                    post=None,\n                    success=False,\n                    error_message=\"Post not found\"\n                )\n\n            # Business rule: Increment view count\n            post.increment_views()\n            await self.post_repository.save(post)\n\n            return GetPostResponse(\n                post=post,\n                success=True\n            )\n\n        except Exception as e:\n            return GetPostResponse(\n                post=None,\n                success=False,\n                error_message=f\"Unexpected error: {str(e)}\"\n            )\n\n# ==================== INTERFACE ADAPTERS (Infrastructure Layer) ====================\n\n# Database Implementations\nclass DatabaseUserRepository(IUserRepository):\n    @inject\n    def __init__(self, database_connection: DatabaseConnection):\n        self.db = database_connection\n        self.users: Dict[str, User] = {}  # In-memory for demo\n\n    async def save(self, user: User) -&gt; User:\n        self.users[user.id] = user\n        return user\n\n    async def find_by_id(self, user_id: str) -&gt; Optional[User]:\n        return self.users.get(user_id)\n\n    async def find_by_username(self, username: str) -&gt; Optional[User]:\n        for user in self.users.values():\n            if user.username == username:\n                return user\n        return None\n\n    async def find_by_email(self, email: str) -&gt; Optional[User]:\n        for user in self.users.values():\n            if user.email == email:\n                return user\n        return None\n\nclass DatabasePostRepository(IPostRepository):\n    @inject\n    def __init__(self, database_connection: DatabaseConnection):\n        self.db = database_connection\n        self.posts: Dict[str, Post] = {}  # In-memory for demo\n\n    async def save(self, post: Post) -&gt; Post:\n        self.posts[post.id] = post\n        return post\n\n    async def find_by_id(self, post_id: str) -&gt; Optional[Post]:\n        return self.posts.get(post_id)\n\n    async def find_by_author(self, author_id: str) -&gt; List[Post]:\n        return [post for post in self.posts.values() if post.author_id == author_id]\n\n# External Service Implementations\nclass EmailServiceImpl(IEmailService):\n    @inject\n    def __init__(self, email_config: EmailConfig):\n        self.config = email_config\n\n    async def send_welcome_email(self, user: User) -&gt; bool:\n        print(f\"Sending welcome email to {user.email}\")\n        await asyncio.sleep(0.1)  # Simulate network delay\n        return True\n\nclass UUIDGenerator(IIdGenerator):\n    def generate_id(self) -&gt; str:\n        import uuid\n        return str(uuid.uuid4())\n\n# Configuration\nclass DatabaseConnection:\n    @inject\n    def __init__(self, db_config: DatabaseConfig):\n        self.config = db_config\n\nclass DatabaseConfig:\n    def __init__(self, host: str, port: int, database: str):\n        self.host = host\n        self.port = port\n        self.database = database\n\nclass EmailConfig:\n    def __init__(self, smtp_host: str, smtp_port: int):\n        self.smtp_host = smtp_host\n        self.smtp_port = smtp_port\n\n# ==================== FRAMEWORKS &amp; DRIVERS (Presentation Layer) ====================\n\n# Web Controllers (FastAPI example)\nclass UserController:\n    @inject\n    def __init__(self, create_user_use_case: CreateUserUseCase):\n        self.create_user_use_case = create_user_use_case\n\n    async def create_user(self, user_data: Dict[str, str]) -&gt; Dict[str, Any]:\n        request = CreateUserRequest(\n            username=user_data[\"username\"],\n            email=user_data[\"email\"]\n        )\n\n        response = await self.create_user_use_case.execute(request)\n\n        if response.success:\n            return {\n                \"status\": \"success\",\n                \"data\": {\n                    \"user_id\": response.user_id,\n                    \"username\": response.username,\n                    \"email\": response.email\n                }\n            }\n        else:\n            return {\n                \"status\": \"error\",\n                \"message\": response.error_message\n            }\n\nclass PostController:\n    @inject\n    def __init__(\n        self,\n        create_post_use_case: CreatePostUseCase,\n        get_post_use_case: GetPostUseCase\n    ):\n        self.create_post_use_case = create_post_use_case\n        self.get_post_use_case = get_post_use_case\n\n    async def create_post(self, post_data: Dict[str, str]) -&gt; Dict[str, Any]:\n        request = CreatePostRequest(\n            title=post_data[\"title\"],\n            content=post_data[\"content\"],\n            author_id=post_data[\"author_id\"]\n        )\n\n        response = await self.create_post_use_case.execute(request)\n\n        if response.success:\n            return {\n                \"status\": \"success\",\n                \"data\": {\n                    \"post_id\": response.post_id,\n                    \"title\": response.title\n                }\n            }\n        else:\n            return {\n                \"status\": \"error\",\n                \"message\": response.error_message\n            }\n\n    async def get_post(self, post_id: str) -&gt; Dict[str, Any]:\n        response = await self.get_post_use_case.execute(post_id)\n\n        if response.success and response.post:\n            post = response.post\n            return {\n                \"status\": \"success\",\n                \"data\": {\n                    \"id\": post.id,\n                    \"title\": post.title,\n                    \"content\": post.content,\n                    \"author_id\": post.author_id,\n                    \"created_at\": post.created_at.isoformat(),\n                    \"published\": post.published,\n                    \"view_count\": post.view_count\n                }\n            }\n        else:\n            return {\n                \"status\": \"error\",\n                \"message\": response.error_message\n            }\n\n# Application Orchestrator\nclass BlogApplication:\n    @inject\n    def __init__(\n        self,\n        user_controller: UserController,\n        post_controller: PostController\n    ):\n        self.user_controller = user_controller\n        self.post_controller = post_controller\n\n    async def run_demo(self):\n        \"\"\"Demonstrate the clean architecture in action.\"\"\"\n        print(\"=== Clean Architecture Demo ===\\n\")\n\n        # Create a user\n        print(\"1. Creating a user...\")\n        user_result = await self.user_controller.create_user({\n            \"username\": \"john_doe\",\n            \"email\": \"john@example.com\"\n        })\n        print(f\"Result: {user_result}\\n\")\n\n        if user_result[\"status\"] == \"success\":\n            user_id = user_result[\"data\"][\"user_id\"]\n\n            # Create a post\n            print(\"2. Creating a post...\")\n            post_result = await self.post_controller.create_post({\n                \"title\": \"My First Blog Post\",\n                \"content\": \"This is the content of my first blog post using Clean Architecture!\",\n                \"author_id\": user_id\n            })\n            print(f\"Result: {post_result}\\n\")\n\n            if post_result[\"status\"] == \"success\":\n                post_id = post_result[\"data\"][\"post_id\"]\n\n                # Get the post (should increment view count)\n                print(\"3. Getting the post...\")\n                get_result = await self.post_controller.get_post(post_id)\n                print(f\"Result: {get_result}\\n\")\n\n                # Get the post again (view count should increment)\n                print(\"4. Getting the post again...\")\n                get_result2 = await self.post_controller.get_post(post_id)\n                print(f\"Result: {get_result2}\\n\")\n\n        # Test validation\n        print(\"5. Testing validation - creating user with invalid email...\")\n        invalid_user_result = await self.user_controller.create_user({\n            \"username\": \"invalid_user\",\n            \"email\": \"invalid-email\"\n        })\n        print(f\"Result: {invalid_user_result}\\n\")\n\n# ==================== DEPENDENCY INJECTION CONFIGURATION ====================\n\nclass CleanArchitectureModule(Module):\n    def configure(self):\n        # Infrastructure Configuration\n        self.bind(DatabaseConfig, DatabaseConfig(\n            host=\"localhost\",\n            port=5432,\n            database=\"blog_db\"\n        )).singleton()\n\n        self.bind(EmailConfig, EmailConfig(\n            smtp_host=\"smtp.example.com\",\n            smtp_port=587\n        )).singleton()\n\n        # Infrastructure Services\n        self.bind(DatabaseConnection, DatabaseConnection).singleton()\n        self.bind(IIdGenerator, UUIDGenerator).singleton()\n        self.bind(IEmailService, EmailServiceImpl).singleton()\n\n        # Repositories (Interface Adapters)\n        self.bind(IUserRepository, DatabaseUserRepository).scoped()\n        self.bind(IPostRepository, DatabasePostRepository).scoped()\n\n        # Use Cases (Application Layer)\n        self.bind(CreateUserUseCase, CreateUserUseCase).scoped()\n        self.bind(CreatePostUseCase, CreatePostUseCase).scoped()\n        self.bind(GetPostUseCase, GetPostUseCase).scoped()\n\n        # Controllers (Presentation Layer)\n        self.bind(UserController, UserController).scoped()\n        self.bind(PostController, PostController).scoped()\n\n        # Application\n        self.bind(BlogApplication, BlogApplication).singleton()\n\n# Usage Example\nasync def clean_architecture_example():\n    container = InjectQ()\n    container.install(CleanArchitectureModule())\n\n    app = container.get(BlogApplication)\n    await app.run_demo()\n</code></pre>"},{"location":"examples/architectural-examples/#domain-driven-design-ddd","title":"\ud83c\udfaf Domain-Driven Design (DDD)","text":"<p>DDD focuses on the business domain and uses ubiquitous language. InjectQ supports DDD patterns through careful dependency management.</p> <pre><code># ddd_example.py - Domain-Driven Design implementation\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass, field\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime, timedelta\nfrom enum import Enum\nfrom injectq import InjectQ, inject, Module\n\n# ==================== VALUE OBJECTS ====================\n\n@dataclass(frozen=True)\nclass Money:\n    amount: float\n    currency: str = \"USD\"\n\n    def __post_init__(self):\n        if self.amount &lt; 0:\n            raise ValueError(\"Amount cannot be negative\")\n        if not self.currency:\n            raise ValueError(\"Currency is required\")\n\n    def add(self, other: 'Money') -&gt; 'Money':\n        if self.currency != other.currency:\n            raise ValueError(\"Cannot add different currencies\")\n        return Money(self.amount + other.amount, self.currency)\n\n    def subtract(self, other: 'Money') -&gt; 'Money':\n        if self.currency != other.currency:\n            raise ValueError(\"Cannot subtract different currencies\")\n        result = self.amount - other.amount\n        if result &lt; 0:\n            raise ValueError(\"Insufficient funds\")\n        return Money(result, self.currency)\n\n    def multiply(self, factor: float) -&gt; 'Money':\n        return Money(self.amount * factor, self.currency)\n\n@dataclass(frozen=True)\nclass CustomerId:\n    value: str\n\n    def __post_init__(self):\n        if not self.value or not self.value.strip():\n            raise ValueError(\"Customer ID cannot be empty\")\n\n@dataclass(frozen=True)\nclass ProductId:\n    value: str\n\n    def __post_init__(self):\n        if not self.value or not self.value.strip():\n            raise ValueError(\"Product ID cannot be empty\")\n\n@dataclass(frozen=True)\nclass OrderId:\n    value: str\n\n    def __post_init__(self):\n        if not self.value or not self.value.strip():\n            raise ValueError(\"Order ID cannot be empty\")\n\n@dataclass(frozen=True)\nclass EmailAddress:\n    value: str\n\n    def __post_init__(self):\n        if not self.value or \"@\" not in self.value:\n            raise ValueError(\"Invalid email address\")\n\n# ==================== ENUMERATIONS ====================\n\nclass OrderStatus(Enum):\n    PENDING = \"pending\"\n    CONFIRMED = \"confirmed\"\n    SHIPPED = \"shipped\"\n    DELIVERED = \"delivered\"\n    CANCELLED = \"cancelled\"\n\nclass CustomerType(Enum):\n    REGULAR = \"regular\"\n    PREMIUM = \"premium\"\n    VIP = \"vip\"\n\n# ==================== ENTITIES ====================\n\nclass Customer:\n    def __init__(\n        self,\n        customer_id: CustomerId,\n        name: str,\n        email: EmailAddress,\n        customer_type: CustomerType = CustomerType.REGULAR\n    ):\n        self.id = customer_id\n        self.name = name\n        self.email = email\n        self.customer_type = customer_type\n        self.created_at = datetime.now()\n        self._order_history: List[OrderId] = []\n\n    def add_order(self, order_id: OrderId):\n        \"\"\"Domain behavior: Add order to customer history.\"\"\"\n        self._order_history.append(order_id)\n\n    def get_order_count(self) -&gt; int:\n        \"\"\"Domain behavior: Get total number of orders.\"\"\"\n        return len(self._order_history)\n\n    def can_get_discount(self) -&gt; bool:\n        \"\"\"Domain rule: VIP customers always get discount, Premium with 5+ orders.\"\"\"\n        if self.customer_type == CustomerType.VIP:\n            return True\n        elif self.customer_type == CustomerType.PREMIUM:\n            return self.get_order_count() &gt;= 5\n        return False\n\n    def get_discount_percentage(self) -&gt; float:\n        \"\"\"Domain rule: Calculate discount percentage.\"\"\"\n        if self.customer_type == CustomerType.VIP:\n            return 0.15  # 15%\n        elif self.customer_type == CustomerType.PREMIUM and self.get_order_count() &gt;= 5:\n            return 0.10  # 10%\n        return 0.0\n\nclass Product:\n    def __init__(\n        self,\n        product_id: ProductId,\n        name: str,\n        price: Money,\n        stock_quantity: int\n    ):\n        self.id = product_id\n        self.name = name\n        self.price = price\n        self.stock_quantity = stock_quantity\n\n    def is_available(self, quantity: int) -&gt; bool:\n        \"\"\"Domain rule: Check if product is available in required quantity.\"\"\"\n        return self.stock_quantity &gt;= quantity\n\n    def reduce_stock(self, quantity: int):\n        \"\"\"Domain behavior: Reduce stock quantity.\"\"\"\n        if not self.is_available(quantity):\n            raise ValueError(f\"Insufficient stock. Available: {self.stock_quantity}, Requested: {quantity}\")\n        self.stock_quantity -= quantity\n\n    def increase_stock(self, quantity: int):\n        \"\"\"Domain behavior: Increase stock quantity.\"\"\"\n        self.stock_quantity += quantity\n\n# ==================== AGGREGATES ====================\n\n@dataclass\nclass OrderItem:\n    product_id: ProductId\n    product_name: str\n    unit_price: Money\n    quantity: int\n\n    @property\n    def total_price(self) -&gt; Money:\n        return self.unit_price.multiply(self.quantity)\n\nclass Order:  # Aggregate Root\n    def __init__(\n        self,\n        order_id: OrderId,\n        customer_id: CustomerId\n    ):\n        self.id = order_id\n        self.customer_id = customer_id\n        self.status = OrderStatus.PENDING\n        self.created_at = datetime.now()\n        self._items: List[OrderItem] = []\n        self._discount_percentage: float = 0.0\n\n    def add_item(self, product: Product, quantity: int):\n        \"\"\"Domain behavior: Add item to order.\"\"\"\n        if self.status != OrderStatus.PENDING:\n            raise ValueError(\"Cannot modify confirmed order\")\n\n        if not product.is_available(quantity):\n            raise ValueError(f\"Product {product.name} is not available in quantity {quantity}\")\n\n        # Check if item already exists\n        for item in self._items:\n            if item.product_id == product.id:\n                item.quantity += quantity\n                return\n\n        # Add new item\n        order_item = OrderItem(\n            product_id=product.id,\n            product_name=product.name,\n            unit_price=product.price,\n            quantity=quantity\n        )\n        self._items.append(order_item)\n\n    def remove_item(self, product_id: ProductId):\n        \"\"\"Domain behavior: Remove item from order.\"\"\"\n        if self.status != OrderStatus.PENDING:\n            raise ValueError(\"Cannot modify confirmed order\")\n\n        self._items = [item for item in self._items if item.product_id != product_id]\n\n    def apply_customer_discount(self, customer: Customer):\n        \"\"\"Domain behavior: Apply customer-specific discount.\"\"\"\n        if customer.can_get_discount():\n            self._discount_percentage = customer.get_discount_percentage()\n\n    def get_subtotal(self) -&gt; Money:\n        \"\"\"Domain calculation: Calculate subtotal before discounts.\"\"\"\n        if not self._items:\n            return Money(0.0)\n\n        total = self._items[0].total_price\n        for item in self._items[1:]:\n            total = total.add(item.total_price)\n        return total\n\n    def get_discount_amount(self) -&gt; Money:\n        \"\"\"Domain calculation: Calculate discount amount.\"\"\"\n        subtotal = self.get_subtotal()\n        return subtotal.multiply(self._discount_percentage)\n\n    def get_total(self) -&gt; Money:\n        \"\"\"Domain calculation: Calculate final total.\"\"\"\n        subtotal = self.get_subtotal()\n        discount = self.get_discount_amount()\n        return subtotal.subtract(discount)\n\n    def confirm(self):\n        \"\"\"Domain behavior: Confirm the order.\"\"\"\n        if not self._items:\n            raise ValueError(\"Cannot confirm empty order\")\n        if self.status != OrderStatus.PENDING:\n            raise ValueError(\"Order already confirmed\")\n\n        self.status = OrderStatus.CONFIRMED\n\n    def ship(self):\n        \"\"\"Domain behavior: Ship the order.\"\"\"\n        if self.status != OrderStatus.CONFIRMED:\n            raise ValueError(\"Can only ship confirmed orders\")\n        self.status = OrderStatus.SHIPPED\n\n    def deliver(self):\n        \"\"\"Domain behavior: Mark order as delivered.\"\"\"\n        if self.status != OrderStatus.SHIPPED:\n            raise ValueError(\"Can only deliver shipped orders\")\n        self.status = OrderStatus.DELIVERED\n\n    def cancel(self):\n        \"\"\"Domain behavior: Cancel the order.\"\"\"\n        if self.status in [OrderStatus.SHIPPED, OrderStatus.DELIVERED]:\n            raise ValueError(\"Cannot cancel shipped or delivered orders\")\n        self.status = OrderStatus.CANCELLED\n\n    @property\n    def items(self) -&gt; List[OrderItem]:\n        \"\"\"Read-only access to order items.\"\"\"\n        return self._items.copy()\n\n# ==================== DOMAIN SERVICES ====================\n\nclass PricingService:\n    \"\"\"Domain service for complex pricing logic.\"\"\"\n\n    def calculate_shipping_cost(self, order: Order, customer: Customer) -&gt; Money:\n        \"\"\"Calculate shipping cost based on order and customer.\"\"\"\n        subtotal = order.get_subtotal()\n\n        # Free shipping for VIP customers\n        if customer.customer_type == CustomerType.VIP:\n            return Money(0.0)\n\n        # Free shipping for orders over $100\n        if subtotal.amount &gt;= 100.0:\n            return Money(0.0)\n\n        # Premium customers get reduced shipping\n        if customer.customer_type == CustomerType.PREMIUM:\n            return Money(5.0)\n\n        # Regular shipping cost\n        return Money(10.0)\n\n    def calculate_tax(self, order: Order) -&gt; Money:\n        \"\"\"Calculate tax for the order.\"\"\"\n        subtotal = order.get_subtotal()\n        discount = order.get_discount_amount()\n        taxable_amount = subtotal.subtract(discount)\n\n        # 8.5% tax rate\n        return taxable_amount.multiply(0.085)\n\nclass InventoryService:\n    \"\"\"Domain service for inventory management.\"\"\"\n\n    @inject\n    def __init__(self, product_repository: 'IProductRepository'):\n        self.product_repository = product_repository\n\n    async def reserve_inventory(self, order: Order) -&gt; bool:\n        \"\"\"Reserve inventory for order items.\"\"\"\n        try:\n            # Check availability for all items first\n            for item in order.items:\n                product = await self.product_repository.find_by_id(item.product_id)\n                if not product or not product.is_available(item.quantity):\n                    return False\n\n            # Reserve inventory for all items\n            for item in order.items:\n                product = await self.product_repository.find_by_id(item.product_id)\n                product.reduce_stock(item.quantity)\n                await self.product_repository.save(product)\n\n            return True\n\n        except Exception:\n            # Rollback logic would go here in a real implementation\n            return False\n\n    async def release_inventory(self, order: Order) -&gt; bool:\n        \"\"\"Release reserved inventory (e.g., when order is cancelled).\"\"\"\n        try:\n            for item in order.items:\n                product = await self.product_repository.find_by_id(item.product_id)\n                if product:\n                    product.increase_stock(item.quantity)\n                    await self.product_repository.save(product)\n\n            return True\n\n        except Exception:\n            return False\n\n# ==================== REPOSITORIES (INTERFACES) ====================\n\nclass ICustomerRepository(ABC):\n    @abstractmethod\n    async def find_by_id(self, customer_id: CustomerId) -&gt; Optional[Customer]:\n        pass\n\n    @abstractmethod\n    async def save(self, customer: Customer) -&gt; Customer:\n        pass\n\nclass IProductRepository(ABC):\n    @abstractmethod\n    async def find_by_id(self, product_id: ProductId) -&gt; Optional[Product]:\n        pass\n\n    @abstractmethod\n    async def save(self, product: Product) -&gt; Product:\n        pass\n\nclass IOrderRepository(ABC):\n    @abstractmethod\n    async def find_by_id(self, order_id: OrderId) -&gt; Optional[Order]:\n        pass\n\n    @abstractmethod\n    async def save(self, order: Order) -&gt; Order:\n        pass\n\n    @abstractmethod\n    async def find_by_customer(self, customer_id: CustomerId) -&gt; List[Order]:\n        pass\n\n# ==================== APPLICATION SERVICES ====================\n\nclass OrderApplicationService:\n    \"\"\"Application service orchestrating domain objects.\"\"\"\n\n    @inject\n    def __init__(\n        self,\n        order_repository: IOrderRepository,\n        customer_repository: ICustomerRepository,\n        product_repository: IProductRepository,\n        pricing_service: PricingService,\n        inventory_service: InventoryService\n    ):\n        self.order_repository = order_repository\n        self.customer_repository = customer_repository\n        self.product_repository = product_repository\n        self.pricing_service = pricing_service\n        self.inventory_service = inventory_service\n\n    async def create_order(self, customer_id: CustomerId, order_id: OrderId) -&gt; Order:\n        \"\"\"Create a new order.\"\"\"\n        customer = await self.customer_repository.find_by_id(customer_id)\n        if not customer:\n            raise ValueError(\"Customer not found\")\n\n        order = Order(order_id, customer_id)\n        await self.order_repository.save(order)\n        return order\n\n    async def add_item_to_order(\n        self,\n        order_id: OrderId,\n        product_id: ProductId,\n        quantity: int\n    ) -&gt; Order:\n        \"\"\"Add item to an existing order.\"\"\"\n        order = await self.order_repository.find_by_id(order_id)\n        if not order:\n            raise ValueError(\"Order not found\")\n\n        product = await self.product_repository.find_by_id(product_id)\n        if not product:\n            raise ValueError(\"Product not found\")\n\n        order.add_item(product, quantity)\n        await self.order_repository.save(order)\n        return order\n\n    async def confirm_order(self, order_id: OrderId) -&gt; Dict[str, Any]:\n        \"\"\"Confirm an order with full business logic.\"\"\"\n        order = await self.order_repository.find_by_id(order_id)\n        if not order:\n            raise ValueError(\"Order not found\")\n\n        customer = await self.customer_repository.find_by_id(order.customer_id)\n        if not customer:\n            raise ValueError(\"Customer not found\")\n\n        # Apply domain logic\n        order.apply_customer_discount(customer)\n\n        # Reserve inventory\n        inventory_reserved = await self.inventory_service.reserve_inventory(order)\n        if not inventory_reserved:\n            raise ValueError(\"Unable to reserve inventory\")\n\n        # Confirm order\n        order.confirm()\n\n        # Calculate final amounts\n        subtotal = order.get_subtotal()\n        discount = order.get_discount_amount()\n        tax = self.pricing_service.calculate_tax(order)\n        shipping = self.pricing_service.calculate_shipping_cost(order, customer)\n        total = order.get_total().add(tax).add(shipping)\n\n        # Update customer order history\n        customer.add_order(order.id)\n\n        # Save changes\n        await self.order_repository.save(order)\n        await self.customer_repository.save(customer)\n\n        return {\n            \"order_id\": order.id.value,\n            \"status\": order.status.value,\n            \"subtotal\": subtotal.amount,\n            \"discount\": discount.amount,\n            \"tax\": tax.amount,\n            \"shipping\": shipping.amount,\n            \"total\": total.amount,\n            \"currency\": total.currency\n        }\n\n# ==================== INFRASTRUCTURE ====================\n\n# Repository Implementations\nclass InMemoryCustomerRepository(ICustomerRepository):\n    def __init__(self):\n        self._customers: Dict[str, Customer] = {}\n\n    async def find_by_id(self, customer_id: CustomerId) -&gt; Optional[Customer]:\n        return self._customers.get(customer_id.value)\n\n    async def save(self, customer: Customer) -&gt; Customer:\n        self._customers[customer.id.value] = customer\n        return customer\n\nclass InMemoryProductRepository(IProductRepository):\n    def __init__(self):\n        self._products: Dict[str, Product] = {}\n\n    async def find_by_id(self, product_id: ProductId) -&gt; Optional[Product]:\n        return self._products.get(product_id.value)\n\n    async def save(self, product: Product) -&gt; Product:\n        self._products[product.id.value] = product\n        return product\n\nclass InMemoryOrderRepository(IOrderRepository):\n    def __init__(self):\n        self._orders: Dict[str, Order] = {}\n\n    async def find_by_id(self, order_id: OrderId) -&gt; Optional[Order]:\n        return self._orders.get(order_id.value)\n\n    async def save(self, order: Order) -&gt; Order:\n        self._orders[order.id.value] = order\n        return order\n\n    async def find_by_customer(self, customer_id: CustomerId) -&gt; List[Order]:\n        return [\n            order for order in self._orders.values()\n            if order.customer_id == customer_id\n        ]\n\n# ==================== MODULE CONFIGURATION ====================\n\nclass DDDModule(Module):\n    def configure(self):\n        # Repositories\n        self.bind(ICustomerRepository, InMemoryCustomerRepository).singleton()\n        self.bind(IProductRepository, InMemoryProductRepository).singleton()\n        self.bind(IOrderRepository, InMemoryOrderRepository).singleton()\n\n        # Domain Services\n        self.bind(PricingService, PricingService).singleton()\n        self.bind(InventoryService, InventoryService).singleton()\n\n        # Application Services\n        self.bind(OrderApplicationService, OrderApplicationService).singleton()\n\n# ==================== DEMO APPLICATION ====================\n\nclass DDDDemo:\n    @inject\n    def __init__(\n        self,\n        customer_repository: ICustomerRepository,\n        product_repository: IProductRepository,\n        order_service: OrderApplicationService\n    ):\n        self.customer_repository = customer_repository\n        self.product_repository = product_repository\n        self.order_service = order_service\n\n    async def run_demo(self):\n        \"\"\"Demonstrate DDD patterns.\"\"\"\n        print(\"=== Domain-Driven Design Demo ===\\n\")\n\n        # Setup test data\n        await self._setup_test_data()\n\n        # Create and process an order\n        customer_id = CustomerId(\"customer-123\")\n        order_id = OrderId(\"order-456\")\n\n        print(\"1. Creating order...\")\n        order = await self.order_service.create_order(customer_id, order_id)\n        print(f\"Created order: {order.id.value}\\n\")\n\n        print(\"2. Adding items to order...\")\n        await self.order_service.add_item_to_order(\n            order_id,\n            ProductId(\"laptop-001\"),\n            1\n        )\n        await self.order_service.add_item_to_order(\n            order_id,\n            ProductId(\"mouse-001\"),\n            2\n        )\n        print(\"Items added to order\\n\")\n\n        print(\"3. Confirming order...\")\n        result = await self.order_service.confirm_order(order_id)\n        print(f\"Order confirmed: {result}\\n\")\n\n    async def _setup_test_data(self):\n        \"\"\"Setup test customers and products.\"\"\"\n        # Create customers\n        customer = Customer(\n            CustomerId(\"customer-123\"),\n            \"John Doe\",\n            EmailAddress(\"john@example.com\"),\n            CustomerType.PREMIUM\n        )\n        await self.customer_repository.save(customer)\n\n        # Create products\n        laptop = Product(\n            ProductId(\"laptop-001\"),\n            \"Gaming Laptop\",\n            Money(999.99),\n            10\n        )\n        await self.product_repository.save(laptop)\n\n        mouse = Product(\n            ProductId(\"mouse-001\"),\n            \"Wireless Mouse\",\n            Money(29.99),\n            50\n        )\n        await self.product_repository.save(mouse)\n\n# Usage Example\nasync def ddd_example():\n    container = InjectQ()\n    container.install(DDDModule())\n\n    demo = container.get(DDDDemo)\n    await demo.run_demo()\n</code></pre> <p>This architectural examples section demonstrates:</p> <ol> <li>Clean Architecture: Complete implementation with proper layer separation and dependency inversion</li> <li>Domain-Driven Design: Rich domain models with value objects, entities, aggregates, and domain services</li> </ol> <p>Key architectural principles shown: - Dependency inversion through interfaces - Separation of concerns across layers - Rich domain models with business logic - Application services orchestrating domain operations - Infrastructure implementations hidden behind abstractions - Proper error handling and validation - Comprehensive dependency injection configuration</p> <p>Ready to continue with more architectural patterns or move to the next documentation section?</p>"},{"location":"examples/design-patterns/","title":"Design Patterns with InjectQ","text":"<p>This guide demonstrates how to implement common design patterns using InjectQ's dependency injection capabilities.</p>"},{"location":"examples/design-patterns/#factory-pattern","title":"\ud83c\udfed Factory Pattern","text":"<p>The Factory pattern provides a way to create objects without specifying their exact class. InjectQ makes this pattern elegant through named bindings and conditional injection.</p>"},{"location":"examples/design-patterns/#simple-factory","title":"Simple Factory","text":"<pre><code># simple_factory.py\nfrom abc import ABC, abstractmethod\nfrom injectq import InjectQ, inject, Module\nfrom typing import Dict, Type\n\n# Product Interface\nclass INotificationService(ABC):\n    @abstractmethod\n    async def send(self, message: str, recipient: str) -&gt; bool:\n        pass\n\n# Concrete Products\nclass EmailNotificationService(INotificationService):\n    @inject\n    def __init__(self, email_config: EmailConfig):\n        self.config = email_config\n\n    async def send(self, message: str, recipient: str) -&gt; bool:\n        print(f\"Sending email to {recipient}: {message}\")\n        return True\n\nclass SMSNotificationService(INotificationService):\n    @inject\n    def __init__(self, sms_config: SMSConfig):\n        self.config = sms_config\n\n    async def send(self, message: str, recipient: str) -&gt; bool:\n        print(f\"Sending SMS to {recipient}: {message}\")\n        return True\n\nclass PushNotificationService(INotificationService):\n    @inject\n    def __init__(self, push_config: PushConfig):\n        self.config = push_config\n\n    async def send(self, message: str, recipient: str) -&gt; bool:\n        print(f\"Sending push notification to {recipient}: {message}\")\n        return True\n\n# Configuration Classes\nclass EmailConfig:\n    def __init__(self, smtp_host: str, smtp_port: int):\n        self.smtp_host = smtp_host\n        self.smtp_port = smtp_port\n\nclass SMSConfig:\n    def __init__(self, api_key: str, endpoint: str):\n        self.api_key = api_key\n        self.endpoint = endpoint\n\nclass PushConfig:\n    def __init__(self, app_id: str, api_key: str):\n        self.app_id = app_id\n        self.api_key = api_key\n\n# Factory Interface\nclass INotificationFactory(ABC):\n    @abstractmethod\n    def create_notification_service(self, notification_type: str) -&gt; INotificationService:\n        pass\n\n# Factory Implementation\nclass NotificationFactory(INotificationFactory):\n    @inject\n    def __init__(self, container: InjectQ):\n        self.container = container\n        self._service_map = {\n            \"email\": \"email_service\",\n            \"sms\": \"sms_service\",\n            \"push\": \"push_service\"\n        }\n\n    def create_notification_service(self, notification_type: str) -&gt; INotificationService:\n        service_name = self._service_map.get(notification_type)\n        if not service_name:\n            raise ValueError(f\"Unsupported notification type: {notification_type}\")\n\n        return self.container.get(INotificationService, name=service_name)\n\n# Client Code\nclass NotificationManager:\n    @inject\n    def __init__(self, notification_factory: INotificationFactory):\n        self.factory = notification_factory\n\n    async def send_notification(self, notification_type: str, message: str, recipient: str) -&gt; bool:\n        service = self.factory.create_notification_service(notification_type)\n        return await service.send(message, recipient)\n\n    async def send_multi_channel(self, message: str, recipient: str, channels: list) -&gt; Dict[str, bool]:\n        results = {}\n        for channel in channels:\n            try:\n                service = self.factory.create_notification_service(channel)\n                results[channel] = await service.send(message, recipient)\n            except Exception as e:\n                print(f\"Failed to send {channel} notification: {e}\")\n                results[channel] = False\n        return results\n\n# Module Configuration\nclass NotificationModule(Module):\n    def configure(self):\n        # Configuration\n        self.bind(EmailConfig, EmailConfig(\"smtp.example.com\", 587)).singleton()\n        self.bind(SMSConfig, SMSConfig(\"sms_api_key\", \"https://api.sms.com\")).singleton()\n        self.bind(PushConfig, PushConfig(\"app_123\", \"push_api_key\")).singleton()\n\n        # Named service bindings\n        self.bind(INotificationService, EmailNotificationService, name=\"email_service\").singleton()\n        self.bind(INotificationService, SMSNotificationService, name=\"sms_service\").singleton()\n        self.bind(INotificationService, PushNotificationService, name=\"push_service\").singleton()\n\n        # Factory\n        self.bind(INotificationFactory, NotificationFactory).singleton()\n        self.bind(NotificationManager, NotificationManager).singleton()\n\n# Usage Example\nasync def factory_example():\n    container = InjectQ()\n    container.install(NotificationModule())\n\n    manager = container.get(NotificationManager)\n\n    # Send single notification\n    result = await manager.send_notification(\"email\", \"Hello World!\", \"user@example.com\")\n    print(f\"Email sent: {result}\")\n\n    # Send multi-channel notification\n    results = await manager.send_multi_channel(\n        \"Important Alert!\",\n        \"user@example.com\",\n        [\"email\", \"sms\", \"push\"]\n    )\n    print(f\"Multi-channel results: {results}\")\n</code></pre>"},{"location":"examples/design-patterns/#abstract-factory","title":"Abstract Factory","text":"<pre><code># abstract_factory.py\nfrom abc import ABC, abstractmethod\nfrom injectq import InjectQ, inject, Module\nfrom enum import Enum\n\nclass Environment(Enum):\n    DEVELOPMENT = \"development\"\n    PRODUCTION = \"production\"\n    TESTING = \"testing\"\n\n# Abstract Products\nclass IDatabase(ABC):\n    @abstractmethod\n    async def connect(self) -&gt; bool:\n        pass\n\n    @abstractmethod\n    async def query(self, sql: str) -&gt; list:\n        pass\n\nclass ICache(ABC):\n    @abstractmethod\n    async def get(self, key: str):\n        pass\n\n    @abstractmethod\n    async def set(self, key: str, value, ttl: int = 300):\n        pass\n\nclass ILogger(ABC):\n    @abstractmethod\n    def log(self, level: str, message: str):\n        pass\n\n# Development Environment Products\nclass SQLiteDatabase(IDatabase):\n    @inject\n    def __init__(self, config: DatabaseConfig):\n        self.config = config\n\n    async def connect(self) -&gt; bool:\n        print(\"Connected to SQLite database\")\n        return True\n\n    async def query(self, sql: str) -&gt; list:\n        print(f\"SQLite query: {sql}\")\n        return []\n\nclass InMemoryCache(ICache):\n    def __init__(self):\n        self._cache = {}\n\n    async def get(self, key: str):\n        return self._cache.get(key)\n\n    async def set(self, key: str, value, ttl: int = 300):\n        self._cache[key] = value\n\nclass ConsoleLogger(ILogger):\n    def log(self, level: str, message: str):\n        print(f\"[{level}] {message}\")\n\n# Production Environment Products\nclass PostgreSQLDatabase(IDatabase):\n    @inject\n    def __init__(self, config: DatabaseConfig):\n        self.config = config\n\n    async def connect(self) -&gt; bool:\n        print(\"Connected to PostgreSQL database\")\n        return True\n\n    async def query(self, sql: str) -&gt; list:\n        print(f\"PostgreSQL query: {sql}\")\n        return []\n\nclass RedisCache(ICache):\n    @inject\n    def __init__(self, cache_config: CacheConfig):\n        self.config = cache_config\n\n    async def get(self, key: str):\n        print(f\"Redis GET: {key}\")\n        return None\n\n    async def set(self, key: str, value, ttl: int = 300):\n        print(f\"Redis SET: {key} = {value} (TTL: {ttl})\")\n\nclass FileLogger(ILogger):\n    @inject\n    def __init__(self, logger_config: LoggerConfig):\n        self.config = logger_config\n\n    def log(self, level: str, message: str):\n        print(f\"File log [{level}]: {message}\")\n\n# Testing Environment Products\nclass MockDatabase(IDatabase):\n    async def connect(self) -&gt; bool:\n        print(\"Connected to mock database\")\n        return True\n\n    async def query(self, sql: str) -&gt; list:\n        print(f\"Mock query: {sql}\")\n        return [{\"id\": 1, \"name\": \"test\"}]\n\nclass MockCache(ICache):\n    async def get(self, key: str):\n        return f\"mock_value_for_{key}\"\n\n    async def set(self, key: str, value, ttl: int = 300):\n        pass\n\nclass MockLogger(ILogger):\n    def log(self, level: str, message: str):\n        pass  # Silent in tests\n\n# Configuration Classes\nclass DatabaseConfig:\n    def __init__(self, host: str, port: int, database: str):\n        self.host = host\n        self.port = port\n        self.database = database\n\nclass CacheConfig:\n    def __init__(self, host: str, port: int):\n        self.host = host\n        self.port = port\n\nclass LoggerConfig:\n    def __init__(self, log_file: str, level: str):\n        self.log_file = log_file\n        self.level = level\n\n# Abstract Factory\nclass IInfrastructureFactory(ABC):\n    @abstractmethod\n    def create_database(self) -&gt; IDatabase:\n        pass\n\n    @abstractmethod\n    def create_cache(self) -&gt; ICache:\n        pass\n\n    @abstractmethod\n    def create_logger(self) -&gt; ILogger:\n        pass\n\n# Concrete Factories\nclass DevelopmentInfrastructureFactory(IInfrastructureFactory):\n    @inject\n    def __init__(self, container: InjectQ):\n        self.container = container\n\n    def create_database(self) -&gt; IDatabase:\n        return self.container.get(IDatabase, name=\"sqlite\")\n\n    def create_cache(self) -&gt; ICache:\n        return self.container.get(ICache, name=\"memory\")\n\n    def create_logger(self) -&gt; ILogger:\n        return self.container.get(ILogger, name=\"console\")\n\nclass ProductionInfrastructureFactory(IInfrastructureFactory):\n    @inject\n    def __init__(self, container: InjectQ):\n        self.container = container\n\n    def create_database(self) -&gt; IDatabase:\n        return self.container.get(IDatabase, name=\"postgresql\")\n\n    def create_cache(self) -&gt; ICache:\n        return self.container.get(ICache, name=\"redis\")\n\n    def create_logger(self) -&gt; ILogger:\n        return self.container.get(ILogger, name=\"file\")\n\nclass TestingInfrastructureFactory(IInfrastructureFactory):\n    @inject\n    def __init__(self, container: InjectQ):\n        self.container = container\n\n    def create_database(self) -&gt; IDatabase:\n        return self.container.get(IDatabase, name=\"mock\")\n\n    def create_cache(self) -&gt; ICache:\n        return self.container.get(ICache, name=\"mock_cache\")\n\n    def create_logger(self) -&gt; ILogger:\n        return self.container.get(ILogger, name=\"mock_logger\")\n\n# Application Service\nclass ApplicationService:\n    @inject\n    def __init__(self, infrastructure_factory: IInfrastructureFactory):\n        self.factory = infrastructure_factory\n        self.database = None\n        self.cache = None\n        self.logger = None\n\n    async def initialize(self):\n        \"\"\"Initialize infrastructure components.\"\"\"\n        self.database = self.factory.create_database()\n        self.cache = self.factory.create_cache()\n        self.logger = self.factory.create_logger()\n\n        await self.database.connect()\n        self.logger.log(\"INFO\", \"Application initialized\")\n\n    async def process_data(self, data: dict):\n        \"\"\"Process some data using infrastructure.\"\"\"\n        self.logger.log(\"INFO\", f\"Processing data: {data}\")\n\n        # Check cache first\n        cache_key = f\"data_{data.get('id')}\"\n        cached_result = await self.cache.get(cache_key)\n\n        if cached_result:\n            self.logger.log(\"INFO\", \"Cache hit\")\n            return cached_result\n\n        # Query database\n        result = await self.database.query(f\"SELECT * FROM data WHERE id = {data.get('id')}\")\n\n        # Cache result\n        await self.cache.set(cache_key, result)\n\n        self.logger.log(\"INFO\", \"Data processed successfully\")\n        return result\n\n# Environment-specific Modules\nclass DevelopmentModule(Module):\n    def configure(self):\n        # Configuration\n        self.bind(DatabaseConfig, DatabaseConfig(\"localhost\", 5432, \"dev_db\")).singleton()\n\n        # Infrastructure components\n        self.bind(IDatabase, SQLiteDatabase, name=\"sqlite\").singleton()\n        self.bind(ICache, InMemoryCache, name=\"memory\").singleton()\n        self.bind(ILogger, ConsoleLogger, name=\"console\").singleton()\n\n        # Factory\n        self.bind(IInfrastructureFactory, DevelopmentInfrastructureFactory).singleton()\n\nclass ProductionModule(Module):\n    def configure(self):\n        # Configuration\n        self.bind(DatabaseConfig, DatabaseConfig(\"prod-db.example.com\", 5432, \"prod_db\")).singleton()\n        self.bind(CacheConfig, CacheConfig(\"redis.example.com\", 6379)).singleton()\n        self.bind(LoggerConfig, LoggerConfig(\"/var/log/app.log\", \"INFO\")).singleton()\n\n        # Infrastructure components\n        self.bind(IDatabase, PostgreSQLDatabase, name=\"postgresql\").singleton()\n        self.bind(ICache, RedisCache, name=\"redis\").singleton()\n        self.bind(ILogger, FileLogger, name=\"file\").singleton()\n\n        # Factory\n        self.bind(IInfrastructureFactory, ProductionInfrastructureFactory).singleton()\n\nclass TestingModule(Module):\n    def configure(self):\n        # Infrastructure components\n        self.bind(IDatabase, MockDatabase, name=\"mock\").singleton()\n        self.bind(ICache, MockCache, name=\"mock_cache\").singleton()\n        self.bind(ILogger, MockLogger, name=\"mock_logger\").singleton()\n\n        # Factory\n        self.bind(IInfrastructureFactory, TestingInfrastructureFactory).singleton()\n\n# Factory Provider\nclass InfrastructureFactoryProvider:\n    @staticmethod\n    def get_module(environment: Environment) -&gt; Module:\n        if environment == Environment.DEVELOPMENT:\n            return DevelopmentModule()\n        elif environment == Environment.PRODUCTION:\n            return ProductionModule()\n        elif environment == Environment.TESTING:\n            return TestingModule()\n        else:\n            raise ValueError(f\"Unsupported environment: {environment}\")\n\n# Usage Example\nasync def abstract_factory_example():\n    # Change environment here\n    current_env = Environment.DEVELOPMENT\n\n    container = InjectQ()\n    module = InfrastructureFactoryProvider.get_module(current_env)\n    container.install(module)\n\n    # Application always works the same regardless of environment\n    service = container.get(ApplicationService)\n    await service.initialize()\n\n    result = await service.process_data({\"id\": 123, \"name\": \"test\"})\n    print(f\"Processing result: {result}\")\n</code></pre>"},{"location":"examples/design-patterns/#observer-pattern","title":"\ud83d\udd0d Observer Pattern","text":"<p>The Observer pattern allows objects to be notified of changes without tight coupling. InjectQ makes this pattern clean through interface injection.</p> <pre><code># observer_pattern.py\nfrom abc import ABC, abstractmethod\nfrom injectq import InjectQ, inject, Module\nfrom typing import List, Dict, Any\nimport asyncio\n\n# Subject Interface\nclass ISubject(ABC):\n    @abstractmethod\n    def attach(self, observer: 'IObserver'):\n        pass\n\n    @abstractmethod\n    def detach(self, observer: 'IObserver'):\n        pass\n\n    @abstractmethod\n    async def notify(self, event_type: str, data: Dict[str, Any]):\n        pass\n\n# Observer Interface\nclass IObserver(ABC):\n    @abstractmethod\n    async def update(self, subject: ISubject, event_type: str, data: Dict[str, Any]):\n        pass\n\n# Concrete Subject\nclass UserManager(ISubject):\n    def __init__(self):\n        self._observers: List[IObserver] = []\n        self._users: Dict[str, Dict] = {}\n\n    def attach(self, observer: IObserver):\n        if observer not in self._observers:\n            self._observers.append(observer)\n\n    def detach(self, observer: IObserver):\n        if observer in self._observers:\n            self._observers.remove(observer)\n\n    async def notify(self, event_type: str, data: Dict[str, Any]):\n        for observer in self._observers:\n            try:\n                await observer.update(self, event_type, data)\n            except Exception as e:\n                print(f\"Error notifying observer {observer.__class__.__name__}: {e}\")\n\n    async def create_user(self, user_id: str, user_data: Dict[str, Any]):\n        self._users[user_id] = user_data\n        await self.notify(\"user_created\", {\"user_id\": user_id, \"user_data\": user_data})\n\n    async def update_user(self, user_id: str, updates: Dict[str, Any]):\n        if user_id in self._users:\n            old_data = self._users[user_id].copy()\n            self._users[user_id].update(updates)\n            await self.notify(\"user_updated\", {\n                \"user_id\": user_id,\n                \"old_data\": old_data,\n                \"new_data\": self._users[user_id]\n            })\n\n    async def delete_user(self, user_id: str):\n        if user_id in self._users:\n            user_data = self._users.pop(user_id)\n            await self.notify(\"user_deleted\", {\"user_id\": user_id, \"user_data\": user_data})\n\n    def get_user(self, user_id: str) -&gt; Dict[str, Any]:\n        return self._users.get(user_id, {})\n\n# Concrete Observers\nclass EmailNotificationObserver(IObserver):\n    @inject\n    def __init__(self, email_service: EmailService):\n        self.email_service = email_service\n\n    async def update(self, subject: ISubject, event_type: str, data: Dict[str, Any]):\n        if event_type == \"user_created\":\n            await self._send_welcome_email(data)\n        elif event_type == \"user_updated\":\n            await self._send_update_notification(data)\n        elif event_type == \"user_deleted\":\n            await self._send_goodbye_email(data)\n\n    async def _send_welcome_email(self, data: Dict[str, Any]):\n        user_data = data[\"user_data\"]\n        await self.email_service.send_email(\n            to=user_data.get(\"email\"),\n            subject=\"Welcome!\",\n            body=\"Welcome to our platform!\"\n        )\n\n    async def _send_update_notification(self, data: Dict[str, Any]):\n        user_data = data[\"new_data\"]\n        await self.email_service.send_email(\n            to=user_data.get(\"email\"),\n            subject=\"Profile Updated\",\n            body=\"Your profile has been updated.\"\n        )\n\n    async def _send_goodbye_email(self, data: Dict[str, Any]):\n        user_data = data[\"user_data\"]\n        await self.email_service.send_email(\n            to=user_data.get(\"email\"),\n            subject=\"Account Deleted\",\n            body=\"Sorry to see you go!\"\n        )\n\nclass AuditLogObserver(IObserver):\n    @inject\n    def __init__(self, audit_service: AuditService):\n        self.audit_service = audit_service\n\n    async def update(self, subject: ISubject, event_type: str, data: Dict[str, Any]):\n        await self.audit_service.log_event(event_type, data)\n\nclass AnalyticsObserver(IObserver):\n    @inject\n    def __init__(self, analytics_service: AnalyticsService):\n        self.analytics_service = analytics_service\n\n    async def update(self, subject: ISubject, event_type: str, data: Dict[str, Any]):\n        if event_type == \"user_created\":\n            await self.analytics_service.track_user_registration(data[\"user_id\"])\n        elif event_type == \"user_deleted\":\n            await self.analytics_service.track_user_churn(data[\"user_id\"])\n\nclass CacheInvalidationObserver(IObserver):\n    @inject\n    def __init__(self, cache_service: CacheService):\n        self.cache_service = cache_service\n\n    async def update(self, subject: ISubject, event_type: str, data: Dict[str, Any]):\n        user_id = data[\"user_id\"]\n        cache_keys = [\n            f\"user:{user_id}\",\n            f\"user_profile:{user_id}\",\n            f\"user_permissions:{user_id}\"\n        ]\n\n        for key in cache_keys:\n            await self.cache_service.delete(key)\n\n# Supporting Services\nclass EmailService:\n    async def send_email(self, to: str, subject: str, body: str):\n        print(f\"Sending email to {to}: {subject}\")\n        await asyncio.sleep(0.1)  # Simulate network delay\n\nclass AuditService:\n    def __init__(self):\n        self.audit_log = []\n\n    async def log_event(self, event_type: str, data: Dict[str, Any]):\n        log_entry = {\n            \"timestamp\": asyncio.get_event_loop().time(),\n            \"event_type\": event_type,\n            \"data\": data\n        }\n        self.audit_log.append(log_entry)\n        print(f\"Audit log: {event_type} - {data}\")\n\nclass AnalyticsService:\n    def __init__(self):\n        self.metrics = {\"registrations\": 0, \"churn\": 0}\n\n    async def track_user_registration(self, user_id: str):\n        self.metrics[\"registrations\"] += 1\n        print(f\"Analytics: User registration tracked for {user_id}\")\n\n    async def track_user_churn(self, user_id: str):\n        self.metrics[\"churn\"] += 1\n        print(f\"Analytics: User churn tracked for {user_id}\")\n\nclass CacheService:\n    def __init__(self):\n        self.cache = {}\n\n    async def delete(self, key: str):\n        self.cache.pop(key, None)\n        print(f\"Cache: Invalidated key {key}\")\n\n# Observer Manager\nclass ObserverManager:\n    @inject\n    def __init__(\n        self,\n        user_manager: UserManager,\n        email_observer: EmailNotificationObserver,\n        audit_observer: AuditLogObserver,\n        analytics_observer: AnalyticsObserver,\n        cache_observer: CacheInvalidationObserver\n    ):\n        self.user_manager = user_manager\n        self.observers = [\n            email_observer,\n            audit_observer,\n            analytics_observer,\n            cache_observer\n        ]\n\n    def setup_observers(self):\n        \"\"\"Attach all observers to the subject.\"\"\"\n        for observer in self.observers:\n            self.user_manager.attach(observer)\n\n    def teardown_observers(self):\n        \"\"\"Detach all observers from the subject.\"\"\"\n        for observer in self.observers:\n            self.user_manager.detach(observer)\n\n# Module Configuration\nclass ObserverModule(Module):\n    def configure(self):\n        # Services\n        self.bind(EmailService, EmailService).singleton()\n        self.bind(AuditService, AuditService).singleton()\n        self.bind(AnalyticsService, AnalyticsService).singleton()\n        self.bind(CacheService, CacheService).singleton()\n\n        # Subject\n        self.bind(UserManager, UserManager).singleton()\n\n        # Observers\n        self.bind(EmailNotificationObserver, EmailNotificationObserver).singleton()\n        self.bind(AuditLogObserver, AuditLogObserver).singleton()\n        self.bind(AnalyticsObserver, AnalyticsObserver).singleton()\n        self.bind(CacheInvalidationObserver, CacheInvalidationObserver).singleton()\n\n        # Manager\n        self.bind(ObserverManager, ObserverManager).singleton()\n\n# Usage Example\nasync def observer_example():\n    container = InjectQ()\n    container.install(ObserverModule())\n\n    # Setup observer pattern\n    observer_manager = container.get(ObserverManager)\n    observer_manager.setup_observers()\n\n    user_manager = container.get(UserManager)\n\n    # Perform user operations - observers will be notified automatically\n    await user_manager.create_user(\"user123\", {\n        \"name\": \"John Doe\",\n        \"email\": \"john@example.com\",\n        \"age\": 30\n    })\n\n    await user_manager.update_user(\"user123\", {\"age\": 31})\n\n    await user_manager.delete_user(\"user123\")\n\n    # Cleanup\n    observer_manager.teardown_observers()\n</code></pre>"},{"location":"examples/design-patterns/#strategy-pattern","title":"\ud83c\udfad Strategy Pattern","text":"<p>The Strategy pattern enables selecting algorithms at runtime. InjectQ makes strategy injection and swapping elegant.</p> <pre><code># strategy_pattern.py\nfrom abc import ABC, abstractmethod\nfrom injectq import InjectQ, inject, Module\nfrom typing import List, Dict, Any\nfrom enum import Enum\n\n# Strategy Interface\nclass IPaymentStrategy(ABC):\n    @abstractmethod\n    async def process_payment(self, amount: float, payment_details: Dict[str, Any]) -&gt; Dict[str, Any]:\n        pass\n\n    @abstractmethod\n    def get_fees(self, amount: float) -&gt; float:\n        pass\n\n# Concrete Strategies\nclass CreditCardStrategy(IPaymentStrategy):\n    @inject\n    def __init__(self, card_processor: CardProcessor):\n        self.processor = card_processor\n\n    async def process_payment(self, amount: float, payment_details: Dict[str, Any]) -&gt; Dict[str, Any]:\n        card_number = payment_details[\"card_number\"]\n        cvv = payment_details[\"cvv\"]\n        expiry = payment_details[\"expiry\"]\n\n        # Validate card\n        if not self._validate_card(card_number, cvv, expiry):\n            return {\"success\": False, \"error\": \"Invalid card details\"}\n\n        # Process payment\n        result = await self.processor.charge_card(card_number, amount)\n\n        return {\n            \"success\": result[\"success\"],\n            \"transaction_id\": result.get(\"transaction_id\"),\n            \"fees\": self.get_fees(amount),\n            \"method\": \"credit_card\"\n        }\n\n    def get_fees(self, amount: float) -&gt; float:\n        return amount * 0.029  # 2.9% fee\n\n    def _validate_card(self, card_number: str, cvv: str, expiry: str) -&gt; bool:\n        # Simplified validation\n        return len(card_number) == 16 and len(cvv) == 3\n\nclass PayPalStrategy(IPaymentStrategy):\n    @inject\n    def __init__(self, paypal_client: PayPalClient):\n        self.client = paypal_client\n\n    async def process_payment(self, amount: float, payment_details: Dict[str, Any]) -&gt; Dict[str, Any]:\n        email = payment_details[\"email\"]\n\n        # Process through PayPal\n        result = await self.client.create_payment(email, amount)\n\n        return {\n            \"success\": result[\"success\"],\n            \"transaction_id\": result.get(\"transaction_id\"),\n            \"fees\": self.get_fees(amount),\n            \"method\": \"paypal\",\n            \"redirect_url\": result.get(\"redirect_url\")\n        }\n\n    def get_fees(self, amount: float) -&gt; float:\n        return amount * 0.035 + 0.30  # 3.5% + $0.30\n\nclass BankTransferStrategy(IPaymentStrategy):\n    @inject\n    def __init__(self, bank_client: BankClient):\n        self.client = bank_client\n\n    async def process_payment(self, amount: float, payment_details: Dict[str, Any]) -&gt; Dict[str, Any]:\n        account_number = payment_details[\"account_number\"]\n        routing_number = payment_details[\"routing_number\"]\n\n        # Process bank transfer\n        result = await self.client.initiate_transfer(account_number, routing_number, amount)\n\n        return {\n            \"success\": result[\"success\"],\n            \"transaction_id\": result.get(\"transaction_id\"),\n            \"fees\": self.get_fees(amount),\n            \"method\": \"bank_transfer\",\n            \"processing_time\": \"3-5 business days\"\n        }\n\n    def get_fees(self, amount: float) -&gt; float:\n        return 1.00 if amount &gt; 100 else 0.50  # Flat fee\n\nclass CryptocurrencyStrategy(IPaymentStrategy):\n    @inject\n    def __init__(self, crypto_client: CryptoClient):\n        self.client = crypto_client\n\n    async def process_payment(self, amount: float, payment_details: Dict[str, Any]) -&gt; Dict[str, Any]:\n        wallet_address = payment_details[\"wallet_address\"]\n        crypto_type = payment_details.get(\"crypto_type\", \"BTC\")\n\n        # Convert USD to crypto\n        crypto_amount = await self.client.convert_usd_to_crypto(amount, crypto_type)\n\n        # Process crypto payment\n        result = await self.client.send_crypto(wallet_address, crypto_amount, crypto_type)\n\n        return {\n            \"success\": result[\"success\"],\n            \"transaction_id\": result.get(\"transaction_id\"),\n            \"fees\": self.get_fees(amount),\n            \"method\": \"cryptocurrency\",\n            \"crypto_amount\": crypto_amount,\n            \"crypto_type\": crypto_type\n        }\n\n    def get_fees(self, amount: float) -&gt; float:\n        return amount * 0.015  # 1.5% fee\n\n# Payment Processors\nclass CardProcessor:\n    async def charge_card(self, card_number: str, amount: float) -&gt; Dict[str, Any]:\n        # Simulate card processing\n        import random\n        success = random.random() &gt; 0.1  # 90% success rate\n\n        if success:\n            return {\n                \"success\": True,\n                \"transaction_id\": f\"cc_{card_number[-4:]}_{int(amount*100)}\"\n            }\n        else:\n            return {\"success\": False, \"error\": \"Card declined\"}\n\nclass PayPalClient:\n    async def create_payment(self, email: str, amount: float) -&gt; Dict[str, Any]:\n        # Simulate PayPal API call\n        return {\n            \"success\": True,\n            \"transaction_id\": f\"pp_{email.split('@')[0]}_{int(amount*100)}\",\n            \"redirect_url\": f\"https://paypal.com/checkout?amount={amount}\"\n        }\n\nclass BankClient:\n    async def initiate_transfer(self, account: str, routing: str, amount: float) -&gt; Dict[str, Any]:\n        # Simulate bank transfer\n        return {\n            \"success\": True,\n            \"transaction_id\": f\"bt_{account[-4:]}_{int(amount*100)}\"\n        }\n\nclass CryptoClient:\n    async def convert_usd_to_crypto(self, usd_amount: float, crypto_type: str) -&gt; float:\n        # Simulate conversion rates\n        rates = {\"BTC\": 0.000025, \"ETH\": 0.0005, \"LTC\": 0.01}\n        return usd_amount * rates.get(crypto_type, 0.000025)\n\n    async def send_crypto(self, wallet: str, amount: float, crypto_type: str) -&gt; Dict[str, Any]:\n        # Simulate crypto transaction\n        return {\n            \"success\": True,\n            \"transaction_id\": f\"crypto_{crypto_type}_{wallet[-8:]}_{int(amount*1000000)}\"\n        }\n\n# Context Class\nclass PaymentProcessor:\n    @inject\n    def __init__(self):\n        self._strategy: IPaymentStrategy = None\n\n    def set_strategy(self, strategy: IPaymentStrategy):\n        \"\"\"Set the payment strategy at runtime.\"\"\"\n        self._strategy = strategy\n\n    async def process_payment(self, amount: float, payment_details: Dict[str, Any]) -&gt; Dict[str, Any]:\n        if not self._strategy:\n            raise ValueError(\"Payment strategy not set\")\n\n        return await self._strategy.process_payment(amount, payment_details)\n\n    def calculate_total_with_fees(self, amount: float) -&gt; float:\n        if not self._strategy:\n            raise ValueError(\"Payment strategy not set\")\n\n        fees = self._strategy.get_fees(amount)\n        return amount + fees\n\n# Strategy Factory\nclass PaymentStrategyFactory:\n    @inject\n    def __init__(self, container: InjectQ):\n        self.container = container\n        self._strategies = {\n            \"credit_card\": \"credit_card_strategy\",\n            \"paypal\": \"paypal_strategy\",\n            \"bank_transfer\": \"bank_transfer_strategy\",\n            \"cryptocurrency\": \"crypto_strategy\"\n        }\n\n    def create_strategy(self, payment_method: str) -&gt; IPaymentStrategy:\n        strategy_name = self._strategies.get(payment_method)\n        if not strategy_name:\n            raise ValueError(f\"Unsupported payment method: {payment_method}\")\n\n        return self.container.get(IPaymentStrategy, name=strategy_name)\n\n# Payment Service\nclass PaymentService:\n    @inject\n    def __init__(\n        self,\n        processor: PaymentProcessor,\n        strategy_factory: PaymentStrategyFactory\n    ):\n        self.processor = processor\n        self.factory = strategy_factory\n\n    async def process_payment_with_method(\n        self,\n        payment_method: str,\n        amount: float,\n        payment_details: Dict[str, Any]\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Process payment with specified method.\"\"\"\n        try:\n            # Get appropriate strategy\n            strategy = self.factory.create_strategy(payment_method)\n\n            # Set strategy\n            self.processor.set_strategy(strategy)\n\n            # Calculate total with fees\n            total_amount = self.processor.calculate_total_with_fees(amount)\n\n            # Process payment\n            result = await self.processor.process_payment(amount, payment_details)\n            result[\"original_amount\"] = amount\n            result[\"total_amount\"] = total_amount\n\n            return result\n\n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": str(e),\n                \"method\": payment_method\n            }\n\n    async def find_best_payment_method(\n        self,\n        amount: float,\n        available_methods: List[str]\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Find the payment method with lowest fees.\"\"\"\n        best_method = None\n        lowest_fees = float('inf')\n\n        for method in available_methods:\n            try:\n                strategy = self.factory.create_strategy(method)\n                fees = strategy.get_fees(amount)\n\n                if fees &lt; lowest_fees:\n                    lowest_fees = fees\n                    best_method = method\n            except ValueError:\n                continue  # Skip unsupported methods\n\n        if best_method:\n            return {\n                \"method\": best_method,\n                \"fees\": lowest_fees,\n                \"total\": amount + lowest_fees\n            }\n        else:\n            return {\"error\": \"No supported payment methods found\"}\n\n# Module Configuration\nclass PaymentModule(Module):\n    def configure(self):\n        # Payment processors\n        self.bind(CardProcessor, CardProcessor).singleton()\n        self.bind(PayPalClient, PayPalClient).singleton()\n        self.bind(BankClient, BankClient).singleton()\n        self.bind(CryptoClient, CryptoClient).singleton()\n\n        # Payment strategies\n        self.bind(IPaymentStrategy, CreditCardStrategy, name=\"credit_card_strategy\").scoped()\n        self.bind(IPaymentStrategy, PayPalStrategy, name=\"paypal_strategy\").scoped()\n        self.bind(IPaymentStrategy, BankTransferStrategy, name=\"bank_transfer_strategy\").scoped()\n        self.bind(IPaymentStrategy, CryptocurrencyStrategy, name=\"crypto_strategy\").scoped()\n\n        # Context and factory\n        self.bind(PaymentProcessor, PaymentProcessor).scoped()\n        self.bind(PaymentStrategyFactory, PaymentStrategyFactory).singleton()\n\n        # Service\n        self.bind(PaymentService, PaymentService).scoped()\n\n# Usage Examples\nasync def strategy_example():\n    container = InjectQ()\n    container.install(PaymentModule())\n\n    service = container.get(PaymentService)\n\n    # Process credit card payment\n    cc_result = await service.process_payment_with_method(\n        \"credit_card\",\n        100.0,\n        {\n            \"card_number\": \"1234567890123456\",\n            \"cvv\": \"123\",\n            \"expiry\": \"12/25\"\n        }\n    )\n    print(f\"Credit card payment: {cc_result}\")\n\n    # Process PayPal payment\n    paypal_result = await service.process_payment_with_method(\n        \"paypal\",\n        100.0,\n        {\"email\": \"user@example.com\"}\n    )\n    print(f\"PayPal payment: {paypal_result}\")\n\n    # Find best payment method\n    best_method = await service.find_best_payment_method(\n        100.0,\n        [\"credit_card\", \"paypal\", \"bank_transfer\", \"cryptocurrency\"]\n    )\n    print(f\"Best payment method: {best_method}\")\n\n    # Process with best method\n    if \"method\" in best_method:\n        best_result = await service.process_payment_with_method(\n            best_method[\"method\"],\n            100.0,\n            {\"account_number\": \"123456789\", \"routing_number\": \"987654321\"}\n        )\n        print(f\"Best method payment: {best_result}\")\n</code></pre>"},{"location":"examples/design-patterns/#builder-pattern","title":"\ud83c\udfd7\ufe0f Builder Pattern","text":"<p>The Builder pattern constructs complex objects step by step. InjectQ can inject builders and their dependencies cleanly.</p> <pre><code># builder_pattern.py\nfrom abc import ABC, abstractmethod\nfrom injectq import InjectQ, inject, Module\nfrom typing import Optional, List, Dict, Any\nfrom dataclasses import dataclass, field\n\n# Product Classes\n@dataclass\nclass DatabaseConfig:\n    host: str = \"localhost\"\n    port: int = 5432\n    database: str = \"app\"\n    username: Optional[str] = None\n    password: Optional[str] = None\n    ssl_enabled: bool = False\n    connection_pool_size: int = 10\n    timeout: int = 30\n    retry_attempts: int = 3\n\n@dataclass\nclass CacheConfig:\n    host: str = \"localhost\"\n    port: int = 6379\n    password: Optional[str] = None\n    database: int = 0\n    ttl: int = 300\n    max_connections: int = 10\n\n@dataclass\nclass LoggingConfig:\n    level: str = \"INFO\"\n    format: str = \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n    file_path: Optional[str] = None\n    max_file_size: int = 10 * 1024 * 1024  # 10MB\n    backup_count: int = 5\n    console_output: bool = True\n\n@dataclass\nclass SecurityConfig:\n    jwt_secret: str = \"default_secret\"\n    jwt_expiration: int = 3600\n    password_hash_rounds: int = 12\n    require_https: bool = False\n    cors_origins: List[str] = field(default_factory=list)\n    rate_limit_requests: int = 100\n    rate_limit_window: int = 60\n\n@dataclass\nclass ApplicationConfig:\n    app_name: str = \"MyApp\"\n    version: str = \"1.0.0\"\n    debug: bool = False\n    database: DatabaseConfig = field(default_factory=DatabaseConfig)\n    cache: CacheConfig = field(default_factory=CacheConfig)\n    logging: LoggingConfig = field(default_factory=LoggingConfig)\n    security: SecurityConfig = field(default_factory=SecurityConfig)\n    custom_settings: Dict[str, Any] = field(default_factory=dict)\n\n# Builder Interface\nclass IConfigBuilder(ABC):\n    @abstractmethod\n    def reset(self) -&gt; 'IConfigBuilder':\n        pass\n\n    @abstractmethod\n    def build(self) -&gt; ApplicationConfig:\n        pass\n\n# Concrete Builder\nclass ApplicationConfigBuilder(IConfigBuilder):\n    @inject\n    def __init__(self, default_provider: DefaultConfigProvider):\n        self.default_provider = default_provider\n        self.reset()\n\n    def reset(self) -&gt; 'ApplicationConfigBuilder':\n        \"\"\"Reset the builder to start fresh.\"\"\"\n        self._config = ApplicationConfig()\n        return self\n\n    def build(self) -&gt; ApplicationConfig:\n        \"\"\"Build and return the final configuration.\"\"\"\n        # Apply any default validations or final processing\n        self._validate_config()\n        return self._config\n\n    # App-level configuration\n    def with_app_info(self, name: str, version: str = \"1.0.0\") -&gt; 'ApplicationConfigBuilder':\n        self._config.app_name = name\n        self._config.version = version\n        return self\n\n    def with_debug(self, debug: bool = True) -&gt; 'ApplicationConfigBuilder':\n        self._config.debug = debug\n        return self\n\n    # Database configuration\n    def with_database(\n        self,\n        host: str = \"localhost\",\n        port: int = 5432,\n        database: str = \"app\",\n        username: Optional[str] = None,\n        password: Optional[str] = None\n    ) -&gt; 'ApplicationConfigBuilder':\n        self._config.database = DatabaseConfig(\n            host=host,\n            port=port,\n            database=database,\n            username=username,\n            password=password\n        )\n        return self\n\n    def with_database_ssl(self, enabled: bool = True) -&gt; 'ApplicationConfigBuilder':\n        self._config.database.ssl_enabled = enabled\n        return self\n\n    def with_database_pool(\n        self,\n        pool_size: int = 10,\n        timeout: int = 30,\n        retry_attempts: int = 3\n    ) -&gt; 'ApplicationConfigBuilder':\n        self._config.database.connection_pool_size = pool_size\n        self._config.database.timeout = timeout\n        self._config.database.retry_attempts = retry_attempts\n        return self\n\n    # Cache configuration\n    def with_cache(\n        self,\n        host: str = \"localhost\",\n        port: int = 6379,\n        password: Optional[str] = None,\n        database: int = 0\n    ) -&gt; 'ApplicationConfigBuilder':\n        self._config.cache = CacheConfig(\n            host=host,\n            port=port,\n            password=password,\n            database=database\n        )\n        return self\n\n    def with_cache_settings(\n        self,\n        ttl: int = 300,\n        max_connections: int = 10\n    ) -&gt; 'ApplicationConfigBuilder':\n        self._config.cache.ttl = ttl\n        self._config.cache.max_connections = max_connections\n        return self\n\n    # Logging configuration\n    def with_logging(\n        self,\n        level: str = \"INFO\",\n        console_output: bool = True\n    ) -&gt; 'ApplicationConfigBuilder':\n        self._config.logging = LoggingConfig(\n            level=level,\n            console_output=console_output\n        )\n        return self\n\n    def with_file_logging(\n        self,\n        file_path: str,\n        max_size: int = 10 * 1024 * 1024,\n        backup_count: int = 5\n    ) -&gt; 'ApplicationConfigBuilder':\n        self._config.logging.file_path = file_path\n        self._config.logging.max_file_size = max_size\n        self._config.logging.backup_count = backup_count\n        return self\n\n    def with_log_format(self, format_string: str) -&gt; 'ApplicationConfigBuilder':\n        self._config.logging.format = format_string\n        return self\n\n    # Security configuration\n    def with_security(\n        self,\n        jwt_secret: str,\n        jwt_expiration: int = 3600,\n        password_hash_rounds: int = 12\n    ) -&gt; 'ApplicationConfigBuilder':\n        self._config.security = SecurityConfig(\n            jwt_secret=jwt_secret,\n            jwt_expiration=jwt_expiration,\n            password_hash_rounds=password_hash_rounds\n        )\n        return self\n\n    def with_https(self, require_https: bool = True) -&gt; 'ApplicationConfigBuilder':\n        self._config.security.require_https = require_https\n        return self\n\n    def with_cors(self, origins: List[str]) -&gt; 'ApplicationConfigBuilder':\n        self._config.security.cors_origins = origins\n        return self\n\n    def with_rate_limiting(\n        self,\n        requests: int = 100,\n        window: int = 60\n    ) -&gt; 'ApplicationConfigBuilder':\n        self._config.security.rate_limit_requests = requests\n        self._config.security.rate_limit_window = window\n        return self\n\n    # Custom settings\n    def with_custom_setting(self, key: str, value: Any) -&gt; 'ApplicationConfigBuilder':\n        self._config.custom_settings[key] = value\n        return self\n\n    def with_custom_settings(self, settings: Dict[str, Any]) -&gt; 'ApplicationConfigBuilder':\n        self._config.custom_settings.update(settings)\n        return self\n\n    # Preset configurations\n    def for_development(self) -&gt; 'ApplicationConfigBuilder':\n        \"\"\"Apply development preset.\"\"\"\n        return (self\n                .with_debug(True)\n                .with_database(\"localhost\", 5432, \"dev_db\")\n                .with_cache(\"localhost\", 6379)\n                .with_logging(\"DEBUG\", console_output=True)\n                .with_security(\"dev_secret\", jwt_expiration=7200)\n                .with_cors([\"http://localhost:3000\", \"http://localhost:8080\"]))\n\n    def for_production(self) -&gt; 'ApplicationConfigBuilder':\n        \"\"\"Apply production preset.\"\"\"\n        prod_secret = self.default_provider.get_jwt_secret()\n        db_config = self.default_provider.get_production_database_config()\n\n        return (self\n                .with_debug(False)\n                .with_database(\n                    db_config[\"host\"],\n                    db_config[\"port\"],\n                    db_config[\"database\"],\n                    db_config[\"username\"],\n                    db_config[\"password\"]\n                )\n                .with_database_ssl(True)\n                .with_database_pool(20, 60, 5)\n                .with_cache(\"redis-prod.example.com\", 6379, password=\"redis_password\")\n                .with_cache_settings(ttl=600, max_connections=20)\n                .with_logging(\"INFO\", console_output=False)\n                .with_file_logging(\"/var/log/app.log\", 50 * 1024 * 1024, 10)\n                .with_security(prod_secret, jwt_expiration=3600, password_hash_rounds=15)\n                .with_https(True)\n                .with_rate_limiting(500, 60))\n\n    def for_testing(self) -&gt; 'ApplicationConfigBuilder':\n        \"\"\"Apply testing preset.\"\"\"\n        return (self\n                .with_debug(True)\n                .with_database(\"localhost\", 5432, \"test_db\")\n                .with_cache(\"localhost\", 6379, database=1)\n                .with_logging(\"DEBUG\", console_output=False)\n                .with_security(\"test_secret\", jwt_expiration=300))\n\n    def _validate_config(self):\n        \"\"\"Validate the configuration.\"\"\"\n        if not self._config.app_name:\n            raise ValueError(\"App name is required\")\n\n        if self._config.security.require_https and self._config.debug:\n            print(\"Warning: HTTPS required but debug mode is enabled\")\n\n        if self._config.database.connection_pool_size &lt; 1:\n            raise ValueError(\"Database connection pool size must be at least 1\")\n\n# Configuration Provider\nclass DefaultConfigProvider:\n    @inject\n    def __init__(self, env_reader: EnvironmentReader):\n        self.env_reader = env_reader\n\n    def get_jwt_secret(self) -&gt; str:\n        \"\"\"Get JWT secret from environment or generate default.\"\"\"\n        secret = self.env_reader.get(\"JWT_SECRET\")\n        if not secret:\n            import secrets\n            secret = secrets.token_hex(32)\n            print(f\"Generated JWT secret: {secret}\")\n        return secret\n\n    def get_production_database_config(self) -&gt; Dict[str, Any]:\n        \"\"\"Get production database configuration.\"\"\"\n        return {\n            \"host\": self.env_reader.get(\"DB_HOST\", \"localhost\"),\n            \"port\": int(self.env_reader.get(\"DB_PORT\", \"5432\")),\n            \"database\": self.env_reader.get(\"DB_NAME\", \"prod_db\"),\n            \"username\": self.env_reader.get(\"DB_USER\", \"postgres\"),\n            \"password\": self.env_reader.get(\"DB_PASSWORD\", \"\")\n        }\n\nclass EnvironmentReader:\n    def get(self, key: str, default: Optional[str] = None) -&gt; Optional[str]:\n        \"\"\"Get environment variable.\"\"\"\n        import os\n        return os.getenv(key, default)\n\n# Director Class\nclass ConfigurationDirector:\n    @inject\n    def __init__(self, builder: ApplicationConfigBuilder):\n        self.builder = builder\n\n    def create_development_config(self, app_name: str) -&gt; ApplicationConfig:\n        \"\"\"Create a development configuration.\"\"\"\n        return (self.builder\n                .reset()\n                .with_app_info(app_name, \"1.0.0-dev\")\n                .for_development()\n                .with_custom_setting(\"hot_reload\", True)\n                .with_custom_setting(\"mock_external_apis\", True)\n                .build())\n\n    def create_production_config(self, app_name: str, version: str) -&gt; ApplicationConfig:\n        \"\"\"Create a production configuration.\"\"\"\n        return (self.builder\n                .reset()\n                .with_app_info(app_name, version)\n                .for_production()\n                .with_custom_setting(\"monitoring_enabled\", True)\n                .with_custom_setting(\"metrics_collection\", True)\n                .build())\n\n    def create_testing_config(self, app_name: str) -&gt; ApplicationConfig:\n        \"\"\"Create a testing configuration.\"\"\"\n        return (self.builder\n                .reset()\n                .with_app_info(app_name, \"test\")\n                .for_testing()\n                .with_custom_setting(\"test_mode\", True)\n                .with_custom_setting(\"disable_external_calls\", True)\n                .build())\n\n    def create_microservice_config(\n        self,\n        service_name: str,\n        service_port: int,\n        dependencies: List[str]\n    ) -&gt; ApplicationConfig:\n        \"\"\"Create a microservice configuration.\"\"\"\n        return (self.builder\n                .reset()\n                .with_app_info(service_name)\n                .for_production()\n                .with_custom_setting(\"service_port\", service_port)\n                .with_custom_setting(\"service_dependencies\", dependencies)\n                .with_custom_setting(\"health_check_enabled\", True)\n                .with_custom_setting(\"distributed_tracing\", True)\n                .build())\n\n# Configuration Manager\nclass ConfigurationManager:\n    @inject\n    def __init__(self, director: ConfigurationDirector):\n        self.director = director\n        self._configs: Dict[str, ApplicationConfig] = {}\n\n    def get_or_create_config(\n        self,\n        config_type: str,\n        app_name: str,\n        **kwargs\n    ) -&gt; ApplicationConfig:\n        \"\"\"Get or create configuration by type.\"\"\"\n        cache_key = f\"{config_type}_{app_name}\"\n\n        if cache_key not in self._configs:\n            if config_type == \"development\":\n                config = self.director.create_development_config(app_name)\n            elif config_type == \"production\":\n                version = kwargs.get(\"version\", \"1.0.0\")\n                config = self.director.create_production_config(app_name, version)\n            elif config_type == \"testing\":\n                config = self.director.create_testing_config(app_name)\n            elif config_type == \"microservice\":\n                service_port = kwargs.get(\"service_port\", 8080)\n                dependencies = kwargs.get(\"dependencies\", [])\n                config = self.director.create_microservice_config(\n                    app_name, service_port, dependencies\n                )\n            else:\n                raise ValueError(f\"Unknown configuration type: {config_type}\")\n\n            self._configs[cache_key] = config\n\n        return self._configs[cache_key]\n\n    def clear_cache(self):\n        \"\"\"Clear configuration cache.\"\"\"\n        self._configs.clear()\n\n# Module Configuration\nclass BuilderModule(Module):\n    def configure(self):\n        # Utilities\n        self.bind(EnvironmentReader, EnvironmentReader).singleton()\n        self.bind(DefaultConfigProvider, DefaultConfigProvider).singleton()\n\n        # Builder\n        self.bind(ApplicationConfigBuilder, ApplicationConfigBuilder).scoped()\n\n        # Director\n        self.bind(ConfigurationDirector, ConfigurationDirector).scoped()\n\n        # Manager\n        self.bind(ConfigurationManager, ConfigurationManager).singleton()\n\n# Usage Examples\nasync def builder_example():\n    container = InjectQ()\n    container.install(BuilderModule())\n\n    # Using builder directly\n    builder = container.get(ApplicationConfigBuilder)\n\n    custom_config = (builder\n                     .reset()\n                     .with_app_info(\"CustomApp\", \"2.0.0\")\n                     .with_debug(True)\n                     .with_database(\"custom-db.example.com\", 5432, \"custom_db\", \"user\", \"pass\")\n                     .with_database_ssl(True)\n                     .with_cache(\"redis.example.com\", 6379, password=\"redis_pass\")\n                     .with_logging(\"DEBUG\")\n                     .with_file_logging(\"/var/log/custom.log\")\n                     .with_security(\"super_secret\", jwt_expiration=7200)\n                     .with_cors([\"https://example.com\"])\n                     .with_custom_settings({\"feature_flags\": {\"new_ui\": True}})\n                     .build())\n\n    print(f\"Custom config: {custom_config.app_name} v{custom_config.version}\")\n\n    # Using director for preset configurations\n    director = container.get(ConfigurationDirector)\n\n    dev_config = director.create_development_config(\"MyApp\")\n    print(f\"Dev config debug: {dev_config.debug}\")\n\n    prod_config = director.create_production_config(\"MyApp\", \"1.2.3\")\n    print(f\"Prod config HTTPS: {prod_config.security.require_https}\")\n\n    # Using configuration manager\n    manager = container.get(ConfigurationManager)\n\n    test_config = manager.get_or_create_config(\"testing\", \"TestApp\")\n    print(f\"Test config: {test_config.custom_settings}\")\n\n    microservice_config = manager.get_or_create_config(\n        \"microservice\",\n        \"UserService\",\n        service_port=8001,\n        dependencies=[\"database\", \"cache\", \"auth-service\"]\n    )\n    print(f\"Microservice config: {microservice_config.custom_settings}\")\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    async def main():\n        await factory_example()\n        print(\"\\n\" + \"=\"*50 + \"\\n\")\n        await abstract_factory_example()\n        print(\"\\n\" + \"=\"*50 + \"\\n\")\n        await observer_example()\n        print(\"\\n\" + \"=\"*50 + \"\\n\")\n        await strategy_example()\n        print(\"\\n\" + \"=\"*50 + \"\\n\")\n        await builder_example()\n\n    asyncio.run(main())\n</code></pre> <p>This design patterns section demonstrates:</p> <ol> <li>Factory Pattern: Creating notification services with named bindings and conditional logic</li> <li>Abstract Factory: Environment-specific infrastructure with multiple related products</li> <li>Observer Pattern: Event-driven architecture with automatic notifications</li> <li>Strategy Pattern: Runtime algorithm selection for payment processing</li> <li>Builder Pattern: Complex configuration construction with fluent interface and presets</li> </ol> <p>Each pattern shows: - Clean interface design - Proper dependency injection usage - Realistic business scenarios - Module configuration patterns - Error handling and validation - Testing considerations</p> <p>Ready to continue with more design patterns or move to the next documentation section?</p>"},{"location":"examples/practical-examples/","title":"Practical Examples","text":"<p>This section provides comprehensive, real-world examples of using InjectQ in various application scenarios and design patterns.</p>"},{"location":"examples/practical-examples/#web-application-example","title":"\ud83d\ude80 Web Application Example","text":""},{"location":"examples/practical-examples/#fastapi-e-commerce-application","title":"FastAPI E-commerce Application","text":"<pre><code># main.py - Complete e-commerce application\nfrom fastapi import FastAPI, Depends, HTTPException\nfrom injectq import InjectQ, inject, Module\nfrom typing import List, Optional\nimport asyncio\n\n# Domain Models\nclass User:\n    def __init__(self, id: str, name: str, email: str):\n        self.id = id\n        self.name = name\n        self.email = email\n\nclass Product:\n    def __init__(self, id: str, name: str, price: float, inventory: int):\n        self.id = id\n        self.name = name\n        self.price = price\n        self.inventory = inventory\n\nclass Order:\n    def __init__(self, id: str, user_id: str, items: List[dict], total: float):\n        self.id = id\n        self.user_id = user_id\n        self.items = items\n        self.total = total\n\n# Repository Layer\nfrom abc import ABC, abstractmethod\n\nclass IUserRepository(ABC):\n    @abstractmethod\n    async def find_by_id(self, user_id: str) -&gt; Optional[User]:\n        pass\n\n    @abstractmethod\n    async def create(self, user: User) -&gt; User:\n        pass\n\nclass IProductRepository(ABC):\n    @abstractmethod\n    async def find_by_id(self, product_id: str) -&gt; Optional[Product]:\n        pass\n\n    @abstractmethod\n    async def update_inventory(self, product_id: str, quantity: int) -&gt; bool:\n        pass\n\nclass IOrderRepository(ABC):\n    @abstractmethod\n    async def create(self, order: Order) -&gt; Order:\n        pass\n\n    @abstractmethod\n    async def find_by_user(self, user_id: str) -&gt; List[Order]:\n        pass\n\n# Concrete Implementations\nclass DatabaseUserRepository(IUserRepository):\n    @inject\n    async def __init__(self, db_connection: DatabaseConnection):\n        self.db = db_connection\n\n    async def find_by_id(self, user_id: str) -&gt; Optional[User]:\n        # Simulate database query\n        await asyncio.sleep(0.01)\n        return User(user_id, f\"User {user_id}\", f\"user{user_id}@example.com\")\n\n    async def create(self, user: User) -&gt; User:\n        # Simulate database insert\n        await asyncio.sleep(0.01)\n        return user\n\nclass DatabaseProductRepository(IProductRepository):\n    @inject\n    async def __init__(self, db_connection: DatabaseConnection, cache: CacheService):\n        self.db = db_connection\n        self.cache = cache\n\n    async def find_by_id(self, product_id: str) -&gt; Optional[Product]:\n        # Check cache first\n        cached = await self.cache.get(f\"product:{product_id}\")\n        if cached:\n            return cached\n\n        # Simulate database query\n        await asyncio.sleep(0.01)\n        product = Product(product_id, f\"Product {product_id}\", 99.99, 10)\n\n        # Cache the result\n        await self.cache.set(f\"product:{product_id}\", product, ttl=300)\n        return product\n\n    async def update_inventory(self, product_id: str, quantity: int) -&gt; bool:\n        # Simulate inventory update\n        await asyncio.sleep(0.01)\n        await self.cache.delete(f\"product:{product_id}\")  # Invalidate cache\n        return True\n\nclass DatabaseOrderRepository(IOrderRepository):\n    @inject\n    async def __init__(self, db_connection: DatabaseConnection):\n        self.db = db_connection\n\n    async def create(self, order: Order) -&gt; Order:\n        # Simulate database insert\n        await asyncio.sleep(0.01)\n        return order\n\n    async def find_by_user(self, user_id: str) -&gt; List[Order]:\n        # Simulate database query\n        await asyncio.sleep(0.01)\n        return []\n\n# Service Layer\nclass UserService:\n    @inject\n    def __init__(self, user_repo: IUserRepository, email_service: EmailService):\n        self.user_repo = user_repo\n        self.email_service = email_service\n\n    async def get_user(self, user_id: str) -&gt; Optional[User]:\n        return await self.user_repo.find_by_id(user_id)\n\n    async def create_user(self, user_data: dict) -&gt; User:\n        user = User(\n            id=user_data[\"id\"],\n            name=user_data[\"name\"],\n            email=user_data[\"email\"]\n        )\n\n        created_user = await self.user_repo.create(user)\n\n        # Send welcome email\n        await self.email_service.send_welcome_email(created_user)\n\n        return created_user\n\nclass ProductService:\n    @inject\n    def __init__(self, product_repo: IProductRepository):\n        self.product_repo = product_repo\n\n    async def get_product(self, product_id: str) -&gt; Optional[Product]:\n        return await self.product_repo.find_by_id(product_id)\n\n    async def check_availability(self, product_id: str, quantity: int) -&gt; bool:\n        product = await self.product_repo.find_by_id(product_id)\n        return product and product.inventory &gt;= quantity\n\nclass OrderService:\n    @inject\n    def __init__(\n        self,\n        order_repo: IOrderRepository,\n        product_service: ProductService,\n        payment_service: PaymentService,\n        notification_service: NotificationService\n    ):\n        self.order_repo = order_repo\n        self.product_service = product_service\n        self.payment_service = payment_service\n        self.notification_service = notification_service\n\n    async def create_order(self, user_id: str, items: List[dict]) -&gt; Order:\n        # Validate inventory\n        for item in items:\n            available = await self.product_service.check_availability(\n                item[\"product_id\"], item[\"quantity\"]\n            )\n            if not available:\n                raise HTTPException(\n                    status_code=400,\n                    detail=f\"Product {item['product_id']} not available\"\n                )\n\n        # Calculate total\n        total = 0.0\n        for item in items:\n            product = await self.product_service.get_product(item[\"product_id\"])\n            total += product.price * item[\"quantity\"]\n\n        # Process payment\n        payment_result = await self.payment_service.process_payment(user_id, total)\n        if not payment_result.success:\n            raise HTTPException(status_code=400, detail=\"Payment failed\")\n\n        # Create order\n        order = Order(\n            id=f\"order_{user_id}_{len(items)}\",\n            user_id=user_id,\n            items=items,\n            total=total\n        )\n\n        created_order = await self.order_repo.create(order)\n\n        # Send notifications\n        await self.notification_service.send_order_confirmation(created_order)\n\n        return created_order\n\n# Infrastructure Services\nclass DatabaseConnection:\n    @inject\n    async def __init__(self, config: DatabaseConfig):\n        self.config = config\n        await self.connect()\n\n    async def connect(self):\n        # Simulate database connection\n        await asyncio.sleep(0.1)\n\nclass CacheService:\n    def __init__(self):\n        self._cache = {}\n\n    async def get(self, key: str):\n        return self._cache.get(key)\n\n    async def set(self, key: str, value, ttl: int = 300):\n        self._cache[key] = value\n\n    async def delete(self, key: str):\n        self._cache.pop(key, None)\n\nclass EmailService:\n    @inject\n    def __init__(self, email_config: EmailConfig):\n        self.config = email_config\n\n    async def send_welcome_email(self, user: User):\n        print(f\"Sending welcome email to {user.email}\")\n\nclass PaymentService:\n    @inject\n    def __init__(self, payment_config: PaymentConfig):\n        self.config = payment_config\n\n    async def process_payment(self, user_id: str, amount: float):\n        # Simulate payment processing\n        await asyncio.sleep(0.1)\n        return PaymentResult(success=True, transaction_id=f\"txn_{user_id}\")\n\nclass NotificationService:\n    @inject\n    def __init__(self, notification_config: NotificationConfig):\n        self.config = notification_config\n\n    async def send_order_confirmation(self, order: Order):\n        print(f\"Order confirmation sent for order {order.id}\")\n\n# Configuration Classes\nclass DatabaseConfig:\n    def __init__(self, host: str, port: int, database: str):\n        self.host = host\n        self.port = port\n        self.database = database\n\nclass EmailConfig:\n    def __init__(self, smtp_host: str, smtp_port: int):\n        self.smtp_host = smtp_host\n        self.smtp_port = smtp_port\n\nclass PaymentConfig:\n    def __init__(self, api_key: str, endpoint: str):\n        self.api_key = api_key\n        self.endpoint = endpoint\n\nclass NotificationConfig:\n    def __init__(self, webhook_url: str):\n        self.webhook_url = webhook_url\n\nclass PaymentResult:\n    def __init__(self, success: bool, transaction_id: str):\n        self.success = success\n        self.transaction_id = transaction_id\n\n# Application Module\nclass ECommerceModule(Module):\n    def configure(self):\n        # Configuration\n        self.bind(DatabaseConfig, DatabaseConfig(\n            host=\"localhost\",\n            port=5432,\n            database=\"ecommerce\"\n        )).singleton()\n\n        self.bind(EmailConfig, EmailConfig(\n            smtp_host=\"smtp.example.com\",\n            smtp_port=587\n        )).singleton()\n\n        self.bind(PaymentConfig, PaymentConfig(\n            api_key=\"test_key\",\n            endpoint=\"https://api.payment.com\"\n        )).singleton()\n\n        self.bind(NotificationConfig, NotificationConfig(\n            webhook_url=\"https://notifications.example.com\"\n        )).singleton()\n\n        # Infrastructure\n        self.bind(DatabaseConnection, DatabaseConnection).singleton()\n        self.bind(CacheService, CacheService).singleton()\n        self.bind(EmailService, EmailService).singleton()\n        self.bind(PaymentService, PaymentService).singleton()\n        self.bind(NotificationService, NotificationService).singleton()\n\n        # Repositories\n        self.bind(IUserRepository, DatabaseUserRepository).scoped()\n        self.bind(IProductRepository, DatabaseProductRepository).scoped()\n        self.bind(IOrderRepository, DatabaseOrderRepository).scoped()\n\n        # Services\n        self.bind(UserService, UserService).scoped()\n        self.bind(ProductService, ProductService).scoped()\n        self.bind(OrderService, OrderService).scoped()\n\n# FastAPI Application\napp = FastAPI(title=\"E-commerce API\")\n\n# Setup DI container\ncontainer = InjectQ()\ncontainer.install(ECommerceModule())\n\n# Dependency provider for FastAPI\ndef get_container():\n    return container\n\n# API Endpoints\n@app.post(\"/users\")\nasync def create_user(\n    user_data: dict,\n    container: InjectQ = Depends(get_container)\n):\n    user_service = container.get(UserService)\n    user = await user_service.create_user(user_data)\n    return {\"id\": user.id, \"name\": user.name, \"email\": user.email}\n\n@app.get(\"/users/{user_id}\")\nasync def get_user(\n    user_id: str,\n    container: InjectQ = Depends(get_container)\n):\n    user_service = container.get(UserService)\n    user = await user_service.get_user(user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\"id\": user.id, \"name\": user.name, \"email\": user.email}\n\n@app.get(\"/products/{product_id}\")\nasync def get_product(\n    product_id: str,\n    container: InjectQ = Depends(get_container)\n):\n    product_service = container.get(ProductService)\n    product = await product_service.get_product(product_id)\n    if not product:\n        raise HTTPException(status_code=404, detail=\"Product not found\")\n    return {\n        \"id\": product.id,\n        \"name\": product.name,\n        \"price\": product.price,\n        \"inventory\": product.inventory\n    }\n\n@app.post(\"/orders\")\nasync def create_order(\n    order_data: dict,\n    container: InjectQ = Depends(get_container)\n):\n    order_service = container.get(OrderService)\n    order = await order_service.create_order(\n        order_data[\"user_id\"],\n        order_data[\"items\"]\n    )\n    return {\n        \"id\": order.id,\n        \"user_id\": order.user_id,\n        \"items\": order.items,\n        \"total\": order.total\n    }\n\n# Application startup\n@app.on_event(\"startup\")\nasync def startup_event():\n    print(\"E-commerce API started successfully!\")\n\n# Run with: uvicorn main:app --reload\n</code></pre>"},{"location":"examples/practical-examples/#scientific-computing-example","title":"\ud83e\uddee Scientific Computing Example","text":""},{"location":"examples/practical-examples/#data-processing-pipeline","title":"Data Processing Pipeline","text":"<pre><code># data_pipeline.py - Scientific data processing pipeline\nimport numpy as np\nimport pandas as pd\nfrom abc import ABC, abstractmethod\nfrom injectq import InjectQ, inject, Module\nimport asyncio\nfrom typing import List, Dict, Any\n\n# Data Models\nclass Dataset:\n    def __init__(self, name: str, data: pd.DataFrame):\n        self.name = name\n        self.data = data\n        self.metadata = {}\n\nclass ProcessingResult:\n    def __init__(self, dataset_name: str, results: Dict[str, Any]):\n        self.dataset_name = dataset_name\n        self.results = results\n        self.timestamp = pd.Timestamp.now()\n\n# Data Source Interfaces\nclass IDataSource(ABC):\n    @abstractmethod\n    async def load_data(self, source_id: str) -&gt; Dataset:\n        pass\n\nclass IDataSink(ABC):\n    @abstractmethod\n    async def save_results(self, results: ProcessingResult) -&gt; bool:\n        pass\n\n# Data Processing Interfaces\nclass IDataProcessor(ABC):\n    @abstractmethod\n    async def process(self, dataset: Dataset) -&gt; ProcessingResult:\n        pass\n\nclass IDataValidator(ABC):\n    @abstractmethod\n    async def validate(self, dataset: Dataset) -&gt; bool:\n        pass\n\n# Concrete Implementations\nclass CSVDataSource(IDataSource):\n    @inject\n    def __init__(self, config: DataSourceConfig):\n        self.config = config\n\n    async def load_data(self, source_id: str) -&gt; Dataset:\n        # Simulate loading CSV data\n        await asyncio.sleep(0.1)\n\n        # Generate sample data\n        np.random.seed(42)\n        data = pd.DataFrame({\n            'timestamp': pd.date_range('2023-01-01', periods=1000, freq='H'),\n            'temperature': np.random.normal(20, 5, 1000),\n            'humidity': np.random.normal(60, 10, 1000),\n            'pressure': np.random.normal(1013, 20, 1000)\n        })\n\n        return Dataset(name=f\"dataset_{source_id}\", data=data)\n\nclass DatabaseDataSink(IDataSink):\n    @inject\n    def __init__(self, db_connection: DatabaseConnection):\n        self.db = db_connection\n\n    async def save_results(self, results: ProcessingResult) -&gt; bool:\n        # Simulate saving to database\n        await asyncio.sleep(0.05)\n        print(f\"Saved results for {results.dataset_name} to database\")\n        return True\n\nclass StatisticalProcessor(IDataProcessor):\n    @inject\n    def __init__(self, stats_config: StatisticsConfig):\n        self.config = stats_config\n\n    async def process(self, dataset: Dataset) -&gt; ProcessingResult:\n        # Perform statistical analysis\n        data = dataset.data\n\n        results = {\n            'mean_temperature': data['temperature'].mean(),\n            'std_temperature': data['temperature'].std(),\n            'mean_humidity': data['humidity'].mean(),\n            'std_humidity': data['humidity'].std(),\n            'correlation_temp_humidity': data['temperature'].corr(data['humidity']),\n            'total_records': len(data)\n        }\n\n        return ProcessingResult(dataset.name, results)\n\nclass AnomalyDetectionProcessor(IDataProcessor):\n    @inject\n    def __init__(self, anomaly_config: AnomalyConfig):\n        self.config = anomaly_config\n\n    async def process(self, dataset: Dataset) -&gt; ProcessingResult:\n        # Detect anomalies using Z-score\n        data = dataset.data\n\n        z_scores = np.abs((data['temperature'] - data['temperature'].mean()) / data['temperature'].std())\n        anomalies = data[z_scores &gt; self.config.threshold]\n\n        results = {\n            'anomaly_count': len(anomalies),\n            'anomaly_percentage': (len(anomalies) / len(data)) * 100,\n            'max_z_score': z_scores.max(),\n            'anomaly_timestamps': anomalies['timestamp'].tolist()\n        }\n\n        return ProcessingResult(dataset.name, results)\n\nclass DataQualityValidator(IDataValidator):\n    @inject\n    def __init__(self, quality_config: QualityConfig):\n        self.config = quality_config\n\n    async def validate(self, dataset: Dataset) -&gt; bool:\n        data = dataset.data\n\n        # Check for missing values\n        missing_percentage = (data.isnull().sum().sum() / (len(data) * len(data.columns))) * 100\n        if missing_percentage &gt; self.config.max_missing_percentage:\n            return False\n\n        # Check for outliers\n        for column in ['temperature', 'humidity', 'pressure']:\n            z_scores = np.abs((data[column] - data[column].mean()) / data[column].std())\n            outlier_percentage = (len(data[z_scores &gt; 3]) / len(data)) * 100\n            if outlier_percentage &gt; self.config.max_outlier_percentage:\n                return False\n\n        return True\n\n# Data Pipeline Orchestrator\nclass DataPipeline:\n    @inject\n    def __init__(\n        self,\n        data_source: IDataSource,\n        data_sink: IDataSink,\n        processors: List[IDataProcessor],\n        validator: IDataValidator,\n        logger: LoggingService\n    ):\n        self.data_source = data_source\n        self.data_sink = data_sink\n        self.processors = processors\n        self.validator = validator\n        self.logger = logger\n\n    async def process_dataset(self, source_id: str) -&gt; List[ProcessingResult]:\n        \"\"\"Process a single dataset through the entire pipeline.\"\"\"\n        try:\n            # Load data\n            self.logger.info(f\"Loading dataset {source_id}\")\n            dataset = await self.data_source.load_data(source_id)\n\n            # Validate data quality\n            self.logger.info(f\"Validating dataset {dataset.name}\")\n            is_valid = await self.validator.validate(dataset)\n            if not is_valid:\n                self.logger.error(f\"Dataset {dataset.name} failed validation\")\n                return []\n\n            # Process data with all processors\n            results = []\n            for processor in self.processors:\n                self.logger.info(f\"Processing {dataset.name} with {processor.__class__.__name__}\")\n                result = await processor.process(dataset)\n                results.append(result)\n\n                # Save results\n                await self.data_sink.save_results(result)\n\n            self.logger.info(f\"Pipeline completed for dataset {dataset.name}\")\n            return results\n\n        except Exception as e:\n            self.logger.error(f\"Pipeline failed for dataset {source_id}: {str(e)}\")\n            raise\n\n    async def process_multiple_datasets(self, source_ids: List[str]) -&gt; Dict[str, List[ProcessingResult]]:\n        \"\"\"Process multiple datasets concurrently.\"\"\"\n        tasks = [self.process_dataset(source_id) for source_id in source_ids]\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n\n        return {\n            source_id: result if not isinstance(result, Exception) else []\n            for source_id, result in zip(source_ids, results)\n        }\n\n# Configuration Classes\nclass DataSourceConfig:\n    def __init__(self, base_path: str, file_format: str = \"csv\"):\n        self.base_path = base_path\n        self.file_format = file_format\n\nclass StatisticsConfig:\n    def __init__(self, confidence_level: float = 0.95):\n        self.confidence_level = confidence_level\n\nclass AnomalyConfig:\n    def __init__(self, threshold: float = 3.0):\n        self.threshold = threshold\n\nclass QualityConfig:\n    def __init__(self, max_missing_percentage: float = 5.0, max_outlier_percentage: float = 1.0):\n        self.max_missing_percentage = max_missing_percentage\n        self.max_outlier_percentage = max_outlier_percentage\n\n# Logging Service\nclass LoggingService:\n    def __init__(self):\n        import logging\n        self.logger = logging.getLogger(\"DataPipeline\")\n        self.logger.setLevel(logging.INFO)\n\n        if not self.logger.handlers:\n            handler = logging.StreamHandler()\n            formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n            handler.setFormatter(formatter)\n            self.logger.addHandler(handler)\n\n    def info(self, message: str):\n        self.logger.info(message)\n\n    def error(self, message: str):\n        self.logger.error(message)\n\n    def warning(self, message: str):\n        self.logger.warning(message)\n\n# Data Processing Module\nclass DataProcessingModule(Module):\n    def configure(self):\n        # Configuration\n        self.bind(DataSourceConfig, DataSourceConfig(\n            base_path=\"/data/input\",\n            file_format=\"csv\"\n        )).singleton()\n\n        self.bind(StatisticsConfig, StatisticsConfig(\n            confidence_level=0.95\n        )).singleton()\n\n        self.bind(AnomalyConfig, AnomalyConfig(\n            threshold=3.0\n        )).singleton()\n\n        self.bind(QualityConfig, QualityConfig(\n            max_missing_percentage=5.0,\n            max_outlier_percentage=1.0\n        )).singleton()\n\n        # Infrastructure\n        self.bind(DatabaseConnection, DatabaseConnection).singleton()\n        self.bind(LoggingService, LoggingService).singleton()\n\n        # Data Sources and Sinks\n        self.bind(IDataSource, CSVDataSource).singleton()\n        self.bind(IDataSink, DatabaseDataSink).singleton()\n\n        # Validators\n        self.bind(IDataValidator, DataQualityValidator).singleton()\n\n        # Processors (multiple implementations)\n        self.bind(IDataProcessor, StatisticalProcessor, name=\"stats\").singleton()\n        self.bind(IDataProcessor, AnomalyDetectionProcessor, name=\"anomaly\").singleton()\n\n        # Pipeline\n        self.bind(List[IDataProcessor], lambda: [\n            self.container.get(IDataProcessor, name=\"stats\"),\n            self.container.get(IDataProcessor, name=\"anomaly\")\n        ]).singleton()\n\n        self.bind(DataPipeline, DataPipeline).singleton()\n\n# Example Usage\nasync def main():\n    # Setup container\n    container = InjectQ()\n    container.install(DataProcessingModule())\n\n    # Get pipeline\n    pipeline = container.get(DataPipeline)\n\n    # Process multiple datasets\n    source_ids = [\"weather_station_1\", \"weather_station_2\", \"weather_station_3\"]\n    results = await pipeline.process_multiple_datasets(source_ids)\n\n    # Display results\n    for source_id, dataset_results in results.items():\n        print(f\"\\nResults for {source_id}:\")\n        for result in dataset_results:\n            print(f\"  Processor: {result.dataset_name}\")\n            for key, value in result.results.items():\n                print(f\"    {key}: {value}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/practical-examples/#microservices-example","title":"\ud83e\udd16 Microservices Example","text":""},{"location":"examples/practical-examples/#event-driven-microservice","title":"Event-Driven Microservice","text":"<pre><code># microservice.py - Event-driven microservice with InjectQ\nfrom injectq import InjectQ, inject, Module\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, List, Optional, Callable\nimport asyncio\nimport json\nfrom dataclasses import dataclass, asdict\nfrom datetime import datetime\n\n# Event System\n@dataclass\nclass Event:\n    event_type: str\n    event_id: str\n    timestamp: datetime\n    data: Dict\n    source: str\n\nclass IEventBus(ABC):\n    @abstractmethod\n    async def publish(self, event: Event) -&gt; bool:\n        pass\n\n    @abstractmethod\n    async def subscribe(self, event_type: str, handler: Callable) -&gt; bool:\n        pass\n\nclass IEventStore(ABC):\n    @abstractmethod\n    async def store_event(self, event: Event) -&gt; bool:\n        pass\n\n    @abstractmethod\n    async def get_events(self, event_type: str, limit: int = 100) -&gt; List[Event]:\n        pass\n\n# Command and Query Separation\n@dataclass\nclass Command:\n    command_type: str\n    command_id: str\n    data: Dict\n    timestamp: datetime\n\n@dataclass\nclass Query:\n    query_type: str\n    query_id: str\n    parameters: Dict\n    timestamp: datetime\n\nclass ICommandHandler(ABC):\n    @abstractmethod\n    async def handle(self, command: Command) -&gt; Dict:\n        pass\n\nclass IQueryHandler(ABC):\n    @abstractmethod\n    async def handle(self, query: Query) -&gt; Dict:\n        pass\n\n# Domain Models\n@dataclass\nclass Order:\n    id: str\n    customer_id: str\n    items: List[Dict]\n    total_amount: float\n    status: str\n    created_at: datetime\n\n@dataclass\nclass Customer:\n    id: str\n    name: str\n    email: str\n    created_at: datetime\n\n# Repositories\nclass IOrderRepository(ABC):\n    @abstractmethod\n    async def save(self, order: Order) -&gt; Order:\n        pass\n\n    @abstractmethod\n    async def find_by_id(self, order_id: str) -&gt; Optional[Order]:\n        pass\n\n    @abstractmethod\n    async def find_by_customer(self, customer_id: str) -&gt; List[Order]:\n        pass\n\nclass ICustomerRepository(ABC):\n    @abstractmethod\n    async def save(self, customer: Customer) -&gt; Customer:\n        pass\n\n    @abstractmethod\n    async def find_by_id(self, customer_id: str) -&gt; Optional[Customer]:\n        pass\n\n# Event Bus Implementation\nclass InMemoryEventBus(IEventBus):\n    def __init__(self):\n        self.subscribers: Dict[str, List[Callable]] = {}\n\n    async def publish(self, event: Event) -&gt; bool:\n        handlers = self.subscribers.get(event.event_type, [])\n\n        for handler in handlers:\n            try:\n                await handler(event)\n            except Exception as e:\n                print(f\"Error handling event {event.event_id}: {e}\")\n\n        return True\n\n    async def subscribe(self, event_type: str, handler: Callable) -&gt; bool:\n        if event_type not in self.subscribers:\n            self.subscribers[event_type] = []\n\n        self.subscribers[event_type].append(handler)\n        return True\n\nclass DatabaseEventStore(IEventStore):\n    @inject\n    def __init__(self, db_connection: DatabaseConnection):\n        self.db = db_connection\n        self.events = []  # In-memory for demo\n\n    async def store_event(self, event: Event) -&gt; bool:\n        # Simulate database storage\n        self.events.append(event)\n        return True\n\n    async def get_events(self, event_type: str, limit: int = 100) -&gt; List[Event]:\n        # Filter events by type\n        filtered_events = [e for e in self.events if e.event_type == event_type]\n        return filtered_events[:limit]\n\n# Repository Implementations\nclass DatabaseOrderRepository(IOrderRepository):\n    @inject\n    def __init__(self, db_connection: DatabaseConnection, event_bus: IEventBus):\n        self.db = db_connection\n        self.event_bus = event_bus\n        self.orders = {}  # In-memory for demo\n\n    async def save(self, order: Order) -&gt; Order:\n        self.orders[order.id] = order\n\n        # Publish event\n        event = Event(\n            event_type=\"order.created\" if order.id not in self.orders else \"order.updated\",\n            event_id=f\"event_{order.id}_{datetime.now().timestamp()}\",\n            timestamp=datetime.now(),\n            data=asdict(order),\n            source=\"order_service\"\n        )\n        await self.event_bus.publish(event)\n\n        return order\n\n    async def find_by_id(self, order_id: str) -&gt; Optional[Order]:\n        return self.orders.get(order_id)\n\n    async def find_by_customer(self, customer_id: str) -&gt; List[Order]:\n        return [order for order in self.orders.values() if order.customer_id == customer_id]\n\nclass DatabaseCustomerRepository(ICustomerRepository):\n    @inject\n    def __init__(self, db_connection: DatabaseConnection, event_bus: IEventBus):\n        self.db = db_connection\n        self.event_bus = event_bus\n        self.customers = {}  # In-memory for demo\n\n    async def save(self, customer: Customer) -&gt; Customer:\n        self.customers[customer.id] = customer\n\n        # Publish event\n        event = Event(\n            event_type=\"customer.created\" if customer.id not in self.customers else \"customer.updated\",\n            event_id=f\"event_{customer.id}_{datetime.now().timestamp()}\",\n            timestamp=datetime.now(),\n            data=asdict(customer),\n            source=\"customer_service\"\n        )\n        await self.event_bus.publish(event)\n\n        return customer\n\n    async def find_by_id(self, customer_id: str) -&gt; Optional[Customer]:\n        return self.customers.get(customer_id)\n\n# Command Handlers\nclass CreateOrderCommandHandler(ICommandHandler):\n    @inject\n    def __init__(\n        self,\n        order_repo: IOrderRepository,\n        customer_repo: ICustomerRepository,\n        event_store: IEventStore\n    ):\n        self.order_repo = order_repo\n        self.customer_repo = customer_repo\n        self.event_store = event_store\n\n    async def handle(self, command: Command) -&gt; Dict:\n        if command.command_type != \"create_order\":\n            raise ValueError(f\"Unsupported command type: {command.command_type}\")\n\n        data = command.data\n\n        # Validate customer exists\n        customer = await self.customer_repo.find_by_id(data[\"customer_id\"])\n        if not customer:\n            return {\"success\": False, \"error\": \"Customer not found\"}\n\n        # Create order\n        order = Order(\n            id=data[\"order_id\"],\n            customer_id=data[\"customer_id\"],\n            items=data[\"items\"],\n            total_amount=data[\"total_amount\"],\n            status=\"created\",\n            created_at=datetime.now()\n        )\n\n        # Save order\n        saved_order = await self.order_repo.save(order)\n\n        # Store command as event\n        command_event = Event(\n            event_type=\"command.executed\",\n            event_id=command.command_id,\n            timestamp=command.timestamp,\n            data={\"command\": asdict(command), \"result\": asdict(saved_order)},\n            source=\"order_service\"\n        )\n        await self.event_store.store_event(command_event)\n\n        return {\"success\": True, \"order_id\": saved_order.id}\n\nclass CreateCustomerCommandHandler(ICommandHandler):\n    @inject\n    def __init__(self, customer_repo: ICustomerRepository, event_store: IEventStore):\n        self.customer_repo = customer_repo\n        self.event_store = event_store\n\n    async def handle(self, command: Command) -&gt; Dict:\n        if command.command_type != \"create_customer\":\n            raise ValueError(f\"Unsupported command type: {command.command_type}\")\n\n        data = command.data\n\n        # Create customer\n        customer = Customer(\n            id=data[\"customer_id\"],\n            name=data[\"name\"],\n            email=data[\"email\"],\n            created_at=datetime.now()\n        )\n\n        # Save customer\n        saved_customer = await self.customer_repo.save(customer)\n\n        # Store command as event\n        command_event = Event(\n            event_type=\"command.executed\",\n            event_id=command.command_id,\n            timestamp=command.timestamp,\n            data={\"command\": asdict(command), \"result\": asdict(saved_customer)},\n            source=\"customer_service\"\n        )\n        await self.event_store.store_event(command_event)\n\n        return {\"success\": True, \"customer_id\": saved_customer.id}\n\n# Query Handlers\nclass GetOrderQueryHandler(IQueryHandler):\n    @inject\n    def __init__(self, order_repo: IOrderRepository):\n        self.order_repo = order_repo\n\n    async def handle(self, query: Query) -&gt; Dict:\n        if query.query_type != \"get_order\":\n            raise ValueError(f\"Unsupported query type: {query.query_type}\")\n\n        order_id = query.parameters[\"order_id\"]\n        order = await self.order_repo.find_by_id(order_id)\n\n        if order:\n            return {\"success\": True, \"order\": asdict(order)}\n        else:\n            return {\"success\": False, \"error\": \"Order not found\"}\n\nclass GetCustomerOrdersQueryHandler(IQueryHandler):\n    @inject\n    def __init__(self, order_repo: IOrderRepository):\n        self.order_repo = order_repo\n\n    async def handle(self, query: Query) -&gt; Dict:\n        if query.query_type != \"get_customer_orders\":\n            raise ValueError(f\"Unsupported query type: {query.query_type}\")\n\n        customer_id = query.parameters[\"customer_id\"]\n        orders = await self.order_repo.find_by_customer(customer_id)\n\n        return {\n            \"success\": True,\n            \"orders\": [asdict(order) for order in orders]\n        }\n\n# Event Handlers\nclass OrderEventHandler:\n    @inject\n    def __init__(self, notification_service: NotificationService):\n        self.notification_service = notification_service\n\n    async def handle_order_created(self, event: Event):\n        order_data = event.data\n        print(f\"Order created: {order_data['id']}\")\n\n        # Send notification\n        await self.notification_service.send_order_confirmation(order_data)\n\n    async def handle_order_updated(self, event: Event):\n        order_data = event.data\n        print(f\"Order updated: {order_data['id']}\")\n\nclass CustomerEventHandler:\n    @inject\n    def __init__(self, email_service: EmailService):\n        self.email_service = email_service\n\n    async def handle_customer_created(self, event: Event):\n        customer_data = event.data\n        print(f\"Customer created: {customer_data['id']}\")\n\n        # Send welcome email\n        await self.email_service.send_welcome_email(customer_data)\n\n# Application Services\nclass CommandDispatcher:\n    @inject\n    def __init__(self):\n        self.handlers: Dict[str, ICommandHandler] = {}\n\n    def register_handler(self, command_type: str, handler: ICommandHandler):\n        self.handlers[command_type] = handler\n\n    async def dispatch(self, command: Command) -&gt; Dict:\n        handler = self.handlers.get(command.command_type)\n        if not handler:\n            raise ValueError(f\"No handler for command type: {command.command_type}\")\n\n        return await handler.handle(command)\n\nclass QueryDispatcher:\n    @inject\n    def __init__(self):\n        self.handlers: Dict[str, IQueryHandler] = {}\n\n    def register_handler(self, query_type: str, handler: IQueryHandler):\n        self.handlers[query_type] = handler\n\n    async def dispatch(self, query: Query) -&gt; Dict:\n        handler = self.handlers.get(query.query_type)\n        if not handler:\n            raise ValueError(f\"No handler for query type: {query.query_type}\")\n\n        return await handler.handle(query)\n\n# Infrastructure Services\nclass NotificationService:\n    def __init__(self):\n        pass\n\n    async def send_order_confirmation(self, order_data: Dict):\n        print(f\"Sending order confirmation for order {order_data['id']}\")\n\nclass EmailService:\n    def __init__(self):\n        pass\n\n    async def send_welcome_email(self, customer_data: Dict):\n        print(f\"Sending welcome email to {customer_data['email']}\")\n\n# Microservice Application\nclass MicroserviceApplication:\n    @inject\n    def __init__(\n        self,\n        event_bus: IEventBus,\n        command_dispatcher: CommandDispatcher,\n        query_dispatcher: QueryDispatcher,\n        order_event_handler: OrderEventHandler,\n        customer_event_handler: CustomerEventHandler\n    ):\n        self.event_bus = event_bus\n        self.command_dispatcher = command_dispatcher\n        self.query_dispatcher = query_dispatcher\n        self.order_event_handler = order_event_handler\n        self.customer_event_handler = customer_event_handler\n\n    async def initialize(self):\n        \"\"\"Initialize the microservice.\"\"\"\n        # Register event handlers\n        await self.event_bus.subscribe(\"order.created\", self.order_event_handler.handle_order_created)\n        await self.event_bus.subscribe(\"order.updated\", self.order_event_handler.handle_order_updated)\n        await self.event_bus.subscribe(\"customer.created\", self.customer_event_handler.handle_customer_created)\n\n        print(\"Microservice initialized successfully\")\n\n    async def process_command(self, command_data: Dict) -&gt; Dict:\n        \"\"\"Process a command.\"\"\"\n        command = Command(\n            command_type=command_data[\"command_type\"],\n            command_id=command_data[\"command_id\"],\n            data=command_data[\"data\"],\n            timestamp=datetime.now()\n        )\n\n        return await self.command_dispatcher.dispatch(command)\n\n    async def process_query(self, query_data: Dict) -&gt; Dict:\n        \"\"\"Process a query.\"\"\"\n        query = Query(\n            query_type=query_data[\"query_type\"],\n            query_id=query_data[\"query_id\"],\n            parameters=query_data[\"parameters\"],\n            timestamp=datetime.now()\n        )\n\n        return await self.query_dispatcher.dispatch(query)\n\n# Module Configuration\nclass MicroserviceModule(Module):\n    def configure(self):\n        # Infrastructure\n        self.bind(DatabaseConnection, DatabaseConnection).singleton()\n        self.bind(IEventBus, InMemoryEventBus).singleton()\n        self.bind(IEventStore, DatabaseEventStore).singleton()\n\n        # Repositories\n        self.bind(IOrderRepository, DatabaseOrderRepository).singleton()\n        self.bind(ICustomerRepository, DatabaseCustomerRepository).singleton()\n\n        # Command Handlers\n        self.bind(ICommandHandler, CreateOrderCommandHandler, name=\"create_order\").singleton()\n        self.bind(ICommandHandler, CreateCustomerCommandHandler, name=\"create_customer\").singleton()\n\n        # Query Handlers\n        self.bind(IQueryHandler, GetOrderQueryHandler, name=\"get_order\").singleton()\n        self.bind(IQueryHandler, GetCustomerOrdersQueryHandler, name=\"get_customer_orders\").singleton()\n\n        # Dispatchers\n        self.bind(CommandDispatcher, self.create_command_dispatcher).singleton()\n        self.bind(QueryDispatcher, self.create_query_dispatcher).singleton()\n\n        # Event Handlers\n        self.bind(OrderEventHandler, OrderEventHandler).singleton()\n        self.bind(CustomerEventHandler, CustomerEventHandler).singleton()\n\n        # Services\n        self.bind(NotificationService, NotificationService).singleton()\n        self.bind(EmailService, EmailService).singleton()\n\n        # Application\n        self.bind(MicroserviceApplication, MicroserviceApplication).singleton()\n\n    def create_command_dispatcher(self) -&gt; CommandDispatcher:\n        dispatcher = CommandDispatcher()\n        dispatcher.register_handler(\"create_order\", self.container.get(ICommandHandler, name=\"create_order\"))\n        dispatcher.register_handler(\"create_customer\", self.container.get(ICommandHandler, name=\"create_customer\"))\n        return dispatcher\n\n    def create_query_dispatcher(self) -&gt; QueryDispatcher:\n        dispatcher = QueryDispatcher()\n        dispatcher.register_handler(\"get_order\", self.container.get(IQueryHandler, name=\"get_order\"))\n        dispatcher.register_handler(\"get_customer_orders\", self.container.get(IQueryHandler, name=\"get_customer_orders\"))\n        return dispatcher\n\n# Example Usage\nasync def main():\n    # Setup container\n    container = InjectQ()\n    container.install(MicroserviceModule())\n\n    # Get application\n    app = container.get(MicroserviceApplication)\n    await app.initialize()\n\n    # Create customer\n    customer_command = {\n        \"command_type\": \"create_customer\",\n        \"command_id\": \"cmd_001\",\n        \"data\": {\n            \"customer_id\": \"cust_001\",\n            \"name\": \"John Doe\",\n            \"email\": \"john@example.com\"\n        }\n    }\n\n    result = await app.process_command(customer_command)\n    print(f\"Customer creation result: {result}\")\n\n    # Create order\n    order_command = {\n        \"command_type\": \"create_order\",\n        \"command_id\": \"cmd_002\",\n        \"data\": {\n            \"order_id\": \"order_001\",\n            \"customer_id\": \"cust_001\",\n            \"items\": [{\"product_id\": \"prod_001\", \"quantity\": 2, \"price\": 50.0}],\n            \"total_amount\": 100.0\n        }\n    }\n\n    result = await app.process_command(order_command)\n    print(f\"Order creation result: {result}\")\n\n    # Query order\n    order_query = {\n        \"query_type\": \"get_order\",\n        \"query_id\": \"query_001\",\n        \"parameters\": {\"order_id\": \"order_001\"}\n    }\n\n    result = await app.process_query(order_query)\n    print(f\"Order query result: {result}\")\n\n    # Query customer orders\n    customer_orders_query = {\n        \"query_type\": \"get_customer_orders\",\n        \"query_id\": \"query_002\",\n        \"parameters\": {\"customer_id\": \"cust_001\"}\n    }\n\n    result = await app.process_query(customer_orders_query)\n    print(f\"Customer orders query result: {result}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>This examples section provides comprehensive, real-world examples that demonstrate:</p> <ol> <li>Web Application Example: Complete FastAPI e-commerce application showing layered architecture with repositories, services, and proper dependency injection</li> <li>Scientific Computing Example: Data processing pipeline with multiple processors, validators, and async processing capabilities</li> <li>Microservices Example: Event-driven microservice with CQRS pattern, event sourcing, and proper separation of concerns</li> </ol> <p>Each example shows: - Proper interface usage and abstraction - Module configuration and dependency binding - Async/await patterns - Error handling and validation - Testing considerations - Real-world architectural patterns</p> <p>Ready to continue with more examples or move to the next section?</p>"},{"location":"getting-started/first-app/","title":"Your First App","text":"<p>Let's build a complete application with InjectQ! We'll create a simple user management system that demonstrates real-world patterns.</p>"},{"location":"getting-started/first-app/#application-overview","title":"\ud83c\udfaf Application Overview","text":"<p>We'll build a user management API with:</p> <ul> <li>User repository for data access</li> <li>User service for business logic</li> <li>Configuration management</li> <li>Dependency injection throughout</li> <li>Proper error handling</li> </ul>"},{"location":"getting-started/first-app/#project-structure","title":"\ud83d\udcc1 Project Structure","text":"<pre><code>my_injectq_app/\n\u251c\u2500\u2500 main.py              # Application entry point\n\u251c\u2500\u2500 config.py            # Configuration classes\n\u251c\u2500\u2500 database.py          # Database layer\n\u251c\u2500\u2500 repository.py        # Data access layer\n\u251c\u2500\u2500 service.py           # Business logic layer\n\u2514\u2500\u2500 models.py            # Data models\n</code></pre>"},{"location":"getting-started/first-app/#step-1-define-data-models","title":"\ud83c\udfd7\ufe0f Step 1: Define Data Models","text":"<pre><code># models.py\nfrom dataclasses import dataclass\nfrom typing import Optional\nfrom datetime import datetime\n\n@dataclass\nclass User:\n    id: Optional[int]\n    username: str\n    email: str\n    created_at: datetime\n    is_active: bool = True\n\n@dataclass\nclass CreateUserRequest:\n    username: str\n    email: str\n\n@dataclass\nclass UpdateUserRequest:\n    username: Optional[str] = None\n    email: Optional[str] = None\n    is_active: Optional[bool] = None\n</code></pre>"},{"location":"getting-started/first-app/#step-2-configuration","title":"\u2699\ufe0f Step 2: Configuration","text":"<pre><code># config.py\nfrom injectq import singleton\n\n@singleton\nclass DatabaseConfig:\n    def __init__(self):\n        self.host = \"localhost\"\n        self.port = 5432\n        self.database = \"userdb\"\n        self.user = \"postgres\"\n        self.password = \"password\"\n\n    @property\n    def connection_string(self) -&gt; str:\n        return f\"postgresql://{self.user}:{self.password}@{self.host}:{self.port}/{self.database}\"\n\n@singleton\nclass AppConfig:\n    def __init__(self):\n        self.app_name = \"User Management API\"\n        self.version = \"1.0.0\"\n        self.debug = True\n</code></pre>"},{"location":"getting-started/first-app/#step-3-database-layer","title":"\ud83d\uddc4\ufe0f Step 3: Database Layer","text":"<pre><code># database.py\nfrom typing import List, Optional\nfrom injectq import singleton\nimport asyncio\n\nfrom .config import DatabaseConfig\nfrom .models import User\n\n@singleton\nclass Database:\n    def __init__(self, config: DatabaseConfig):\n        self.config = config\n        self._users = {}  # In-memory storage for demo\n        self._next_id = 1\n        print(f\"Database initialized with config: {config.connection_string}\")\n\n    async def create_user(self, user: User) -&gt; User:\n        \"\"\"Create a new user.\"\"\"\n        user.id = self._next_id\n        self._users[user.id] = user\n        self._next_id += 1\n        return user\n\n    async def get_user(self, user_id: int) -&gt; Optional[User]:\n        \"\"\"Get user by ID.\"\"\"\n        return self._users.get(user_id)\n\n    async def get_user_by_username(self, username: str) -&gt; Optional[User]:\n        \"\"\"Get user by username.\"\"\"\n        for user in self._users.values():\n            if user.username == username:\n                return user\n        return None\n\n    async def get_all_users(self) -&gt; List[User]:\n        \"\"\"Get all users.\"\"\"\n        return list(self._users.values())\n\n    async def update_user(self, user_id: int, updates: dict) -&gt; Optional[User]:\n        \"\"\"Update user.\"\"\"\n        user = self._users.get(user_id)\n        if not user:\n            return None\n\n        for key, value in updates.items():\n            if hasattr(user, key):\n                setattr(user, key, value)\n\n        return user\n\n    async def delete_user(self, user_id: int) -&gt; bool:\n        \"\"\"Delete user.\"\"\"\n        if user_id in self._users:\n            del self._users[user_id]\n            return True\n        return False\n</code></pre>"},{"location":"getting-started/first-app/#step-4-repository-layer","title":"\ud83d\udcca Step 4: Repository Layer","text":"<pre><code># repository.py\nfrom typing import List, Optional\nfrom injectq import singleton\n\nfrom .database import Database\nfrom .models import User, CreateUserRequest, UpdateUserRequest\n\n@singleton\nclass UserRepository:\n    def __init__(self, db: Database):\n        self.db = db\n\n    async def create(self, request: CreateUserRequest) -&gt; User:\n        \"\"\"Create a new user.\"\"\"\n        from datetime import datetime\n        user = User(\n            id=None,\n            username=request.username,\n            email=request.email,\n            created_at=datetime.now(),\n            is_active=True\n        )\n        return await self.db.create_user(user)\n\n    async def get_by_id(self, user_id: int) -&gt; Optional[User]:\n        \"\"\"Get user by ID.\"\"\"\n        return await self.db.get_user(user_id)\n\n    async def get_by_username(self, username: str) -&gt; Optional[User]:\n        \"\"\"Get user by username.\"\"\"\n        return await self.db.get_user_by_username(username)\n\n    async def get_all(self) -&gt; List[User]:\n        \"\"\"Get all users.\"\"\"\n        return await self.db.get_all_users()\n\n    async def update(self, user_id: int, request: UpdateUserRequest) -&gt; Optional[User]:\n        \"\"\"Update user.\"\"\"\n        updates = {}\n        if request.username is not None:\n            updates[\"username\"] = request.username\n        if request.email is not None:\n            updates[\"email\"] = request.email\n        if request.is_active is not None:\n            updates[\"is_active\"] = request.is_active\n\n        return await self.db.update_user(user_id, updates)\n\n    async def delete(self, user_id: int) -&gt; bool:\n        \"\"\"Delete user.\"\"\"\n        return await self.db.delete_user(user_id)\n</code></pre>"},{"location":"getting-started/first-app/#step-5-service-layer","title":"\ud83d\udd27 Step 5: Service Layer","text":"<pre><code># service.py\nfrom typing import List, Optional\nfrom injectq import singleton\n\nfrom .repository import UserRepository\nfrom .models import User, CreateUserRequest, UpdateUserRequest\n\n@singleton\nclass UserService:\n    def __init__(self, repo: UserRepository):\n        self.repo = repo\n\n    async def create_user(self, request: CreateUserRequest) -&gt; User:\n        \"\"\"Create a new user with validation.\"\"\"\n        # Check if username already exists\n        existing = await self.repo.get_by_username(request.username)\n        if existing:\n            raise ValueError(f\"Username '{request.username}' already exists\")\n\n        # Check if email already exists\n        # In a real app, you'd check this too\n        return await self.repo.create(request)\n\n    async def get_user(self, user_id: int) -&gt; Optional[User]:\n        \"\"\"Get user by ID.\"\"\"\n        return await self.repo.get_by_id(user_id)\n\n    async def get_user_by_username(self, username: str) -&gt; Optional[User]:\n        \"\"\"Get user by username.\"\"\"\n        return await self.repo.get_by_username(username)\n\n    async def get_all_users(self) -&gt; List[User]:\n        \"\"\"Get all users.\"\"\"\n        return await self.repo.get_all()\n\n    async def update_user(self, user_id: int, request: UpdateUserRequest) -&gt; Optional[User]:\n        \"\"\"Update user with validation.\"\"\"\n        # Check if user exists\n        existing = await self.repo.get_by_id(user_id)\n        if not existing:\n            return None\n\n        # Check username uniqueness if being updated\n        if request.username and request.username != existing.username:\n            duplicate = await self.repo.get_by_username(request.username)\n            if duplicate:\n                raise ValueError(f\"Username '{request.username}' already exists\")\n\n        return await self.repo.update(user_id, request)\n\n    async def delete_user(self, user_id: int) -&gt; bool:\n        \"\"\"Delete user.\"\"\"\n        return await self.repo.delete(user_id)\n\n    async def deactivate_user(self, user_id: int) -&gt; Optional[User]:\n        \"\"\"Deactivate user.\"\"\"\n        return await self.update_user(user_id, UpdateUserRequest(is_active=False))\n\n    async def activate_user(self, user_id: int) -&gt; Optional[User]:\n        \"\"\"Activate user.\"\"\"\n        return await self.update_user(user_id, UpdateUserRequest(is_active=True))\n</code></pre>"},{"location":"getting-started/first-app/#step-6-application-entry-point","title":"\ud83d\ude80 Step 6: Application Entry Point","text":"<pre><code># main.py\nimport asyncio\nfrom injectq import InjectQ, inject\n\nfrom .config import DatabaseConfig, AppConfig\nfrom .database import Database\nfrom .repository import UserRepository\nfrom .service import UserService\nfrom .models import CreateUserRequest, UpdateUserRequest\n\nasync def setup_container() -&gt; None:\n    \"\"\"Set up the dependency injection container using the public convenience container.\"\"\"\n    from injectq import InjectQ\n\n    # use the global convenience container directly\n    container = InjectQ.get_instance()\n\n    # Bind configurations\n    container[DatabaseConfig] = DatabaseConfig\n    container[AppConfig] = AppConfig\n\n    # Bind services (automatically resolved)\n    container[Database] = Database\n    container[UserRepository] = UserRepository\n    container[UserService] = UserService\n\n\n@inject\nasync def demo_user_operations(service: UserService, config: AppConfig):\n    \"\"\"Demonstrate user operations.\"\"\"\n    print(f\"\ud83d\ude80 {config.app_name} v{config.version}\")\n    print(\"=\" * 50)\n\n    # Create users\n    print(\"\\n\ud83d\udcdd Creating users...\")\n    user1 = await service.create_user(CreateUserRequest(\n        username=\"john_doe\",\n        email=\"john@example.com\"\n    ))\n    print(f\"Created user: {user1.username} (ID: {user1.id})\")\n\n    user2 = await service.create_user(CreateUserRequest(\n        username=\"jane_smith\",\n        email=\"jane@example.com\"\n    ))\n    print(f\"Created user: {user2.username} (ID: {user2.id})\")\n\n    # Get user\n    print(\"\\n\ud83d\udd0d Getting user...\")\n    retrieved = await service.get_user(user1.id)\n    if retrieved:\n        print(f\"Retrieved user: {retrieved.username}\")\n\n    # Update user\n    print(\"\\n\u270f\ufe0f  Updating user...\")\n    updated = await service.update_user(user1.id, UpdateUserRequest(\n        email=\"john.doe@example.com\"\n    ))\n    if updated:\n        print(f\"Updated user email: {updated.email}\")\n\n    # List all users\n    print(\"\\n\ud83d\udccb All users:\")\n    users = await service.get_all_users()\n    for user in users:\n        status = \"Active\" if user.is_active else \"Inactive\"\n        print(f\"  - {user.username} ({user.email}) - {status}\")\n\n    # Deactivate user\n    print(\"\\n\ud83d\udeab Deactivating user...\")\n    deactivated = await service.deactivate_user(user2.id)\n    if deactivated:\n        print(f\"Deactivated user: {deactivated.username}\")\n\n    # List users again\n    print(\"\\n\ud83d\udccb Users after deactivation:\")\n    users = await service.get_all_users()\n    for user in users:\n        status = \"Active\" if user.is_active else \"Inactive\"\n        print(f\"  - {user.username} ({user.email}) - {status}\")\n\nasync def main():\n    \"\"\"Main application entry point.\"\"\"\n    # Set up container\n    await setup_container()\n\n    # Run demo\n    await demo_user_operations()\n\n    print(\"\\n\u2705 Demo completed successfully!\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"getting-started/first-app/#step-7-running-the-application","title":"\ud83c\udfaf Step 7: Running the Application","text":"<p>Create the files above and run:</p> <pre><code>python main.py\n</code></pre> <p>You should see output like:</p> <pre><code>\ud83d\ude80 User Management API v1.0.0\n==================================================\n\n\ud83d\udcdd Creating users...\nDatabase initialized with config: postgresql://postgres:password@localhost:5432/userdb\nCreated user: john_doe (ID: 1)\nCreated user: jane_smith (ID: 2)\n\n\ud83d\udd0d Getting user...\nRetrieved user: john_doe\n\n\u270f\ufe0f  Updating user...\nUpdated user email: john.doe@example.com\n\n\ud83d\udccb All users:\n  - john_doe (john.doe@example.com) - Active\n  - jane_smith (jane@example.com) - Active\n\n\ud83d\udeab Deactivating user...\nDeactivated user: jane_smith\n\n\ud83d\udccb Users after deactivation:\n  - john_doe (john.doe@example.com) - Active\n  - jane_smith (jane@example.com) - Inactive\n\n\u2705 Demo completed successfully!\n</code></pre>"},{"location":"getting-started/first-app/#step-8-adding-error-handling","title":"\ud83d\udd27 Step 8: Adding Error Handling","text":"<p>Let's enhance our application with proper error handling:</p> <pre><code># Add to service.py\nclass UserServiceError(Exception):\n    \"\"\"Base exception for user service errors.\"\"\"\n    pass\n\nclass UserNotFoundError(UserServiceError):\n    \"\"\"Raised when a user is not found.\"\"\"\n    pass\n\nclass UserAlreadyExistsError(UserServiceError):\n    \"\"\"Raised when trying to create a user that already exists.\"\"\"\n    pass\n\n# Update UserService methods\nasync def get_user(self, user_id: int) -&gt; User:\n    \"\"\"Get user by ID.\"\"\"\n    user = await self.repo.get_by_id(user_id)\n    if not user:\n        raise UserNotFoundError(f\"User with ID {user_id} not found\")\n    return user\n\nasync def create_user(self, request: CreateUserRequest) -&gt; User:\n    \"\"\"Create a new user with validation.\"\"\"\n    # Check if username already exists\n    existing = await self.repo.get_by_username(request.username)\n    if existing:\n        raise UserAlreadyExistsError(f\"Username '{request.username}' already exists\")\n\n    return await self.repo.create(request)\n</code></pre>"},{"location":"getting-started/first-app/#step-9-adding-tests","title":"\ud83e\uddea Step 9: Adding Tests","text":"<pre><code># tests/test_user_service.py\nimport pytest\nfrom injectq.testing import test_container, override_dependency\n\nfrom ..service import UserService\nfrom ..models import CreateUserRequest\n\nclass MockRepository:\n    def __init__(self):\n        self.users = {}\n\n    async def create(self, request):\n        # Mock implementation\n        pass\n\n    async def get_by_id(self, user_id):\n        return self.users.get(user_id)\n\ndef test_create_user():\n    with test_container() as container:\n        # Override repository with mock\n        mock_repo = MockRepository()\n        container.bind_instance(\"UserRepository\", mock_repo)\n\n        service = container.get(UserService)\n\n        # Test user creation\n        request = CreateUserRequest(username=\"test\", email=\"test@example.com\")\n        # ... test implementation\n\ndef test_get_user_not_found():\n    with test_container() as container:\n        mock_repo = MockRepository()\n        container.bind_instance(\"UserRepository\", mock_repo)\n\n        service = container.get(UserService)\n\n        with pytest.raises(UserNotFoundError):\n            await service.get_user(999)\n</code></pre>"},{"location":"getting-started/first-app/#whats-next","title":"\ud83d\ude80 What's Next?","text":"<p>Congratulations! You've built a complete application with InjectQ. Here are some next steps:</p> <ol> <li>Add FastAPI Integration: Turn this into a REST API</li> <li>Add Database Integration: Use a real database</li> <li>Add Authentication: Secure your API</li> <li>Add Testing: Write comprehensive tests</li> <li>Explore Advanced Features: Add caching, logging, etc.</li> </ol>"},{"location":"getting-started/first-app/#key-takeaways","title":"\ud83d\udca1 Key Takeaways","text":"<ul> <li>Separation of Concerns: Each layer has a single responsibility</li> <li>Dependency Injection: Clean, testable, and maintainable code</li> <li>Type Safety: Full type hints throughout</li> <li>Async Support: Modern Python async/await patterns</li> <li>Error Handling: Proper exception handling and validation</li> <li>Testing: Easy to test with dependency overrides</li> </ul> <p>Your InjectQ journey has just begun! \ud83c\udf89</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide helps you install InjectQ and verify a minimal setup.</p>"},{"location":"getting-started/installation/#basic-installation","title":"Basic installation","text":"<pre><code>pip install injectq\n</code></pre>"},{"location":"getting-started/installation/#optional-integrations-install-only-what-you-need","title":"Optional integrations (install only what you need)","text":"<ul> <li>FastAPI integration: <code>pip install injectq[fastapi]</code></li> <li>Taskiq integration: <code>pip install injectq[taskiq]</code></li> <li>Developer extras (mypy, pytest, black, ...): <code>pip install injectq[dev]</code></li> </ul> <p>Example combined install:</p> <pre><code>pip install \"injectq[fastapi,taskiq]\"\n</code></pre>"},{"location":"getting-started/installation/#supported-python-versions","title":"Supported Python versions","text":"<p>InjectQ supports Python 3.10 and above. Using 3.11+ is recommended for best runtime performance.</p>"},{"location":"getting-started/installation/#quick-verification","title":"Quick verification","text":"<p>After installation, verify the library behaves as expected. Use the exported <code>injectq</code> global (recommended):</p> <pre><code>from injectq import injectq\n\nprint(f\"InjectQ available: {injectq is not None}\")\n\nclass A:\n    pass\n\n# Bind a simple instance\ninjectq[A] = A()\n\nassert injectq[A] is not None\nassert injectq.get(A) is injectq[A]\nassert injectq.try_get(A, None) is injectq[A]\n\nprint(\"InjectQ appears to be working\")\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development installation","text":"<p>To work on the repository locally:</p> <pre><code>git clone https://github.com/Iamsdt/injectq.git\ncd injectq\npip install -e .[dev]\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next steps","text":"<p>Now explore the Quick Start and the <code>docs/</code> pages for patterns like the dict-like interface, <code>@inject</code> usage, and integrations.</p>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Get up and running with InjectQ in minutes! This guide will walk you through the basic concepts and APIs.</p>"},{"location":"getting-started/quick-start/#hello-world-example","title":"\ud83c\udfaf Hello World Example","text":"<p>Let's start with a simple example:</p> <pre><code>from injectq import InjectQ, inject\n\n# 1. Get the container\ncontainer = InjectQ.get_instance()\n\n# 2. Bind a simple value\ncontainer[str] = \"Hello, InjectQ!\"\n\n# 3. Use dependency injection\n@inject\ndef greet(message: str) -&gt; str:\n    return f\"Message: {message}\"\n\n# 4. Call the function\nresult = greet()\nprint(result)  # Output: Message: Hello, InjectQ!\n</code></pre>"},{"location":"getting-started/quick-start/#building-your-first-application","title":"\ud83c\udfd7\ufe0f Building Your First Application","text":"<p>Let's create a more realistic example with classes and dependencies:</p> <pre><code>from injectq import InjectQ, inject, singleton\n\n# 1. Define your services\n@singleton\nclass Database:\n    def __init__(self, connection_string: str):\n        self.connection_string = connection_string\n        print(f\"Connected to: {connection_string}\")\n\n    def query(self, sql: str) -&gt; str:\n        return f\"Executed: {sql}\"\n\nclass UserService:\n    def __init__(self, db: Database):\n        self.db = db\n\n    def get_user_count(self) -&gt; int:\n        result = self.db.query(\"SELECT COUNT(*) FROM users\")\n        return 42  # Mock result\n\n# 2. Set up the container\ncontainer = InjectQ.get_instance()\ncontainer[str] = \"postgresql://localhost:5432/myapp\"\n\n# Bind services (classes are automatically resolved)\ncontainer[Database] = Database\ncontainer[UserService] = UserService\n\n# 3. Use dependency injection\n@inject\ndef show_user_stats(service: UserService) -&gt; None:\n    count = service.get_user_count()\n    print(f\"Total users: {count}\")\n\n# 4. Run the application\nif __name__ == \"__main__\":\n    show_user_stats()\n</code></pre>"},{"location":"getting-started/quick-start/#different-injection-patterns","title":"\ud83d\udd04 Different Injection Patterns","text":"<p>InjectQ supports multiple ways to inject dependencies:</p>"},{"location":"getting-started/quick-start/#method-1-inject-decorator-recommended","title":"Method 1: @inject Decorator (Recommended)","text":"<pre><code>@inject\ndef process_data(service: UserService, config: str) -&gt; None:\n    # All parameters automatically injected\n    pass\n\n# Call without arguments\nprocess_data()\n</code></pre>"},{"location":"getting-started/quick-start/#method-2-dict-like-interface","title":"Method 2: Dict-like Interface","text":"<pre><code>container = InjectQ.get_instance()\ncontainer[\"api_key\"] = \"your-secret-key\"\ncontainer[UserService] = UserService()\n\n# Access directly\napi_key = container[\"api_key\"]\nservice = container[UserService]\n</code></pre>"},{"location":"getting-started/quick-start/#method-3-manual-resolution","title":"Method 3: Manual Resolution","text":"<pre><code># Get services when needed\ncontainer = InjectQ.get_instance()\nservice = container[UserService]\nconfig = container[str]\n</code></pre>"},{"location":"getting-started/quick-start/#understanding-scopes","title":"\ud83c\udfad Understanding Scopes","text":"<p>Control how long your services live:</p> <pre><code>from injectq import InjectQ, singleton, transient\n\ncontainer = InjectQ.get_instance()\n\n@singleton  # One instance for entire app\nclass DatabaseConnection:\n    def __init__(self):\n        self.id = id(self)\n        print(f\"Database created: {self.id}\")\n\n@transient  # New instance every time\nclass RequestHandler:\n    def __init__(self, db: DatabaseConnection):\n        self.db = db\n        self.id = id(self)\n        print(f\"Handler created: {self.id}\")\n\ncontainer[DatabaseConnection] = DatabaseConnection\ncontainer[RequestHandler] = RequestHandler\n\n# Test singleton behavior\ndb1 = container[DatabaseConnection]\ndb2 = container[DatabaseConnection]\nprint(f\"Same database? {db1 is db2}\")  # True\n\n# Test transient behavior\nhandler1 = container[RequestHandler]\nhandler2 = container[RequestHandler]\nprint(f\"Different handlers? {handler1 is not handler2}\")  # True\nprint(f\"Same database in handlers? {handler1.db is handler2.db}\")  # True\n</code></pre>"},{"location":"getting-started/quick-start/#using-modules","title":"\ud83d\udce6 Using Modules","text":"<p>Organize your dependencies with modules:</p> <pre><code>from injectq import InjectQ, Module, provider\n\ncontainer = InjectQ.get_instance()\n\nclass ConfigModule(Module):\n    def configure(self, binder):\n        binder.bind_instance(\"database_url\", \"postgresql://localhost/db\")\n        binder.bind_instance(\"api_key\", \"secret-key\")\n\nclass ServiceModule(Module):\n    @provider\n    def provide_database(self, url: str) -&gt; Database:\n        return Database(url)\n\n    @provider\n    def provide_user_service(self, db: Database) -&gt; UserService:\n        return UserService(db)\n\n# Create container with modules\ncontainer = InjectQ([ConfigModule(), ServiceModule()])\n\n# Services are automatically available\n@inject\ndef main(service: UserService):\n    print(\"Application started!\")\n\nmain()\n</code></pre>"},{"location":"getting-started/quick-start/#testing-with-injectq","title":"\ud83e\uddea Testing with InjectQ","text":"<p>InjectQ makes testing easy:</p> <pre><code>from injectq import InjectQ\nfrom injectq.testing import override_dependency\n\ncontainer = InjectQ.get_instance()\n\ndef test_user_service():\n    # Override dependencies for testing\n    mock_db = MockDatabase()\n\n    with override_dependency(Database, mock_db):\n        service = container.get(UserService)\n        # service now uses mock_db\n        result = service.get_user_count()\n        assert result == 0  # Mocked result\n\n# Or use test containers\nfrom injectq.testing import test_container\n\ndef test_with_isolated_container():\n    with test_container() as test_cont:\n        test_cont.bind(Database, MockDatabase)\n        service = test_cont.get(UserService)\n        # Test in isolation\n</code></pre>"},{"location":"getting-started/quick-start/#whats-next","title":"\ud83d\ude80 What's Next?","text":"<p>Now that you understand the basics:</p> <ol> <li>Explore Core Concepts: Learn about dependency injection patterns</li> <li>Master Scopes: Understand service lifetimes</li> <li>Use Modules: Organize complex applications</li> <li>Framework Integration: Integrate with FastAPI, Taskiq, etc.</li> <li>Check Examples: See more practical examples</li> </ol>"},{"location":"getting-started/quick-start/#pro-tips","title":"\ud83d\udca1 Pro Tips","text":"<ul> <li>Use <code>@inject</code> for automatic dependency injection</li> <li>Use <code>@singleton</code> for services that should be shared</li> <li>Use <code>@transient</code> for services that need fresh instances</li> <li>Use modules to organize related dependencies</li> <li>Use <code>override_dependency</code> for testing</li> </ul> <p>Happy coding with InjectQ! \ud83c\udf89</p>"},{"location":"injection-patterns/binding-patterns/","title":"Binding Patterns","text":"<p>Binding patterns in InjectQ define how services are registered and resolved. Understanding these patterns is key to building flexible, maintainable applications.</p>"},{"location":"injection-patterns/binding-patterns/#basic-binding","title":"\ud83c\udfaf Basic Binding","text":""},{"location":"injection-patterns/binding-patterns/#instance-binding","title":"Instance Binding","text":"<p>Bind a specific instance to be reused:</p> <pre><code>from injectq import InjectQ\n\ncontainer = InjectQ()\n\n# Bind a specific instance\nconfig = AppConfig(host=\"prod\", debug=False)\ncontainer.bind(AppConfig, config)\n\n# Same instance returned every time\nconfig1 = container.get(AppConfig)\nconfig2 = container.get(AppConfig)\nassert config1 is config2  # True\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#class-binding","title":"Class Binding","text":"<p>Bind a class for automatic instantiation:</p> <pre><code>class Database:\n    def __init__(self, config: AppConfig):\n        self.config = config\n\n# Bind class - InjectQ creates instances as needed\ncontainer.bind(Database, Database)\n\n# Each call creates a new instance (unless scoped)\ndb1 = container.get(Database)\ndb2 = container.get(Database)\nassert db1 is not db2  # True (transient by default)\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#factory-binding","title":"Factory Binding","text":"<p>Bind a factory function for custom creation logic:</p> <pre><code>def create_database(config: AppConfig) -&gt; Database:\n    if config.environment == \"test\":\n        return SQLiteDatabase(config)\n    else:\n        return PostgreSQLDatabase(config)\n\ncontainer.bind_factory(Database, create_database)\n\n# Factory called each time\ndb = container.get(Database)\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#advanced-binding-patterns","title":"\ud83d\udd27 Advanced Binding Patterns","text":""},{"location":"injection-patterns/binding-patterns/#interface-to-implementation","title":"Interface to Implementation","text":"<p>Bind abstractions to concrete implementations:</p> <pre><code>from typing import Protocol\n\nclass IDatabase(Protocol):\n    def connect(self) -&gt; None: ...\n    def disconnect(self) -&gt; None: ...\n\nclass PostgreSQLDatabase:\n    def connect(self) -&gt; None:\n        print(\"Connected to PostgreSQL\")\n\n    def disconnect(self) -&gt; None:\n        print(\"Disconnected from PostgreSQL\")\n\n# Bind interface to implementation\ncontainer.bind(IDatabase, PostgreSQLDatabase)\n\n# Usage\n@inject\ndef use_database(db: IDatabase) -&gt; None:\n    db.connect()\n    # ... use database\n    db.disconnect()\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#named-bindings","title":"Named Bindings","text":"<p>Multiple implementations of the same type:</p> <pre><code>class RedisCache:\n    def __init__(self, host: str):\n        self.host = host\n\nclass MemoryCache:\n    def __init__(self):\n        self.data = {}\n\n# Named bindings\ncontainer.bind(Cache, RedisCache, name=\"redis\")\ncontainer.bind(Cache, MemoryCache, name=\"memory\")\n\n# Resolve by name\nredis_cache = container.get(Cache, name=\"redis\")\nmemory_cache = container.get(Cache, name=\"memory\")\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#conditional-bindings","title":"Conditional Bindings","text":"<p>Bind different implementations based on conditions:</p> <pre><code>if environment == \"production\":\n    container.bind(IDatabase, PostgreSQLDatabase)\n    container.bind(ICache, RedisCache)\nelif environment == \"testing\":\n    container.bind(IDatabase, SQLiteDatabase)\n    container.bind(ICache, MemoryCache)\nelse:\n    container.bind(IDatabase, InMemoryDatabase)\n    container.bind(ICache, MemoryCache)\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#generic-bindings","title":"Generic Bindings","text":"<p>Bind generic types:</p> <pre><code>from typing import TypeVar, Generic\n\nT = TypeVar('T')\n\nclass Repository(Generic[T]):\n    def __init__(self, entity_type: type):\n        self.entity_type = entity_type\n\n# Bind specific generic instances\ncontainer.bind(Repository[User], Repository[User])\ncontainer.bind(Repository[Order], Repository[Order])\n\n# Usage\n@inject\ndef get_user_repo(repo: Repository[User]) -&gt; Repository[User]:\n    return repo\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#scope-based-bindings","title":"\ud83c\udfad Scope-Based Bindings","text":""},{"location":"injection-patterns/binding-patterns/#singleton-scope","title":"Singleton Scope","text":"<p>One instance for the entire application:</p> <pre><code>from injectq import Scope\n\n# Explicit singleton\ncontainer.bind(Database, Database, scope=Scope.SINGLETON)\n\n# Or use decorator\n@singleton\nclass Database:\n    pass\n\n# Same instance everywhere\ndb1 = container.get(Database)\ndb2 = container.get(Database)\nassert db1 is db2\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#transient-scope","title":"Transient Scope","text":"<p>New instance every time:</p> <pre><code>from injectq import Scope, transient\n\n# Explicit transient\ncontainer.bind(RequestHandler, RequestHandler, scope=Scope.TRANSIENT)\n\n# Or use decorator\n@transient\nclass RequestHandler:\n    pass\n\n# Different instances\nhandler1 = container.get(RequestHandler)\nhandler2 = container.get(RequestHandler)\nassert handler1 is not handler2\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#scoped-bindings","title":"Scoped Bindings","text":"<p>Instance per scope (request, session, etc.):</p> <pre><code>from injectq import Scope, scoped\n\n# Request-scoped\ncontainer.bind(UserSession, UserSession, scope=Scope.REQUEST)\n\n# Or use decorator\n@scoped(\"request\")\nclass UserSession:\n    pass\n\n# Same instance within request scope\nasync with container.scope(\"request\"):\n    session1 = container.get(UserSession)\n    session2 = container.get(UserSession)\n    assert session1 is session2\n\n# Different instance in new scope\nasync with container.scope(\"request\"):\n    session3 = container.get(UserSession)\n    assert session1 is not session3\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#module-based-bindings","title":"\ud83d\udce6 Module-Based Bindings","text":""},{"location":"injection-patterns/binding-patterns/#simple-module","title":"Simple Module","text":"<p>Group related bindings:</p> <pre><code>from injectq import Module\n\nclass DatabaseModule(Module):\n    def configure(self, binder):\n        binder.bind(IDatabase, PostgreSQLDatabase)\n        binder.bind(DatabaseConfig, DatabaseConfig)\n\nclass ServiceModule(Module):\n    def configure(self, binder):\n        binder.bind(IUserService, UserService)\n        binder.bind(IOrderService, OrderService)\n\n# Use modules\ncontainer = InjectQ([DatabaseModule(), ServiceModule()])\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#configuration-module","title":"Configuration Module","text":"<p>Bind configuration values:</p> <pre><code>from injectq import ConfigurationModule\n\nconfig_module = ConfigurationModule({\n    \"database_url\": \"postgresql://localhost/db\",\n    \"redis_url\": \"redis://localhost:6379\",\n    \"app_name\": \"MyApp\"\n})\n\ncontainer = InjectQ([config_module])\n\n# Access configuration\ndb_url = container.get(str, name=\"database_url\")\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#provider-module","title":"Provider Module","text":"<p>Use providers for complex initialization:</p> <pre><code>from injectq import ProviderModule, provider\n\nclass CacheModule(ProviderModule):\n    @provider\n    def provide_cache(self, redis_url: str) -&gt; ICache:\n        return RedisCache(redis_url)\n\n    @provider\n    @singleton\n    def provide_expensive_service(self, cache: ICache) -&gt; ExpensiveService:\n        return ExpensiveService(cache)\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#binding-resolution-strategies","title":"\ud83d\udd04 Binding Resolution Strategies","text":""},{"location":"injection-patterns/binding-patterns/#type-based-resolution","title":"Type-Based Resolution","text":"<p>Default resolution by type:</p> <pre><code>class IUserRepository(Protocol):\n    pass\n\nclass UserRepository:\n    pass\n\ncontainer.bind(IUserRepository, UserRepository)\n\n# Resolves UserRepository when IUserRepository is requested\nrepo = container.get(IUserRepository)  # Returns UserRepository instance\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#name-based-resolution","title":"Name-Based Resolution","text":"<p>Resolve by name when multiple implementations exist:</p> <pre><code>container.bind(Cache, RedisCache, name=\"redis\")\ncontainer.bind(Cache, MemoryCache, name=\"memory\")\n\n# Resolve by name\nredis_cache = container.get(Cache, name=\"redis\")\nmemory_cache = container.get(Cache, name=\"memory\")\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#context-based-resolution","title":"Context-Based Resolution","text":"<p>Different implementations based on context:</p> <pre><code>class DevelopmentDatabase:\n    pass\n\nclass ProductionDatabase:\n    pass\n\n# Context-based binding\nif os.getenv(\"ENV\") == \"production\":\n    container.bind(IDatabase, ProductionDatabase)\nelse:\n    container.bind(IDatabase, DevelopmentDatabase)\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#testing-binding-patterns","title":"\ud83e\uddea Testing Binding Patterns","text":""},{"location":"injection-patterns/binding-patterns/#override-bindings","title":"Override Bindings","text":"<pre><code>from injectq.testing import override_dependency\n\ndef test_user_service():\n    mock_repo = MockUserRepository()\n\n    with override_dependency(IUserRepository, mock_repo):\n        service = container.get(UserService)\n        result = service.get_user(1)\n        assert result.name == \"Mock User\"\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#test-containers","title":"Test Containers","text":"<pre><code>from injectq.testing import test_container\n\ndef test_with_isolation():\n    with test_container() as container:\n        # Set up test bindings\n        container.bind(IUserRepository, MockUserRepository)\n        container.bind(IEmailService, MockEmailService)\n\n        # Test the service\n        service = container.get(UserService)\n        user = service.create_user(\"test@example.com\")\n        assert user.email == \"test@example.com\"\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#partial-overrides","title":"Partial Overrides","text":"<pre><code>def test_partial_override():\n    # Override only some dependencies\n    with override_dependency(ICache, MockCache):\n        service = container.get(UserService)\n        # service uses MockCache but real database\n        pass\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#advanced-patterns","title":"\ud83d\ude80 Advanced Patterns","text":""},{"location":"injection-patterns/binding-patterns/#decorator-based-bindings","title":"Decorator-Based Bindings","text":"<pre><code>from injectq import singleton, transient, scoped\n\n@singleton\nclass Database:\n    pass\n\n@transient\nclass RequestHandler:\n    pass\n\n@scoped(\"request\")\nclass UserSession:\n    pass\n\n# Automatic registration when container starts\ncontainer = InjectQ()\n# Decorated classes are automatically registered\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#lazy-bindings","title":"Lazy Bindings","text":"<pre><code># Bind factory for lazy initialization\ndef create_expensive_service() -&gt; ExpensiveService:\n    print(\"Creating expensive service...\")\n    return ExpensiveService()\n\ncontainer.bind_factory(ExpensiveService, create_expensive_service)\n\n# Service created only when first requested\nprint(\"Container ready\")\nservice = container.get(ExpensiveService)  # \"Creating expensive service...\"\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#conditional-factories","title":"Conditional Factories","text":"<pre><code>def create_cache(config: AppConfig) -&gt; ICache:\n    if config.use_redis:\n        return RedisCache(config.redis_url)\n    else:\n        return MemoryCache()\n\ncontainer.bind_factory(ICache, create_cache)\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#performance-considerations","title":"\u26a1 Performance Considerations","text":""},{"location":"injection-patterns/binding-patterns/#binding-resolution","title":"Binding Resolution","text":"<pre><code># Fast - direct type lookup\ncontainer.bind(IService, ServiceImpl)\nservice = container.get(IService)  # O(1) lookup\n\n# Slower - factory invocation\ncontainer.bind_factory(IService, lambda: ServiceImpl())\nservice = container.get(IService)  # Factory execution overhead\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#caching-strategies","title":"Caching Strategies","text":"<pre><code># Singleton - cached after first creation\n@singleton\nclass Database:\n    def __init__(self):\n        time.sleep(1)  # Expensive\n\ndb1 = container.get(Database)  # 1 second\ndb2 = container.get(Database)  # Instant (cached)\n\n# Transient - no caching\n@transient\nclass Handler:\n    pass\n\nh1 = container.get(Handler)  # New instance\nh2 = container.get(Handler)  # New instance\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#best-practices","title":"\ud83c\udfc6 Best Practices","text":""},{"location":"injection-patterns/binding-patterns/#1-use-interfaces","title":"1. Use Interfaces","text":"<pre><code># \u2705 Good - depend on abstractions\ncontainer.bind(IDatabase, PostgreSQLDatabase)\ncontainer.bind(IUserService, UserService)\n\n# \u274c Avoid - depend on concrete classes\ncontainer.bind(Database, PostgreSQLDatabase)\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#2-group-related-bindings","title":"2. Group Related Bindings","text":"<pre><code># \u2705 Good - use modules\nclass DatabaseModule(Module):\n    def configure(self, binder):\n        binder.bind(IDatabase, PostgreSQLDatabase)\n        binder.bind(DatabaseConfig, DatabaseConfig)\n\n# \u274c Avoid - scattered bindings\ncontainer.bind(IDatabase, PostgreSQLDatabase)\ncontainer.bind(DatabaseConfig, DatabaseConfig)\ncontainer.bind(DatabaseConnection, DatabaseConnection)\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#3-use-appropriate-scopes","title":"3. Use Appropriate Scopes","text":"<pre><code># \u2705 Good - correct scopes\n@singleton\nclass Database:  # Shared resource\n    pass\n\n@scoped(\"request\")\nclass UserSession:  # Per request\n    pass\n\n@transient\nclass EmailSender:  # Stateless\n    pass\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#4-document-complex-bindings","title":"4. Document Complex Bindings","text":"<pre><code># \u2705 Good - documented bindings\ncontainer.bind_factory(\n    ICache,\n    create_cache,\n    # Redis cache for production, memory cache for testing\n)\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#5-validate-configuration","title":"5. Validate Configuration","text":"<pre><code># \u2705 Good - validate bindings\ncontainer = InjectQ([DatabaseModule(), ServiceModule()])\ntry:\n    container.validate()\n    print(\"\u2705 All bindings valid\")\nexcept Exception as e:\n    print(f\"\u274c Binding error: {e}\")\n    exit(1)\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#common-binding-mistakes","title":"\ud83d\udea8 Common Binding Mistakes","text":""},{"location":"injection-patterns/binding-patterns/#1-binding-concrete-classes","title":"1. Binding Concrete Classes","text":"<pre><code># \u274c Wrong - binding concrete class\ncontainer.bind(UserService, UserService)\n\n# \u2705 Correct - bind interface to implementation\ncontainer.bind(IUserService, UserService)\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#2-wrong-scope","title":"2. Wrong Scope","text":"<pre><code># \u274c Wrong - singleton for per-request data\n@singleton\nclass RequestData:\n    def __init__(self):\n        self.user_id = None\n\n# \u2705 Correct - request-scoped\n@scoped(\"request\")\nclass RequestData:\n    def __init__(self):\n        self.user_id = None\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#3-circular-dependencies","title":"3. Circular Dependencies","text":"<pre><code># \u274c Circular dependency\nclass A:\n    def __init__(self, b: IB):\n        self.b = b\n\nclass B:\n    def __init__(self, a: IA):  # Circular!\n        self.a = a\n\n# \u2705 Break circular dependency\nclass A:\n    def __init__(self, b_factory: Callable[[], IB]):\n        self.b_factory = b_factory\n\n    def get_b(self) -&gt; IB:\n        return self.b_factory()\n</code></pre>"},{"location":"injection-patterns/binding-patterns/#summary","title":"\ud83c\udfaf Summary","text":"<p>Binding patterns in InjectQ provide:</p> <ul> <li>Flexible registration - Bind instances, classes, or factories</li> <li>Type-based resolution - Automatic dependency resolution</li> <li>Scope management - Control service lifetimes</li> <li>Module organization - Group related bindings</li> <li>Testing support - Easy dependency overrides</li> </ul> <p>Key concepts: - Bind abstractions (interfaces/protocols) to implementations - Use appropriate scopes (singleton, transient, scoped) - Group bindings with modules - Validate configuration early - Use factories for complex initialization</p> <p>Binding hierarchy: 1. Instance bindings - Specific objects 2. Class bindings - Automatic instantiation 3. Factory bindings - Custom creation logic 4. Module bindings - Organized groups 5. Decorator bindings - Automatic registration</p> <p>Ready to explore scopes in detail?</p>"},{"location":"injection-patterns/dict-interface/","title":"Dict-like Interface","text":"<p>The dict-like interface is the simplest way to start with InjectQ. Use <code>InjectQ.get_instance()</code> to get the container \u2014 it prefers the active container context if present and falls back to a global singleton.</p>"},{"location":"injection-patterns/dict-interface/#basic-usage","title":"Basic usage","text":"<pre><code>from injectq import InjectQ\n\ncontainer = InjectQ.get_instance()\n\n# Bind simple values\ncontainer[str] = \"Hello, InjectQ!\"\ncontainer[int] = 42\ncontainer[\"database_url\"] = \"postgresql://localhost/db\"\n\n# Retrieve services\nmessage = container[str]      # \"Hello, InjectQ!\"\nnumber = container[int]       # 42\ndb_url = container[\"database_url\"]  # \"postgresql://localhost/db\"\n</code></pre>"},{"location":"injection-patterns/dict-interface/#class-registration","title":"\ud83c\udfd7\ufe0f Class Registration","text":"<p>Register classes for automatic instantiation:</p> <pre><code>from injectq import InjectQ\n\ncontainer = InjectQ.get_instance()\n\nclass DatabaseConfig:\n    def __init__(self, host: str = \"localhost\", port: int = 5432):\n        self.host = host\n        self.port = port\n        self.url = f\"postgresql://{host}:{port}/mydb\"\n\nclass Database:\n    def __init__(self, config: DatabaseConfig):\n        self.config = config\n\nclass UserRepository:\n    def __init__(self, db: Database):\n        self.db = db\n\n# Register bindings\ncontainer[DatabaseConfig] = DatabaseConfig()\ncontainer[Database] = Database\ncontainer[UserRepository] = UserRepository\n\n# Automatic dependency resolution\nrepo = container[UserRepository]  # Creates DatabaseConfig, Database, then UserRepository\n</code></pre>"},{"location":"injection-patterns/dict-interface/#key-operations","title":"Key operations","text":""},{"location":"injection-patterns/dict-interface/#setting-values","title":"Setting values","text":"<pre><code>from injectq import InjectQ\n\ncontainer = InjectQ.get_instance()\n\n# Simple values\ncontainer[str] = \"configuration\"\ncontainer[int] = 12345\ncontainer[bool] = True\n\n# Complex objects\ncontainer[\"config\"] = AppConfig(host=\"prod\", debug=False)\n\n# Classes (for automatic instantiation)\ncontainer[Database] = Database\ncontainer[UserService] = UserService\n\n# Instances (pre-created objects)\ncontainer[\"cache\"] = RedisCache(host=\"localhost\")\n</code></pre>"},{"location":"injection-patterns/dict-interface/#getting-values","title":"Getting values","text":"<pre><code># Simple retrieval\nconfig = container[str]\nnumber = container[int]\n\n# With type hints (better IDE support)\nconfig: str = container[str]\nservice: UserService = container[UserService]\n</code></pre>"},{"location":"injection-patterns/dict-interface/#checking-existence","title":"Checking existence","text":"<pre><code># Check if a service is registered\nif str in container:\n    config = container[str]\n\nif \"database\" in container:\n    db = container[\"database\"]\n</code></pre>"},{"location":"injection-patterns/dict-interface/#removing-services","title":"Removing services","text":"<pre><code># Remove a service\ndel container[str]\ndel container[Database]\n\n# Check removal\nassert str not in container\nassert Database not in container\n</code></pre>"},{"location":"injection-patterns/dict-interface/#advanced-patterns","title":"\ud83c\udfa8 Advanced Patterns","text":""},{"location":"injection-patterns/dict-interface/#factory-functions","title":"Factory functions","text":"<p>Use <code>bind_factory</code> or the <code>factories</code> proxy for factory bindings (examples below show simple lambdas). For async factories, use <code>get_async</code>.</p> <pre><code>from injectq import InjectQ\n\ncontainer = InjectQ.get_instance()\n\nimport uuid\nfrom datetime import datetime\n\n# Simple factory-like binding (synchronous)\ncontainer[\"request_id\"] = lambda: str(uuid.uuid4())\n\n# For more advanced factories use bind_factory\ncontainer.bind_factory(\"timestamp\", lambda: datetime.now().isoformat())\n\n# Accessing factories returns created values\nid1 = container[\"request_id\"]\nid2 = container[\"request_id\"]\nprint(f\"IDs are different: {id1 != id2}\")\n</code></pre>"},{"location":"injection-patterns/dict-interface/#conditional-registration","title":"Conditional Registration","text":"<p>Register services based on environment:</p> <pre><code>from injectq import InjectQ\n\ncontainer = InjectQ.get_instance()\n\nif environment == \"production\":\n    container[Database] = PostgreSQLDatabase\n    container[\"cache\"] = RedisCache(host=\"prod-redis\")\nelif environment == \"testing\":\n    container[Database] = SQLiteDatabase\n    container[\"cache\"] = MemoryCache()\nelse:\n    container[Database] = InMemoryDatabase\n    container[\"cache\"] = MemoryCache()\n</code></pre>"},{"location":"injection-patterns/dict-interface/#named-services","title":"Named Services","text":"<p>Use strings as keys for multiple implementations:</p> <pre><code>from injectq import InjectQ\n\ncontainer = InjectQ.get_instance()\n\n# Multiple cache implementations\ncontainer[\"redis_cache\"] = RedisCache(host=\"localhost\")\ncontainer[\"memory_cache\"] = MemoryCache()\ncontainer[\"file_cache\"] = FileCache(path=\"/tmp/cache\")\n\n# Usage\ncache = container[\"redis_cache\"]\nbackup_cache = container[\"memory_cache\"]\n</code></pre>"},{"location":"injection-patterns/dict-interface/#integration-with-decorators","title":"Integration with decorators","text":"<p>The dict-style bindings work with the <code>@inject</code> decorator and <code>Inject[T]</code> markers.</p> <pre><code>from injectq import inject, singleton, InjectQ\n\ncontainer = InjectQ.get_instance()\n\n# Register services\ncontainer[Database] = Database\ncontainer[\"config\"] = AppConfig()\n\n@inject\ndef process_data(db: Database, config: dict) -&gt; None:\n    # db and config automatically injected\n    print(f\"Processing with config: {config}\")\n\nprocess_data()\n</code></pre>"},{"location":"injection-patterns/dict-interface/#testing-with-dict-interface","title":"Testing with dict interface","text":"<p>Use the testing utilities to create disposable containers for unit tests.</p> <pre><code>from injectq import InjectQ\nfrom injectq.testing import test_container\n\ndef test_user_service():\n    with test_container() as container:\n        container[Database] = MockDatabase()\n        container[\"config\"] = {\"test\": True}\n\n        service = container[UserService]\n        result = service.get_user(1)\n        assert result is not None\n</code></pre>"},{"location":"injection-patterns/dict-interface/#real-world-example","title":"Real-world example","text":"<pre><code>from injectq import InjectQ\nfrom typing import List, Optional\nfrom dataclasses import dataclass\n\ncontainer = InjectQ.get_instance()\n\n@dataclass\nclass User:\n    id: int\n    name: str\n    email: str\n\nclass UserRepository:\n    def __init__(self, db_url: str):\n        self.db_url = db_url\n        self.users = {}\n\n    def save(self, user: User) -&gt; User:\n        self.users[user.id] = user\n        return user\n\n    def find_by_id(self, user_id: int) -&gt; Optional[User]:\n        return self.users.get(user_id)\n\n    def find_all(self) -&gt; List[User]:\n        return list(self.users.values())\n\nclass UserService:\n    def __init__(self, repo: UserRepository, cache_timeout: int):\n        self.repo = repo\n        self.cache_timeout = cache_timeout\n\n    def create_user(self, name: str, email: str) -&gt; User:\n        user_id = len(self.repo.users) + 1\n        user = User(id=user_id, name=name, email=email)\n        return self.repo.save(user)\n\n    def get_user(self, user_id: int) -&gt; Optional[User]:\n        return self.repo.find_by_id(user_id)\n\n# Application setup\ncontainer[str] = \"postgresql://localhost:5432/myapp\"  # Database URL\ncontainer[int] = 300  # Cache timeout in seconds\n\ncontainer[UserRepository] = UserRepository\ncontainer[UserService] = UserService\n\nservice = container[UserService]\n\nuser1 = service.create_user(\"John Doe\", \"john@example.com\")\nuser2 = service.create_user(\"Jane Smith\", \"jane@example.com\")\n\nfound_user = service.get_user(1)\nprint(f\"Found user: {found_user}\")\n\nall_users = container[UserRepository].find_all()\nprint(f\"All users: {all_users}\")\n</code></pre>"},{"location":"injection-patterns/dict-interface/#when-to-use-dict-interface","title":"\u2696\ufe0f When to Use Dict Interface","text":""},{"location":"injection-patterns/dict-interface/#good-for","title":"\u2705 Good For","text":"<ul> <li>Simple applications - Quick setup without complex configuration</li> <li>Configuration values - Storing strings, numbers, settings</li> <li>Prototyping - Fast iteration and testing</li> <li>Small projects - When you don't need advanced features</li> <li>Learning DI - Easiest way to understand the concepts</li> </ul>"},{"location":"injection-patterns/dict-interface/#not-ideal-for","title":"\u274c Not Ideal For","text":"<ul> <li>Large applications - Can become messy with many services</li> <li>Complex dependencies - Hard to manage intricate dependency graphs</li> <li>Type safety - Less type-safe than other approaches</li> <li>Advanced scoping - Limited lifetime management</li> <li>Team development - Less explicit about dependencies</li> </ul>"},{"location":"injection-patterns/dict-interface/#migration-path","title":"\ud83d\udd04 Migration Path","text":"<p>You can start with the dict interface and migrate to more advanced patterns:</p> <pre><code># Phase 1: Simple dict interface\ncontainer = InjectQ()\ncontainer[Database] = Database\ncontainer[UserService] = UserService\n\n# Phase 2: Add modules for organization\nclass DatabaseModule(Module):\n    def configure(self, binder):\n        binder.bind(Database, Database)\n\ncontainer = InjectQ([DatabaseModule()])\n\n# Phase 3: Add type safety with protocols\nclass IDatabase(Protocol):\n    def connect(self) -&gt; None: ...\n\ncontainer.bind(IDatabase, PostgreSQLDatabase)\n</code></pre>"},{"location":"injection-patterns/dict-interface/#best-practices","title":"\ud83c\udfc6 Best Practices","text":""},{"location":"injection-patterns/dict-interface/#1-use-descriptive-keys","title":"1. Use Descriptive Keys","text":"<pre><code># \u2705 Good - descriptive keys\ncontainer[\"database_url\"] = \"postgresql://...\"\ncontainer[\"redis_host\"] = \"localhost\"\ncontainer[\"api_timeout\"] = 30\n\n# \u274c Avoid - unclear keys\ncontainer[\"url\"] = \"postgresql://...\"\ncontainer[\"host\"] = \"localhost\"\ncontainer[\"num\"] = 30\n</code></pre>"},{"location":"injection-patterns/dict-interface/#2-group-related-configuration","title":"2. Group Related Configuration","text":"<pre><code># \u2705 Good - grouped configuration\ncontainer[\"database\"] = {\n    \"host\": \"localhost\",\n    \"port\": 5432,\n    \"name\": \"myapp\"\n}\ncontainer[\"cache\"] = {\n    \"host\": \"redis\",\n    \"ttl\": 3600\n}\n\n# \u274c Avoid - scattered configuration\ncontainer[\"db_host\"] = \"localhost\"\ncontainer[\"db_port\"] = 5432\ncontainer[\"cache_host\"] = \"redis\"\n</code></pre>"},{"location":"injection-patterns/dict-interface/#3-use-factories-for-dynamic-values","title":"3. Use Factories for Dynamic Values","text":"<pre><code># \u2705 Good - factories for dynamic values\ncontainer[\"request_id\"] = lambda: str(uuid.uuid4())\ncontainer[\"timestamp\"] = lambda: datetime.now()\n\n# \u274c Avoid - static values that should be dynamic\ncontainer[\"request_id\"] = \"static-id\"  # Same for all requests\n</code></pre>"},{"location":"injection-patterns/dict-interface/#4-document-your-services","title":"4. Document Your Services","text":"<pre><code># \u2705 Good - documented services\ncontainer[\"database\"] = PostgreSQLDatabase()  # Main application database\ncontainer[\"cache\"] = RedisCache()            # Redis cache for performance\ncontainer[\"logger\"] = StructuredLogger()     # JSON structured logging\n</code></pre>"},{"location":"injection-patterns/dict-interface/#summary","title":"\ud83c\udfaf Summary","text":"<p>The dict-like interface is:</p> <ul> <li>Simple - Easy to understand and use</li> <li>Flexible - Store any type of value or service</li> <li>Fast - Quick setup for small projects</li> <li>Intuitive - Familiar dictionary-like API</li> </ul> <p>Key features: - Store simple values, objects, classes, or factories - Automatic dependency resolution for registered classes - Easy testing with dependency overrides - Seamless integration with other InjectQ features</p> <p>When to use: - Learning dependency injection - Small to medium applications - Prototyping and experimentation - Simple configuration management</p> <p>Ready to explore the @inject decorator?</p>"},{"location":"injection-patterns/inject-decorator/","title":"@inject Decorator","text":"<p>The <code>@inject</code> decorator is InjectQ's most powerful and recommended way to inject dependencies. It automatically resolves and injects dependencies based on type hints, making your code clean and declarative.</p>"},{"location":"injection-patterns/inject-decorator/#basic-usage","title":"\ud83c\udfaf Basic Usage","text":"<p>The <code>@inject</code> decorator eliminates manual dependency management:</p> <pre><code>from injectq import InjectQ, inject\n\ncontainer = InjectQ.get_instance()\n\n# Set up container\ncontainer[Database] = Database\ncontainer[UserService] = UserService\n\n# Use @inject decorator\n@inject\ndef process_user(service: UserService, db: Database) -&gt; None:\n    # Dependencies automatically injected\n    user = service.get_user(1)\n    db.save(user)\n\n# Call without parameters - dependencies injected automatically\nprocess_user()\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#how-it-works","title":"\ud83c\udfd7\ufe0f How It Works","text":""},{"location":"injection-patterns/inject-decorator/#automatic-resolution","title":"Automatic Resolution","text":"<p>The <code>@inject</code> decorator analyzes function signatures and resolves dependencies:</p> <pre><code>@inject\ndef create_report(\n    user_service: UserService,\n    analytics: AnalyticsService,\n    cache: Cache,\n    config: AppConfig\n) -&gt; Report:\n    # InjectQ automatically:\n    # 1. Gets UserService from container\n    # 2. Gets AnalyticsService from container\n    # 3. Gets Cache from container\n    # 4. Gets AppConfig from container\n    # 5. Calls the function with all dependencies\n    pass\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#type-based-resolution","title":"Type-Based Resolution","text":"<p>Dependencies are resolved based on type hints:</p> <pre><code>from injectq import InjectQ\n\ncontainer = InjectQ.get_instance()\n\nclass IUserRepository(Protocol):\n    def get_by_id(self, id: int) -&gt; Optional[User]: ...\n\nclass UserRepository:\n    def get_by_id(self, id: int) -&gt; Optional[User]:\n        # Implementation\n        pass\n\n# Register implementation\ncontainer.bind(IUserRepository, UserRepository)\n\n@inject\ndef get_user(repo: IUserRepository) -&gt; Optional[User]:\n    # InjectQ finds UserRepository for IUserRepository\n    return repo.get_by_id(1)\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#advanced-patterns","title":"\ud83c\udfa8 Advanced Patterns","text":""},{"location":"injection-patterns/inject-decorator/#async-functions","title":"Async Functions","text":"<p>Works seamlessly with async functions:</p> <pre><code>@inject\nasync def process_user_async(service: UserService, user_id: int) -&gt; User:\n    # All dependencies injected\n    user = await service.get_user_async(user_id)\n    return user\n\n# Usage\nresult = await process_user_async(user_id=123)\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#class-methods","title":"Class Methods","text":"<p>Can be used on class methods:</p> <pre><code>class UserController:\n    @inject\n    def get_user(self, service: UserService, user_id: int) -&gt; User:\n        # 'self' is not injected, other parameters are\n        return service.get_user(user_id)\n\n    @classmethod\n    @inject\n    def create_user(cls, service: UserService, data: dict) -&gt; User:\n        # 'cls' is not injected\n        return service.create_user(data)\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#static-methods","title":"Static Methods","text":"<p>Works with static methods:</p> <pre><code>class UserUtils:\n    @staticmethod\n    @inject\n    def validate_user(service: UserService, user_id: int) -&gt; bool:\n        user = service.get_user(user_id)\n        return user is not None and user.is_active\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#nested-injection","title":"Nested Injection","text":"<p>Dependencies can have their own dependencies:</p> <pre><code>class Database:\n    def __init__(self, config: DatabaseConfig):\n        self.config = config\n\nclass UserRepository:\n    def __init__(self, db: Database):\n        self.db = db\n\nclass UserService:\n    def __init__(self, repo: UserRepository):\n        self.repo = repo\n\n# Register only the top-level service\ncontainer[UserService] = UserService\n\n@inject\ndef use_service(service: UserService) -&gt; None:\n    # InjectQ automatically creates:\n    # 1. DatabaseConfig\n    # 2. Database (with DatabaseConfig)\n    # 3. UserRepository (with Database)\n    # 4. UserService (with UserRepository)\n    pass\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#integration-patterns","title":"\ud83d\udd27 Integration Patterns","text":""},{"location":"injection-patterns/inject-decorator/#with-fastapi","title":"With FastAPI","text":"<pre><code>from fastapi import FastAPI\nfrom injectq.integrations.fastapi import Injected\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}\")\n@inject\ndef get_user(user_id: int, service: UserService) -&gt; User:\n    return service.get_user(user_id)\n\n# Or using Injected type\n@app.get(\"/users/{user_id}\")\ndef get_user(user_id: int, service: Injected[UserService]) -&gt; User:\n    return service.get_user(user_id)\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#with-classes","title":"With Classes","text":"<p>Use <code>@inject</code> on <code>__init__</code> methods:</p> <pre><code>class UserController:\n    @inject\n    def __init__(self, service: UserService, logger: Logger):\n        self.service = service\n        self.logger = logger\n\n    def get_user(self, user_id: int) -&gt; User:\n        self.logger.info(f\"Getting user {user_id}\")\n        return self.service.get_user(user_id)\n\n# Usage\ncontroller = UserController()  # Dependencies automatically injected\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#with-context-managers","title":"With Context Managers","text":"<pre><code>class DatabaseTransaction:\n    @inject\n    def __init__(self, db: Database):\n        self.db = db\n\n    def __enter__(self):\n        self.db.begin_transaction()\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type:\n            self.db.rollback()\n        else:\n            self.db.commit()\n\n@inject\ndef process_with_transaction(service: UserService) -&gt; None:\n    with DatabaseTransaction() as tx:\n        # Transaction automatically injected\n        service.update_user(1, {\"name\": \"New Name\"})\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#testing-with-inject","title":"\ud83e\uddea Testing with @inject","text":""},{"location":"injection-patterns/inject-decorator/#mock-dependencies","title":"Mock Dependencies","text":"<pre><code>from injectq import InjectQ\nfrom injectq.testing import override_dependency\n\ndef test_user_service():\n    mock_service = MockUserService()\n\n    with override_dependency(UserService, mock_service):\n        # @inject decorated functions use the mock\n        result = get_user(user_id=1)\n        assert result.name == \"Mock User\"\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#test-containers","title":"Test Containers","text":"<pre><code>from injectq import InjectQ\nfrom injectq.testing import test_container\n\ndef test_with_isolation():\n    with test_container() as container:\n        # Set up test dependencies\n        container.bind(UserService, MockUserService)\n        container.bind(Database, MockDatabase)\n\n        # Test the function\n        result = get_user(user_id=1)\n        assert result is not None\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#error-handling","title":"\ud83d\udea8 Error Handling","text":""},{"location":"injection-patterns/inject-decorator/#missing-dependencies","title":"Missing Dependencies","text":"<pre><code>@inject\ndef process_data(service: UserService) -&gt; None:\n    pass\n\n# If UserService is not registered\ntry:\n    process_data()\nexcept DependencyNotFoundError as e:\n    print(f\"Missing dependency: {e}\")\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#circular-dependencies","title":"Circular Dependencies","text":"<pre><code>class A:\n    def __init__(self, b: B):\n        self.b = b\n\nclass B:\n    def __init__(self, a: A):  # Circular!\n        self.a = a\n\ncontainer.bind(A, A)\ncontainer.bind(B, B)\n\n@inject\ndef use_a(a: A) -&gt; None:\n    pass\n\n# Will raise CircularDependencyError\nuse_a()\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#performance-considerations","title":"\u26a1 Performance Considerations","text":""},{"location":"injection-patterns/inject-decorator/#compilation","title":"Compilation","text":"<p>For better performance in production:</p> <pre><code># Pre-compile dependency resolution\ncontainer.compile()\n\n# Now @inject functions resolve faster\n@inject\ndef fast_function(service: UserService) -&gt; None:\n    pass\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#caching","title":"Caching","text":"<p>Resolved instances are cached based on scope:</p> <pre><code>@inject\ndef use_service(service: UserService) -&gt; None:\n    pass\n\n# First call - creates UserService\nuse_service()\n\n# Second call - reuses cached UserService (if singleton)\nuse_service()\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#best-practices","title":"\ud83c\udfc6 Best Practices","text":""},{"location":"injection-patterns/inject-decorator/#1-use-type-hints","title":"1. Use Type Hints","text":"<pre><code># \u2705 Good - explicit type hints\n@inject\ndef process_user(service: UserService, user_id: int) -&gt; User:\n    pass\n\n# \u274c Avoid - missing type hints\n@inject\ndef process_user(service, user_id):\n    pass\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#2-prefer-protocols","title":"2. Prefer Protocols","text":"<pre><code># \u2705 Good - depend on abstractions\nclass IUserService(Protocol):\n    def get_user(self, id: int) -&gt; User: ...\n\n@inject\ndef process_user(service: IUserService) -&gt; None:\n    pass\n\n# \u274c Avoid - depend on concrete classes\n@inject\ndef process_user(service: UserService) -&gt; None:\n    pass\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#3-keep-functions-focused","title":"3. Keep Functions Focused","text":"<pre><code># \u2705 Good - single responsibility\n@inject\ndef create_user(service: UserService, data: CreateUserRequest) -&gt; User:\n    return service.create_user(data)\n\n@inject\ndef send_welcome_email(email_service: EmailService, user: User) -&gt; None:\n    email_service.send_welcome(user)\n\n# \u274c Avoid - multiple responsibilities\n@inject\ndef create_user_and_send_email(\n    user_service: UserService,\n    email_service: EmailService,\n    data: CreateUserRequest\n) -&gt; User:\n    user = user_service.create_user(data)\n    email_service.send_welcome(user)  # Multiple concerns\n    return user\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#4-handle-optional-dependencies","title":"4. Handle Optional Dependencies","text":"<pre><code># \u2705 Good - optional dependencies\n@inject\ndef log_request(logger: Optional[Logger], request: Request) -&gt; None:\n    if logger:\n        logger.info(f\"Request: {request.path}\")\n\n# \u2705 Good - default values\n@inject\ndef process_data(cache: Optional[Cache] = None) -&gt; None:\n    if cache:\n        # Use cache\n        pass\n    else:\n        # Cache not available\n        pass\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#5-use-descriptive-names","title":"5. Use Descriptive Names","text":"<pre><code># \u2705 Good - descriptive parameter names\n@inject\ndef authenticate_user(\n    auth_service: AuthenticationService,\n    user_credentials: UserCredentials\n) -&gt; AuthResult:\n    pass\n\n# \u274c Avoid - unclear names\n@inject\ndef auth(s: AuthenticationService, c: UserCredentials) -&gt; AuthResult:\n    pass\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#comparison-with-other-patterns","title":"\ud83d\udd04 Comparison with Other Patterns","text":""},{"location":"injection-patterns/inject-decorator/#inject-vs-dict-interface","title":"@inject vs Dict Interface","text":"<pre><code># Dict interface - manual resolution\ndef process_user(user_id: int) -&gt; User:\n    service = container[UserService]\n    return service.get_user(user_id)\n\n# @inject - automatic resolution\n@inject\ndef process_user(service: UserService, user_id: int) -&gt; User:\n    return service.get_user(user_id)\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#inject-vs-inject-function","title":"@inject vs Inject() Function","text":"<pre><code># Inject() function - explicit injection\ndef process_user(user_id: int, service=Inject(UserService)) -&gt; User:\n    return service.get_user(user_id)\n\n# @inject - implicit injection\n@inject\ndef process_user(service: UserService, user_id: int) -&gt; User:\n    return service.get_user(user_id)\n</code></pre>"},{"location":"injection-patterns/inject-decorator/#when-to-use-inject","title":"\ud83c\udfaf When to Use @inject","text":""},{"location":"injection-patterns/inject-decorator/#ideal-for","title":"\u2705 Ideal For","text":"<ul> <li>Most applications - Recommended default approach</li> <li>Complex dependency graphs - Automatic resolution</li> <li>Type safety - Full mypy support</li> <li>Clean code - Declarative dependency specification</li> <li>Testing - Easy to mock and override</li> </ul>"},{"location":"injection-patterns/inject-decorator/#considerations","title":"\u26a0\ufe0f Considerations","text":"<ul> <li>Performance - Slight overhead for resolution (can be optimized)</li> <li>Debugging - Dependencies not visible in function calls</li> <li>Learning curve - Need to understand type hints</li> </ul>"},{"location":"injection-patterns/inject-decorator/#summary","title":"\ud83c\udf89 Summary","text":"<p>The <code>@inject</code> decorator provides:</p> <ul> <li>Automatic dependency resolution - No manual wiring</li> <li>Type-based injection - Uses type hints for resolution</li> <li>Clean syntax - Declarative and readable</li> <li>Full type safety - Works with mypy and IDEs</li> <li>Async support - Works with async functions</li> <li>Testing friendly - Easy to override dependencies</li> </ul> <p>Key benefits: - Eliminates boilerplate dependency management - Makes dependencies explicit through type hints - Enables easy testing with dependency overrides - Works seamlessly with all InjectQ features - Provides excellent IDE support and autocomplete</p> <p>Ready to explore the Inject() function?</p>"},{"location":"injection-patterns/inject-function/","title":"Inject() Function","text":"<p>The <code>Inject()</code> function provides explicit dependency injection for specific parameters. It's an alternative to the <code>@inject</code> decorator when you need fine-grained control over which dependencies are injected.</p>"},{"location":"injection-patterns/inject-function/#basic-usage","title":"\ud83c\udfaf Basic Usage","text":"<p>Use <code>Inject()</code> to specify which parameters should be injected:</p> <pre><code>from injectq import InjectQ, Inject\n\n# Set up container\ncontainer = InjectQ.get_instance()\ncontainer[Database] = Database\ncontainer[UserService] = UserService\n\n# Use Inject() for specific parameters\ndef process_user(user_id: int, service=Inject(UserService)) -&gt; User:\n    # Only 'service' is injected, 'user_id' is passed normally\n    return service.get_user(user_id)\n\n# Usage\nuser = process_user(user_id=123)  # service automatically injected\n</code></pre>"},{"location":"injection-patterns/inject-function/#how-it-works","title":"\ud83d\udd27 How It Works","text":""},{"location":"injection-patterns/inject-function/#selective-injection","title":"Selective Injection","text":"<p><code>Inject()</code> allows you to mix injected and regular parameters:</p> <pre><code>def create_report(\n    report_id: str,                    # Regular parameter\n    user_service=Inject(UserService),  # Injected\n    analytics=Inject(Analytics),       # Injected\n    format: str = \"pdf\"               # Regular parameter with default\n) -&gt; Report:\n    # report_id and format passed normally\n    # user_service and analytics injected automatically\n    pass\n\n# Usage\nreport = create_report(\n    \"report_001\",        # report_id\n    format=\"excel\"       # format\n    # user_service and analytics automatically injected\n)\n</code></pre>"},{"location":"injection-patterns/inject-function/#type-based-resolution","title":"Type-Based Resolution","text":"<p>Like <code>@inject</code>, <code>Inject()</code> uses type hints for resolution:</p> <pre><code>class IDatabase(Protocol):\n    def connect(self) -&gt; None: ...\n\nclass PostgreSQLDatabase:\n    def connect(self) -&gt; None:\n        print(\"Connected to PostgreSQL\")\n\n# Register implementation\ncontainer.bind(IDatabase, PostgreSQLDatabase)\n\ndef use_database(db=Inject(IDatabase)) -&gt; None:\n    # InjectQ resolves IDatabase to PostgreSQLDatabase\n    db.connect()\n\nuse_database()  # Prints: Connected to PostgreSQL\n</code></pre>"},{"location":"injection-patterns/inject-function/#advanced-patterns","title":"\ud83c\udfa8 Advanced Patterns","text":""},{"location":"injection-patterns/inject-function/#multiple-inject-calls","title":"Multiple Inject() Calls","text":"<p>Use multiple <code>Inject()</code> calls in the same function:</p> <pre><code>def complex_operation(\n    operation_id: str,\n    db=Inject(Database),\n    cache=Inject(Cache),\n    logger=Inject(Logger),\n    config=Inject(AppConfig)\n) -&gt; Result:\n    logger.info(f\"Starting operation {operation_id}\")\n\n    # Use all injected dependencies\n    data = cache.get(operation_id)\n    if not data:\n        data = db.query(f\"SELECT * FROM operations WHERE id = {operation_id}\")\n        cache.set(operation_id, data)\n\n    return process_data(data, config)\n</code></pre>"},{"location":"injection-patterns/inject-function/#with-default-values","title":"With Default Values","text":"<p>Combine <code>Inject()</code> with regular default values:</p> <pre><code>def send_email(\n    to: str,\n    subject: str,\n    body: str,\n    smtp=Inject(SMTPClient),           # Injected\n    from_addr: str = \"noreply@app.com\", # Regular default\n    priority: str = \"normal\"           # Regular default\n) -&gt; None:\n    smtp.send(\n        from_addr=from_addr,\n        to=to,\n        subject=subject,\n        body=body,\n        priority=priority\n    )\n</code></pre>"},{"location":"injection-patterns/inject-function/#conditional-injection","title":"Conditional Injection","text":"<p>Use <code>Inject()</code> conditionally:</p> <pre><code>def process_data(\n    data: bytes,\n    use_cache: bool = True,\n    cache=Inject(Cache),      # Always injected\n    processor=Inject(DataProcessor)\n) -&gt; ProcessedData:\n    if use_cache:\n        # Use cache\n        cached = cache.get(data_hash(data))\n        if cached:\n            return cached\n\n    # Process data\n    result = processor.process(data)\n\n    if use_cache:\n        cache.set(data_hash(data), result)\n\n    return result\n</code></pre>"},{"location":"injection-patterns/inject-function/#comparison-with-inject","title":"\ud83d\udd04 Comparison with @inject","text":""},{"location":"injection-patterns/inject-function/#inject-decorator","title":"@inject Decorator","text":"<pre><code>@inject\ndef process_all(service: UserService, cache: Cache, user_id: int) -&gt; User:\n    # All parameters except self/cls are injected\n    return service.get_user(user_id)\n</code></pre>"},{"location":"injection-patterns/inject-function/#inject-function_1","title":"Inject() Function","text":"<pre><code>def process_selective(\n    user_id: int,                    # Regular parameter\n    service=Inject(UserService),     # Injected\n    use_cache: bool = True          # Regular parameter\n) -&gt; User:\n    # Only service is injected\n    return service.get_user(user_id)\n</code></pre>"},{"location":"injection-patterns/inject-function/#testing-with-inject","title":"\ud83e\uddea Testing with Inject()","text":""},{"location":"injection-patterns/inject-function/#override-specific-dependencies","title":"Override Specific Dependencies","text":"<pre><code>from injectq.testing import override_dependency\n\ndef test_process_user():\n    mock_service = MockUserService()\n\n    with override_dependency(UserService, mock_service):\n        # Only UserService is mocked\n        result = process_user(user_id=1)\n        assert result.name == \"Mock User\"\n</code></pre>"},{"location":"injection-patterns/inject-function/#partial-mocking","title":"Partial Mocking","text":"<pre><code>def test_complex_operation():\n    mock_cache = MockCache()\n    mock_db = MockDatabase()\n\n    with override_dependency(Cache, mock_cache):\n        with override_dependency(Database, mock_db):\n            # Only Cache and Database are mocked\n            # Logger and Config use real implementations\n            result = complex_operation(\"op_123\")\n            assert result is not None\n</code></pre>"},{"location":"injection-patterns/inject-function/#real-world-examples","title":"\ud83d\ude80 Real-World Examples","text":""},{"location":"injection-patterns/inject-function/#http-handler","title":"HTTP Handler","text":"<pre><code>def handle_user_request(\n    request: HttpRequest,\n    response: HttpResponse,\n    user_service=Inject(UserService),\n    auth_service=Inject(AuthService)\n) -&gt; HttpResponse:\n    # Validate authentication\n    user = auth_service.authenticate(request.token)\n    if not user:\n        response.status = 401\n        return response\n\n    # Process request\n    data = user_service.get_user_data(user.id)\n    response.json = {\"user\": data}\n    return response\n</code></pre>"},{"location":"injection-patterns/inject-function/#background-job","title":"Background Job","text":"<pre><code>def process_user_notifications(\n    user_ids: List[int],\n    notification_service=Inject(NotificationService),\n    user_service=Inject(UserService),\n    logger=Inject(Logger)\n) -&gt; None:\n    for user_id in user_ids:\n        try:\n            user = user_service.get_user(user_id)\n            if user and user.notifications_enabled:\n                notification_service.send_daily_digest(user)\n                logger.info(f\"Sent notifications to user {user_id}\")\n        except Exception as e:\n            logger.error(f\"Failed to process notifications for user {user_id}: {e}\")\n</code></pre>"},{"location":"injection-patterns/inject-function/#data-pipeline","title":"Data Pipeline","text":"<pre><code>def run_data_pipeline(\n    pipeline_config: dict,\n    extractor=Inject(DataExtractor),\n    transformer=Inject(DataTransformer),\n    loader=Inject(DataLoader),\n    monitor=Inject(PipelineMonitor)\n) -&gt; PipelineResult:\n    monitor.start_pipeline(pipeline_config[\"name\"])\n\n    try:\n        # Extract\n        raw_data = extractor.extract(pipeline_config[\"source\"])\n\n        # Transform\n        processed_data = transformer.transform(raw_data, pipeline_config[\"rules\"])\n\n        # Load\n        result = loader.load(processed_data, pipeline_config[\"destination\"])\n\n        monitor.end_pipeline(success=True)\n        return result\n\n    except Exception as e:\n        monitor.end_pipeline(success=False, error=str(e))\n        raise\n</code></pre>"},{"location":"injection-patterns/inject-function/#performance-considerations","title":"\u26a1 Performance Considerations","text":""},{"location":"injection-patterns/inject-function/#resolution-overhead","title":"Resolution Overhead","text":"<p><code>Inject()</code> has similar performance characteristics to <code>@inject</code>:</p> <pre><code># Each call resolves dependencies\nfor i in range(1000):\n    result = process_user(user_id=i)  # Resolves UserService each time\n</code></pre>"},{"location":"injection-patterns/inject-function/#caching","title":"Caching","text":"<p>Dependencies are cached based on their scope:</p> <pre><code>def use_service(service=Inject(UserService)) -&gt; None:\n    pass\n\n# If UserService is singleton\nuse_service()  # Creates and caches UserService\nuse_service()  # Reuses cached UserService\n</code></pre>"},{"location":"injection-patterns/inject-function/#best-practices","title":"\ud83c\udfc6 Best Practices","text":""},{"location":"injection-patterns/inject-function/#1-use-for-selective-injection","title":"1. Use for Selective Injection","text":"<pre><code># \u2705 Good - selective injection\ndef api_handler(request, service=Inject(UserService)):\n    pass\n\n# \u274c Avoid - use @inject for all dependencies\ndef api_handler(service=Inject(UserService), cache=Inject(Cache)):\n    pass\n</code></pre>"},{"location":"injection-patterns/inject-function/#2-combine-with-regular-defaults","title":"2. Combine with Regular Defaults","text":"<pre><code># \u2705 Good - mix injected and regular defaults\ndef process(\n    data: bytes,\n    service=Inject(Processor),\n    retries: int = 3,\n    timeout: float = 30.0\n):\n    pass\n\n# \u274c Avoid - all parameters injected\ndef process(\n    data=Inject(bytes),  # Doesn't make sense\n    service=Inject(Processor)\n):\n    pass\n</code></pre>"},{"location":"injection-patterns/inject-function/#3-use-descriptive-parameter-names","title":"3. Use Descriptive Parameter Names","text":"<pre><code># \u2705 Good - clear parameter names\ndef authenticate_user(\n    credentials: UserCredentials,\n    auth_service=Inject(AuthenticationService),\n    audit_logger=Inject(AuditLogger)\n):\n    pass\n\n# \u274c Avoid - unclear names\ndef auth(creds, auth_svc=Inject(AuthSvc), logger=Inject(Logger)):\n    pass\n</code></pre>"},{"location":"injection-patterns/inject-function/#4-document-injected-parameters","title":"4. Document Injected Parameters","text":"<pre><code>def create_user(\n    user_data: dict,\n    user_service=Inject(UserService),  # Creates and saves user\n    email_service=Inject(EmailService)  # Sends welcome email\n) -&gt; User:\n    \"\"\"Create a new user and send welcome email.\n\n    Args:\n        user_data: User information (name, email, etc.)\n        user_service: Automatically injected user service\n        email_service: Automatically injected email service\n    \"\"\"\n    pass\n</code></pre>"},{"location":"injection-patterns/inject-function/#common-patterns-and-pitfalls","title":"\ud83d\udea8 Common Patterns and Pitfalls","text":""},{"location":"injection-patterns/inject-function/#pattern-factory-functions","title":"Pattern: Factory Functions","text":"<pre><code>def create_user_service(db=Inject(Database)) -&gt; UserService:\n    \"\"\"Factory function that creates UserService with injected dependencies.\"\"\"\n    return UserService(db)\n\n# Usage\nservice = create_user_service()  # Dependencies injected\n</code></pre>"},{"location":"injection-patterns/inject-function/#pattern-builder-pattern","title":"Pattern: Builder Pattern","text":"<pre><code>class ReportBuilder:\n    def __init__(\n        self,\n        data_source=Inject(DataSource),\n        formatter=Inject(ReportFormatter)\n    ):\n        self.data_source = data_source\n        self.formatter = formatter\n\n    def build_report(self, config: ReportConfig) -&gt; Report:\n        data = self.data_source.get_data(config.query)\n        return self.formatter.format(data, config.format)\n</code></pre>"},{"location":"injection-patterns/inject-function/#pitfall-over-injection","title":"Pitfall: Over-Injection","text":"<pre><code># \u274c Too many injected parameters\ndef complex_function(\n    a=Inject(A), b=Inject(B), c=Inject(C),\n    d=Inject(D), e=Inject(E), f=Inject(F)\n):\n    pass\n\n# \u2705 Group related dependencies\n@dataclass\nclass ProcessingContext:\n    service_a: A\n    service_b: B\n    service_c: C\n\ndef complex_function(context=Inject(ProcessingContext)):\n    pass\n</code></pre>"},{"location":"injection-patterns/inject-function/#when-to-use-inject","title":"\ud83c\udfaf When to Use Inject()","text":""},{"location":"injection-patterns/inject-function/#good-for","title":"\u2705 Good For","text":"<ul> <li>Selective injection - Only some parameters need injection</li> <li>Mixed parameters - Some injected, some passed normally</li> <li>Fine-grained control - Explicit about what's injected</li> <li>Legacy code - Gradually add DI without changing all functions</li> <li>Factory functions - Create objects with injected dependencies</li> </ul>"},{"location":"injection-patterns/inject-function/#not-ideal-for","title":"\u274c Not Ideal For","text":"<ul> <li>All parameters injected - Use <code>@inject</code> decorator instead</li> <li>Simple functions - May add unnecessary complexity</li> <li>Type safety - Slightly less type-safe than <code>@inject</code></li> </ul>"},{"location":"injection-patterns/inject-function/#migration-from-manual-di","title":"\ud83d\udd04 Migration from Manual DI","text":""},{"location":"injection-patterns/inject-function/#before-manual","title":"Before (Manual)","text":"<pre><code>def process_user(container, user_id: int) -&gt; User:\n    service = container.get(UserService)\n    return service.get_user(user_id)\n\n# Usage\nuser = process_user(container, 123)\n</code></pre>"},{"location":"injection-patterns/inject-function/#after-inject","title":"After (Inject())","text":"<pre><code>def process_user(user_id: int, service=Inject(UserService)) -&gt; User:\n    return service.get_user(user_id)\n\n# Usage\nuser = process_user(123)  # container not needed\n</code></pre>"},{"location":"injection-patterns/inject-function/#summary","title":"\ud83c\udf89 Summary","text":"<p>The <code>Inject()</code> function provides:</p> <ul> <li>Selective dependency injection - Choose which parameters to inject</li> <li>Fine-grained control - Mix injected and regular parameters</li> <li>Explicit injection - Clear about what's being injected</li> <li>Type-based resolution - Uses type hints for dependency resolution</li> <li>Testing friendly - Easy to override specific dependencies</li> </ul> <p>Key features: - Works with any function (regular, async, methods, etc.) - Can be combined with regular default values - Supports all InjectQ dependency resolution features - Minimal performance overhead - Excellent for gradual adoption of DI</p> <p>Ready to explore binding patterns?</p>"},{"location":"integrations/fastapi/","title":"FastAPI Integration","text":"<p>FastAPI integration provides seamless dependency injection for FastAPI applications, enabling automatic service resolution with proper request scoping and lifecycle management.</p>"},{"location":"integrations/fastapi/#getting-started","title":"\ud83c\udfaf Getting Started","text":""},{"location":"integrations/fastapi/#basic-setup","title":"Basic Setup","text":"<pre><code>from fastapi import FastAPI\nfrom injectq import InjectQ\nfrom injectq.integrations.fastapi import setup_fastapi_integration, InjectQDependency\n\n# 1. Create container and bind services\ncontainer = InjectQ()\ncontainer.bind(IUserService, UserService())\ncontainer.bind(IOrderService, OrderService())\n\n# 2. Create FastAPI app\napp = FastAPI(title=\"My API\", version=\"1.0.0\")\n\n# 3. Set up integration\nsetup_fastapi_integration(app, container)\n\n# 4. Use dependency injection in endpoints\n@app.get(\"/users/{user_id}\")\nasync def get_user(\n    user_id: int,\n    user_service: IUserService = InjectQDependency(IUserService)\n):\n    return user_service.get_user(user_id)\n\n@app.post(\"/orders\")\nasync def create_order(\n    order_data: OrderCreate,\n    order_service: IOrderService = InjectQDependency(IOrderService)\n):\n    return order_service.create_order(order_data)\n</code></pre>"},{"location":"integrations/fastapi/#service-definitions","title":"Service Definitions","text":"<pre><code>from typing import Protocol\n\n# Define service interfaces\nclass IUserService(Protocol):\n    def get_user(self, user_id: int) -&gt; User: ...\n    def create_user(self, user_data: UserCreate) -&gt; User: ...\n\nclass IOrderService(Protocol):\n    def create_order(self, order_data: OrderCreate) -&gt; Order: ...\n    def get_order(self, order_id: int) -&gt; Order: ...\n\n# Implement services\nclass UserService:\n    def __init__(self, db: IDatabaseConnection):\n        self.db = db\n\n    def get_user(self, user_id: int) -&gt; User:\n        return self.db.query(User).filter(id=user_id).first()\n\n    def create_user(self, user_data: UserCreate) -&gt; User:\n        user = User(**user_data.dict())\n        self.db.add(user)\n        self.db.commit()\n        return user\n\nclass OrderService:\n    def __init__(self, db: IDatabaseConnection, user_service: IUserService):\n        self.db = db\n        self.user_service = user_service\n\n    def create_order(self, order_data: OrderCreate) -&gt; Order:\n        # Validate user exists\n        user = self.user_service.get_user(order_data.user_id)\n\n        order = Order(**order_data.dict())\n        self.db.add(order)\n        self.db.commit()\n        return order\n\n    def get_order(self, order_id: int) -&gt; Order:\n        return self.db.query(Order).filter(id=order_id).first()\n</code></pre>"},{"location":"integrations/fastapi/#advanced-configuration","title":"\ud83d\udd27 Advanced Configuration","text":""},{"location":"integrations/fastapi/#custom-container-setup","title":"Custom Container Setup","text":"<pre><code>from injectq import InjectQ, Module\n\nclass ApplicationModule(Module):\n    def __init__(self, config: AppConfig):\n        self.config = config\n\n    def configure(self, binder):\n        # Database\n        binder.bind(IDatabaseConnection, create_database_connection(self.config.database))\n\n        # Services\n        binder.bind(IUserService, UserService())\n        binder.bind(IOrderService, OrderService())\n\n        # External services\n        binder.bind(IEmailService, SmtpEmailService(self.config.email))\n        binder.bind(IPaymentService, StripePaymentService(self.config.payment))\n\ndef create_app(config: AppConfig) -&gt; FastAPI:\n    # Create container with modules\n    container = InjectQ()\n    container.install(ApplicationModule(config))\n\n    # Create FastAPI app\n    app = FastAPI(\n        title=config.app_name,\n        version=config.version,\n        debug=config.debug\n    )\n\n    # Set up integration\n    setup_fastapi_integration(app, container)\n\n    return app\n\n# Usage\nconfig = AppConfig.from_env()\napp = create_app(config)\n</code></pre>"},{"location":"integrations/fastapi/#environment-specific-setup","title":"Environment-Specific Setup","text":"<pre><code>def create_container_for_env(env: str) -&gt; InjectQ:\n    container = InjectQ()\n\n    if env == \"production\":\n        container.install(ProductionDatabaseModule())\n        container.install(RedisCacheModule())\n        container.install(SmtpEmailModule())\n    elif env == \"testing\":\n        container.install(TestDatabaseModule())\n        container.install(InMemoryCacheModule())\n        container.install(MockEmailModule())\n    else:  # development\n        container.install(DevDatabaseModule())\n        container.install(InMemoryCacheModule())\n        container.install(ConsoleEmailModule())\n\n    return container\n\ndef create_app() -&gt; FastAPI:\n    env = os.getenv(\"ENV\", \"development\")\n    container = create_container_for_env(env)\n\n    app = FastAPI()\n    setup_fastapi_integration(app, container)\n\n    return app\n</code></pre>"},{"location":"integrations/fastapi/#dependency-injection-patterns","title":"\ud83c\udfa8 Dependency Injection Patterns","text":""},{"location":"integrations/fastapi/#constructor-injection","title":"Constructor Injection","text":"<pre><code># Services with dependencies\n@singleton\nclass DatabaseConnection:\n    def __init__(self, config: DatabaseConfig):\n        self.config = config\n        self.connection = create_connection(config)\n\n@scoped\nclass UserService:\n    def __init__(self, db: IDatabaseConnection, cache: ICache):\n        self.db = db\n        self.cache = cache\n\n# Bind in module\nclass ServiceModule(Module):\n    def configure(self, binder):\n        binder.bind(DatabaseConfig, DatabaseConfig.from_env())\n        binder.bind(IDatabaseConnection, DatabaseConnection())\n        binder.bind(ICache, RedisCache())\n        binder.bind(IUserService, UserService())\n\n# Use in endpoints\n@app.get(\"/users/{user_id}\")\nasync def get_user(\n    user_id: int,\n    user_service: IUserService = InjectQDependency(IUserService)\n):\n    return user_service.get_user(user_id)\n</code></pre>"},{"location":"integrations/fastapi/#request-scoped-services","title":"Request-Scoped Services","text":"<pre><code>@scoped\nclass RequestContext:\n    def __init__(self):\n        self.request_id = str(uuid.uuid4())\n        self.start_time = time.time()\n        self.user_id = None\n\n    def set_user(self, user_id: int):\n        self.user_id = user_id\n        self.request_time = time.time() - self.start_time\n\n@scoped\nclass RequestCache:\n    def __init__(self):\n        self.data = {}\n\n    def get(self, key: str):\n        return self.cache.get(key)\n\n    def set(self, key: str, value):\n        self.cache[key] = value\n\n# Automatic request scoping\n@app.get(\"/users/{user_id}\")\nasync def get_user(\n    user_id: int,\n    ctx: RequestContext = InjectQDependency(RequestContext),\n    cache: RequestCache = InjectQDependency(RequestCache),\n    user_service: IUserService = InjectQDependency(IUserService)\n):\n    ctx.set_user(user_id)  # Context is scoped to this request\n\n    # Cache is also scoped to this request\n    cache_key = f\"user:{user_id}\"\n    user = cache.get(cache_key)\n\n    if user is None:\n        user = user_service.get_user(user_id)\n        cache.set(cache_key, user)\n\n    return user\n</code></pre>"},{"location":"integrations/fastapi/#authentication-integration","title":"Authentication Integration","text":"<pre><code>from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom fastapi import Depends, HTTPException\n\nsecurity = HTTPBearer()\n\n@singleton\nclass AuthService:\n    def __init__(self, jwt_secret: str):\n        self.jwt_secret = jwt_secret\n\n    def verify_token(self, token: str) -&gt; User:\n        try:\n            payload = jwt.decode(token, self.jwt_secret, algorithms=[\"HS256\"])\n            return User(id=payload[\"user_id\"], email=payload[\"email\"])\n        except jwt.ExpiredSignatureError:\n            raise HTTPException(status_code=401, detail=\"Token expired\")\n        except jwt.InvalidTokenError:\n            raise HTTPException(status_code=401, detail=\"Invalid token\")\n\nasync def get_current_user(\n    credentials: HTTPAuthorizationCredentials = Depends(security),\n    auth_service: IAuthService = InjectQDependency(IAuthService)\n) -&gt; User:\n    return auth_service.verify_token(credentials.credentials)\n\n@app.get(\"/me\")\nasync def get_me(current_user: User = Depends(get_current_user)):\n    return current_user\n\n@app.get(\"/users/{user_id}\")\nasync def get_user(\n    user_id: int,\n    current_user: User = Depends(get_current_user),\n    user_service: IUserService = InjectQDependency(IUserService)\n):\n    # current_user is authenticated user from JWT\n    # user_service is injected from container\n    if current_user.id != user_id and not current_user.is_admin:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n\n    return user_service.get_user(user_id)\n</code></pre>"},{"location":"integrations/fastapi/#testing-fastapi-integration","title":"\ud83e\uddea Testing FastAPI Integration","text":""},{"location":"integrations/fastapi/#unit-testing-endpoints","title":"Unit Testing Endpoints","text":"<pre><code>import pytest\nfrom fastapi.testclient import TestClient\nfrom injectq.integrations.fastapi import setup_fastapi_integration\n\n@pytest.fixture\ndef test_app():\n    # Create test container\n    container = InjectQ()\n    container.bind(IUserService, MockUserService())\n    container.bind(IOrderService, MockOrderService())\n\n    # Create test app\n    app = FastAPI()\n    setup_fastapi_integration(app, container)\n\n    @app.get(\"/users/{user_id}\")\n    async def get_user(\n        user_id: int,\n        user_service: IUserService = InjectQDependency(IUserService)\n    ):\n        return user_service.get_user(user_id)\n\n    return app\n\ndef test_get_user(test_app):\n    client = TestClient(test_app)\n\n    response = client.get(\"/users/123\")\n\n    assert response.status_code == 200\n    assert response.json()[\"id\"] == 123\n\ndef test_request_scoping(test_app):\n    client = TestClient(test_app)\n\n    # Each request should be isolated\n    response1 = client.get(\"/users/1\")\n    response2 = client.get(\"/users/2\")\n\n    # Both should succeed (no state leakage)\n    assert response1.status_code == 200\n    assert response2.status_code == 200\n</code></pre>"},{"location":"integrations/fastapi/#integration-testing","title":"Integration Testing","text":"<pre><code>@pytest.fixture\ndef integration_app():\n    # Real container with test database\n    container = InjectQ()\n    container.install(TestDatabaseModule())\n    container.install(UserModule())\n    container.install(OrderModule())\n\n    app = FastAPI()\n    setup_fastapi_integration(app, container)\n\n    @app.post(\"/users\")\n    async def create_user(\n        user_data: UserCreate,\n        user_service: IUserService = InjectQDependency(IUserService)\n    ):\n        return user_service.create_user(user_data)\n\n    @app.post(\"/orders\")\n    async def create_order(\n        order_data: OrderCreate,\n        order_service: IOrderService = InjectQDependency(IOrderService)\n    ):\n        return order_service.create_order(order_data)\n\n    return app\n\ndef test_user_order_workflow(integration_app):\n    client = TestClient(integration_app)\n\n    # Create user\n    user_response = client.post(\"/users\", json={\n        \"name\": \"Test User\",\n        \"email\": \"test@example.com\"\n    })\n    assert user_response.status_code == 201\n    user_id = user_response.json()[\"id\"]\n\n    # Create order for user\n    order_response = client.post(\"/orders\", json={\n        \"user_id\": user_id,\n        \"items\": [{\"product_id\": 1, \"quantity\": 2}]\n    })\n    assert order_response.status_code == 201\n\n    order = order_response.json()\n    assert order[\"user_id\"] == user_id\n</code></pre>"},{"location":"integrations/fastapi/#mock-testing","title":"Mock Testing","text":"<pre><code>class MockUserService:\n    def __init__(self):\n        self.users = {}\n        self.call_count = 0\n\n    def get_user(self, user_id: int):\n        self.call_count += 1\n        return self.users.get(user_id, {\"id\": user_id, \"name\": \"Mock User\"})\n\n    def create_user(self, user_data):\n        user_id = len(self.users) + 1\n        user = {\"id\": user_id, **user_data.dict()}\n        self.users[user_id] = user\n        return user\n\ndef test_with_mocks():\n    container = InjectQ()\n    mock_user_service = MockUserService()\n    container.bind(IUserService, mock_user_service)\n\n    app = FastAPI()\n    setup_fastapi_integration(app, container)\n\n    @app.get(\"/users/{user_id}\")\n    async def get_user(\n        user_id: int,\n        user_service: IUserService = InjectQDependency(IUserService)\n    ):\n        return user_service.get_user(user_id)\n\n    client = TestClient(app)\n\n    # Test endpoint\n    response = client.get(\"/users/123\")\n    assert response.status_code == 200\n\n    # Verify mock was called\n    assert mock_user_service.call_count == 1\n</code></pre>"},{"location":"integrations/fastapi/#common-patterns-and-pitfalls","title":"\ud83d\udea8 Common Patterns and Pitfalls","text":""},{"location":"integrations/fastapi/#good-patterns","title":"\u2705 Good Patterns","text":""},{"location":"integrations/fastapi/#1-proper-scoping","title":"1. Proper Scoping","text":"<pre><code># \u2705 Good: Use scoped for request-specific data\n@scoped\nclass RequestMetrics:\n    def __init__(self):\n        self.start_time = time.time()\n        self.queries = []\n\n    def record_query(self, query: str, duration: float):\n        self.queries.append({\"query\": query, \"duration\": duration})\n\n# \u2705 Good: Use singleton for shared resources\n@singleton\nclass DatabasePool:\n    def __init__(self, config: DatabaseConfig):\n        self.pool = create_pool(config)\n\n# \u2705 Good: Use transient for stateless operations\n@transient\nclass PasswordHasher:\n    def hash(self, password: str) -&gt; str:\n        return bcrypt.hashpw(password.encode(), bcrypt.gensalt())\n</code></pre>"},{"location":"integrations/fastapi/#2-error-handling","title":"2. Error Handling","text":"<pre><code># \u2705 Good: Handle service errors gracefully\n@app.get(\"/users/{user_id}\")\nasync def get_user(\n    user_id: int,\n    user_service: IUserService = InjectQDependency(IUserService)\n):\n    try:\n        return user_service.get_user(user_id)\n    except UserNotFoundError:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    except ServiceError:\n        raise HTTPException(status_code=500, detail=\"Internal server error\")\n</code></pre>"},{"location":"integrations/fastapi/#3-middleware-integration","title":"3. Middleware Integration","text":"<pre><code># \u2705 Good: Use middleware for cross-cutting concerns\nfrom fastapi import Request\n\n@app.middleware(\"http\")\nasync def logging_middleware(request: Request, call_next):\n    start_time = time.time()\n\n    # Get request-scoped logger if available\n    try:\n        logger = get_request_container(request).get(ILogger)\n        logger.info(f\"Request started: {request.method} {request.url}\")\n    except:\n        pass  # Logger not available, continue\n\n    response = await call_next(request)\n\n    duration = time.time() - start_time\n    print(f\"Request completed in {duration:.2f}s\")\n\n    return response\n</code></pre>"},{"location":"integrations/fastapi/#bad-patterns","title":"\u274c Bad Patterns","text":""},{"location":"integrations/fastapi/#1-manual-container-access","title":"1. Manual Container Access","text":"<pre><code># \u274c Bad: Manual container access in endpoints\ncontainer = InjectQ()  # Global container\n\n@app.get(\"/users/{user_id}\")\nasync def get_user(user_id: int):\n    user_service = container.get(IUserService)  # Manual resolution\n    return user_service.get_user(user_id)\n\n# \u2705 Good: Use dependency injection\n@app.get(\"/users/{user_id}\")\nasync def get_user(\n    user_id: int,\n    user_service: IUserService = InjectQDependency(IUserService)\n):\n    return user_service.get_user(user_id)\n</code></pre>"},{"location":"integrations/fastapi/#2-singleton-abuse","title":"2. Singleton Abuse","text":"<pre><code># \u274c Bad: Singleton for request-specific data\n@singleton\nclass CurrentUser:\n    def __init__(self):\n        self.user = None\n\n    def set_user(self, user):\n        self.user = user  # Shared across requests!\n\n# \u274c Bad: Singleton for mutable state\n@singleton\nclass RequestCache:\n    def __init__(self):\n        self.data = {}  # Shared and accumulates forever!\n\n# \u2705 Good: Scoped for request-specific data\n@scoped\nclass CurrentUser:\n    def __init__(self):\n        self.user = None\n\n@scoped\nclass RequestCache:\n    def __init__(self):\n        self.data = {}  # Isolated per request\n</code></pre>"},{"location":"integrations/fastapi/#3-heavy-services-per-request","title":"3. Heavy Services per Request","text":"<pre><code># \u274c Bad: Heavy service per request\n@transient\nclass MLModelService:\n    def __init__(self):\n        self.model = load_ml_model()  # 2GB model loaded per request!\n\n# \u2705 Good: Singleton for heavy resources\n@singleton\nclass MLModelService:\n    def __init__(self):\n        self.model = load_ml_model()  # Loaded once\n\n    def predict(self, data):\n        return self.model.predict(data)\n</code></pre>"},{"location":"integrations/fastapi/#advanced-features","title":"\u26a1 Advanced Features","text":""},{"location":"integrations/fastapi/#custom-dependency-resolver","title":"Custom Dependency Resolver","text":"<pre><code>from injectq.integrations.fastapi import InjectQDependencyResolver\n\nclass CustomResolver(InjectQDependencyResolver):\n    def resolve_dependency(self, dependency_type: Type[T]) -&gt; T:\n        # Custom resolution logic\n        if dependency_type == ISpecialService:\n            # Create special service with custom logic\n            return SpecialServiceImpl(custom_config)\n\n        # Fall back to container resolution\n        return super().resolve_dependency(dependency_type)\n\n# Use custom resolver\nsetup_fastapi_integration(app, container, resolver=CustomResolver())\n</code></pre>"},{"location":"integrations/fastapi/#request-container-access","title":"Request Container Access","text":"<pre><code>from injectq.integrations.fastapi import get_request_container\n\n@app.get(\"/debug\")\nasync def debug_endpoint(request: Request):\n    # Get the request-scoped container\n    request_container = get_request_container(request)\n\n    # Access request-scoped services\n    ctx = request_container.get(RequestContext)\n    cache = request_container.get(RequestCache)\n\n    return {\n        \"request_id\": ctx.request_id,\n        \"cache_size\": len(cache.data),\n        \"services\": list(request_container._bindings.keys())\n    }\n</code></pre>"},{"location":"integrations/fastapi/#background-tasks-integration","title":"Background Tasks Integration","text":"<pre><code>from fastapi import BackgroundTasks\n\n@singleton\nclass BackgroundTaskService:\n    def __init__(self, email_service: IEmailService):\n        self.email_service = email_service\n\n    async def send_welcome_email(self, user_email: str):\n        await self.email_service.send_email(\n            to=user_email,\n            subject=\"Welcome!\",\n            body=\"Welcome to our platform!\"\n        )\n\n@app.post(\"/users\")\nasync def create_user(\n    user_data: UserCreate,\n    background_tasks: BackgroundTasks,\n    user_service: IUserService = InjectQDependency(IUserService),\n    task_service: BackgroundTaskService = InjectQDependency(BackgroundTaskService)\n):\n    # Create user\n    user = user_service.create_user(user_data)\n\n    # Send welcome email in background\n    background_tasks.add_task(\n        task_service.send_welcome_email,\n        user.email\n    )\n\n    return user\n</code></pre>"},{"location":"integrations/fastapi/#websocket-support","title":"WebSocket Support","text":"<pre><code>from fastapi import WebSocket\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(\n    websocket: WebSocket,\n    client_id: str,\n    ws_service: IWebSocketService = InjectQDependency(IWebSocketService)\n):\n    await websocket.accept()\n\n    # WebSocket connection gets its own scoped services\n    ctx = websocket.scope.get(\"injectq_container\")\n    if ctx:\n        # Services are scoped to this WebSocket connection\n        session_service = ctx.get(ISessionService)\n        session_service.set_client_id(client_id)\n\n    while True:\n        data = await websocket.receive_text()\n        # Handle WebSocket messages with injected services\n        response = ws_service.process_message(client_id, data)\n        await websocket.send_text(response)\n</code></pre>"},{"location":"integrations/fastapi/#summary","title":"\ud83c\udfaf Summary","text":"<p>FastAPI integration provides:</p> <ul> <li>Automatic dependency injection - No manual container management</li> <li>Request-scoped services - Proper isolation per HTTP request</li> <li>Type-driven injection - Just add type hints to endpoint parameters</li> <li>Framework lifecycle integration - Automatic cleanup and resource management</li> <li>Testing support - Easy mocking and test isolation</li> </ul> <p>Key features: - Seamless integration with FastAPI's dependency system - Support for all InjectQ scopes (singleton, scoped, transient) - Request-scoped container access - Custom dependency resolvers - Background task integration - WebSocket support</p> <p>Best practices: - Use scoped services for request-specific data - Use singleton for shared resources and heavy objects - Use transient for stateless operations - Handle errors gracefully in endpoints - Test thoroughly with mocked dependencies - Avoid manual container access in endpoints</p> <p>Ready to explore Taskiq integration?</p>"},{"location":"integrations/fastmcp/","title":"FastMCP Integration","text":"<p>FastMCP integration enables dependency injection for MCP (Model Context Protocol) servers, providing automatic service resolution with proper request scoping and lifecycle management.</p>"},{"location":"integrations/fastmcp/#getting-started","title":"\ud83c\udfaf Getting Started","text":""},{"location":"integrations/fastmcp/#basic-setup","title":"Basic Setup","text":"<pre><code>from fastmcp import FastMCP\nfrom injectq import InjectQ\nfrom injectq.integrations.fastmcp import setup_fastmcp_integration, InjectQDependency\n\n# 1. Create container and bind services\ncontainer = InjectQ()\ncontainer.bind(IDocumentService, DocumentService())\ncontainer.bind(IUserService, UserService())\ncontainer.bind(IAuthService, AuthService())\n\n# 2. Create FastMCP server\nmcp = FastMCP(\"My MCP Server\")\n\n# 3. Set up integration\nsetup_fastmcp_integration(mcp, container)\n\n# 4. Use dependency injection in tools\n@mcp.tool()\nasync def search_documents(\n    query: str,\n    limit: int = 10,\n    doc_service: IDocumentService = InjectQDependency(IDocumentService),\n    user_service: IUserService = InjectQDependency(IUserService)\n):\n    \"\"\"Search documents with user context.\"\"\"\n    # Get current user from context\n    user = user_service.get_current_user()\n\n    # Search documents\n    results = await doc_service.search_documents(\n        query=query,\n        user_id=user.id,\n        limit=limit\n    )\n\n    return results\n\n@mcp.tool()\nasync def create_document(\n    title: str,\n    content: str,\n    doc_service: IDocumentService = InjectQDependency(IDocumentService),\n    auth_service: IAuthService = InjectQDependency(IAuthService)\n):\n    \"\"\"Create a new document.\"\"\"\n    # Verify permissions\n    if not auth_service.has_permission(\"create_document\"):\n        raise ValueError(\"Insufficient permissions\")\n\n    # Create document\n    document = await doc_service.create_document(\n        title=title,\n        content=content\n    )\n\n    return document\n\n# 5. Start the server\nif __name__ == \"__main__\":\n    mcp.run()\n</code></pre>"},{"location":"integrations/fastmcp/#service-definitions","title":"Service Definitions","text":"<pre><code>from typing import Protocol, List, Optional\nfrom datetime import datetime\n\n# Define service interfaces\nclass IDocumentService(Protocol):\n    async def search_documents(self, query: str, user_id: int, limit: int) -&gt; List[Document]: ...\n    async def create_document(self, title: str, content: str) -&gt; Document: ...\n    async def get_document(self, doc_id: int) -&gt; Optional[Document]: ...\n    async def update_document(self, doc_id: int, title: str, content: str) -&gt; Document: ...\n    async def delete_document(self, doc_id: int) -&gt; bool: ...\n\nclass IUserService(Protocol):\n    def get_current_user(self) -&gt; User: ...\n    def get_user(self, user_id: int) -&gt; Optional[User]: ...\n    def get_user_permissions(self, user_id: int) -&gt; List[str]: ...\n\nclass IAuthService(Protocol):\n    def has_permission(self, permission: str) -&gt; bool: ...\n    def authenticate_user(self, token: str) -&gt; Optional[User]: ...\n    def authorize_action(self, user: User, action: str, resource: str) -&gt; bool: ...\n\n# Data models\nclass User:\n    def __init__(self, id: int, name: str, email: str):\n        self.id = id\n        self.name = name\n        self.email = email\n\nclass Document:\n    def __init__(self, id: int, title: str, content: str, user_id: int, created_at: datetime):\n        self.id = id\n        self.title = title\n        self.content = content\n        self.user_id = user_id\n        self.created_at = created_at\n\n# Implement services\nclass DocumentService:\n    def __init__(self, db: IDatabaseConnection):\n        self.db = db\n\n    async def search_documents(self, query: str, user_id: int, limit: int) -&gt; List[Document]:\n        # Search documents in database\n        return await self.db.query(Document).filter(\n            Document.user_id == user_id,\n            Document.title.contains(query) | Document.content.contains(query)\n        ).limit(limit).all()\n\n    async def create_document(self, title: str, content: str) -&gt; Document:\n        # Get current user from context\n        user_service = self.db.get(IUserService)  # Injected via container\n        user = user_service.get_current_user()\n\n        document = Document(\n            id=self.db.next_id(),\n            title=title,\n            content=content,\n            user_id=user.id,\n            created_at=datetime.now()\n        )\n\n        await self.db.save(document)\n        return document\n\n    async def get_document(self, doc_id: int) -&gt; Optional[Document]:\n        return await self.db.query(Document).filter(Document.id == doc_id).first()\n\n    async def update_document(self, doc_id: int, title: str, content: str) -&gt; Document:\n        document = await self.get_document(doc_id)\n        if not document:\n            raise ValueError(f\"Document {doc_id} not found\")\n\n        document.title = title\n        document.content = content\n        await self.db.save(document)\n        return document\n\n    async def delete_document(self, doc_id: int) -&gt; bool:\n        document = await self.get_document(doc_id)\n        if not document:\n            return False\n\n        await self.db.delete(document)\n        return True\n\nclass UserService:\n    def __init__(self, db: IDatabaseConnection):\n        self.db = db\n        self._current_user = None\n\n    def get_current_user(self) -&gt; User:\n        if self._current_user is None:\n            # Get from request context (set by middleware)\n            self._current_user = self._get_user_from_context()\n        return self._current_user\n\n    def _get_user_from_context(self) -&gt; User:\n        # Implementation depends on your auth system\n        # This would typically get user from request context\n        pass\n\n    def get_user(self, user_id: int) -&gt; Optional[User]:\n        return self.db.query(User).filter(User.id == user_id).first()\n\n    def get_user_permissions(self, user_id: int) -&gt; List[str]:\n        # Get user permissions from database\n        return self.db.query(Permission).filter(Permission.user_id == user_id).all()\n\nclass AuthService:\n    def __init__(self, user_service: IUserService):\n        self.user_service = user_service\n\n    def has_permission(self, permission: str) -&gt; bool:\n        user = self.user_service.get_current_user()\n        permissions = self.user_service.get_user_permissions(user.id)\n        return permission in permissions\n\n    def authenticate_user(self, token: str) -&gt; Optional[User]:\n        # Verify token and return user\n        pass\n\n    def authorize_action(self, user: User, action: str, resource: str) -&gt; bool:\n        # Check if user can perform action on resource\n        pass\n</code></pre>"},{"location":"integrations/fastmcp/#advanced-configuration","title":"\ud83d\udd27 Advanced Configuration","text":""},{"location":"integrations/fastmcp/#request-scoped-services","title":"Request-Scoped Services","text":"<pre><code>from injectq import scoped\n\n@scoped\nclass RequestContext:\n    def __init__(self):\n        self.request_id = str(uuid.uuid4())\n        self.start_time = time.time()\n        self.user = None\n        self.metadata = {}\n\n    def set_user(self, user: User):\n        self.user = user\n\n    def set_metadata(self, key: str, value: Any):\n        self.metadata[key] = value\n\n    def get_duration(self) -&gt; float:\n        return time.time() - self.start_time\n\n@scoped\nclass RequestMetrics:\n    def __init__(self):\n        self.operations = []\n        self.errors = []\n\n    def record_operation(self, operation: str, duration: float):\n        self.operations.append({\n            \"operation\": operation,\n            \"duration\": duration,\n            \"timestamp\": time.time()\n        })\n\n    def record_error(self, error: str):\n        self.errors.append({\n            \"error\": error,\n            \"timestamp\": time.time()\n        })\n\n# Use in MCP tools\n@mcp.tool()\nasync def complex_document_operation(\n    doc_id: int,\n    operation: str,\n    ctx: RequestContext = InjectQDependency(RequestContext),\n    metrics: RequestMetrics = InjectQDependency(RequestMetrics),\n    doc_service: IDocumentService = InjectQDependency(IDocumentService)\n):\n    ctx.set_metadata(\"operation\", operation)\n    ctx.set_metadata(\"doc_id\", doc_id)\n\n    try:\n        # Perform operation with metrics\n        start_time = time.time()\n\n        if operation == \"get\":\n            result = await doc_service.get_document(doc_id)\n        elif operation == \"update\":\n            result = await doc_service.update_document(doc_id, \"New Title\", \"New Content\")\n        else:\n            raise ValueError(f\"Unknown operation: {operation}\")\n\n        duration = time.time() - start_time\n        metrics.record_operation(operation, duration)\n\n        return result\n\n    except Exception as e:\n        metrics.record_error(str(e))\n        raise\n</code></pre>"},{"location":"integrations/fastmcp/#module-based-setup","title":"Module-Based Setup","text":"<pre><code>from injectq import Module\n\nclass DocumentModule(Module):\n    def configure(self, binder):\n        # Document services\n        binder.bind(IDocumentService, DocumentService())\n        binder.bind(IUserService, UserService())\n        binder.bind(IAuthService, AuthService())\n\n        # Request context services\n        binder.bind(RequestContext, RequestContext())\n        binder.bind(RequestMetrics, RequestMetrics())\n\nclass InfrastructureModule(Module):\n    def configure(self, binder):\n        # Database and external services\n        binder.bind(IDatabaseConnection, PostgresConnection())\n        binder.bind(ICacheService, RedisCache())\n\nclass AuthModule(Module):\n    def configure(self, binder):\n        # Authentication services\n        binder.bind(ITokenService, JWTTokenService())\n        binder.bind(ISessionService, SessionService())\n\ndef create_mcp_server() -&gt; FastMCP:\n    # Create container with modules\n    container = InjectQ()\n    container.install(InfrastructureModule())\n    container.install(AuthModule())\n    container.install(DocumentModule())\n\n    # Create MCP server\n    mcp = FastMCP(\"Document Management Server\")\n\n    # Set up integration\n    setup_fastmcp_integration(mcp, container)\n\n    return mcp\n\n# Usage\nmcp = create_mcp_server()\n</code></pre>"},{"location":"integrations/fastmcp/#mcp-tool-patterns","title":"\ud83c\udfa8 MCP Tool Patterns","text":""},{"location":"integrations/fastmcp/#document-management-tools","title":"Document Management Tools","text":"<pre><code>@mcp.tool()\nasync def list_user_documents(\n    limit: int = 20,\n    offset: int = 0,\n    doc_service: IDocumentService = InjectQDependency(IDocumentService)\n):\n    \"\"\"List current user's documents.\"\"\"\n    documents = await doc_service.list_user_documents(limit, offset)\n    return {\n        \"documents\": [\n            {\n                \"id\": doc.id,\n                \"title\": doc.title,\n                \"created_at\": doc.created_at.isoformat()\n            }\n            for doc in documents\n        ],\n        \"total\": len(documents)\n    }\n\n@mcp.tool()\nasync def search_documents(\n    query: str,\n    category: Optional[str] = None,\n    limit: int = 10,\n    doc_service: IDocumentService = InjectQDependency(IDocumentService)\n):\n    \"\"\"Search documents with advanced filters.\"\"\"\n    results = await doc_service.search_documents(\n        query=query,\n        category=category,\n        limit=limit\n    )\n\n    return {\n        \"query\": query,\n        \"results\": [\n            {\n                \"id\": result.id,\n                \"title\": result.title,\n                \"snippet\": result.content[:200] + \"...\" if len(result.content) &gt; 200 else result.content,\n                \"score\": result.score\n            }\n            for result in results\n        ]\n    }\n\n@mcp.tool()\nasync def create_document_from_template(\n    template_id: int,\n    title: str,\n    variables: dict,\n    doc_service: IDocumentService = InjectQDependency(IDocumentService),\n    template_service: ITemplateService = InjectQDependency(ITemplateService)\n):\n    \"\"\"Create document from template with variable substitution.\"\"\"\n    # Get template\n    template = await template_service.get_template(template_id)\n\n    # Substitute variables\n    content = template.content\n    for key, value in variables.items():\n        content = content.replace(f\"{{{{ {key} }}}}\", str(value))\n\n    # Create document\n    document = await doc_service.create_document(title, content)\n\n    return {\n        \"document_id\": document.id,\n        \"title\": document.title,\n        \"created_at\": document.created_at.isoformat()\n    }\n</code></pre>"},{"location":"integrations/fastmcp/#user-management-tools","title":"User Management Tools","text":"<pre><code>@mcp.tool()\nasync def get_user_profile(\n    user_service: IUserService = InjectQDependency(IUserService)\n):\n    \"\"\"Get current user's profile.\"\"\"\n    user = user_service.get_current_user()\n    permissions = user_service.get_user_permissions(user.id)\n\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"email\": user.email,\n        \"permissions\": permissions\n    }\n\n@mcp.tool()\nasync def update_user_preferences(\n    preferences: dict,\n    user_service: IUserService = InjectQDependency(IUserService),\n    preference_service: IPreferenceService = InjectQDependency(IPreferenceService)\n):\n    \"\"\"Update user preferences.\"\"\"\n    user = user_service.get_current_user()\n\n    await preference_service.update_preferences(user.id, preferences)\n\n    return {\"message\": \"Preferences updated successfully\"}\n\n@mcp.tool()\nasync def share_document(\n    document_id: int,\n    target_user_id: int,\n    permissions: List[str],\n    doc_service: IDocumentService = InjectQDependency(IDocumentService),\n    auth_service: IAuthService = InjectQDependency(IAuthService)\n):\n    \"\"\"Share document with another user.\"\"\"\n    # Check if current user owns the document\n    document = await doc_service.get_document(document_id)\n    current_user = doc_service.user_service.get_current_user()\n\n    if document.user_id != current_user.id:\n        raise ValueError(\"You can only share documents you own\")\n\n    # Check permissions\n    if not auth_service.authorize_action(current_user, \"share\", \"document\"):\n        raise ValueError(\"Insufficient permissions to share documents\")\n\n    # Share document\n    await doc_service.share_document(document_id, target_user_id, permissions)\n\n    return {\"message\": f\"Document shared with user {target_user_id}\"}\n</code></pre>"},{"location":"integrations/fastmcp/#analytics-and-reporting-tools","title":"Analytics and Reporting Tools","text":"<pre><code>@mcp.tool()\nasync def get_document_stats(\n    document_id: int,\n    analytics_service: IAnalyticsService = InjectQDependency(IAnalyticsService),\n    auth_service: IAuthService = InjectQDependency(IAuthService)\n):\n    \"\"\"Get analytics for a document.\"\"\"\n    # Check permissions\n    if not auth_service.has_permission(\"view_analytics\"):\n        raise ValueError(\"Insufficient permissions\")\n\n    stats = await analytics_service.get_document_stats(document_id)\n\n    return {\n        \"document_id\": document_id,\n        \"views\": stats.views,\n        \"unique_viewers\": stats.unique_viewers,\n        \"last_viewed\": stats.last_viewed.isoformat() if stats.last_viewed else None,\n        \"average_session_duration\": stats.average_session_duration\n    }\n\n@mcp.tool()\nasync def generate_user_report(\n    user_id: Optional[int] = None,\n    date_from: Optional[str] = None,\n    date_to: Optional[str] = None,\n    report_service: IReportService = InjectQDependency(IReportService),\n    auth_service: IAuthService = InjectQDependency(IAuthService)\n):\n    \"\"\"Generate user activity report.\"\"\"\n    # Check permissions\n    if not auth_service.has_permission(\"generate_reports\"):\n        raise ValueError(\"Insufficient permissions\")\n\n    # Default to current user if not specified\n    if user_id is None:\n        user_service = report_service.container.get(IUserService)\n        user_id = user_service.get_current_user().id\n\n    # Parse dates\n    from_date = datetime.fromisoformat(date_from) if date_from else None\n    to_date = datetime.fromisoformat(date_to) if date_to else None\n\n    # Generate report\n    report = await report_service.generate_user_report(\n        user_id=user_id,\n        from_date=from_date,\n        to_date=to_date\n    )\n\n    return {\n        \"user_id\": user_id,\n        \"period\": {\n            \"from\": from_date.isoformat() if from_date else None,\n            \"to\": to_date.isoformat() if to_date else None\n        },\n        \"documents_created\": report.documents_created,\n        \"documents_viewed\": report.documents_viewed,\n        \"total_activity_time\": report.total_activity_time,\n        \"most_active_day\": report.most_active_day.isoformat() if report.most_active_day else None\n    }\n</code></pre>"},{"location":"integrations/fastmcp/#testing-fastmcp-integration","title":"\ud83e\uddea Testing FastMCP Integration","text":""},{"location":"integrations/fastmcp/#unit-testing-tools","title":"Unit Testing Tools","text":"<pre><code>import pytest\nfrom injectq.integrations.fastmcp import setup_fastmcp_integration\n\n@pytest.fixture\ndef test_mcp():\n    # Create test container\n    container = InjectQ()\n    container.bind(IDocumentService, MockDocumentService())\n    container.bind(IUserService, MockUserService())\n\n    # Create test MCP server\n    mcp = FastMCP(\"Test Server\")\n    setup_fastmcp_integration(mcp, container)\n\n    return mcp\n\ndef test_search_documents_tool(test_mcp):\n    # Define test tool\n    @test_mcp.tool()\n    async def search_documents(\n        query: str,\n        doc_service: IDocumentService = InjectQDependency(IDocumentService)\n    ):\n        results = await doc_service.search_documents(query, user_id=1, limit=5)\n        return {\"results\": results, \"count\": len(results)}\n\n    # Mock the request context\n    with test_mcp.test_context():\n        # Execute tool\n        result = await test_mcp.call_tool(\"search_documents\", {\"query\": \"test\"})\n\n        # Verify result\n        assert \"results\" in result\n        assert \"count\" in result\n        assert result[\"count\"] &gt; 0\n\ndef test_request_scoping(test_mcp):\n    # Define tool with scoped service\n    @test_mcp.tool()\n    async def scoped_tool(\n        data: str,\n        ctx: RequestContext = InjectQDependency(RequestContext)\n    ):\n        ctx.set_metadata(\"input\", data)\n        return ctx.metadata\n\n    # Execute multiple requests\n    with test_mcp.test_context():\n        result1 = await test_mcp.call_tool(\"scoped_tool\", {\"data\": \"test1\"})\n        result2 = await test_mcp.call_tool(\"scoped_tool\", {\"data\": \"test2\"})\n\n    # Each request should have its own context\n    assert result1[\"input\"] == \"test1\"\n    assert result2[\"input\"] == \"test2\"\n</code></pre>"},{"location":"integrations/fastmcp/#integration-testing","title":"Integration Testing","text":"<pre><code>@pytest.fixture\ndef integration_mcp():\n    # Real container with test database\n    container = InjectQ()\n    container.install(TestDatabaseModule())\n    container.install(DocumentModule())\n    container.install(AuthModule())\n\n    mcp = FastMCP(\"Integration Test Server\")\n    setup_fastmcp_integration(mcp, container)\n\n    return mcp\n\ndef test_document_creation_integration(integration_mcp):\n    # Define integration tool\n    @integration_mcp.tool()\n    async def create_test_document(\n        title: str,\n        content: str,\n        doc_service: IDocumentService = InjectQDependency(IDocumentService)\n    ):\n        document = await doc_service.create_document(title, content)\n        return {\n            \"id\": document.id,\n            \"title\": document.title,\n            \"content_length\": len(document.content)\n        }\n\n    # Execute tool\n    with integration_mcp.test_context():\n        result = await integration_mcp.call_tool(\"create_test_document\", {\n            \"title\": \"Test Document\",\n            \"content\": \"This is a test document content.\"\n        })\n\n    # Verify result\n    assert result[\"title\"] == \"Test Document\"\n    assert result[\"content_length\"] == len(\"This is a test document content.\")\n    assert \"id\" in result\n\ndef test_error_handling_integration(integration_mcp):\n    # Define tool that might fail\n    @integration_mcp.tool()\n    async def risky_tool(\n        doc_id: int,\n        doc_service: IDocumentService = InjectQDependency(IDocumentService)\n    ):\n        document = await doc_service.get_document(doc_id)\n        if not document:\n            raise ValueError(\"Document not found\")\n        return {\"title\": document.title}\n\n    # Test successful case\n    with integration_mcp.test_context():\n        # First create a document\n        create_result = await integration_mcp.call_tool(\"create_test_document\", {\n            \"title\": \"Test\",\n            \"content\": \"Content\"\n        })\n\n        # Then retrieve it\n        result = await integration_mcp.call_tool(\"risky_tool\", {\n            \"doc_id\": create_result[\"id\"]\n        })\n\n        assert result[\"title\"] == \"Test\"\n\n    # Test error case\n    with integration_mcp.test_context():\n        with pytest.raises(ValueError, match=\"Document not found\"):\n            await integration_mcp.call_tool(\"risky_tool\", {\"doc_id\": 99999})\n</code></pre>"},{"location":"integrations/fastmcp/#mock-testing","title":"Mock Testing","text":"<pre><code>class MockDocumentService:\n    def __init__(self):\n        self.documents = {}\n        self.next_id = 1\n\n    async def search_documents(self, query: str, user_id: int, limit: int):\n        # Simple mock search\n        results = [\n            doc for doc in self.documents.values()\n            if query.lower() in doc.title.lower() or query.lower() in doc.content.lower()\n        ]\n        return results[:limit]\n\n    async def create_document(self, title: str, content: str):\n        doc_id = self.next_id\n        self.next_id += 1\n\n        document = Document(\n            id=doc_id,\n            title=title,\n            content=content,\n            user_id=1,  # Mock user\n            created_at=datetime.now()\n        )\n\n        self.documents[doc_id] = document\n        return document\n\n    async def get_document(self, doc_id: int):\n        return self.documents.get(doc_id)\n\nclass MockUserService:\n    def __init__(self):\n        self.current_user = User(id=1, name=\"Test User\", email=\"test@example.com\")\n\n    def get_current_user(self):\n        return self.current_user\n\n    def get_user(self, user_id: int):\n        if user_id == 1:\n            return self.current_user\n        return None\n\ndef test_with_mocks():\n    container = InjectQ()\n    mock_doc = MockDocumentService()\n    mock_user = MockUserService()\n\n    container.bind(IDocumentService, mock_doc)\n    container.bind(IUserService, mock_user)\n\n    mcp = FastMCP(\"Mock Test Server\")\n    setup_fastmcp_integration(mcp, container)\n\n    @mcp.tool()\n    async def test_tool(\n        title: str,\n        doc_service: IDocumentService = InjectQDependency(IDocumentService)\n    ):\n        doc = await doc_service.create_document(title, \"Test content\")\n        return {\"created_id\": doc.id, \"documents_count\": len(mock_doc.documents)}\n\n    # Execute tool\n    with mcp.test_context():\n        result = await mcp.call_tool(\"test_tool\", {\"title\": \"Mock Test\"})\n\n    # Verify mock interactions\n    assert result[\"created_id\"] == 1\n    assert result[\"documents_count\"] == 1\n    assert len(mock_doc.documents) == 1\n</code></pre>"},{"location":"integrations/fastmcp/#common-patterns-and-pitfalls","title":"\ud83d\udea8 Common Patterns and Pitfalls","text":""},{"location":"integrations/fastmcp/#good-patterns","title":"\u2705 Good Patterns","text":""},{"location":"integrations/fastmcp/#1-proper-request-scoping","title":"1. Proper Request Scoping","text":"<pre><code># \u2705 Good: Use scoped for request-specific data\n@scoped\nclass RequestContext:\n    def __init__(self):\n        self.request_id = str(uuid.uuid4())\n        self.user = None\n        self.metadata = {}\n\n# \u2705 Good: Use singleton for shared resources\n@singleton\nclass DatabasePool:\n    def __init__(self):\n        self.pool = create_database_pool()\n\n# \u2705 Good: Use transient for stateless operations\n@transient\nclass DataValidator:\n    def validate(self, data: dict) -&gt; bool:\n        return validate_schema(data)\n</code></pre>"},{"location":"integrations/fastmcp/#2-error-handling","title":"2. Error Handling","text":"<pre><code># \u2705 Good: Handle tool errors gracefully\n@mcp.tool()\nasync def safe_tool_operation(\n    data: dict,\n    service: IService = InjectQDependency(IService),\n    logger: ILogger = InjectQDependency(ILogger)\n):\n    try:\n        result = await service.process_data(data)\n        return result\n    except ValidationError as e:\n        logger.error(f\"Validation failed: {e}\")\n        return {\"error\": \"Invalid data\", \"details\": str(e)}\n    except Exception as e:\n        logger.error(f\"Unexpected error: {e}\")\n        return {\"error\": \"Internal server error\"}\n</code></pre>"},{"location":"integrations/fastmcp/#3-permission-checking","title":"3. Permission Checking","text":"<pre><code># \u2705 Good: Check permissions before operations\n@mcp.tool()\nasync def secure_document_operation(\n    doc_id: int,\n    operation: str,\n    auth_service: IAuthService = InjectQDependency(IAuthService),\n    doc_service: IDocumentService = InjectQDependency(IDocumentService)\n):\n    # Check permissions first\n    if not auth_service.has_permission(f\"document.{operation}\"):\n        raise ValueError(f\"Insufficient permissions for {operation}\")\n\n    # Perform operation\n    if operation == \"read\":\n        return await doc_service.get_document(doc_id)\n    elif operation == \"update\":\n        return await doc_service.update_document(doc_id, \"New Title\", \"New Content\")\n    else:\n        raise ValueError(f\"Unknown operation: {operation}\")\n</code></pre>"},{"location":"integrations/fastmcp/#bad-patterns","title":"\u274c Bad Patterns","text":""},{"location":"integrations/fastmcp/#1-manual-container-access","title":"1. Manual Container Access","text":"<pre><code># \u274c Bad: Manual container access in tools\ncontainer = InjectQ()  # Global container\n\n@mcp.tool()\nasync def manual_tool(user_id: int):\n    user_service = container.get(IUserService)  # Manual resolution\n    return user_service.get_user(user_id)\n\n# \u2705 Good: Use dependency injection\n@mcp.tool()\nasync def injected_tool(\n    user_id: int,\n    user_service: IUserService = InjectQDependency(IUserService)\n):\n    return user_service.get_user(user_id)\n</code></pre>"},{"location":"integrations/fastmcp/#2-singleton-abuse","title":"2. Singleton Abuse","text":"<pre><code># \u274c Bad: Singleton for request-specific state\n@singleton\nclass RequestState:\n    def __init__(self):\n        self.current_request_data = None  # Shared across requests!\n\n    def set_request_data(self, data):\n        self.current_request_data = data  # Overwrites other requests!\n\n# \u274c Bad: Singleton for mutable request data\n@singleton\nclass RequestMetrics:\n    def __init__(self):\n        self.request_count = 0  # Accumulates across all requests\n\n    def increment_request_count(self):\n        self.request_count += 1  # Not request-specific\n\n# \u2705 Good: Scoped for request-specific data\n@scoped\nclass RequestState:\n    def __init__(self):\n        self.request_data = None\n\n@scoped\nclass RequestMetrics:\n    def __init__(self):\n        self.operations = []\n</code></pre>"},{"location":"integrations/fastmcp/#3-heavy-operations-in-tools","title":"3. Heavy Operations in Tools","text":"<pre><code># \u274c Bad: Heavy initialization per request\n@mcp.tool()\nasync def heavy_tool(data: dict):\n    # Load model on every request\n    model = await load_ml_model()  # 2GB model!\n    result = model.predict(data)\n    return result\n\n# \u2705 Good: Pre-load heavy resources\n@singleton\nclass MLModelService:\n    def __init__(self):\n        self.model = None\n\n    async def initialize(self):\n        if self.model is None:\n            self.model = await load_ml_model()\n\n    async def predict(self, data: dict):\n        await self.initialize()\n        return self.model.predict(data)\n\n@mcp.tool()\nasync def light_tool(\n    data: dict,\n    ml_service: MLModelService = InjectQDependency(MLModelService)\n):\n    return await ml_service.predict(data)\n</code></pre>"},{"location":"integrations/fastmcp/#advanced-features","title":"\u26a1 Advanced Features","text":""},{"location":"integrations/fastmcp/#custom-mcp-middleware","title":"Custom MCP Middleware","text":"<pre><code>from injectq.integrations.fastmcp import FastMCPMiddleware\n\nclass MetricsMiddleware(FastMCPMiddleware):\n    def __init__(self, metrics_service: IMetricsService):\n        self.metrics = metrics_service\n\n    async def before_tool_call(self, tool_name, args):\n        # Record tool call start\n        self.metrics.increment(\"tool_calls_started\")\n        self.metrics.increment(f\"tool_{tool_name}_calls\")\n\n    async def after_tool_call(self, tool_name, args, result, duration):\n        # Record tool call completion\n        self.metrics.histogram(\"tool_call_duration\", duration)\n        self.metrics.increment(\"tool_calls_completed\")\n\n    async def on_tool_error(self, tool_name, args, error):\n        # Record tool call failure\n        self.metrics.increment(\"tool_calls_failed\")\n        self.metrics.increment(f\"tool_error_{type(error).__name__}\")\n\n# Use custom middleware\nsetup_fastmcp_integration(\n    mcp,\n    container,\n    middlewares=[MetricsMiddleware(metrics_service)]\n)\n</code></pre>"},{"location":"integrations/fastmcp/#tool-result-caching","title":"Tool Result Caching","text":"<pre><code>@scoped\nclass ToolCache:\n    def __init__(self):\n        self.cache = {}\n\n    def get(self, key: str):\n        return self.cache.get(key)\n\n    def set(self, key: str, value: Any, ttl: int = 300):\n        self.cache[key] = {\n            \"value\": value,\n            \"expires_at\": time.time() + ttl\n        }\n\n    def is_expired(self, key: str) -&gt; bool:\n        if key not in self.cache:\n            return True\n        return time.time() &gt; self.cache[key][\"expires_at\"]\n\n@mcp.tool()\nasync def cached_search_documents(\n    query: str,\n    cache: ToolCache = InjectQDependency(ToolCache),\n    doc_service: IDocumentService = InjectQDependency(IDocumentService)\n):\n    \"\"\"Search documents with caching.\"\"\"\n    cache_key = f\"search:{query}\"\n\n    # Check cache first\n    if not cache.is_expired(cache_key):\n        return cache.get(cache_key)[\"value\"]\n\n    # Perform search\n    results = await doc_service.search_documents(query, user_id=1, limit=10)\n\n    # Cache results\n    cache.set(cache_key, results)\n\n    return results\n</code></pre>"},{"location":"integrations/fastmcp/#tool-composition","title":"Tool Composition","text":"<pre><code>@mcp.tool()\nasync def complex_workflow(\n    input_data: dict,\n    validator: IDataValidator = InjectQDependency(IDataValidator),\n    processor: IDataProcessor = InjectQDependency(IDataProcessor),\n    formatter: IDataFormatter = InjectQDependency(IDataFormatter)\n):\n    \"\"\"Complex workflow combining multiple services.\"\"\"\n    # Step 1: Validate input\n    validation_result = validator.validate(input_data)\n    if not validation_result.valid:\n        return {\"error\": \"Validation failed\", \"details\": validation_result.errors}\n\n    # Step 2: Process data\n    processed_data = await processor.process_data(input_data)\n\n    # Step 3: Format output\n    formatted_result = formatter.format_data(processed_data)\n\n    return {\n        \"success\": True,\n        \"original_input\": input_data,\n        \"processed_data\": processed_data,\n        \"formatted_result\": formatted_result\n    }\n\n@mcp.tool()\nasync def batch_operation(\n    items: List[dict],\n    batch_processor: IBatchProcessor = InjectQDependency(IBatchProcessor)\n):\n    \"\"\"Process multiple items in batch.\"\"\"\n    # Process items in parallel\n    results = await batch_processor.process_batch(items)\n\n    # Group results\n    successful = [r for r in results if r.success]\n    failed = [r for r in results if not r.success]\n\n    return {\n        \"total_items\": len(items),\n        \"successful\": len(successful),\n        \"failed\": len(failed),\n        \"results\": results\n    }\n</code></pre>"},{"location":"integrations/fastmcp/#summary","title":"\ud83c\udfaf Summary","text":"<p>FastMCP integration provides:</p> <ul> <li>Automatic dependency injection - No manual container management in tools</li> <li>Request-scoped services - Proper isolation per MCP request</li> <li>Type-driven injection - Just add type hints to tool parameters</li> <li>Framework lifecycle integration - Automatic cleanup and resource management</li> <li>Testing support - Easy mocking and test isolation</li> </ul> <p>Key features: - Seamless integration with FastMCP's tool system - Support for all InjectQ scopes (singleton, scoped, transient) - Request-scoped container access - Custom middleware support - Tool result caching - Tool composition patterns</p> <p>Best practices: - Use scoped services for request-specific data - Use singleton for shared resources and heavy objects - Use transient for stateless operations - Handle errors gracefully in tools - Check permissions before operations - Test thoroughly with mocked dependencies - Avoid manual container access in tools</p> <p>Congratulations! You've completed the framework integrations section. Ready to explore testing utilities?</p>"},{"location":"integrations/overview/","title":"Framework Integrations","text":"<p>Framework integrations enable seamless dependency injection with popular Python frameworks like FastAPI, Taskiq, and FastMCP, providing automatic service resolution and request-scoped dependencies.</p>"},{"location":"integrations/overview/#what-are-framework-integrations","title":"\ud83c\udfaf What are Framework Integrations?","text":"<p>Framework integrations automatically handle dependency injection within the framework's request/response lifecycle, eliminating manual container management and ensuring proper scope isolation.</p> <pre><code>from injectq import InjectQ\nfrom injectq.integrations.fastapi import InjectQDependency\n\n# Set up container\ncontainer = InjectQ()\ncontainer.bind(IUserService, UserService())\ncontainer.bind(IOrderService, OrderService())\n\n# FastAPI integration\napp = FastAPI()\n\n@app.get(\"/users/{user_id}\")\nasync def get_user(\n    user_id: int,\n    user_service: IUserService = InjectQDependency(IUserService)\n):\n    # user_service is automatically resolved from container\n    # Each request gets properly scoped dependencies\n    return user_service.get_user(user_id)\n\n@app.post(\"/orders\")\nasync def create_order(\n    order_data: OrderCreate,\n    order_service: IOrderService = InjectQDependency(IOrderService),\n    user_service: IUserService = InjectQDependency(IUserService)\n):\n    # Both services are injected automatically\n    # Same request scope shared between services\n    user = user_service.get_current_user()\n    order = order_service.create_order(user.id, order_data)\n    return order\n</code></pre>"},{"location":"integrations/overview/#integration-benefits","title":"\ud83c\udfd7\ufe0f Integration Benefits","text":""},{"location":"integrations/overview/#automatic-resolution","title":"\u2705 Automatic Resolution","text":"<ul> <li>No manual container calls - Services resolved automatically</li> <li>Type hints drive injection - Just add type hints</li> <li>Framework lifecycle aware - Proper cleanup and scoping</li> </ul> <pre><code># Without integration - manual resolution\n@app.get(\"/users/{user_id}\")\nasync def get_user_manual(user_id: int):\n    user_service = container.get(IUserService)  # Manual\n    return user_service.get_user(user_id)\n\n# With integration - automatic resolution\n@app.get(\"/users/{user_id}\")\nasync def get_user_auto(\n    user_id: int,\n    user_service: IUserService = InjectQDependency(IUserService)  # Automatic\n):\n    return user_service.get_user(user_id)\n</code></pre>"},{"location":"integrations/overview/#request-scoping","title":"\u2705 Request Scoping","text":"<ul> <li>Automatic scope management - Per-request service instances</li> <li>Isolation between requests - No state leakage</li> <li>Resource cleanup - Automatic disposal at request end</li> </ul> <pre><code>@scoped\nclass RequestCache:\n    def __init__(self):\n        self.data = {}\n\n# Each request gets its own cache instance\n@app.get(\"/data\")\nasync def get_data(\n    cache: RequestCache = InjectQDependency(RequestCache)\n):\n    if \"data\" not in cache.data:\n        cache.data[\"data\"] = expensive_operation()\n    return cache.data[\"data\"]\n</code></pre>"},{"location":"integrations/overview/#framework-compatibility","title":"\u2705 Framework Compatibility","text":"<ul> <li>Works with existing code - No framework modifications needed</li> <li>Preserves framework features - All FastAPI/Taskiq features work</li> <li>Multiple integration support - Use multiple frameworks together</li> </ul>"},{"location":"integrations/overview/#integration-types","title":"\ud83d\udd27 Integration Types","text":""},{"location":"integrations/overview/#fastapi-integration","title":"FastAPI Integration","text":"<p>FastAPI integration provides automatic dependency injection for web endpoints with proper request scoping.</p> <pre><code>from fastapi import FastAPI\nfrom injectq.integrations.fastapi import InjectQDependency, setup_fastapi_integration\n\n# Set up container\ncontainer = InjectQ()\ncontainer.bind(IUserService, UserService())\ncontainer.bind(IAuthService, AuthService())\n\n# Create FastAPI app with integration\napp = FastAPI()\nsetup_fastapi_integration(app, container)\n\n# Use in endpoints\n@app.get(\"/users/me\")\nasync def get_current_user(\n    auth_service: IAuthService = InjectQDependency(IAuthService),\n    user_service: IUserService = InjectQDependency(IUserService)\n):\n    user_id = auth_service.get_current_user_id()\n    return user_service.get_user(user_id)\n\n@app.post(\"/users\")\nasync def create_user(\n    user_data: UserCreate,\n    user_service: IUserService = InjectQDependency(IUserService)\n):\n    return user_service.create_user(user_data)\n</code></pre>"},{"location":"integrations/overview/#taskiq-integration","title":"Taskiq Integration","text":"<p>Taskiq integration enables dependency injection for background tasks and workers.</p> <pre><code>from taskiq import TaskiqScheduler\nfrom injectq.integrations.taskiq import setup_taskiq_integration\n\n# Set up container\ncontainer = InjectQ()\ncontainer.bind(IEmailService, EmailService())\ncontainer.bind(IUserService, UserService())\n\n# Create scheduler with integration\nscheduler = TaskiqScheduler()\nsetup_taskiq_integration(scheduler, container)\n\n# Use in tasks\n@scheduler.task\nasync def send_welcome_email(\n    user_id: int,\n    email_service: IEmailService = InjectQDependency(IEmailService),\n    user_service: IUserService = InjectQDependency(IUserService)\n):\n    user = user_service.get_user(user_id)\n    await email_service.send_welcome_email(user.email)\n\n# Schedule task\nawait scheduler.schedule_task(send_welcome_email, user_id=123)\n</code></pre>"},{"location":"integrations/overview/#fastmcp-integration","title":"FastMCP Integration","text":"<p>FastMCP integration provides dependency injection for MCP (Model Context Protocol) servers.</p> <pre><code>from fastmcp import FastMCP\nfrom injectq.integrations.fastmcp import setup_fastmcp_integration\n\n# Set up container\ncontainer = InjectQ()\ncontainer.bind(IDocumentService, DocumentService())\ncontainer.bind(IAIService, AIService())\n\n# Create FastMCP server with integration\nmcp = FastMCP(\"MyAIAssistant\")\nsetup_fastmcp_integration(mcp, container)\n\n# Use in tools\n@mcp.tool()\nasync def analyze_document(\n    document_id: str,\n    doc_service: IDocumentService = InjectQDependency(IDocumentService),\n    ai_service: IAIService = InjectQDependency(IAIService)\n):\n    document = doc_service.get_document(document_id)\n    analysis = await ai_service.analyze_document(document)\n    return analysis\n\n# Run server\nmcp.run()\n</code></pre>"},{"location":"integrations/overview/#integration-patterns","title":"\ud83c\udfa8 Integration Patterns","text":""},{"location":"integrations/overview/#middleware-integration","title":"Middleware Integration","text":"<pre><code>from fastapi import Request\nfrom injectq.integrations.fastapi import get_request_container\n\n# Custom middleware with container access\n@app.middleware(\"http\")\nasync def container_middleware(request: Request, call_next):\n    # Get request-scoped container\n    container = get_request_container(request)\n\n    # Add request-specific services\n    container.bind(IRequestContext, RequestContext(request))\n\n    response = await call_next(request)\n    return response\n\n# Use request context in endpoints\n@app.get(\"/data\")\nasync def get_data(\n    request: Request,\n    ctx: IRequestContext = InjectQDependency(IRequestContext)\n):\n    # Access request-specific data\n    return {\"user_agent\": ctx.user_agent, \"path\": ctx.path}\n</code></pre>"},{"location":"integrations/overview/#authentication-integration","title":"Authentication Integration","text":"<pre><code>from fastapi.security import HTTPBearer\nfrom injectq.integrations.fastapi import InjectQDependency\n\nsecurity = HTTPBearer()\n\n@singleton\nclass AuthService:\n    def get_current_user(self, token: str) -&gt; User:\n        # Validate token and return user\n        return decode_jwt_token(token)\n\n# Protected endpoint with automatic auth\n@app.get(\"/protected\")\nasync def protected_endpoint(\n    credentials = Depends(security),\n    auth_service: IAuthService = InjectQDependency(IAuthService),\n    user_service: IUserService = InjectQDependency(IUserService)\n):\n    user = auth_service.get_current_user(credentials.credentials)\n    data = user_service.get_user_data(user.id)\n    return data\n</code></pre>"},{"location":"integrations/overview/#database-transaction-integration","title":"Database Transaction Integration","text":"<pre><code>@scoped\nclass DatabaseTransaction:\n    def __init__(self, db: IDatabaseConnection):\n        self.db = db\n        self.transaction = db.begin_transaction()\n\n    def commit(self):\n        self.transaction.commit()\n\n    def rollback(self):\n        self.transaction.rollback()\n\n# Automatic transaction management\n@app.post(\"/orders\")\nasync def create_order(\n    order_data: OrderCreate,\n    transaction: DatabaseTransaction = InjectQDependency(DatabaseTransaction),\n    order_service: IOrderService = InjectQDependency(IOrderService)\n):\n    try:\n        order = order_service.create_order(order_data)\n        transaction.commit()\n        return order\n    except Exception:\n        transaction.rollback()\n        raise\n</code></pre>"},{"location":"integrations/overview/#testing-framework-integrations","title":"\ud83e\uddea Testing Framework Integrations","text":""},{"location":"integrations/overview/#integration-testing","title":"Integration Testing","text":"<pre><code>from fastapi.testclient import TestClient\nfrom injectq.integrations.fastapi import setup_fastapi_integration\n\ndef test_fastapi_integration():\n    # Create test container\n    container = InjectQ()\n    container.bind(IUserService, MockUserService())\n\n    # Create test app\n    app = FastAPI()\n    setup_fastapi_integration(app, container)\n\n    @app.get(\"/users/{user_id}\")\n    async def get_user(\n        user_id: int,\n        user_service: IUserService = InjectQDependency(IUserService)\n    ):\n        return user_service.get_user(user_id)\n\n    # Test with client\n    client = TestClient(app)\n    response = client.get(\"/users/123\")\n\n    assert response.status_code == 200\n    assert response.json()[\"id\"] == 123\n\ndef test_request_scoping():\n    container = InjectQ()\n\n    @scoped\n    class RequestCounter:\n        def __init__(self):\n            self.count = 0\n\n        def increment(self):\n            self.count += 1\n            return self.count\n\n    container.bind(RequestCounter, RequestCounter())\n\n    app = FastAPI()\n    setup_fastapi_integration(app, container)\n\n    @app.get(\"/count\")\n    async def get_count(\n        counter: RequestCounter = InjectQDependency(RequestCounter)\n    ):\n        return {\"count\": counter.increment()}\n\n    client = TestClient(app)\n\n    # Each request should get its own counter\n    response1 = client.get(\"/count\")\n    response2 = client.get(\"/count\")\n\n    assert response1.json()[\"count\"] == 1\n    assert response2.json()[\"count\"] == 1  # New request, new counter\n</code></pre>"},{"location":"integrations/overview/#mock-integration","title":"Mock Integration","text":"<pre><code>def test_with_mocked_services():\n    # Create container with mocks\n    container = InjectQ()\n    container.bind(IUserService, MockUserService())\n    container.bind(IEmailService, MockEmailService())\n\n    app = FastAPI()\n    setup_fastapi_integration(app, container)\n\n    @app.post(\"/users\")\n    async def create_user(\n        user_data: UserCreate,\n        user_service: IUserService = InjectQDependency(IUserService),\n        email_service: IEmailService = InjectQDependency(IEmailService)\n    ):\n        user = user_service.create_user(user_data)\n        email_service.send_welcome_email(user.email)\n        return user\n\n    client = TestClient(app)\n\n    # Test endpoint\n    response = client.post(\"/users\", json={\"name\": \"Test\", \"email\": \"test@example.com\"})\n\n    assert response.status_code == 200\n\n    # Verify mocks were called\n    mock_user_service = container.get(IUserService)\n    mock_email_service = container.get(IEmailService)\n\n    assert len(mock_user_service.created_users) == 1\n    assert len(mock_email_service.sent_emails) == 1\n</code></pre>"},{"location":"integrations/overview/#integration-considerations","title":"\ud83d\udea8 Integration Considerations","text":""},{"location":"integrations/overview/#scope-management","title":"Scope Management","text":"<pre><code># \u2705 Good: Proper scoping\n@scoped\nclass RequestService:\n    def __init__(self):\n        self.data = {}\n\n# \u274c Bad: Singleton in request context\n@singleton\nclass RequestService:\n    def __init__(self):\n        self.data = {}  # Shared across requests!\n</code></pre>"},{"location":"integrations/overview/#error-handling","title":"Error Handling","text":"<pre><code># \u2705 Good: Integration handles errors gracefully\n@app.get(\"/data\")\nasync def get_data(\n    service: IService = InjectQDependency(IService)\n):\n    try:\n        return service.get_data()\n    except ServiceError:\n        raise HTTPException(status_code=500, detail=\"Service error\")\n\n# \u274c Bad: Let integration errors bubble up\n@app.get(\"/data\")\nasync def get_data(\n    service: IService = InjectQDependency(IService)\n):\n    return service.get_data()  # May raise unexpected errors\n</code></pre>"},{"location":"integrations/overview/#performance-considerations","title":"Performance Considerations","text":"<pre><code># \u2705 Good: Efficient resolution\n@transient\nclass LightweightService:\n    def process(self, data):\n        return data.upper()\n\n# \u274c Bad: Heavy services per request\n@transient\nclass HeavyService:\n    def __init__(self):\n        self.model = load_ml_model()  # 500MB model per request!\n</code></pre>"},{"location":"integrations/overview/#advanced-integration-features","title":"\u26a1 Advanced Integration Features","text":""},{"location":"integrations/overview/#custom-dependency-resolvers","title":"Custom Dependency Resolvers","text":"<pre><code>from injectq.integrations.fastapi import InjectQDependencyResolver\n\nclass CustomResolver(InjectQDependencyResolver):\n    def resolve_dependency(self, dependency_type: Type[T]) -&gt; T:\n        # Custom resolution logic\n        if dependency_type == ISpecialService:\n            return self.create_special_service()\n\n        # Fall back to default\n        return super().resolve_dependency(dependency_type)\n\n# Use custom resolver\nsetup_fastapi_integration(app, container, resolver=CustomResolver())\n</code></pre>"},{"location":"integrations/overview/#integration-plugins","title":"Integration Plugins","text":"<pre><code>class MetricsIntegration:\n    \"\"\"Integration that adds metrics to all endpoints.\"\"\"\n\n    def __init__(self, metrics_service: IMetricsService):\n        self.metrics = metrics_service\n\n    def setup(self, app: FastAPI):\n        @app.middleware(\"http\")\n        async def metrics_middleware(request, call_next):\n            start_time = time.time()\n\n            response = await call_next(request)\n\n            duration = time.time() - start_time\n            self.metrics.record_request(\n                method=request.method,\n                path=request.url.path,\n                duration=duration,\n                status=response.status_code\n            )\n\n            return response\n\n# Use metrics integration\nmetrics_integration = MetricsIntegration(metrics_service)\nmetrics_integration.setup(app)\n</code></pre>"},{"location":"integrations/overview/#multi-framework-support","title":"Multi-Framework Support","text":"<pre><code># Application using multiple frameworks\ncontainer = InjectQ()\n\n# Set up FastAPI\nfastapi_app = FastAPI()\nsetup_fastapi_integration(fastapi_app, container)\n\n# Set up Taskiq\ntaskiq_scheduler = TaskiqScheduler()\nsetup_taskiq_integration(taskiq_scheduler, container)\n\n# Set up FastMCP\nmcp_server = FastMCP(\"MyAssistant\")\nsetup_fastmcp_integration(mcp_server, container)\n\n# All frameworks share the same container\n# Services are properly scoped per framework context\n</code></pre>"},{"location":"integrations/overview/#summary","title":"\ud83c\udfaf Summary","text":"<p>Framework integrations provide:</p> <ul> <li>Automatic dependency resolution - No manual container calls</li> <li>Request-scoped services - Proper isolation per request</li> <li>Framework lifecycle integration - Automatic cleanup</li> <li>Type-driven injection - Just add type hints</li> <li>Multi-framework support - Use FastAPI, Taskiq, FastMCP together</li> </ul> <p>Key benefits: - Seamless integration with existing frameworks - Proper scoping and resource management - Reduced boilerplate code - Enhanced testability - Framework-agnostic service definitions</p> <p>Supported frameworks: - FastAPI - Web API dependency injection - Taskiq - Background task dependency injection - FastMCP - MCP server dependency injection</p> <p>Ready to explore FastAPI integration in detail?</p>"},{"location":"integrations/taskiq/","title":"Taskiq Integration","text":"<p>Taskiq integration enables dependency injection for background tasks and workers, providing automatic service resolution with proper task scoping and lifecycle management.</p>"},{"location":"integrations/taskiq/#getting-started","title":"\ud83c\udfaf Getting Started","text":""},{"location":"integrations/taskiq/#basic-setup","title":"Basic Setup","text":"<pre><code>from taskiq import TaskiqScheduler\nfrom injectq import InjectQ\nfrom injectq.integrations.taskiq import setup_taskiq_integration, InjectQDependency\n\n# 1. Create container and bind services\ncontainer = InjectQ()\ncontainer.bind(IEmailService, EmailService())\ncontainer.bind(IUserService, UserService())\ncontainer.bind(INotificationService, NotificationService())\n\n# 2. Create Taskiq scheduler\nscheduler = TaskiqScheduler()\n\n# 3. Set up integration\nsetup_taskiq_integration(scheduler, container)\n\n# 4. Use dependency injection in tasks\n@scheduler.task\nasync def send_welcome_email(\n    user_id: int,\n    email_service: IEmailService = InjectQDependency(IEmailService),\n    user_service: IUserService = InjectQDependency(IUserService)\n):\n    user = user_service.get_user(user_id)\n    await email_service.send_welcome_email(user.email)\n\n@scheduler.task\nasync def process_order(\n    order_id: int,\n    notification_svc: INotificationService = InjectQDependency(INotificationService)\n):\n    # Process order logic\n    await notification_svc.send_order_confirmation(order_id)\n\n# 5. Schedule tasks\nawait scheduler.schedule_task(send_welcome_email, user_id=123)\nawait scheduler.schedule_task(process_order, order_id=456)\n</code></pre>"},{"location":"integrations/taskiq/#service-definitions","title":"Service Definitions","text":"<pre><code>from typing import Protocol\n\n# Define service interfaces\nclass IEmailService(Protocol):\n    async def send_welcome_email(self, email: str) -&gt; None: ...\n    async def send_order_confirmation(self, email: str, order_id: int) -&gt; None: ...\n\nclass IUserService(Protocol):\n    def get_user(self, user_id: int) -&gt; User: ...\n    def update_user_status(self, user_id: int, status: str) -&gt; None: ...\n\nclass INotificationService(Protocol):\n    async def send_order_confirmation(self, order_id: int) -&gt; None: ...\n    async def send_payment_failed(self, user_id: int) -&gt; None: ...\n\n# Implement services\nclass EmailService:\n    def __init__(self, smtp_config: SMTPConfig):\n        self.smtp_config = smtp_config\n\n    async def send_welcome_email(self, email: str) -&gt; None:\n        # Send welcome email logic\n        print(f\"Sending welcome email to {email}\")\n\n    async def send_order_confirmation(self, email: str, order_id: int) -&gt; None:\n        # Send order confirmation logic\n        print(f\"Sending order confirmation to {email} for order {order_id}\")\n\nclass UserService:\n    def __init__(self, db: IDatabaseConnection):\n        self.db = db\n\n    def get_user(self, user_id: int) -&gt; User:\n        return self.db.query(User).filter(id=user_id).first()\n\n    def update_user_status(self, user_id: int, status: str) -&gt; None:\n        user = self.get_user(user_id)\n        user.status = status\n        self.db.commit()\n\nclass NotificationService:\n    def __init__(self, email_svc: IEmailService, user_svc: IUserService):\n        self.email_svc = email_svc\n        self.user_svc = user_svc\n\n    async def send_order_confirmation(self, order_id: int) -&gt; None:\n        # Get order and user\n        order = self.db.get_order(order_id)\n        user = self.user_svc.get_user(order.user_id)\n\n        # Send notification\n        await self.email_svc.send_order_confirmation(user.email, order_id)\n\n    async def send_payment_failed(self, user_id: int) -&gt; None:\n        user = self.user_svc.get_user(user_id)\n        await self.email_svc.send_payment_failed(user.email)\n</code></pre>"},{"location":"integrations/taskiq/#advanced-configuration","title":"\ud83d\udd27 Advanced Configuration","text":""},{"location":"integrations/taskiq/#task-scoped-services","title":"Task-Scoped Services","text":"<pre><code>from injectq import scoped\n\n@scoped\nclass TaskContext:\n    def __init__(self):\n        self.task_id = str(uuid.uuid4())\n        self.start_time = time.time()\n        self.metadata = {}\n\n    def set_metadata(self, key: str, value: Any):\n        self.metadata[key] = value\n\n    def get_duration(self) -&gt; float:\n        return time.time() - self.start_time\n\n@scoped\nclass TaskMetrics:\n    def __init__(self):\n        self.operations = []\n        self.errors = []\n\n    def record_operation(self, operation: str, duration: float):\n        self.operations.append({\n            \"operation\": operation,\n            \"duration\": duration,\n            \"timestamp\": time.time()\n        })\n\n    def record_error(self, error: str):\n        self.errors.append({\n            \"error\": error,\n            \"timestamp\": time.time()\n        })\n\n# Use in tasks\n@scheduler.task\nasync def complex_task(\n    data: dict,\n    ctx: TaskContext = InjectQDependency(TaskContext),\n    metrics: TaskMetrics = InjectQDependency(TaskMetrics),\n    processor: IDataProcessor = InjectQDependency(IDataProcessor)\n):\n    ctx.set_metadata(\"input_size\", len(data))\n\n    try:\n        # Process data with metrics\n        start_time = time.time()\n        result = await processor.process_data(data)\n        duration = time.time() - start_time\n\n        metrics.record_operation(\"process_data\", duration)\n\n        return result\n\n    except Exception as e:\n        metrics.record_error(str(e))\n        raise\n</code></pre>"},{"location":"integrations/taskiq/#module-based-setup","title":"Module-Based Setup","text":"<pre><code>from injectq import Module\n\nclass TaskModule(Module):\n    def configure(self, binder):\n        # Task-specific services\n        binder.bind(IEmailService, EmailService())\n        binder.bind(IUserService, UserService())\n        binder.bind(INotificationService, NotificationService())\n\n        # Task context services\n        binder.bind(TaskContext, TaskContext())\n        binder.bind(TaskMetrics, TaskMetrics())\n\n        # Data processors\n        binder.bind(IDataProcessor, DataProcessor())\n\nclass InfrastructureModule(Module):\n    def configure(self, binder):\n        # Database and external services\n        binder.bind(IDatabaseConnection, PostgresConnection())\n        binder.bind(SMTPConfig, SMTPConfig.from_env())\n\ndef create_taskiq_scheduler() -&gt; TaskiqScheduler:\n    # Create container with modules\n    container = InjectQ()\n    container.install(InfrastructureModule())\n    container.install(TaskModule())\n\n    # Create scheduler\n    scheduler = TaskiqScheduler()\n\n    # Set up integration\n    setup_taskiq_integration(scheduler, container)\n\n    return scheduler\n\n# Usage\nscheduler = create_taskiq_scheduler()\n</code></pre>"},{"location":"integrations/taskiq/#task-patterns","title":"\ud83c\udfa8 Task Patterns","text":""},{"location":"integrations/taskiq/#background-email-tasks","title":"Background Email Tasks","text":"<pre><code>@scheduler.task\nasync def send_bulk_emails(\n    user_ids: List[int],\n    template: str,\n    email_service: IEmailService = InjectQDependency(IEmailService),\n    user_service: IUserService = InjectQDependency(IUserService)\n):\n    \"\"\"Send emails to multiple users.\"\"\"\n    for user_id in user_ids:\n        user = user_service.get_user(user_id)\n        await email_service.send_template_email(\n            user.email,\n            template,\n            {\"name\": user.name}\n        )\n\n@scheduler.task\nasync def send_reminder_emails(\n    reminder_type: str,\n    email_service: IEmailService = InjectQDependency(IEmailService),\n    user_service: IUserService = InjectQDependency(IUserService)\n):\n    \"\"\"Send reminder emails based on type.\"\"\"\n    users = user_service.get_users_due_for_reminder(reminder_type)\n\n    for user in users:\n        await email_service.send_reminder_email(\n            user.email,\n            reminder_type\n        )\n\n# Schedule recurring tasks\nawait scheduler.schedule_task(\n    send_reminder_emails,\n    reminder_type=\"payment_due\",\n    cron=\"0 9 * * *\"  # Daily at 9 AM\n)\n</code></pre>"},{"location":"integrations/taskiq/#data-processing-tasks","title":"Data Processing Tasks","text":"<pre><code>@scheduler.task\nasync def process_user_data(\n    user_id: int,\n    data_type: str,\n    processor: IDataProcessor = InjectQDependency(IDataProcessor),\n    storage: IDataStorage = InjectQDependency(IDataStorage),\n    metrics: TaskMetrics = InjectQDependency(TaskMetrics)\n):\n    \"\"\"Process user data in background.\"\"\"\n    try:\n        # Get user data\n        raw_data = await storage.get_user_data(user_id, data_type)\n\n        # Process data\n        start_time = time.time()\n        processed_data = await processor.process_user_data(raw_data)\n        processing_time = time.time() - start_time\n\n        metrics.record_operation(\"process_user_data\", processing_time)\n\n        # Store processed data\n        await storage.store_processed_data(user_id, data_type, processed_data)\n\n    except Exception as e:\n        metrics.record_error(f\"Failed to process user data: {e}\")\n        raise\n\n@scheduler.task\nasync def cleanup_old_data(\n    days_old: int = 30,\n    storage: IDataStorage = InjectQDependency(IDataStorage)\n):\n    \"\"\"Clean up old processed data.\"\"\"\n    cutoff_date = datetime.now() - timedelta(days=days_old)\n    deleted_count = await storage.cleanup_old_data(cutoff_date)\n\n    print(f\"Cleaned up {deleted_count} old data records\")\n</code></pre>"},{"location":"integrations/taskiq/#notification-tasks","title":"Notification Tasks","text":"<pre><code>@scheduler.task\nasync def send_order_notifications(\n    order_id: int,\n    notification_svc: INotificationService = InjectQDependency(INotificationService),\n    user_svc: IUserService = InjectQDependency(IUserService)\n):\n    \"\"\"Send notifications for order events.\"\"\"\n    order = user_svc.get_order(order_id)\n\n    # Send to customer\n    await notification_svc.send_order_confirmation(order_id)\n\n    # Send to admin if high value\n    if order.total &gt; 1000:\n        await notification_svc.send_high_value_order_alert(order_id)\n\n@scheduler.task\nasync def send_payment_reminders(\n    user_id: int,\n    amount: float,\n    due_date: str,\n    notification_svc: INotificationService = InjectQDependency(INotificationService)\n):\n    \"\"\"Send payment reminder notifications.\"\"\"\n    await notification_svc.send_payment_reminder(user_id, amount, due_date)\n\n# Chain tasks together\n@scheduler.task\nasync def process_payment_and_notify(\n    payment_data: dict,\n    payment_svc: IPaymentService = InjectQDependency(IPaymentService),\n    notification_svc: INotificationService = InjectQDependency(INotificationService)\n):\n    \"\"\"Process payment and send notifications.\"\"\"\n    # Process payment\n    result = await payment_svc.process_payment(payment_data)\n\n    if result.success:\n        # Send success notification\n        await notification_svc.send_payment_success(\n            result.user_id,\n            result.amount\n        )\n    else:\n        # Send failure notification\n        await notification_svc.send_payment_failed(result.user_id)\n\n    return result\n</code></pre>"},{"location":"integrations/taskiq/#testing-taskiq-integration","title":"\ud83e\uddea Testing Taskiq Integration","text":""},{"location":"integrations/taskiq/#unit-testing-tasks","title":"Unit Testing Tasks","text":"<pre><code>import pytest\nfrom injectq.integrations.taskiq import setup_taskiq_integration\n\n@pytest.fixture\ndef test_scheduler():\n    # Create test container\n    container = InjectQ()\n    container.bind(IEmailService, MockEmailService())\n    container.bind(IUserService, MockUserService())\n\n    # Create test scheduler\n    scheduler = TaskiqScheduler()\n    setup_taskiq_integration(scheduler, container)\n\n    return scheduler\n\ndef test_send_welcome_email_task(test_scheduler):\n    # Define test task\n    @test_scheduler.task\n    async def send_welcome_email(\n        user_id: int,\n        email_service: IEmailService = InjectQDependency(IEmailService),\n        user_service: IUserService = InjectQDependency(IUserService)\n    ):\n        user = user_service.get_user(user_id)\n        await email_service.send_welcome_email(user.email)\n        return {\"email\": user.email}\n\n    # Execute task\n    result = await test_scheduler.execute_task(\n        send_welcome_email,\n        user_id=123\n    )\n\n    # Verify result\n    assert result[\"email\"] == \"user123@example.com\"\n\n    # Verify mocks were called\n    email_service = test_scheduler.container.get(IEmailService)\n    user_service = test_scheduler.container.get(IUserService)\n\n    assert email_service.send_welcome_email_called\n    assert user_service.get_user_called\n\ndef test_task_scoping(test_scheduler):\n    # Define task with scoped service\n    @test_scheduler.task\n    async def scoped_task(\n        data: str,\n        ctx: TaskContext = InjectQDependency(TaskContext)\n    ):\n        ctx.set_metadata(\"input\", data)\n        return ctx.metadata\n\n    # Execute multiple tasks\n    result1 = await test_scheduler.execute_task(scoped_task, data=\"test1\")\n    result2 = await test_scheduler.execute_task(scoped_task, data=\"test2\")\n\n    # Each task should have its own context\n    assert result1[\"input\"] == \"test1\"\n    assert result2[\"input\"] == \"test2\"\n</code></pre>"},{"location":"integrations/taskiq/#integration-testing","title":"Integration Testing","text":"<pre><code>@pytest.fixture\ndef integration_scheduler():\n    # Real container with test database\n    container = InjectQ()\n    container.install(TestDatabaseModule())\n    container.install(EmailModule())\n    container.install(TaskModule())\n\n    scheduler = TaskiqScheduler()\n    setup_taskiq_integration(scheduler, container)\n\n    return scheduler\n\ndef test_email_task_integration(integration_scheduler):\n    # Define integration task\n    @integration_scheduler.task\n    async def send_user_notification(\n        user_id: int,\n        message: str,\n        email_service: IEmailService = InjectQDependency(IEmailService),\n        user_service: IUserService = InjectQDependency(IUserService)\n    ):\n        user = user_service.get_user(user_id)\n        await email_service.send_notification(user.email, message)\n        return {\"sent_to\": user.email}\n\n    # Execute task\n    result = await integration_scheduler.execute_task(\n        send_user_notification,\n        user_id=123,\n        message=\"Welcome to our platform!\"\n    )\n\n    # Verify result\n    assert \"sent_to\" in result\n    assert result[\"sent_to\"].endswith(\"@example.com\")\n\ndef test_task_error_handling(integration_scheduler):\n    # Define task that might fail\n    @integration_scheduler.task\n    async def risky_task(\n        user_id: int,\n        user_service: IUserService = InjectQDependency(IUserService)\n    ):\n        user = user_service.get_user(user_id)\n        if user.status == \"inactive\":\n            raise ValueError(\"Cannot process inactive user\")\n        return {\"processed\": user.id}\n\n    # Test successful case\n    result = await integration_scheduler.execute_task(risky_task, user_id=123)\n    assert result[\"processed\"] == 123\n\n    # Test error case\n    with pytest.raises(ValueError, match=\"Cannot process inactive user\"):\n        await integration_scheduler.execute_task(risky_task, user_id=456)\n</code></pre>"},{"location":"integrations/taskiq/#mock-testing","title":"Mock Testing","text":"<pre><code>class MockEmailService:\n    def __init__(self):\n        self.sent_emails = []\n\n    async def send_welcome_email(self, email: str):\n        self.sent_emails.append({\n            \"type\": \"welcome\",\n            \"email\": email,\n            \"timestamp\": time.time()\n        })\n\n    async def send_notification(self, email: str, message: str):\n        self.sent_emails.append({\n            \"type\": \"notification\",\n            \"email\": email,\n            \"message\": message,\n            \"timestamp\": time.time()\n        })\n\nclass MockUserService:\n    def __init__(self):\n        self.users = {\n            123: User(id=123, email=\"user123@example.com\", status=\"active\"),\n            456: User(id=456, email=\"user456@example.com\", status=\"inactive\")\n        }\n\n    def get_user(self, user_id: int) -&gt; User:\n        return self.users.get(user_id)\n\ndef test_with_mocks():\n    container = InjectQ()\n    mock_email = MockEmailService()\n    mock_user = MockUserService()\n\n    container.bind(IEmailService, mock_email)\n    container.bind(IUserService, mock_user)\n\n    scheduler = TaskiqScheduler()\n    setup_taskiq_integration(scheduler, container)\n\n    @scheduler.task\n    async def test_task(\n        user_id: int,\n        email_service: IEmailService = InjectQDependency(IEmailService),\n        user_service: IUserService = InjectQDependency(IUserService)\n    ):\n        user = user_service.get_user(user_id)\n        await email_service.send_welcome_email(user.email)\n        return len(mock_email.sent_emails)\n\n    # Execute task\n    result = await scheduler.execute_task(test_task, user_id=123)\n\n    # Verify mock interactions\n    assert result == 1\n    assert len(mock_email.sent_emails) == 1\n    assert mock_email.sent_emails[0][\"email\"] == \"user123@example.com\"\n</code></pre>"},{"location":"integrations/taskiq/#common-patterns-and-pitfalls","title":"\ud83d\udea8 Common Patterns and Pitfalls","text":""},{"location":"integrations/taskiq/#good-patterns","title":"\u2705 Good Patterns","text":""},{"location":"integrations/taskiq/#1-proper-task-scoping","title":"1. Proper Task Scoping","text":"<pre><code># \u2705 Good: Use scoped for task-specific data\n@scoped\nclass TaskProgress:\n    def __init__(self):\n        self.steps = []\n        self.current_step = 0\n\n    def record_step(self, step_name: str):\n        self.steps.append({\n            \"name\": step_name,\n            \"timestamp\": time.time()\n        })\n        self.current_step += 1\n\n# \u2705 Good: Use singleton for shared resources\n@singleton\nclass DatabasePool:\n    def __init__(self):\n        self.pool = create_database_pool()\n\n# \u2705 Good: Use transient for stateless operations\n@transient\nclass DataValidator:\n    def validate(self, data: dict) -&gt; bool:\n        return validate_schema(data)\n</code></pre>"},{"location":"integrations/taskiq/#2-error-handling","title":"2. Error Handling","text":"<pre><code># \u2705 Good: Handle task errors gracefully\n@scheduler.task\nasync def process_with_error_handling(\n    data: dict,\n    processor: IDataProcessor = InjectQDependency(IDataProcessor),\n    logger: ILogger = InjectQDependency(ILogger)\n):\n    try:\n        result = await processor.process_data(data)\n        return result\n    except ValidationError as e:\n        logger.error(f\"Validation failed: {e}\")\n        # Retry logic or dead letter queue\n        await handle_validation_error(data, e)\n    except Exception as e:\n        logger.error(f\"Unexpected error: {e}\")\n        # Alert system or manual intervention\n        await alert_system(f\"Task failed: {e}\")\n        raise\n</code></pre>"},{"location":"integrations/taskiq/#3-task-dependencies","title":"3. Task Dependencies","text":"<pre><code># \u2705 Good: Chain related tasks\n@scheduler.task\nasync def process_order(\n    order_id: int,\n    order_svc: IOrderService = InjectQDependency(IOrderService)\n):\n    order = await order_svc.process_order(order_id)\n    return order\n\n@scheduler.task\nasync def notify_order_processed(\n    order_id: int,\n    notification_svc: INotificationService = InjectQDependency(INotificationService)\n):\n    await notification_svc.send_order_processed_notification(order_id)\n\n# Chain tasks\norder_result = await scheduler.execute_task(process_order, order_id=123)\nawait scheduler.execute_task(notify_order_processed, order_id=123)\n</code></pre>"},{"location":"integrations/taskiq/#bad-patterns","title":"\u274c Bad Patterns","text":""},{"location":"integrations/taskiq/#1-manual-container-access","title":"1. Manual Container Access","text":"<pre><code># \u274c Bad: Manual container access in tasks\ncontainer = InjectQ()  # Global container\n\n@scheduler.task\nasync def manual_task(user_id: int):\n    user_service = container.get(IUserService)  # Manual resolution\n    return user_service.get_user(user_id)\n\n# \u2705 Good: Use dependency injection\n@scheduler.task\nasync def injected_task(\n    user_id: int,\n    user_service: IUserService = InjectQDependency(IUserService)\n):\n    return user_service.get_user(user_id)\n</code></pre>"},{"location":"integrations/taskiq/#2-singleton-abuse","title":"2. Singleton Abuse","text":"<pre><code># \u274c Bad: Singleton for task-specific state\n@singleton\nclass TaskState:\n    def __init__(self):\n        self.current_task_data = None  # Shared across tasks!\n\n    def set_task_data(self, data):\n        self.current_task_data = data  # Overwrites other tasks!\n\n# \u274c Bad: Singleton for mutable task data\n@singleton\nclass TaskMetrics:\n    def __init__(self):\n        self.task_count = 0  # Accumulates across all tasks\n\n    def increment_task_count(self):\n        self.task_count += 1  # Not task-specific\n\n# \u2705 Good: Scoped for task-specific data\n@scoped\nclass TaskState:\n    def __init__(self):\n        self.task_data = None\n\n@scoped\nclass TaskMetrics:\n    def __init__(self):\n        self.operations = []\n</code></pre>"},{"location":"integrations/taskiq/#3-heavy-operations-in-tasks","title":"3. Heavy Operations in Tasks","text":"<pre><code># \u274c Bad: Heavy initialization per task\n@scheduler.task\nasync def heavy_task(data: dict):\n    # Load model on every task execution\n    model = await load_ml_model()  # 2GB model!\n    result = model.predict(data)\n    return result\n\n# \u2705 Good: Pre-load heavy resources\n@singleton\nclass MLModelService:\n    def __init__(self):\n        self.model = None\n\n    async def initialize(self):\n        if self.model is None:\n            self.model = await load_ml_model()\n\n    async def predict(self, data: dict):\n        await self.initialize()\n        return self.model.predict(data)\n\n@scheduler.task\nasync def light_task(\n    data: dict,\n    ml_service: MLModelService = InjectQDependency(MLModelService)\n):\n    return await ml_service.predict(data)\n</code></pre>"},{"location":"integrations/taskiq/#advanced-features","title":"\u26a1 Advanced Features","text":""},{"location":"integrations/taskiq/#custom-task-middleware","title":"Custom Task Middleware","text":"<pre><code>from injectq.integrations.taskiq import TaskiqMiddleware\n\nclass MetricsMiddleware(TaskiqMiddleware):\n    def __init__(self, metrics_service: IMetricsService):\n        self.metrics = metrics_service\n\n    async def before_task(self, task_info):\n        # Record task start\n        self.metrics.increment(\"tasks_started\")\n        task_info.start_time = time.time()\n\n    async def after_task(self, task_info, result):\n        # Record task completion\n        duration = time.time() - task_info.start_time\n        self.metrics.histogram(\"task_duration\", duration)\n        self.metrics.increment(\"tasks_completed\")\n\n    async def on_task_error(self, task_info, error):\n        # Record task failure\n        self.metrics.increment(\"tasks_failed\")\n        self.metrics.increment(f\"task_error_{type(error).__name__}\")\n\n# Use custom middleware\nsetup_taskiq_integration(\n    scheduler,\n    container,\n    middlewares=[MetricsMiddleware(metrics_service)]\n)\n</code></pre>"},{"location":"integrations/taskiq/#task-result-handling","title":"Task Result Handling","text":"<pre><code>@scheduler.task\nasync def process_with_result_handling(\n    data: dict,\n    processor: IDataProcessor = InjectQDependency(IDataProcessor)\n):\n    result = await processor.process_data(data)\n\n    # Return structured result\n    return {\n        \"task_id\": str(uuid.uuid4()),\n        \"processed_at\": time.time(),\n        \"input_size\": len(data),\n        \"output_size\": len(result),\n        \"result\": result\n    }\n\n# Handle task results\nasync def handle_task_result(task_result):\n    if task_result.success:\n        # Process successful result\n        data = task_result.result\n        print(f\"Task completed: {data['task_id']}\")\n\n        # Store result or trigger next task\n        await store_task_result(data)\n    else:\n        # Handle task failure\n        print(f\"Task failed: {task_result.error}\")\n\n        # Retry logic or error handling\n        if task_result.retry_count &lt; 3:\n            await scheduler.retry_task(task_result.task_id)\n        else:\n            await handle_permanent_failure(task_result)\n</code></pre>"},{"location":"integrations/taskiq/#cron-tasks","title":"Cron Tasks","text":"<pre><code>@scheduler.task\nasync def cleanup_expired_sessions(\n    session_svc: ISessionService = InjectQDependency(ISessionService)\n):\n    \"\"\"Clean up expired user sessions.\"\"\"\n    expired_count = await session_svc.cleanup_expired_sessions()\n    print(f\"Cleaned up {expired_count} expired sessions\")\n\n@scheduler.task\nasync def generate_daily_reports(\n    report_svc: IReportService = InjectQDependency(IReportService)\n):\n    \"\"\"Generate daily business reports.\"\"\"\n    await report_svc.generate_daily_report()\n    print(\"Daily report generated\")\n\n@scheduler.task\nasync def send_reminders(\n    reminder_svc: IReminderService = InjectQDependency(IReminderService)\n):\n    \"\"\"Send scheduled reminders.\"\"\"\n    sent_count = await reminder_svc.send_pending_reminders()\n    print(f\"Sent {sent_count} reminders\")\n\n# Schedule cron tasks\nawait scheduler.schedule_cron(\n    cleanup_expired_sessions,\n    cron=\"0 */6 * * *\"  # Every 6 hours\n)\n\nawait scheduler.schedule_cron(\n    generate_daily_reports,\n    cron=\"0 2 * * *\"  # Daily at 2 AM\n)\n\nawait scheduler.schedule_cron(\n    send_reminders,\n    cron=\"0 */2 * * *\"  # Every 2 hours\n)\n</code></pre>"},{"location":"integrations/taskiq/#summary","title":"\ud83c\udfaf Summary","text":"<p>Taskiq integration provides:</p> <ul> <li>Automatic dependency injection - No manual container management in tasks</li> <li>Task-scoped services - Proper isolation per background task</li> <li>Type-driven injection - Just add type hints to task parameters</li> <li>Framework lifecycle integration - Automatic cleanup and resource management</li> <li>Testing support - Easy mocking and test isolation</li> </ul> <p>Key features: - Seamless integration with Taskiq's task system - Support for all InjectQ scopes (singleton, scoped, transient) - Task-scoped container access - Custom middleware support - Cron task scheduling - Result handling and error recovery</p> <p>Best practices: - Use scoped services for task-specific data - Use singleton for shared resources and heavy objects - Use transient for stateless operations - Handle errors gracefully in tasks - Test thoroughly with mocked dependencies - Avoid manual container access in tasks</p> <p>Ready to explore FastMCP integration?</p>"},{"location":"migration/other-frameworks/","title":"Migration from Other DI Frameworks","text":"<p>This guide covers migration from various other dependency injection frameworks to InjectQ, including framework-specific patterns and best practices.</p>"},{"location":"migration/other-frameworks/#framework-comparison-overview","title":"\ud83c\udf1f Framework Comparison Overview","text":"Framework Container Type Injection Style Scopes Async Support Key Features InjectQ Explicit Decorator/Manual Flexible Full Performance, Testing, Profiling dependency-injector Explicit Manual Limited Partial Providers, Containers punq Explicit Manual Basic No Lightweight, Simple lagom Explicit Manual Basic No Service Locator aiodine Explicit Decorator Limited Yes Async-first"},{"location":"migration/other-frameworks/#migration-from-dependency-injector","title":"\ud83d\udd04 Migration from dependency-injector","text":""},{"location":"migration/other-frameworks/#container-setup","title":"Container Setup","text":"<pre><code># \u274c dependency-injector\nfrom dependency_injector import containers, providers\n\nclass Container(containers.DeclarativeContainer):\n    config = providers.Configuration()\n\n    database = providers.Singleton(\n        DatabaseConnection,\n        config.database.url\n    )\n\n    user_service = providers.Factory(\n        UserService,\n        db=database\n    )\n\n# \u2705 InjectQ\nfrom injectq import InjectQ, Module\n\nclass AppModule(Module):\n    def configure(self):\n        # Configuration\n        config = Config()\n        self.bind(Config, config).singleton()\n\n        # Database\n        self.bind(DatabaseConnection, lambda: DatabaseConnection(\n            self.container.get(Config).database.url\n        )).singleton()\n\n        # Services\n        self.bind(UserService, UserService)\n\ncontainer = InjectQ()\ncontainer.install(AppModule())\n</code></pre>"},{"location":"migration/other-frameworks/#provider-migration","title":"Provider Migration","text":"<pre><code># \u274c dependency-injector providers\nfrom dependency_injector import providers\n\nclass Container(containers.DeclarativeContainer):\n    # Singleton provider\n    database = providers.Singleton(DatabaseConnection, host=\"localhost\")\n\n    # Factory provider\n    user_service = providers.Factory(UserService, db=database)\n\n    # Configuration provider\n    config = providers.Configuration()\n\n    # Callable provider\n    api_client = providers.Callable(\n        lambda: ApiClient(config.api.endpoint())\n    )\n\n# \u2705 InjectQ equivalent\nclass AppModule(Module):\n    def configure(self):\n        # Singleton\n        self.bind(DatabaseConnection, lambda: DatabaseConnection(host=\"localhost\")).singleton()\n\n        # Factory (transient by default)\n        self.bind(UserService, UserService)\n\n        # Configuration\n        config = Config()\n        self.bind(Config, config).singleton()\n\n        # Callable/Factory\n        self.bind(ApiClient, lambda: ApiClient(\n            self.container.get(Config).api.endpoint\n        ))\n</code></pre>"},{"location":"migration/other-frameworks/#dependency-resolution","title":"Dependency Resolution","text":"<pre><code># \u274c dependency-injector\ncontainer = Container()\nuser_service = container.user_service()  # Factory call\ndatabase = container.database()          # Singleton call\n\n# \u2705 InjectQ\ncontainer = InjectQ()\ncontainer.install(AppModule())\nuser_service = container.get(UserService)  # Consistent interface\ndatabase = container.get(DatabaseConnection)\n</code></pre>"},{"location":"migration/other-frameworks/#migration-from-punq","title":"\ud83d\udd27 Migration from punq","text":""},{"location":"migration/other-frameworks/#basic-setup","title":"Basic Setup","text":"<pre><code># \u274c punq\nimport punq\n\ncontainer = punq.Container()\n\n# Register singleton\ncontainer.register(DatabaseService, scope=punq.Scope.singleton)\n\n# Register with factory\ncontainer.register(UserService, factory=lambda: UserService(\n    container.resolve(DatabaseService)\n))\n\n# Register instance\nconfig = Configuration()\ncontainer.register(Configuration, instance=config)\n\n# \u2705 InjectQ\ncontainer = InjectQ()\n\n# Register singleton\ncontainer.bind(DatabaseService, DatabaseService).singleton()\n\n# Register with dependencies (auto-resolved)\ncontainer.bind(UserService, UserService)\n\n# Register instance\nconfig = Configuration()\ncontainer.bind(Configuration, config).singleton()\n</code></pre>"},{"location":"migration/other-frameworks/#interface-registration","title":"Interface Registration","text":"<pre><code># \u274c punq\nfrom abc import ABC, abstractmethod\n\nclass IUserRepository(ABC):\n    @abstractmethod\n    def find_user(self, user_id: str):\n        pass\n\nclass SqlUserRepository(IUserRepository):\n    def find_user(self, user_id: str):\n        return {\"id\": user_id}\n\ncontainer = punq.Container()\ncontainer.register(IUserRepository, SqlUserRepository)\n\n# \u2705 InjectQ\nclass IUserRepository(ABC):\n    @abstractmethod\n    def find_user(self, user_id: str):\n        pass\n\nclass SqlUserRepository(IUserRepository):\n    def find_user(self, user_id: str):\n        return {\"id\": user_id}\n\ncontainer = InjectQ()\ncontainer.bind(IUserRepository, SqlUserRepository)\n</code></pre>"},{"location":"migration/other-frameworks/#migration-from-lagom","title":"\ud83c\udf0a Migration from lagom","text":""},{"location":"migration/other-frameworks/#service-registration","title":"Service Registration","text":"<pre><code># \u274c lagom\nfrom lagom import Container\n\ncontainer = Container()\n\n# Register service\ncontainer.register(DatabaseService)\n\n# Register with dependencies\ncontainer.register(UserService, DatabaseService)\n\n# Register singleton\ncontainer.register(CacheService, is_singleton=True)\n\n# \u2705 InjectQ\ncontainer = InjectQ()\n\n# Register service\ncontainer.bind(DatabaseService, DatabaseService)\n\n# Register with auto-resolved dependencies\ncontainer.bind(UserService, UserService)\n\n# Register singleton\ncontainer.bind(CacheService, CacheService).singleton()\n</code></pre>"},{"location":"migration/other-frameworks/#dependency-resolution_1","title":"Dependency Resolution","text":"<pre><code># \u274c lagom\ndatabase_service = container.resolve(DatabaseService)\nuser_service = container.resolve(UserService)\n\n# \u2705 InjectQ\ndatabase_service = container.get(DatabaseService)\nuser_service = container.get(UserService)\n</code></pre>"},{"location":"migration/other-frameworks/#migration-from-aiodine","title":"\u26a1 Migration from aiodine","text":""},{"location":"migration/other-frameworks/#async-service-registration","title":"Async Service Registration","text":"<pre><code># \u274c aiodine\nfrom aiodine import Container\n\ncontainer = Container()\n\n# Register async service\n@container.register\nclass AsyncUserService:\n    async def __init__(self, db: AsyncDatabase):\n        self.db = db\n        await self.initialize()\n\n    async def initialize(self):\n        await self.db.connect()\n\n# \u2705 InjectQ\nfrom injectq import InjectQ, inject\n\ncontainer = InjectQ()\n\nclass AsyncUserService:\n    @inject\n    async def __init__(self, db: AsyncDatabase):\n        self.db = db\n        await self.initialize()\n\n    async def initialize(self):\n        await self.db.connect()\n\n# Register async service\ncontainer.bind(AsyncUserService, AsyncUserService)\n</code></pre>"},{"location":"migration/other-frameworks/#async-resolution","title":"Async Resolution","text":"<pre><code># \u274c aiodine\nasync def main():\n    service = await container.resolve(AsyncUserService)\n    result = await service.process()\n\n# \u2705 InjectQ\nasync def main():\n    service = await container.aget(AsyncUserService)\n    result = await service.process()\n\n    # Or use async context\n    async with container.async_scope():\n        scoped_service = container.get(AsyncUserService)\n        result = await scoped_service.process()\n</code></pre>"},{"location":"migration/other-frameworks/#advanced-migration-patterns","title":"\ud83c\udfaf Advanced Migration Patterns","text":""},{"location":"migration/other-frameworks/#configuration-management","title":"Configuration Management","text":"<pre><code># Generic configuration pattern\nclass ConfigurationManager:\n    \"\"\"Manages configuration across different DI frameworks.\"\"\"\n\n    def __init__(self, environment: str = \"development\"):\n        self.environment = environment\n        self.config_data = self._load_config()\n\n    def _load_config(self):\n        \"\"\"Load configuration based on environment.\"\"\"\n        if self.environment == \"production\":\n            return {\n                \"database\": {\n                    \"host\": \"prod-db.example.com\",\n                    \"port\": 5432,\n                    \"name\": \"production_db\"\n                },\n                \"api\": {\n                    \"endpoint\": \"https://api.example.com\",\n                    \"timeout\": 30\n                }\n            }\n        else:\n            return {\n                \"database\": {\n                    \"host\": \"localhost\",\n                    \"port\": 5433,\n                    \"name\": \"test_db\"\n                },\n                \"api\": {\n                    \"endpoint\": \"http://localhost:8080\",\n                    \"timeout\": 5\n                }\n            }\n\n    def setup_injectq_container(self) -&gt; InjectQ:\n        \"\"\"Setup InjectQ container with configuration.\"\"\"\n        container = InjectQ()\n\n        # Bind configuration\n        container.bind(dict, self.config_data, name=\"config\").singleton()\n\n        # Database configuration\n        db_config = DatabaseConfig(\n            host=self.config_data[\"database\"][\"host\"],\n            port=self.config_data[\"database\"][\"port\"],\n            database=self.config_data[\"database\"][\"name\"]\n        )\n        container.bind(DatabaseConfig, db_config).singleton()\n\n        # API configuration\n        api_config = ApiConfig(\n            endpoint=self.config_data[\"api\"][\"endpoint\"],\n            timeout=self.config_data[\"api\"][\"timeout\"]\n        )\n        container.bind(ApiConfig, api_config).singleton()\n\n        return container\n\n# Usage\nconfig_manager = ConfigurationManager(\"production\")\ncontainer = config_manager.setup_injectq_container()\n</code></pre>"},{"location":"migration/other-frameworks/#service-locator-migration","title":"Service Locator Migration","text":"<pre><code># Migrate from Service Locator pattern to proper DI\nclass ServiceLocatorMigration:\n    \"\"\"Help migrate from service locator pattern.\"\"\"\n\n    def __init__(self):\n        self.container = InjectQ()\n        self._setup_services()\n\n    def _setup_services(self):\n        \"\"\"Setup services in InjectQ container.\"\"\"\n        # Instead of global service locator\n        self.container.bind(DatabaseService, DatabaseService).singleton()\n        self.container.bind(UserService, UserService)\n        self.container.bind(EmailService, EmailService)\n\n    def get_service(self, service_type):\n        \"\"\"Temporary method to ease migration.\"\"\"\n        return self.container.get(service_type)\n\n    def migrate_to_injection(self):\n        \"\"\"Examples of proper dependency injection.\"\"\"\n\n        # \u274c Before: Service locator usage\n        class BadUserController:\n            def __init__(self, service_locator):\n                self.service_locator = service_locator\n\n            def create_user(self, user_data):\n                user_service = self.service_locator.get_service(UserService)\n                email_service = self.service_locator.get_service(EmailService)\n                # Use services...\n\n        # \u2705 After: Proper dependency injection\n        class GoodUserController:\n            @inject\n            def __init__(self, user_service: UserService, email_service: EmailService):\n                self.user_service = user_service\n                self.email_service = email_service\n\n            def create_user(self, user_data):\n                # Use injected services directly\n                user = self.user_service.create_user(user_data)\n                self.email_service.send_welcome_email(user)\n                return user\n\n# Usage\nmigration = ServiceLocatorMigration()\n\n# Temporary service locator interface\nuser_service = migration.get_service(UserService)\n\n# Properly injected controller\ncontainer = migration.container\ncontainer.bind(GoodUserController, GoodUserController)\ncontroller = container.get(GoodUserController)\n</code></pre>"},{"location":"migration/other-frameworks/#factory-pattern-migration","title":"Factory Pattern Migration","text":"<pre><code># Migrate factory patterns\nclass FactoryMigration:\n    \"\"\"Migrate various factory patterns to InjectQ.\"\"\"\n\n    def __init__(self):\n        self.container = InjectQ()\n        self._setup_factories()\n\n    def _setup_factories(self):\n        \"\"\"Setup factory patterns in InjectQ.\"\"\"\n\n        # Simple factory\n        self.container.bind(DatabaseConnection, self.create_database_connection)\n\n        # Abstract factory\n        self.container.bind(ServiceFactory, ConcreteServiceFactory).singleton()\n\n        # Factory method\n        self.container.bind(UserService, self.create_user_service)\n\n    def create_database_connection(self) -&gt; DatabaseConnection:\n        \"\"\"Factory method for database connection.\"\"\"\n        config = self.container.get(DatabaseConfig)\n        return DatabaseConnection(\n            host=config.host,\n            port=config.port,\n            database=config.database\n        )\n\n    def create_user_service(self) -&gt; UserService:\n        \"\"\"Factory method for user service.\"\"\"\n        db = self.container.get(DatabaseConnection)\n        cache = self.container.get(CacheService)\n        return UserService(db, cache)\n\n# Abstract factory pattern\nfrom abc import ABC, abstractmethod\n\nclass ServiceFactory(ABC):\n    @abstractmethod\n    def create_user_service(self) -&gt; UserService:\n        pass\n\n    @abstractmethod\n    def create_order_service(self) -&gt; OrderService:\n        pass\n\nclass ConcreteServiceFactory(ServiceFactory):\n    @inject\n    def __init__(self, container: InjectQ):\n        self.container = container\n\n    def create_user_service(self) -&gt; UserService:\n        return self.container.get(UserService)\n\n    def create_order_service(self) -&gt; OrderService:\n        return self.container.get(OrderService)\n\n# Usage\nmigration = FactoryMigration()\ndb_connection = migration.container.get(DatabaseConnection)\nfactory = migration.container.get(ServiceFactory)\nuser_service = factory.create_user_service()\n</code></pre>"},{"location":"migration/other-frameworks/#testing-migration","title":"\ud83e\uddea Testing Migration","text":""},{"location":"migration/other-frameworks/#universal-testing-pattern","title":"Universal Testing Pattern","text":"<pre><code># Universal testing approach for any framework migration\nclass UniversalTestingMigration:\n    \"\"\"Universal testing patterns for DI framework migration.\"\"\"\n\n    def create_test_container(self) -&gt; InjectQ:\n        \"\"\"Create container for testing.\"\"\"\n        container = InjectQ()\n\n        # Mock dependencies\n        container.bind(DatabaseService, MockDatabaseService).singleton()\n        container.bind(EmailService, MockEmailService).singleton()\n        container.bind(CacheService, MockCacheService).singleton()\n\n        # Real services under test\n        container.bind(UserService, UserService)\n        container.bind(OrderService, OrderService)\n\n        return container\n\n    def create_integration_test_container(self) -&gt; InjectQ:\n        \"\"\"Create container for integration testing.\"\"\"\n        container = InjectQ()\n\n        # Test database\n        test_db_config = DatabaseConfig(\n            host=\"localhost\",\n            port=5433,\n            database=\"test_db\"\n        )\n        container.bind(DatabaseConfig, test_db_config).singleton()\n        container.bind(DatabaseService, DatabaseService).singleton()\n\n        # Mock external services\n        container.bind(EmailService, MockEmailService).singleton()\n\n        # Real services\n        container.bind(UserService, UserService)\n\n        return container\n\n# Mock implementations\nclass MockDatabaseService:\n    def __init__(self):\n        self.data = {}\n\n    def save(self, key: str, value: dict):\n        self.data[key] = value\n\n    def find(self, key: str):\n        return self.data.get(key)\n\nclass MockEmailService:\n    def __init__(self):\n        self.sent_emails = []\n\n    def send_email(self, to: str, subject: str, body: str):\n        self.sent_emails.append({\n            \"to\": to,\n            \"subject\": subject,\n            \"body\": body\n        })\n\n# Test example\nimport unittest\n\nclass TestUserService(unittest.TestCase):\n    def setUp(self):\n        self.migration = UniversalTestingMigration()\n        self.container = self.migration.create_test_container()\n\n    def test_user_creation(self):\n        user_service = self.container.get(UserService)\n        user_data = {\"name\": \"John Doe\", \"email\": \"john@example.com\"}\n\n        user = user_service.create_user(user_data)\n\n        self.assertIsNotNone(user)\n        self.assertEqual(user[\"name\"], \"John Doe\")\n\n        # Check if email was sent\n        email_service = self.container.get(EmailService)\n        self.assertEqual(len(email_service.sent_emails), 1)\n        self.assertEqual(email_service.sent_emails[0][\"to\"], \"john@example.com\")\n</code></pre>"},{"location":"migration/other-frameworks/#performance-migration","title":"\ud83d\udcca Performance Migration","text":""},{"location":"migration/other-frameworks/#performance-optimization","title":"Performance Optimization","text":"<pre><code># Performance optimization during migration\nclass PerformanceMigration:\n    \"\"\"Optimize performance during DI framework migration.\"\"\"\n\n    def __init__(self):\n        self.container = InjectQ()\n        self._optimize_container()\n\n    def _optimize_container(self):\n        \"\"\"Apply performance optimizations.\"\"\"\n\n        # Use appropriate scopes\n        self.container.bind(DatabaseConnection, DatabaseConnection).singleton()\n        self.container.bind(CacheService, CacheService).singleton()\n        self.container.bind(ConfigService, ConfigService).singleton()\n\n        # Transient for lightweight services\n        self.container.bind(UserService, UserService)  # Default: transient\n        self.container.bind(OrderService, OrderService)\n\n        # Scoped for request-specific services\n        self.container.bind(RequestContext, RequestContext).scoped()\n        self.container.bind(SessionService, SessionService).scoped()\n\n    def benchmark_migration(self, old_framework_resolver, iterations: int = 1000):\n        \"\"\"Benchmark performance comparison.\"\"\"\n        import time\n\n        # Benchmark old framework\n        start_time = time.time()\n        for _ in range(iterations):\n            service = old_framework_resolver()\n        old_time = (time.time() - start_time) * 1000  # ms\n\n        # Benchmark InjectQ\n        start_time = time.time()\n        for _ in range(iterations):\n            service = self.container.get(UserService)\n        new_time = (time.time() - start_time) * 1000  # ms\n\n        improvement = ((old_time - new_time) / old_time) * 100\n\n        print(f\"Performance Comparison ({iterations} iterations):\")\n        print(f\"Old framework: {old_time:.2f}ms\")\n        print(f\"InjectQ: {new_time:.2f}ms\")\n        print(f\"Improvement: {improvement:.2f}%\")\n\n        return {\n            \"old_time\": old_time,\n            \"new_time\": new_time,\n            \"improvement_percent\": improvement\n        }\n\n# Usage\nmigration = PerformanceMigration()\n\n# Example old framework resolver\ndef old_framework_resolver():\n    # Simulate old framework resolution\n    import time\n    time.sleep(0.001)  # Simulate slower resolution\n    return UserService(DatabaseService(), EmailService())\n\n# Benchmark\nresults = migration.benchmark_migration(old_framework_resolver)\n</code></pre>"},{"location":"migration/other-frameworks/#migration-summary","title":"\ud83c\udfaf Migration Summary","text":""},{"location":"migration/other-frameworks/#universal-migration-steps","title":"Universal Migration Steps","text":"<ol> <li>Analysis Phase</li> <li>Identify current DI patterns</li> <li>Map services and dependencies</li> <li> <p>Identify pain points and limitations</p> </li> <li> <p>Planning Phase</p> </li> <li>Create migration timeline</li> <li>Plan testing strategy</li> <li> <p>Identify performance requirements</p> </li> <li> <p>Implementation Phase</p> </li> <li>Start with core services</li> <li>Migrate module by module</li> <li> <p>Update tests continuously</p> </li> <li> <p>Optimization Phase</p> </li> <li>Apply appropriate scopes</li> <li>Optimize performance</li> <li> <p>Monitor memory usage</p> </li> <li> <p>Validation Phase</p> </li> <li>Run comprehensive tests</li> <li>Performance benchmarking</li> <li>Production readiness check</li> </ol>"},{"location":"migration/other-frameworks/#common-migration-patterns","title":"Common Migration Patterns","text":"<ul> <li>Container Replacement: Replace old container with InjectQ</li> <li>Binding Migration: Convert registration patterns to InjectQ bindings</li> <li>Scope Optimization: Apply appropriate scopes for performance</li> <li>Testing Enhancement: Use InjectQ's testing utilities</li> <li>Async Upgrade: Add async support where beneficial</li> </ul>"},{"location":"migration/other-frameworks/#benefits-across-all-migrations","title":"Benefits Across All Migrations","text":"<ul> <li>Consistent API: Unified interface across all services</li> <li>Better Performance: Optimized resolution and memory usage</li> <li>Enhanced Testing: Comprehensive testing utilities</li> <li>Type Safety: Better type checking and IDE support</li> <li>Async Support: Full async/await support</li> <li>Profiling Tools: Built-in performance monitoring</li> </ul>"},{"location":"migration/other-frameworks/#migration-best-practices","title":"Migration Best Practices","text":"<ol> <li>Gradual Migration: Migrate incrementally, not all at once</li> <li>Test-Driven: Write tests before migrating production code</li> <li>Performance Monitoring: Benchmark before and after migration</li> <li>Documentation: Document migration decisions and patterns</li> <li>Team Training: Ensure team understands new patterns</li> <li>Rollback Plan: Have a plan to rollback if needed</li> </ol> <p>This completes the migration guides section, providing comprehensive guidance for migrating from various dependency injection frameworks to InjectQ.</p>"},{"location":"migration/python-injector/","title":"Migration from python-injector","text":"<p>python-injector is a mature dependency injection framework. This guide helps you migrate from python-injector to InjectQ while maintaining your existing patterns.</p>"},{"location":"migration/python-injector/#core-differences","title":"\ud83d\udd04 Core Differences","text":""},{"location":"migration/python-injector/#container-and-injector","title":"Container and Injector","text":"<pre><code># \u274c python-injector\nfrom injector import Injector, inject, singleton\n\ninjector = Injector()\n\n# \u2705 InjectQ\nfrom injectq import InjectQ, inject\n\ncontainer = InjectQ()\n</code></pre>"},{"location":"migration/python-injector/#service-binding","title":"Service Binding","text":"<pre><code># \u274c python-injector\nfrom injector import Injector, inject, singleton, Module\n\nclass MyModule(Module):\n    def configure(self, binder):\n        binder.bind(DatabaseService, to=SqlDatabaseService, scope=singleton)\n        binder.bind(str, to=\"Hello World\", annotation=\"greeting\")\n\ninjector = Injector([MyModule])\n\n# \u2705 InjectQ\nfrom injectq import InjectQ, Module\n\nclass MyModule(Module):\n    def configure(self):\n        self.bind(DatabaseService, SqlDatabaseService).singleton()\n        self.bind(str, \"Hello World\", name=\"greeting\")\n\ncontainer = InjectQ()\ncontainer.install(MyModule())\n</code></pre>"},{"location":"migration/python-injector/#dependency-injection","title":"Dependency Injection","text":"<pre><code># \u274c python-injector\nfrom injector import inject\n\nclass UserService:\n    @inject\n    def __init__(self, db: DatabaseService):\n        self.db = db\n\n# Same in InjectQ\n# \u2705 InjectQ\nfrom injectq import inject\n\nclass UserService:\n    @inject\n    def __init__(self, db: DatabaseService):\n        self.db = db\n</code></pre>"},{"location":"migration/python-injector/#migration-checklist","title":"\ud83d\udccb Migration Checklist","text":""},{"location":"migration/python-injector/#step-1-replace-imports","title":"Step 1: Replace Imports","text":"<pre><code># Before: python-injector imports\nfrom injector import Injector, inject, singleton, Module, provider\n\n# After: InjectQ imports\nfrom injectq import InjectQ, inject, Module\nfrom injectq.decorators import singleton  # If needed\n</code></pre>"},{"location":"migration/python-injector/#step-2-convert-injector-to-container","title":"Step 2: Convert Injector to Container","text":"<pre><code># Before: python-injector\ninjector = Injector([MyModule])\n\n# After: InjectQ\ncontainer = InjectQ()\ncontainer.install(MyModule())\n</code></pre>"},{"location":"migration/python-injector/#step-3-update-module-configuration","title":"Step 3: Update Module Configuration","text":"<pre><code># Before: python-injector module\nfrom injector import Module, singleton, provider\n\nclass AppModule(Module):\n    def configure(self, binder):\n        binder.bind(DatabaseService, to=SqlDatabaseService, scope=singleton)\n        binder.bind(ApiClient, to=self.create_api_client, scope=singleton)\n\n    @provider\n    @singleton\n    def create_api_client(self) -&gt; ApiClient:\n        return ApiClient(\"production\")\n\n# After: InjectQ module\nfrom injectq import Module\n\nclass AppModule(Module):\n    def configure(self):\n        self.bind(DatabaseService, SqlDatabaseService).singleton()\n        self.bind(ApiClient, self.create_api_client).singleton()\n\n    def create_api_client(self) -&gt; ApiClient:\n        return ApiClient(\"production\")\n</code></pre>"},{"location":"migration/python-injector/#step-4-convert-providers","title":"Step 4: Convert Providers","text":"<pre><code># Before: python-injector provider\nfrom injector import provider, singleton\n\nclass DatabaseModule(Module):\n    @provider\n    @singleton\n    def provide_database(self, config: DatabaseConfig) -&gt; DatabaseConnection:\n        return DatabaseConnection(\n            host=config.host,\n            port=config.port,\n            database=config.database\n        )\n\n# After: InjectQ provider\nfrom injectq import Module\n\nclass DatabaseModule(Module):\n    def configure(self):\n        self.bind(DatabaseConnection, self.provide_database).singleton()\n\n    def provide_database(self) -&gt; DatabaseConnection:\n        config = self.container.get(DatabaseConfig)\n        return DatabaseConnection(\n            host=config.host,\n            port=config.port,\n            database=config.database\n        )\n</code></pre>"},{"location":"migration/python-injector/#migration-examples","title":"\ud83d\udd27 Migration Examples","text":""},{"location":"migration/python-injector/#complete-python-injector-application","title":"Complete python-injector Application","text":"<pre><code># \u274c Original python-injector Application\nfrom injector import Injector, inject, singleton, Module, provider\nfrom abc import ABC, abstractmethod\n\n# Interfaces\nclass IUserRepository(ABC):\n    @abstractmethod\n    def find_user(self, user_id: str):\n        pass\n\nclass IEmailService(ABC):\n    @abstractmethod\n    def send_email(self, to: str, subject: str, body: str):\n        pass\n\n# Implementations\nclass SqlUserRepository(IUserRepository):\n    @inject\n    def __init__(self, db_connection: str):\n        self.db_connection = db_connection\n\n    def find_user(self, user_id: str):\n        return {\"id\": user_id, \"name\": \"John Doe\"}\n\nclass SmtpEmailService(IEmailService):\n    @inject\n    def __init__(self, smtp_config: dict):\n        self.smtp_config = smtp_config\n\n    def send_email(self, to: str, subject: str, body: str):\n        print(f\"Sending email to {to}: {subject}\")\n\nclass UserService:\n    @inject\n    def __init__(self, user_repo: IUserRepository, email_service: IEmailService):\n        self.user_repo = user_repo\n        self.email_service = email_service\n\n    def register_user(self, user_data: dict):\n        user = self.user_repo.find_user(user_data[\"id\"])\n        self.email_service.send_email(\n            user_data[\"email\"],\n            \"Welcome!\",\n            \"Welcome to our service\"\n        )\n        return user\n\n# Module configuration\nclass AppModule(Module):\n    def configure(self, binder):\n        binder.bind(IUserRepository, to=SqlUserRepository, scope=singleton)\n        binder.bind(IEmailService, to=SmtpEmailService, scope=singleton)\n        binder.bind(UserService, scope=singleton)\n\n    @provider\n    @singleton\n    def provide_db_connection(self) -&gt; str:\n        return \"postgresql://localhost:5432/mydb\"\n\n    @provider\n    @singleton\n    def provide_smtp_config(self) -&gt; dict:\n        return {\n            \"host\": \"smtp.example.com\",\n            \"port\": 587,\n            \"username\": \"user@example.com\",\n            \"password\": \"password\"\n        }\n\n# Setup and usage\ninjector = Injector([AppModule])\nuser_service = injector.get(UserService)\nresult = user_service.register_user({\n    \"id\": \"123\",\n    \"email\": \"user@example.com\"\n})\n</code></pre>"},{"location":"migration/python-injector/#migrated-injectq-application","title":"Migrated InjectQ Application","text":"<pre><code># \u2705 Migrated InjectQ Application\nfrom injectq import InjectQ, inject, Module\nfrom abc import ABC, abstractmethod\n\n# Interfaces (same)\nclass IUserRepository(ABC):\n    @abstractmethod\n    def find_user(self, user_id: str):\n        pass\n\nclass IEmailService(ABC):\n    @abstractmethod\n    def send_email(self, to: str, subject: str, body: str):\n        pass\n\n# Implementations (same)\nclass SqlUserRepository(IUserRepository):\n    @inject\n    def __init__(self, db_connection: str):\n        self.db_connection = db_connection\n\n    def find_user(self, user_id: str):\n        return {\"id\": user_id, \"name\": \"John Doe\"}\n\nclass SmtpEmailService(IEmailService):\n    @inject\n    def __init__(self, smtp_config: dict):\n        self.smtp_config = smtp_config\n\n    def send_email(self, to: str, subject: str, body: str):\n        print(f\"Sending email to {to}: {subject}\")\n\nclass UserService:\n    @inject\n    def __init__(self, user_repo: IUserRepository, email_service: IEmailService):\n        self.user_repo = user_repo\n        self.email_service = email_service\n\n    def register_user(self, user_data: dict):\n        user = self.user_repo.find_user(user_data[\"id\"])\n        self.email_service.send_email(\n            user_data[\"email\"],\n            \"Welcome!\",\n            \"Welcome to our service\"\n        )\n        return user\n\n# Module configuration (updated)\nclass AppModule(Module):\n    def configure(self):\n        self.bind(IUserRepository, SqlUserRepository).singleton()\n        self.bind(IEmailService, SmtpEmailService).singleton()\n        self.bind(UserService, UserService).singleton()\n\n        # Provider bindings\n        self.bind(str, self.provide_db_connection, name=\"db_connection\").singleton()\n        self.bind(dict, self.provide_smtp_config, name=\"smtp_config\").singleton()\n\n    def provide_db_connection(self) -&gt; str:\n        return \"postgresql://localhost:5432/mydb\"\n\n    def provide_smtp_config(self) -&gt; dict:\n        return {\n            \"host\": \"smtp.example.com\",\n            \"port\": 587,\n            \"username\": \"user@example.com\",\n            \"password\": \"password\"\n        }\n\n# Setup and usage (updated)\ncontainer = InjectQ()\ncontainer.install(AppModule())\nuser_service = container.get(UserService)\nresult = user_service.register_user({\n    \"id\": \"123\",\n    \"email\": \"user@example.com\"\n})\n</code></pre>"},{"location":"migration/python-injector/#advanced-migration-patterns","title":"\ud83c\udfaf Advanced Migration Patterns","text":""},{"location":"migration/python-injector/#scope-migration","title":"Scope Migration","text":"<pre><code># \u274c python-injector scopes\nfrom injector import singleton, threadlocal\n\nclass DatabaseModule(Module):\n    def configure(self, binder):\n        binder.bind(DatabaseConnection, scope=singleton)\n        binder.bind(RequestContext, scope=threadlocal)\n\n# \u2705 InjectQ scopes\nclass DatabaseModule(Module):\n    def configure(self):\n        self.bind(DatabaseConnection, DatabaseConnection).singleton()\n        self.bind(RequestContext, RequestContext).scoped()  # or thread_local()\n</code></pre>"},{"location":"migration/python-injector/#provider-method-migration","title":"Provider Method Migration","text":"<pre><code># \u274c python-injector provider methods\nfrom injector import provider, singleton\n\nclass ServiceModule(Module):\n    @provider\n    @singleton\n    def provide_complex_service(self, dep1: Service1, dep2: Service2) -&gt; ComplexService:\n        return ComplexService(dep1, dep2, configuration=\"production\")\n\n# \u2705 InjectQ provider methods\nclass ServiceModule(Module):\n    def configure(self):\n        self.bind(ComplexService, self.provide_complex_service).singleton()\n\n    def provide_complex_service(self) -&gt; ComplexService:\n        dep1 = self.container.get(Service1)\n        dep2 = self.container.get(Service2)\n        return ComplexService(dep1, dep2, configuration=\"production\")\n\n# Alternative: lambda provider\nclass ServiceModule(Module):\n    def configure(self):\n        self.bind(ComplexService, lambda: ComplexService(\n            self.container.get(Service1),\n            self.container.get(Service2),\n            configuration=\"production\"\n        )).singleton()\n</code></pre>"},{"location":"migration/python-injector/#multi-binding-migration","title":"Multi-binding Migration","text":"<pre><code># \u274c python-injector multi-binding\nfrom injector import multiprovider\n\nclass PluginModule(Module):\n    @multiprovider\n    @singleton\n    def provide_plugins(self) -&gt; List[Plugin]:\n        return [\n            DatabasePlugin(),\n            CachePlugin(),\n            LoggingPlugin()\n        ]\n\n# \u2705 InjectQ multi-binding\nfrom typing import List\n\nclass PluginModule(Module):\n    def configure(self):\n        # Individual plugin bindings\n        self.bind(Plugin, DatabasePlugin(), name=\"database\")\n        self.bind(Plugin, CachePlugin(), name=\"cache\")\n        self.bind(Plugin, LoggingPlugin(), name=\"logging\")\n\n        # Aggregate binding\n        self.bind(List[Plugin], self.provide_plugins).singleton()\n\n    def provide_plugins(self) -&gt; List[Plugin]:\n        return [\n            self.container.get(Plugin, name=\"database\"),\n            self.container.get(Plugin, name=\"cache\"),\n            self.container.get(Plugin, name=\"logging\")\n        ]\n\n# Or use collection binding\nclass PluginModule(Module):\n    def configure(self):\n        plugins = [DatabasePlugin(), CachePlugin(), LoggingPlugin()]\n        self.bind(List[Plugin], plugins).singleton()\n</code></pre>"},{"location":"migration/python-injector/#interface-implementation-migration","title":"Interface Implementation Migration","text":"<pre><code># \u274c python-injector abstract binding\nfrom injector import InstanceProvider\n\nclass ServiceModule(Module):\n    def configure(self, binder):\n        # Abstract binding\n        binder.bind(IEmailService, to=SmtpEmailService)\n\n        # Instance binding\n        binder.bind(str, to=InstanceProvider(\"production\"), annotation=\"environment\")\n\n# \u2705 InjectQ interface binding\nclass ServiceModule(Module):\n    def configure(self):\n        # Interface binding\n        self.bind(IEmailService, SmtpEmailService)\n\n        # Instance binding\n        self.bind(str, \"production\", name=\"environment\")\n</code></pre>"},{"location":"migration/python-injector/#testing-migration","title":"\ud83e\uddea Testing Migration","text":""},{"location":"migration/python-injector/#python-injector-testing","title":"python-injector Testing","text":"<pre><code># \u274c python-injector testing\nimport unittest\nfrom injector import Injector, Module\n\nclass TestUserService(unittest.TestCase):\n    def setUp(self):\n        class TestModule(Module):\n            def configure(self, binder):\n                binder.bind(IUserRepository, to=MockUserRepository)\n                binder.bind(IEmailService, to=MockEmailService)\n\n        self.injector = Injector([TestModule])\n\n    def test_register_user(self):\n        user_service = self.injector.get(UserService)\n        result = user_service.register_user({\"id\": \"123\", \"email\": \"test@example.com\"})\n        self.assertIsNotNone(result)\n</code></pre>"},{"location":"migration/python-injector/#injectq-testing","title":"InjectQ Testing","text":"<pre><code># \u2705 InjectQ testing\nimport unittest\nfrom injectq import InjectQ, Module\n\nclass TestUserService(unittest.TestCase):\n    def setUp(self):\n        class TestModule(Module):\n            def configure(self):\n                self.bind(IUserRepository, MockUserRepository)\n                self.bind(IEmailService, MockEmailService)\n\n        self.container = InjectQ()\n        self.container.install(TestModule())\n\n    def test_register_user(self):\n        user_service = self.container.get(UserService)\n        result = user_service.register_user({\"id\": \"123\", \"email\": \"test@example.com\"})\n        self.assertIsNotNone(result)\n\n    def test_with_override(self):\n        # InjectQ supports runtime overrides\n        special_mock = SpecialMockUserRepository()\n        with self.container.override(IUserRepository, special_mock):\n            user_service = self.container.get(UserService)\n            # Test with special mock...\n</code></pre>"},{"location":"migration/python-injector/#async-support-migration","title":"\ud83d\udd17 Async Support Migration","text":""},{"location":"migration/python-injector/#python-injector-async","title":"python-injector Async","text":"<pre><code># \u274c python-injector (limited async support)\nclass AsyncService:\n    @inject\n    def __init__(self, db: DatabaseConnection):\n        self.db = db\n\n    async def process_data(self):\n        # Async operations\n        return await self.db.fetch_data()\n\n# Manual async injection\nasync def main():\n    injector = Injector([AppModule])\n    service = injector.get(AsyncService)\n    result = await service.process_data()\n</code></pre>"},{"location":"migration/python-injector/#injectq-async","title":"InjectQ Async","text":"<pre><code># \u2705 InjectQ (comprehensive async support)\nclass AsyncService:\n    @inject\n    def __init__(self, db: DatabaseConnection):\n        self.db = db\n\n    async def process_data(self):\n        return await self.db.fetch_data()\n\n# Async container support\nasync def main():\n    container = InjectQ()\n    container.install(AppModule())\n\n    # Async resolution\n    service = await container.aget(AsyncService)\n    result = await service.process_data()\n\n    # Async context managers\n    async with container.async_scope():\n        scoped_service = container.get(ScopedAsyncService)\n        await scoped_service.process()\n</code></pre>"},{"location":"migration/python-injector/#configuration-migration","title":"\ud83d\udd27 Configuration Migration","text":""},{"location":"migration/python-injector/#environment-based-configuration","title":"Environment-based Configuration","text":"<pre><code># \u274c python-injector configuration\nimport os\nfrom injector import Module, provider, singleton\n\nclass ConfigModule(Module):\n    @provider\n    @singleton\n    def provide_database_config(self) -&gt; DatabaseConfig:\n        env = os.getenv(\"ENVIRONMENT\", \"development\")\n        if env == \"production\":\n            return DatabaseConfig(\n                host=\"prod-db.example.com\",\n                port=5432,\n                database=\"production\"\n            )\n        else:\n            return DatabaseConfig(\n                host=\"localhost\",\n                port=5433,\n                database=\"test\"\n            )\n\n# \u2705 InjectQ configuration\nimport os\nfrom injectq import Module\n\nclass ConfigModule(Module):\n    def configure(self):\n        env = os.getenv(\"ENVIRONMENT\", \"development\")\n\n        if env == \"production\":\n            config = DatabaseConfig(\n                host=\"prod-db.example.com\",\n                port=5432,\n                database=\"production\"\n            )\n        else:\n            config = DatabaseConfig(\n                host=\"localhost\",\n                port=5433,\n                database=\"test\"\n            )\n\n        self.bind(DatabaseConfig, config).singleton()\n\n# Or use conditional modules\nclass ProductionModule(Module):\n    def configure(self):\n        self.bind(DatabaseConfig, DatabaseConfig(\n            host=\"prod-db.example.com\",\n            port=5432,\n            database=\"production\"\n        )).singleton()\n\nclass DevelopmentModule(Module):\n    def configure(self):\n        self.bind(DatabaseConfig, DatabaseConfig(\n            host=\"localhost\",\n            port=5433,\n            database=\"test\"\n        )).singleton()\n\n# Usage\ncontainer = InjectQ()\nenv = os.getenv(\"ENVIRONMENT\", \"development\")\nif env == \"production\":\n    container.install(ProductionModule())\nelse:\n    container.install(DevelopmentModule())\n</code></pre>"},{"location":"migration/python-injector/#performance-comparison","title":"\u26a1 Performance Comparison","text":""},{"location":"migration/python-injector/#memory-usage","title":"Memory Usage","text":"<pre><code># python-injector uses more reflection\n# InjectQ optimizes for performance\n\n# Performance monitoring with InjectQ\nfrom injectq.profiling import PerformanceMonitor\n\nmonitor = PerformanceMonitor(container)\n\n# Profile resolution performance\nwith monitor.profile_resolution(UserService) as profile:\n    service = container.get(UserService)\n\nresults = profile.get_results()\nprint(f\"Resolution time: {results.total_time}ms\")\nprint(f\"Memory usage: {results.memory_usage} bytes\")\n</code></pre>"},{"location":"migration/python-injector/#startup-time","title":"Startup Time","text":"<pre><code># Measure container setup time\nimport time\n\n# InjectQ container setup\nstart_time = time.time()\ncontainer = InjectQ()\ncontainer.install(AppModule())\nsetup_time = (time.time() - start_time) * 1000\n\nprint(f\"Container setup time: {setup_time}ms\")\n\n# Pre-compile for faster resolution\ncontainer.compile()  # Optional optimization\n</code></pre>"},{"location":"migration/python-injector/#migration-summary","title":"\ud83c\udfaf Migration Summary","text":""},{"location":"migration/python-injector/#key-changes","title":"Key Changes","text":"<ol> <li>Injector \u2192 Container: Replace <code>Injector</code> with <code>InjectQ</code></li> <li>Module.configure(): Remove <code>binder</code> parameter, use <code>self.bind()</code></li> <li>Provider Methods: Access container via <code>self.container</code> instead of injection</li> <li>Scopes: Use method chaining (<code>.singleton()</code>, <code>.scoped()</code>)</li> <li>Multi-binding: Use named bindings or collection bindings</li> <li>Testing: Enhanced override capabilities and test utilities</li> </ol>"},{"location":"migration/python-injector/#benefits-of-migration","title":"Benefits of Migration","text":"<ul> <li>Better Performance: Optimized resolution and memory usage</li> <li>Async Support: Comprehensive async/await support</li> <li>Type Safety: Better type checking and annotation support</li> <li>Testing Tools: Enhanced testing utilities and mocking</li> <li>Profiling: Built-in performance monitoring and profiling</li> <li>Flexibility: More binding options and configuration patterns</li> </ul>"},{"location":"migration/python-injector/#migration-tips","title":"Migration Tips","text":"<ol> <li>Start Simple: Begin with basic service bindings</li> <li>Test Early: Migrate tests alongside production code</li> <li>Use Modules: Organize bindings with modules for better structure</li> <li>Profile Performance: Use InjectQ's profiling tools to optimize</li> <li>Leverage Async: Take advantage of async support where beneficial</li> <li>Monitor Memory: Use InjectQ's memory monitoring for optimization</li> </ol>"},{"location":"migration/python-injector/#common-patterns","title":"Common Patterns","text":"<ul> <li>Replace <code>@provider</code> with method bindings in modules</li> <li>Use named bindings instead of annotations</li> <li>Leverage InjectQ's scope chaining syntax</li> <li>Take advantage of enhanced testing utilities</li> <li>Use async features for async applications</li> </ul> <p>Ready to explore migration from other DI frameworks?</p>"},{"location":"modules/configuration-modules/","title":"Configuration Modules","text":"<p>Configuration modules are the foundation of InjectQ's module system, providing a clean way to organize and configure your dependency bindings.</p>"},{"location":"modules/configuration-modules/#what-are-configuration-modules","title":"\ud83c\udfaf What are Configuration Modules?","text":"<p>Configuration modules are classes that implement the <code>Module</code> interface and define how services are bound to the container.</p> <pre><code>from injectq import Module, InjectQ\n\nclass DatabaseModule(Module):\n    def configure(self, binder):\n        # Bind interfaces to implementations\n        binder.bind(IDatabaseConnection, PostgresConnection())\n        binder.bind(IUserRepository, UserRepositoryImpl())\n\n        # Configure with specific settings\n        binder.bind(DatabaseConfig, DatabaseConfig(max_pool_size=20))\n\n# Usage\ncontainer = InjectQ()\ncontainer.install(DatabaseModule())\n\n# Services are now available\ndb_conn = container.get(IDatabaseConnection)\nuser_repo = container.get(IUserRepository)\n</code></pre>"},{"location":"modules/configuration-modules/#creating-configuration-modules","title":"\ud83d\udd27 Creating Configuration Modules","text":""},{"location":"modules/configuration-modules/#basic-module-structure","title":"Basic Module Structure","text":"<pre><code>from injectq import Module\n\nclass MyModule(Module):\n    def configure(self, binder):\n        \"\"\"\n        Configure bindings for this module.\n\n        Args:\n            binder: The binder object used to create bindings\n        \"\"\"\n        # Add your bindings here\n        pass\n</code></pre>"},{"location":"modules/configuration-modules/#constructor-parameters","title":"Constructor Parameters","text":"<pre><code>class ConfigurableModule(Module):\n    def __init__(self, config: AppConfig):\n        self.config = config\n\n    def configure(self, binder):\n        # Use configuration in bindings\n        binder.bind(IDatabase, PostgresDatabase(self.config.database_url))\n        binder.bind(ICache, RedisCache(self.config.redis_url))\n</code></pre>"},{"location":"modules/configuration-modules/#multiple-constructors","title":"Multiple Constructors","text":"<pre><code>class FlexibleModule(Module):\n    def __init__(self, database_url: str = None, cache_url: str = None):\n        self.database_url = database_url or \"postgresql://localhost/default\"\n        self.cache_url = cache_url or \"redis://localhost:6379\"\n\n    @classmethod\n    def from_config(cls, config: dict) -&gt; 'FlexibleModule':\n        \"\"\"Create module from configuration dictionary\"\"\"\n        return cls(\n            database_url=config.get(\"database_url\"),\n            cache_url=config.get(\"cache_url\")\n        )\n\n    @classmethod\n    def production(cls) -&gt; 'FlexibleModule':\n        \"\"\"Production configuration\"\"\"\n        return cls(\n            database_url=os.getenv(\"DATABASE_URL\"),\n            cache_url=os.getenv(\"REDIS_URL\")\n        )\n</code></pre>"},{"location":"modules/configuration-modules/#binding-patterns","title":"\ud83c\udfa8 Binding Patterns","text":""},{"location":"modules/configuration-modules/#interface-to-implementation","title":"Interface to Implementation","text":"<pre><code>class RepositoryModule(Module):\n    def configure(self, binder):\n        # Bind interfaces to concrete implementations\n        binder.bind(IUserRepository, SqlUserRepository())\n        binder.bind(IOrderRepository, SqlOrderRepository())\n        binder.bind(IProductRepository, SqlProductRepository())\n\n        # All repositories use the same database connection\n        binder.bind(IDatabaseConnection, PostgresConnection())\n</code></pre>"},{"location":"modules/configuration-modules/#singleton-bindings","title":"Singleton Bindings","text":"<pre><code>class SingletonModule(Module):\n    def configure(self, binder):\n        # Explicit singleton binding\n        binder.bind(IAppConfig, AppConfig(), scope=Scope.SINGLETON)\n\n        # Or use decorator (same result)\n        @singleton\n        class AppConfigImpl:\n            pass\n\n        binder.bind(IAppConfig, AppConfigImpl())\n</code></pre>"},{"location":"modules/configuration-modules/#factory-functions","title":"Factory Functions","text":"<pre><code>class FactoryModule(Module):\n    def configure(self, binder):\n        # Bind to factory function\n        def create_database_connection():\n            return PostgresConnection(\n                host=\"localhost\",\n                port=5432,\n                database=\"myapp\"\n            )\n\n        binder.bind_factory(IDatabaseConnection, create_database_connection)\n</code></pre>"},{"location":"modules/configuration-modules/#conditional-bindings","title":"Conditional Bindings","text":"<pre><code>class EnvironmentModule(Module):\n    def __init__(self, environment: str):\n        self.environment = environment\n\n    def configure(self, binder):\n        if self.environment == \"production\":\n            binder.bind(IDatabase, PostgresDatabase())\n            binder.bind(ICache, RedisCache())\n        elif self.environment == \"testing\":\n            binder.bind(IDatabase, InMemoryDatabase())\n            binder.bind(ICache, NoOpCache())\n        else:  # development\n            binder.bind(IDatabase, PostgresDatabase())\n            binder.bind(ICache, InMemoryCache())\n</code></pre>"},{"location":"modules/configuration-modules/#module-dependencies","title":"\ud83d\udd04 Module Dependencies","text":""},{"location":"modules/configuration-modules/#dependent-modules","title":"Dependent Modules","text":"<pre><code>class InfrastructureModule(Module):\n    def configure(self, binder):\n        binder.bind(IDatabaseConnection, PostgresConnection())\n        binder.bind(ICache, RedisCache())\n\nclass ServiceModule(Module):\n    def configure(self, binder):\n        # Depends on InfrastructureModule\n        binder.bind(IUserService, UserService())\n        binder.bind(IOrderService, OrderService())\n\n# Installation order matters\ncontainer.install(InfrastructureModule())  # First\ncontainer.install(ServiceModule())         # Second\n</code></pre>"},{"location":"modules/configuration-modules/#cross-module-references","title":"Cross-Module References","text":"<pre><code>class DatabaseModule(Module):\n    def configure(self, binder):\n        binder.bind(IDatabaseConnection, PostgresConnection())\n\nclass RepositoryModule(Module):\n    def configure(self, binder):\n        # References service from DatabaseModule\n        binder.bind(IUserRepository, UserRepository())\n\nclass ServiceModule(Module):\n    def configure(self, binder):\n        # References services from RepositoryModule\n        binder.bind(IUserService, UserService())\n</code></pre>"},{"location":"modules/configuration-modules/#testing-configuration-modules","title":"\ud83e\uddea Testing Configuration Modules","text":""},{"location":"modules/configuration-modules/#module-isolation-testing","title":"Module Isolation Testing","text":"<pre><code>def test_database_module():\n    \"\"\"Test database module bindings\"\"\"\n    container = InjectQ()\n    container.install(DatabaseModule())\n\n    # Test bindings exist\n    db_conn = container.get(IDatabaseConnection)\n    assert isinstance(db_conn, PostgresConnection)\n\n    user_repo = container.get(IUserRepository)\n    assert isinstance(user_repo, SqlUserRepository)\n\ndef test_environment_modules():\n    \"\"\"Test different environment configurations\"\"\"\n    # Test production\n    prod_container = InjectQ()\n    prod_container.install(EnvironmentModule(\"production\"))\n\n    prod_db = prod_container.get(IDatabase)\n    assert isinstance(prod_db, PostgresDatabase)\n\n    # Test testing\n    test_container = InjectQ()\n    test_container.install(EnvironmentModule(\"testing\"))\n\n    test_db = test_container.get(IDatabase)\n    assert isinstance(test_db, InMemoryDatabase)\n</code></pre>"},{"location":"modules/configuration-modules/#mock-module-replacement","title":"Mock Module Replacement","text":"<pre><code>class MockDatabaseModule(Module):\n    def configure(self, binder):\n        binder.bind(IDatabaseConnection, MockDatabaseConnection())\n\ndef test_service_with_mock_database():\n    \"\"\"Test service with mocked database\"\"\"\n    container = InjectQ()\n\n    # Use mock database\n    container.install(MockDatabaseModule())\n\n    # Use real service\n    container.install(ServiceModule())\n\n    service = container.get(IUserService)\n    result = service.get_user(123)\n\n    # Verify mock was used\n    mock_db = container.get(IDatabaseConnection)\n    assert mock_db.get_user_called\n</code></pre>"},{"location":"modules/configuration-modules/#partial-module-override","title":"Partial Module Override","text":"<pre><code>class TestOverridesModule(Module):\n    def configure(self, binder):\n        # Override only specific bindings\n        binder.bind(IUserRepository, MockUserRepository())\n        # Other bindings remain from production modules\n\ndef test_with_partial_override():\n    \"\"\"Test with partial module override\"\"\"\n    container = InjectQ()\n\n    # Install production modules\n    container.install(DatabaseModule())\n    container.install(RepositoryModule())\n\n    # Override just the repository\n    container.install(TestOverridesModule())\n\n    # Database connection is real\n    db_conn = container.get(IDatabaseConnection)\n    assert isinstance(db_conn, PostgresConnection)\n\n    # Repository is mocked\n    user_repo = container.get(IUserRepository)\n    assert isinstance(user_repo, MockUserRepository)\n</code></pre>"},{"location":"modules/configuration-modules/#module-anti-patterns","title":"\ud83d\udea8 Module Anti-Patterns","text":""},{"location":"modules/configuration-modules/#1-god-module","title":"1. God Module","text":"<pre><code># \u274c Bad: Single module with everything\nclass EverythingModule(Module):\n    def configure(self, binder):\n        # Database\n        binder.bind(IDatabase, PostgresDatabase())\n\n        # Cache\n        binder.bind(ICache, RedisCache())\n\n        # Email\n        binder.bind(IEmailService, SmtpEmailService())\n\n        # Logging\n        binder.bind(ILogger, FileLogger())\n\n        # Security\n        binder.bind(IAuth, JWTAuth())\n\n        # 50+ more bindings...\n\n# \u2705 Good: Split into focused modules\nclass DatabaseModule(Module): pass\nclass CacheModule(Module): pass\nclass EmailModule(Module): pass\nclass LoggingModule(Module): pass\nclass SecurityModule(Module): pass\n</code></pre>"},{"location":"modules/configuration-modules/#2-tight-coupling","title":"2. Tight Coupling","text":"<pre><code># \u274c Bad: Modules with tight coupling\nclass TightlyCoupledModule(Module):\n    def configure(self, binder):\n        # Direct instantiation creates tight coupling\n        binder.bind(IUserService, UserService(SqlUserRepository(PostgresConnection())))\n\n# \u2705 Good: Loose coupling through interfaces\nclass LooselyCoupledModule(Module):\n    def configure(self, binder):\n        binder.bind(IDatabaseConnection, PostgresConnection())\n        binder.bind(IUserRepository, SqlUserRepository())\n        binder.bind(IUserService, UserService())\n</code></pre>"},{"location":"modules/configuration-modules/#3-configuration-scattered","title":"3. Configuration Scattered","text":"<pre><code># \u274c Bad: Configuration scattered across modules\nclass DatabaseModule(Module):\n    def configure(self, binder):\n        binder.bind(IDatabase, PostgresDatabase(\"hardcoded-url\"))\n\nclass CacheModule(Module):\n    def configure(self, binder):\n        binder.bind(ICache, RedisCache(\"hardcoded-url\"))\n\n# \u2705 Good: Centralized configuration\n@dataclass\nclass AppConfig:\n    database_url: str\n    redis_url: str\n\nclass ConfigModule(Module):\n    def __init__(self, config: AppConfig):\n        self.config = config\n\n    def configure(self, binder):\n        binder.bind(AppConfig, self.config)\n\nclass DatabaseModule(Module):\n    def configure(self, binder):\n        config = binder.get(AppConfig)\n        binder.bind(IDatabase, PostgresDatabase(config.database_url))\n</code></pre>"},{"location":"modules/configuration-modules/#4-side-effects-in-configure","title":"4. Side Effects in Configure","text":"<pre><code># \u274c Bad: Side effects in configure\nclass SideEffectModule(Module):\n    def configure(self, binder):\n        # Side effect: creates files, network connections\n        self.create_directories()\n        self.initialize_database()\n\n        binder.bind(IService, MyService())\n\n# \u2705 Good: Pure configuration\nclass PureModule(Module):\n    def configure(self, binder):\n        binder.bind(IService, MyService())\n\n    def initialize(self):\n        \"\"\"Call this after container setup\"\"\"\n        self.create_directories()\n        self.initialize_database()\n</code></pre>"},{"location":"modules/configuration-modules/#best-practices","title":"\ud83c\udfc6 Best Practices","text":""},{"location":"modules/configuration-modules/#1-single-responsibility","title":"1. Single Responsibility","text":"<pre><code># \u2705 Each module has one clear responsibility\nclass UserManagementModule(Module):\n    \"\"\"Handles user-related services\"\"\"\n\nclass OrderProcessingModule(Module):\n    \"\"\"Handles order-related services\"\"\"\n\nclass InfrastructureModule(Module):\n    \"\"\"Handles infrastructure services\"\"\"\n</code></pre>"},{"location":"modules/configuration-modules/#2-interface-segregation","title":"2. Interface Segregation","text":"<pre><code># \u2705 Bind to specific interfaces\nclass RepositoryModule(Module):\n    def configure(self, binder):\n        binder.bind(IReadOnlyRepository, ReadOnlyRepository())\n        binder.bind(IWriteRepository, WriteRepository())\n        binder.bind(IFullRepository, FullRepository())\n\n# \u274c Don't bind to generic interfaces\nclass GenericModule(Module):\n    def configure(self, binder):\n        binder.bind(IRepository, GenericRepository())  # Too generic\n</code></pre>"},{"location":"modules/configuration-modules/#3-configuration-injection","title":"3. Configuration Injection","text":"<pre><code># \u2705 Inject configuration\nclass ConfigurableModule(Module):\n    def __init__(self, config: ServiceConfig):\n        self.config = config\n\n    def configure(self, binder):\n        binder.bind(IService, MyService(self.config.api_key))\n\n# Usage\nconfig = ServiceConfig(api_key=os.getenv(\"API_KEY\"))\ncontainer.install(ConfigurableModule(config))\n</code></pre>"},{"location":"modules/configuration-modules/#4-factory-methods","title":"4. Factory Methods","text":"<pre><code># \u2705 Use factory methods for complex setup\nclass ComplexModule(Module):\n    def configure(self, binder):\n        binder.bind_factory(\n            IDatabasePool,\n            self.create_database_pool\n        )\n\n    def create_database_pool(self) -&gt; IDatabasePool:\n        return DatabasePool(\n            host=self.config.host,\n            port=self.config.port,\n            max_connections=self.config.max_conn\n        )\n</code></pre>"},{"location":"modules/configuration-modules/#5-documentation","title":"5. Documentation","text":"<pre><code>class DocumentedModule(Module):\n    \"\"\"\n    User Authentication Module\n\n    Provides authentication and authorization services for users.\n\n    Bindings:\n    - IAuthenticator -&gt; JWTAuthenticator\n    - IAuthorizer -&gt; RBACAuthorizer\n    - IUserSession -&gt; DatabaseUserSession\n\n    Dependencies:\n    - Requires InfrastructureModule for database access\n    - Requires SecurityModule for encryption\n\n    Configuration:\n    - JWT_SECRET: Secret key for JWT tokens\n    - SESSION_TIMEOUT: Session timeout in seconds\n    \"\"\"\n\n    def __init__(self, jwt_secret: str, session_timeout: int = 3600):\n        self.jwt_secret = jwt_secret\n        self.session_timeout = session_timeout\n\n    def configure(self, binder):\n        binder.bind(IAuthenticator, JWTAuthenticator(self.jwt_secret))\n        binder.bind(IAuthorizer, RBACAuthorizer())\n        binder.bind(IUserSession, DatabaseUserSession(self.session_timeout))\n</code></pre>"},{"location":"modules/configuration-modules/#advanced-patterns","title":"\u26a1 Advanced Patterns","text":""},{"location":"modules/configuration-modules/#module-composition","title":"Module Composition","text":"<pre><code>class CompositeModule(Module):\n    \"\"\"Module that composes other modules\"\"\"\n\n    def __init__(self, config: AppConfig):\n        self.config = config\n        self.submodules = [\n            DatabaseModule(self.config.database),\n            CacheModule(self.config.cache),\n            EmailModule(self.config.email),\n        ]\n\n    def configure(self, binder):\n        # Configure this module\n        binder.bind(AppConfig, self.config)\n\n        # Install submodules\n        for module in self.submodules:\n            container.install(module)\n</code></pre>"},{"location":"modules/configuration-modules/#dynamic-module-loading","title":"Dynamic Module Loading","text":"<pre><code>def load_modules_from_plugins(plugin_dir: str) -&gt; List[Module]:\n    \"\"\"Load modules from plugin directory\"\"\"\n    modules = []\n\n    for plugin_file in Path(plugin_dir).glob(\"**/*.py\"):\n        module_name = plugin_file.stem\n\n        # Import and instantiate\n        plugin_module = importlib.import_module(f\"plugins.{module_name}\")\n        plugin_class = getattr(plugin_module, f\"{module_name.title()}Module\")\n\n        modules.append(plugin_class())\n\n    return modules\n\n# Usage\nplugin_modules = load_modules_from_plugins(\"plugins/\")\nfor module in plugin_modules:\n    container.install(module)\n</code></pre>"},{"location":"modules/configuration-modules/#module-health-checks","title":"Module Health Checks","text":"<pre><code>class HealthCheckModule(Module):\n    def configure(self, binder):\n        binder.bind(IHealthChecker, ModuleHealthChecker())\n\n    @provider\n    def create_health_checker(self) -&gt; IHealthChecker:\n        return ModuleHealthChecker([\n            DatabaseHealthCheck(),\n            CacheHealthCheck(),\n            EmailHealthCheck(),\n        ])\n\nclass ModuleHealthChecker:\n    def __init__(self, checks: List[HealthCheck]):\n        self.checks = checks\n\n    def check_health(self) -&gt; HealthStatus:\n        results = []\n        for check in self.checks:\n            results.append(check.perform_check())\n\n        return HealthStatus(\n            healthy=all(r.healthy for r in results),\n            checks=results\n        )\n</code></pre>"},{"location":"modules/configuration-modules/#summary","title":"\ud83c\udfaf Summary","text":"<p>Configuration modules provide:</p> <ul> <li>Clean organization - Group related bindings together</li> <li>Reusability - Use across different applications</li> <li>Testability - Easy to replace for testing</li> <li>Maintainability - Clear separation of concerns</li> <li>Flexibility - Configurable through parameters</li> </ul> <p>Key principles: - Single responsibility per module - Interface-based bindings - Configuration through constructor parameters - Factory methods for complex services - Comprehensive documentation</p> <p>Common patterns: - Domain modules for business logic - Infrastructure modules for technical services - Environment-specific modules - Test override modules</p> <p>Ready to explore provider modules?</p>"},{"location":"modules/module-best-practices/","title":"Module Best Practices","text":"<p>Module best practices guide you to create maintainable, testable, and reusable modules that work well together in complex applications.</p>"},{"location":"modules/module-best-practices/#module-design-principles","title":"\ud83c\udfaf Module Design Principles","text":""},{"location":"modules/module-best-practices/#single-responsibility-principle","title":"Single Responsibility Principle","text":"<p>Each module should have one clear, focused responsibility.</p> <pre><code># \u2705 Good: Single responsibility modules\nclass UserManagementModule(Module):\n    \"\"\"Handles user registration, authentication, and profiles\"\"\"\n\nclass OrderProcessingModule(Module):\n    \"\"\"Handles order creation, payment, and fulfillment\"\"\"\n\nclass EmailCommunicationModule(Module):\n    \"\"\"Handles all email sending and templates\"\"\"\n\nclass DatabaseInfrastructureModule(Module):\n    \"\"\"Handles database connections and migrations\"\"\"\n\n# \u274c Bad: Multiple responsibilities\nclass EverythingModule(Module):\n    \"\"\"Handles users, orders, email, database, cache, logging...\"\"\"\n</code></pre>"},{"location":"modules/module-best-practices/#interface-segregation","title":"Interface Segregation","text":"<p>Bind to interfaces, not implementations.</p> <pre><code># \u2705 Good: Interface-based bindings\nclass RepositoryModule(Module):\n    def configure(self, binder):\n        binder.bind(IUserRepository, SqlUserRepository())\n        binder.bind(IOrderRepository, SqlOrderRepository())\n\n# \u274c Bad: Implementation bindings\nclass RepositoryModule(Module):\n    def configure(self, binder):\n        binder.bind(SqlUserRepository, SqlUserRepository())\n        binder.bind(SqlOrderRepository, SqlOrderRepository())\n</code></pre>"},{"location":"modules/module-best-practices/#dependency-inversion","title":"Dependency Inversion","text":"<p>Depend on abstractions, not concretions.</p> <pre><code># \u2705 Good: Depends on interfaces\nclass ServiceModule(Module):\n    @provider\n    def user_service(self, user_repo: IUserRepository, email_svc: IEmailService) -&gt; IUserService:\n        return UserService(user_repo, email_svc)\n\n# \u274c Bad: Depends on implementations\nclass ServiceModule(Module):\n    @provider\n    def user_service(self) -&gt; IUserService:\n        return UserService(SqlUserRepository(), SmtpEmailService())\n</code></pre>"},{"location":"modules/module-best-practices/#module-structure-guidelines","title":"\ud83c\udfd7\ufe0f Module Structure Guidelines","text":""},{"location":"modules/module-best-practices/#consistent-module-structure","title":"Consistent Module Structure","text":"<pre><code>class WellStructuredModule(Module):\n    \"\"\"\n    Module docstring describing responsibility and dependencies.\n    \"\"\"\n\n    def __init__(self, config: ModuleConfig):\n        \"\"\"Initialize with configuration.\"\"\"\n        self.config = config\n\n    def configure(self, binder):\n        \"\"\"\n        Configure bindings for this module.\n\n        This method should:\n        1. Bind interfaces to implementations\n        2. Configure services with settings\n        3. Set up any required infrastructure\n        \"\"\"\n        # Interface bindings\n        binder.bind(IMyService, MyServiceImpl(self.config))\n\n        # Configuration bindings\n        binder.bind(ModuleConfig, self.config)\n\n    # Optional: Provider methods for complex services\n    @provider\n    def complex_service(self, dep1: IDep1, dep2: IDep2) -&gt; IComplexService:\n        \"\"\"Provider for complex service creation.\"\"\"\n        return ComplexService(dep1, dep2, self.config)\n</code></pre>"},{"location":"modules/module-best-practices/#configuration-management","title":"Configuration Management","text":"<pre><code>@dataclass\nclass DatabaseConfig:\n    \"\"\"Configuration for database module.\"\"\"\n    host: str\n    port: int\n    database: str\n    username: str\n    password: str\n    max_connections: int = 20\n\nclass DatabaseModule(Module):\n    \"\"\"Database infrastructure module.\"\"\"\n\n    def __init__(self, config: DatabaseConfig):\n        self.config = config\n\n    def configure(self, binder):\n        # Bind configuration\n        binder.bind(DatabaseConfig, self.config)\n\n        # Bind services using configuration\n        binder.bind(IDatabaseConnection, PostgresConnection(self.config))\n\n    @provider\n    def connection_pool(self) -&gt; IDatabasePool:\n        \"\"\"Create database connection pool.\"\"\"\n        return DatabasePool(\n            host=self.config.host,\n            port=self.config.port,\n            database=self.config.database,\n            username=self.config.username,\n            password=self.config.password,\n            max_connections=self.config.max_connections\n        )\n</code></pre>"},{"location":"modules/module-best-practices/#naming-conventions","title":"\ud83d\udd27 Naming Conventions","text":""},{"location":"modules/module-best-practices/#module-naming","title":"Module Naming","text":"<pre><code># \u2705 Good naming patterns\nclass UserManagementModule(Module): pass      # Feature + Module\nclass DatabaseInfrastructureModule(Module): pass  # Layer + Feature + Module\nclass EmailNotificationModule(Module): pass   # Technology + Feature + Module\nclass PaymentProcessingModule(Module): pass   # Domain + Feature + Module\n\n# \u274c Bad naming\nclass Module1(Module): pass                   # Too generic\nclass MyModule(Module): pass                  # Not descriptive\nclass UserStuffModule(Module): pass           # Vague\n</code></pre>"},{"location":"modules/module-best-practices/#provider-method-naming","title":"Provider Method Naming","text":"<pre><code>class ServiceModule(Module):\n    # \u2705 Good: Descriptive names\n    @provider\n    def user_registration_service(self) -&gt; IUserRegistrationService:\n        return UserRegistrationService()\n\n    @provider\n    def email_notification_service(self) -&gt; IEmailNotificationService:\n        return EmailNotificationService()\n\n    # \u274c Bad: Generic names\n    @provider\n    def service1(self) -&gt; IService1:\n        return Service1Impl()\n\n    @provider\n    def create_service(self) -&gt; IService:\n        return Service()\n</code></pre>"},{"location":"modules/module-best-practices/#interface-naming","title":"Interface Naming","text":"<pre><code># \u2705 Good: Clear interface names\nclass IUserRepository: pass\nclass IEmailService: pass\nclass IPaymentProcessor: pass\n\n# \u274c Bad: Unclear names\nclass IRepo: pass\nclass IService: pass\nclass IProcessor: pass\n</code></pre>"},{"location":"modules/module-best-practices/#documentation-standards","title":"\ud83d\udcda Documentation Standards","text":""},{"location":"modules/module-best-practices/#module-documentation","title":"Module Documentation","text":"<pre><code>class UserManagementModule(Module):\n    \"\"\"\n    User Management Module\n\n    Provides comprehensive user management functionality including:\n    - User registration and authentication\n    - Profile management\n    - Password reset functionality\n    - User role and permission management\n\n    Bindings Provided:\n    - IUserRepository -&gt; SqlUserRepository\n    - IUserService -&gt; UserService\n    - IAuthenticationService -&gt; JWTAuthenticationService\n    - IPasswordResetService -&gt; EmailPasswordResetService\n\n    Dependencies Required:\n    - DatabaseInfrastructureModule: For data persistence\n    - EmailCommunicationModule: For notifications\n    - SecurityModule: For authentication\n\n    Configuration:\n    - Requires UserConfig with JWT settings\n    - Database connection from infrastructure module\n\n    Installation Order:\n    Must be installed after DatabaseInfrastructureModule,\n    EmailCommunicationModule, and SecurityModule.\n\n    Environment Variables:\n    - JWT_SECRET: Secret key for JWT tokens\n    - PASSWORD_RESET_URL: Base URL for password reset links\n\n    Example:\n        config = UserConfig(jwt_secret=\"secret\", reset_url=\"https://app.com/reset\")\n        container.install(UserManagementModule(config))\n    \"\"\"\n\n    def __init__(self, config: UserConfig):\n        self.config = config\n\n    def configure(self, binder):\n        # Implementation...\n        pass\n</code></pre>"},{"location":"modules/module-best-practices/#provider-documentation","title":"Provider Documentation","text":"<pre><code>class ComplexServiceModule(Module):\n    @provider\n    def payment_processing_service(\n        self,\n        payment_repo: IPaymentRepository,\n        fraud_detector: IFraudDetector,\n        notification_svc: INotificationService,\n        config: PaymentConfig\n    ) -&gt; IPaymentProcessingService:\n        \"\"\"\n        Create payment processing service with all dependencies.\n\n        This provider creates a comprehensive payment processing service\n        that handles payment authorization, capture, refunds, and fraud\n        detection with real-time notifications.\n\n        Args:\n            payment_repo: Repository for payment data persistence\n            fraud_detector: Service for fraud detection and prevention\n            notification_svc: Service for sending payment notifications\n            config: Configuration for payment processing settings\n\n        Returns:\n            Fully configured payment processing service\n\n        Dependencies:\n            - IPaymentRepository: For payment data storage\n            - IFraudDetector: For fraud detection\n            - INotificationService: For payment notifications\n            - PaymentConfig: For payment settings\n\n        Notes:\n            - Supports multiple payment methods (credit card, PayPal, etc.)\n            - Includes fraud detection with configurable risk thresholds\n            - Sends real-time notifications for payment events\n            - Handles automatic retries for failed payments\n\n        Raises:\n            ConfigurationError: If payment configuration is invalid\n            DependencyError: If required dependencies are not available\n        \"\"\"\n        return PaymentProcessingService(\n            payment_repo,\n            fraud_detector,\n            notification_svc,\n            config\n        )\n</code></pre>"},{"location":"modules/module-best-practices/#testing-best-practices","title":"\ud83e\uddea Testing Best Practices","text":""},{"location":"modules/module-best-practices/#module-testing","title":"Module Testing","text":"<pre><code>def test_module_bindings():\n    \"\"\"Test that module provides expected bindings.\"\"\"\n    container = InjectQ()\n    container.install(TestModule())\n\n    # Test all expected services are bound\n    service1 = container.get(IService1)\n    service2 = container.get(IService2)\n    config = container.get(ModuleConfig)\n\n    assert isinstance(service1, Service1Impl)\n    assert isinstance(service2, Service2Impl)\n    assert config.setting == \"test_value\"\n\ndef test_module_dependencies():\n    \"\"\"Test module with its dependencies.\"\"\"\n    container = InjectQ()\n\n    # Install dependencies first\n    container.install(MockDependencyModule())\n\n    # Install module under test\n    container.install(ModuleUnderTest())\n\n    # Test integration\n    service = container.get(IService)\n    result = service.do_work()\n\n    assert result.success\n</code></pre>"},{"location":"modules/module-best-practices/#provider-testing","title":"Provider Testing","text":"<pre><code>def test_provider_creation():\n    \"\"\"Test that providers create services correctly.\"\"\"\n    container = InjectQ()\n    container.install(ServiceModule())\n\n    # Mock dependencies\n    mock_repo = MockRepository()\n    mock_email = MockEmailService()\n    container.bind(IRepository, mock_repo)\n    container.bind(IEmailService, mock_email)\n\n    # Get provider-created service\n    service = container.get(IService)\n\n    # Verify dependencies were injected\n    assert service.repository is mock_repo\n    assert service.email_service is mock_email\n\ndef test_provider_error_handling():\n    \"\"\"Test provider error handling.\"\"\"\n    container = InjectQ()\n    container.install(ServiceModule())\n\n    # Test with missing dependency\n    with pytest.raises(DependencyResolutionError):\n        container.get(IService)  # Should fail if dependencies not bound\n</code></pre>"},{"location":"modules/module-best-practices/#integration-testing","title":"Integration Testing","text":"<pre><code>def test_module_integration():\n    \"\"\"Test multiple modules working together.\"\"\"\n    container = create_integration_container()\n\n    # Test complete workflow across modules\n    user_service = container.get(IUserService)\n    order_service = container.get(IOrderService)\n    email_service = container.get(IEmailService)\n\n    # Create user\n    user = user_service.create_user(\"test@example.com\", \"password\")\n    assert user.email == \"test@example.com\"\n\n    # Create order\n    order = order_service.create_order(user.id, [order_item])\n    assert order.user_id == user.id\n\n    # Verify notifications sent\n    assert len(email_service.sent_emails) == 2  # Welcome + order confirmation\n\ndef create_integration_container() -&gt; InjectQ:\n    \"\"\"Create container for integration testing.\"\"\"\n    container = InjectQ()\n\n    # Install test versions of all modules\n    container.install(TestDatabaseModule())\n    container.install(TestCacheModule())\n    container.install(UserManagementModule())\n    container.install(OrderProcessingModule())\n    container.install(MockEmailModule())\n\n    return container\n</code></pre>"},{"location":"modules/module-best-practices/#common-anti-patterns","title":"\ud83d\udea8 Common Anti-Patterns","text":""},{"location":"modules/module-best-practices/#1-god-module","title":"1. God Module","text":"<pre><code># \u274c Anti-pattern: God module\nclass GodModule(Module):\n    def configure(self, binder):\n        # Binds everything: database, cache, services, infrastructure...\n        binder.bind(IDatabase, PostgresDatabase())\n        binder.bind(ICache, RedisCache())\n        binder.bind(IUserService, UserService())\n        binder.bind(IOrderService, OrderService())\n        binder.bind(IEmailService, SmtpEmailService())\n        # ... 50+ more bindings\n\n# \u2705 Solution: Split into focused modules\nclass DatabaseModule(Module): pass\nclass CacheModule(Module): pass\nclass UserModule(Module): pass\nclass OrderModule(Module): pass\nclass EmailModule(Module): pass\n</code></pre>"},{"location":"modules/module-best-practices/#2-configuration-scattering","title":"2. Configuration Scattering","text":"<pre><code># \u274c Anti-pattern: Configuration scattered\nclass DatabaseModule(Module):\n    def configure(self, binder):\n        binder.bind(IDatabase, PostgresDatabase(\"hardcoded-url\"))\n\nclass CacheModule(Module):\n    def configure(self, binder):\n        binder.bind(ICache, RedisCache(\"hardcoded-url\"))\n\n# \u2705 Solution: Centralized configuration\n@dataclass\nclass AppConfig:\n    database_url: str\n    redis_url: str\n\nclass ConfigModule(Module):\n    def __init__(self, config: AppConfig):\n        self.config = config\n\n    def configure(self, binder):\n        binder.bind(AppConfig, self.config)\n\nclass DatabaseModule(Module):\n    def configure(self, binder):\n        config = binder.get(AppConfig)\n        binder.bind(IDatabase, PostgresDatabase(config.database_url))\n</code></pre>"},{"location":"modules/module-best-practices/#3-tight-coupling","title":"3. Tight Coupling","text":"<pre><code># \u274c Anti-pattern: Tight coupling\nclass TightlyCoupledModule(Module):\n    def configure(self, binder):\n        # Direct instantiation creates coupling\n        binder.bind(IService, Service(SqlRepository(), SmtpEmailService()))\n\n# \u2705 Solution: Loose coupling through interfaces\nclass LooselyCoupledModule(Module):\n    def configure(self, binder):\n        binder.bind(IService, Service())  # Dependencies resolved at runtime\n</code></pre>"},{"location":"modules/module-best-practices/#4-side-effects-in-configure","title":"4. Side Effects in Configure","text":"<pre><code># \u274c Anti-pattern: Side effects\nclass SideEffectModule(Module):\n    def configure(self, binder):\n        # Side effects in configuration\n        os.makedirs(\"/tmp/app_data\", exist_ok=True)\n        self.initialize_database()\n        binder.bind(IService, Service())\n\n# \u2705 Solution: Pure configuration\nclass PureModule(Module):\n    def configure(self, binder):\n        binder.bind(IService, Service())\n\n    def initialize(self):\n        \"\"\"Call separately for side effects.\"\"\"\n        os.makedirs(\"/tmp/app_data\", exist_ok=True)\n        self.initialize_database()\n</code></pre>"},{"location":"modules/module-best-practices/#5-circular-dependencies","title":"5. Circular Dependencies","text":"<pre><code># \u274c Anti-pattern: Circular dependencies\nclass ModuleA(Module):\n    def configure(self, binder):\n        binder.bind(IServiceA, ServiceA())  # Depends on IServiceB\n\nclass ModuleB(Module):\n    def configure(self, binder):\n        binder.bind(IServiceB, ServiceB())  # Depends on IServiceA\n\n# \u2705 Solution: Break the cycle\nclass RefactoredModuleA(Module):\n    def configure(self, binder):\n        binder.bind(IServiceA, ServiceA(binder.get(IServiceB)))\n\nclass RefactoredModuleB(Module):\n    def configure(self, binder):\n        binder.bind(IServiceB, ServiceB())\n\n# Install B first, then A\ncontainer.install(RefactoredModuleB())\ncontainer.install(RefactoredModuleA())\n</code></pre>"},{"location":"modules/module-best-practices/#advanced-patterns","title":"\u26a1 Advanced Patterns","text":""},{"location":"modules/module-best-practices/#module-versioning","title":"Module Versioning","text":"<pre><code>class VersionedModule(Module):\n    \"\"\"Module with version information and compatibility checking.\"\"\"\n\n    VERSION = \"2.1.0\"\n    MIN_CONTAINER_VERSION = \"1.5.0\"\n\n    def __init__(self, config: ModuleConfig):\n        self.config = config\n\n    def configure(self, binder):\n        # Bind version information\n        binder.bind(ModuleVersion, self.VERSION)\n\n        # Bind services\n        binder.bind(IModuleService, ModuleService(self.VERSION))\n\n    @classmethod\n    def is_compatible(cls, container_version: str) -&gt; bool:\n        \"\"\"Check compatibility with container version.\"\"\"\n        from packaging import version\n        return version.parse(container_version) &gt;= version.parse(cls.MIN_CONTAINER_VERSION)\n</code></pre>"},{"location":"modules/module-best-practices/#module-health-checks","title":"Module Health Checks","text":"<pre><code>class HealthCheckModule(Module):\n    \"\"\"Module that provides health checking for all services.\"\"\"\n\n    def configure(self, binder):\n        binder.bind(IHealthChecker, ModuleHealthChecker())\n\n    @provider\n    def create_health_checker(self) -&gt; IHealthChecker:\n        \"\"\"Create comprehensive health checker.\"\"\"\n        return CompositeHealthChecker([\n            DatabaseHealthCheck(),\n            CacheHealthCheck(),\n            ExternalAPIHealthCheck(),\n            ServiceHealthCheck(),\n        ])\n\nclass ServiceHealthCheck(HealthCheck):\n    \"\"\"Health check for business services.\"\"\"\n\n    def __init__(self, user_service: IUserService, order_service: IOrderService):\n        self.user_service = user_service\n        self.order_service = order_service\n\n    def check(self) -&gt; HealthStatus:\n        \"\"\"Check service health.\"\"\"\n        try:\n            # Test basic service functionality\n            user_count = self.user_service.get_user_count()\n            order_count = self.order_service.get_order_count()\n\n            return HealthStatus(\n                healthy=True,\n                message=f\"Services healthy: {user_count} users, {order_count} orders\"\n            )\n        except Exception as e:\n            return HealthStatus(\n                healthy=False,\n                message=f\"Service check failed: {e}\"\n            )\n</code></pre>"},{"location":"modules/module-best-practices/#dynamic-module-loading","title":"Dynamic Module Loading","text":"<pre><code>class PluginManager:\n    \"\"\"Manages dynamic loading of plugin modules.\"\"\"\n\n    def __init__(self, plugin_dir: str):\n        self.plugin_dir = Path(plugin_dir)\n        self._loaded_plugins = {}\n\n    def load_plugin(self, plugin_name: str) -&gt; Module:\n        \"\"\"Load a plugin module by name.\"\"\"\n        if plugin_name in self._loaded_plugins:\n            return self._loaded_plugins[plugin_name]\n\n        plugin_path = self.plugin_dir / plugin_name / \"plugin.py\"\n        if not plugin_path.exists():\n            raise PluginNotFoundError(f\"Plugin {plugin_name} not found\")\n\n        # Load plugin module\n        spec = importlib.util.spec_from_file_location(\n            f\"plugin_{plugin_name}\",\n            plugin_path\n        )\n        plugin_module = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(plugin_module)\n\n        # Get plugin class\n        plugin_class = getattr(plugin_module, 'PluginModule')\n\n        # Load plugin configuration\n        config = self._load_plugin_config(plugin_name)\n\n        # Create and cache plugin\n        plugin = plugin_class(config)\n        self._loaded_plugins[plugin_name] = plugin\n\n        return plugin\n\n    def _load_plugin_config(self, plugin_name: str) -&gt; dict:\n        \"\"\"Load configuration for plugin.\"\"\"\n        config_file = self.plugin_dir / plugin_name / \"config.yaml\"\n        if config_file.exists():\n            with open(config_file) as f:\n                return yaml.safe_load(f)\n        return {}\n</code></pre>"},{"location":"modules/module-best-practices/#module-metrics","title":"Module Metrics","text":"<pre><code>class MetricsModule(Module):\n    \"\"\"Module that provides metrics collection for all services.\"\"\"\n\n    def configure(self, binder):\n        binder.bind(IMetricsCollector, PrometheusMetricsCollector())\n\n    @provider\n    def create_metrics_collector(self) -&gt; IMetricsCollector:\n        \"\"\"Create metrics collector with module-specific metrics.\"\"\"\n        collector = PrometheusMetricsCollector()\n\n        # Add module metrics\n        collector.gauge(\"modules_loaded\", len(container._modules))\n        collector.counter(\"services_created\", len(container._bindings))\n        collector.histogram(\"service_creation_time\", [])\n\n        return collector\n\nclass InstrumentedModule(Module):\n    \"\"\"Example of instrumented module.\"\"\"\n\n    def __init__(self, metrics: IMetricsCollector):\n        self.metrics = metrics\n\n    def configure(self, binder):\n        # Bind instrumented services\n        binder.bind(IUserService, InstrumentedUserService(self.metrics))\n        binder.bind(IOrderService, InstrumentedOrderService(self.metrics))\n\nclass InstrumentedUserService:\n    \"\"\"User service with metrics instrumentation.\"\"\"\n\n    def __init__(self, metrics: IMetricsCollector):\n        self.metrics = metrics\n        self._user_service = UserService()\n\n    def create_user(self, email: str, password: str) -&gt; User:\n        \"\"\"Create user with metrics.\"\"\"\n        with self.metrics.timer(\"user_creation_duration\"):\n            user = self._user_service.create_user(email, password)\n            self.metrics.increment(\"users_created\")\n            return user\n</code></pre>"},{"location":"modules/module-best-practices/#summary","title":"\ud83c\udfaf Summary","text":"<p>Module best practices ensure:</p> <ul> <li>Maintainability - Clear responsibilities and boundaries</li> <li>Testability - Easy to test in isolation and integration</li> <li>Reusability - Modules work across different applications</li> <li>Flexibility - Easy to compose and configure</li> <li>Reliability - Proper error handling and health checks</li> </ul> <p>Key principles: - Single responsibility per module - Interface-based design - Comprehensive documentation - Thorough testing - Loose coupling and high cohesion</p> <p>Essential practices: - Consistent naming conventions - Centralized configuration management - Dependency documentation - Health checks and monitoring - Version compatibility checking</p> <p>Avoid common pitfalls: - God modules with multiple responsibilities - Configuration scattering - Tight coupling between modules - Side effects in configuration - Circular dependencies</p> <p>Ready to explore framework integrations?</p>"},{"location":"modules/module-composition/","title":"Module Composition","text":"<p>Module composition allows you to combine multiple modules together to create complex applications with clean separation of concerns.</p>"},{"location":"modules/module-composition/#what-is-module-composition","title":"\ud83c\udfaf What is Module Composition?","text":"<p>Module composition is the practice of combining multiple modules to create a complete application configuration, allowing you to mix and match modules for different environments and use cases.</p> <pre><code>from injectq import InjectQ\n\n# Core modules\ncontainer = InjectQ()\ncontainer.install(DatabaseModule())\ncontainer.install(CacheModule())\n\n# Feature modules\ncontainer.install(UserManagementModule())\ncontainer.install(OrderProcessingModule())\n\n# Infrastructure modules\ncontainer.install(EmailModule())\ncontainer.install(LoggingModule())\n\n# Environment-specific modules\nif environment == \"production\":\n    container.install(ProductionMonitoringModule())\nelse:\n    container.install(DevelopmentToolsModule())\n</code></pre>"},{"location":"modules/module-composition/#basic-composition","title":"\ud83d\udd27 Basic Composition","text":""},{"location":"modules/module-composition/#sequential-installation","title":"Sequential Installation","text":"<pre><code>class Application:\n    def __init__(self, config: AppConfig):\n        self.config = config\n        self.container = InjectQ()\n\n    def setup_container(self):\n        \"\"\"Set up container with composed modules\"\"\"\n\n        # 1. Infrastructure first (provides core services)\n        self.container.install(InfrastructureModule(self.config))\n\n        # 2. Domain modules (depend on infrastructure)\n        self.container.install(UserModule())\n        self.container.install(OrderModule())\n        self.container.install(ProductModule())\n\n        # 3. Cross-cutting concerns\n        self.container.install(SecurityModule())\n        self.container.install(LoggingModule())\n\n        # 4. External integrations\n        self.container.install(EmailModule())\n        self.container.install(PaymentModule())\n\n# Usage\napp = Application(config)\napp.setup_container()\n</code></pre>"},{"location":"modules/module-composition/#conditional-composition","title":"Conditional Composition","text":"<pre><code>def create_container_for_environment(env: str) -&gt; InjectQ:\n    \"\"\"Create container based on environment\"\"\"\n    container = InjectQ()\n\n    # Always install core modules\n    container.install(CoreModule())\n\n    # Environment-specific modules\n    if env == \"production\":\n        container.install(ProductionDatabaseModule())\n        container.install(RedisCacheModule())\n        container.install(CloudLoggingModule())\n    elif env == \"staging\":\n        container.install(StagingDatabaseModule())\n        container.install(RedisCacheModule())\n        container.install(FileLoggingModule())\n    elif env == \"testing\":\n        container.install(TestDatabaseModule())\n        container.install(InMemoryCacheModule())\n        container.install(ConsoleLoggingModule())\n    else:  # development\n        container.install(DevDatabaseModule())\n        container.install(InMemoryCacheModule())\n        container.install(ConsoleLoggingModule())\n\n    return container\n</code></pre>"},{"location":"modules/module-composition/#composition-patterns","title":"\ud83c\udfa8 Composition Patterns","text":""},{"location":"modules/module-composition/#layered-architecture","title":"Layered Architecture","text":"<pre><code>class LayeredApplication:\n    def __init__(self, config: AppConfig):\n        self.config = config\n\n    def create_container(self) -&gt; InjectQ:\n        container = InjectQ()\n\n        # Layer 1: Infrastructure\n        self._install_infrastructure_layer(container)\n\n        # Layer 2: Domain\n        self._install_domain_layer(container)\n\n        # Layer 3: Application\n        self._install_application_layer(container)\n\n        # Layer 4: Presentation\n        self._install_presentation_layer(container)\n\n        return container\n\n    def _install_infrastructure_layer(self, container: InjectQ):\n        \"\"\"Infrastructure concerns: database, cache, messaging\"\"\"\n        container.install(DatabaseModule(self.config.database))\n        container.install(CacheModule(self.config.cache))\n        container.install(MessageQueueModule(self.config.mq))\n\n    def _install_domain_layer(self, container: InjectQ):\n        \"\"\"Domain logic: business rules and entities\"\"\"\n        container.install(UserDomainModule())\n        container.install(OrderDomainModule())\n        container.install(InventoryDomainModule())\n\n    def _install_application_layer(self, container: InjectQ):\n        \"\"\"Application services: use cases and workflows\"\"\"\n        container.install(UserApplicationModule())\n        container.install(OrderApplicationModule())\n        container.install(ReportingApplicationModule())\n\n    def _install_presentation_layer(self, container: InjectQ):\n        \"\"\"Presentation: APIs, web interfaces\"\"\"\n        container.install(RestApiModule())\n        container.install(GraphQLModule())\n        container.install(WebSocketModule())\n</code></pre>"},{"location":"modules/module-composition/#feature-toggles","title":"Feature Toggles","text":"<pre><code>class FeatureToggledApplication:\n    def __init__(self, features: FeatureFlags):\n        self.features = features\n\n    def create_container(self) -&gt; InjectQ:\n        container = InjectQ()\n\n        # Core modules always installed\n        container.install(CoreModule())\n\n        # Feature-toggled modules\n        if self.features.user_management:\n            container.install(UserManagementModule())\n\n        if self.features.order_processing:\n            container.install(OrderProcessingModule())\n\n        if self.features.analytics:\n            container.install(AnalyticsModule())\n\n        if self.features.notifications:\n            container.install(NotificationModule())\n\n        return container\n\n# Usage\nfeatures = FeatureFlags(\n    user_management=True,\n    order_processing=True,\n    analytics=False,  # Disabled\n    notifications=True\n)\n\napp = FeatureToggledApplication(features)\ncontainer = app.create_container()\n</code></pre>"},{"location":"modules/module-composition/#plugin-architecture","title":"Plugin Architecture","text":"<pre><code>class PluginBasedApplication:\n    def __init__(self, plugin_dir: str):\n        self.plugin_dir = Path(plugin_dir)\n\n    def create_container(self) -&gt; InjectQ:\n        container = InjectQ()\n\n        # Install core\n        container.install(CoreModule())\n\n        # Load and install plugins\n        plugins = self._load_plugins()\n        for plugin in plugins:\n            container.install(plugin)\n\n        return container\n\n    def _load_plugins(self) -&gt; List[Module]:\n        \"\"\"Load plugin modules from directory\"\"\"\n        plugins = []\n\n        for plugin_path in self.plugin_dir.glob(\"**/plugin.py\"):\n            try:\n                # Import plugin module\n                spec = importlib.util.spec_from_file_location(\n                    f\"plugin_{plugin_path.parent.name}\",\n                    plugin_path\n                )\n                plugin_module = importlib.util.module_from_spec(spec)\n                spec.loader.exec_module(plugin_module)\n\n                # Get plugin class\n                plugin_class = getattr(plugin_module, 'PluginModule')\n\n                # Create and configure plugin\n                plugin_config = self._load_plugin_config(plugin_path.parent)\n                plugin = plugin_class(plugin_config)\n\n                plugins.append(plugin)\n\n            except Exception as e:\n                logger.warning(f\"Failed to load plugin {plugin_path}: {e}\")\n\n        return plugins\n\n    def _load_plugin_config(self, plugin_dir: Path) -&gt; dict:\n        \"\"\"Load configuration for plugin\"\"\"\n        config_file = plugin_dir / \"config.yaml\"\n        if config_file.exists():\n            with open(config_file) as f:\n                return yaml.safe_load(f)\n        return {}\n</code></pre>"},{"location":"modules/module-composition/#module-dependencies","title":"\ud83d\udd04 Module Dependencies","text":""},{"location":"modules/module-composition/#explicit-dependencies","title":"Explicit Dependencies","text":"<pre><code>class DependentModules:\n    def create_container(self) -&gt; InjectQ:\n        container = InjectQ()\n\n        # Install in dependency order\n        container.install(InfrastructureModule())  # Provides database, cache\n        container.install(DomainModule())          # Depends on infrastructure\n        container.install(ApplicationModule())     # Depends on domain\n        container.install(PresentationModule())    # Depends on application\n\n        return container\n\n# Module with explicit dependency documentation\nclass ApplicationModule(Module):\n    \"\"\"\n    Application services module.\n\n    Dependencies:\n    - DomainModule: Provides domain services\n    - InfrastructureModule: Provides technical services\n\n    This module must be installed after its dependencies.\n    \"\"\"\n\n    def configure(self, binder):\n        # Bindings that depend on domain and infrastructure services\n        binder.bind(IUserAppService, UserAppService())\n        binder.bind(IOrderAppService, OrderAppService())\n</code></pre>"},{"location":"modules/module-composition/#dependency-injection-between-modules","title":"Dependency Injection Between Modules","text":"<pre><code># Module A provides service\nclass ModuleA(Module):\n    def configure(self, binder):\n        binder.bind(IServiceA, ServiceAImpl())\n\n# Module B depends on Module A's service\nclass ModuleB(Module):\n    def configure(self, binder):\n        # This will get ServiceAImpl from Module A\n        binder.bind(IServiceB, ServiceBImpl())\n\n# Module C depends on both\nclass ModuleC(Module):\n    def configure(self, binder):\n        # Gets services from Module A and B\n        binder.bind(IServiceC, ServiceCImpl())\n\n# Installation maintains dependency order\ncontainer.install(ModuleA())  # First\ncontainer.install(ModuleB())  # Second - depends on A\ncontainer.install(ModuleC())  # Third - depends on A and B\n</code></pre>"},{"location":"modules/module-composition/#testing-composition","title":"\ud83e\uddea Testing Composition","text":""},{"location":"modules/module-composition/#test-module-assemblies","title":"Test Module Assemblies","text":"<pre><code>def test_minimal_assembly():\n    \"\"\"Test with minimal module set\"\"\"\n    container = InjectQ()\n\n    # Only install essential modules\n    container.install(CoreModule())\n    container.install(TestDatabaseModule())\n\n    # Verify core services work\n    core_service = container.get(ICoreService)\n    assert core_service.is_initialized()\n\ndef test_full_assembly():\n    \"\"\"Test with complete module set\"\"\"\n    container = InjectQ()\n\n    # Install all modules\n    container.install(CoreModule())\n    container.install(DatabaseModule())\n    container.install(CacheModule())\n    container.install(UserModule())\n    container.install(OrderModule())\n\n    # Verify all services can be resolved\n    user_service = container.get(IUserService)\n    order_service = container.get(IOrderService)\n    cache = container.get(ICache)\n\n    assert user_service is not None\n    assert order_service is not None\n    assert cache is not None\n\ndef test_module_isolation():\n    \"\"\"Test that modules don't interfere with each other\"\"\"\n    container1 = InjectQ()\n    container2 = InjectQ()\n\n    # Different configurations\n    container1.install(ProductionModule())\n    container2.install(TestModule())\n\n    # Services should be different\n    service1 = container1.get(IService)\n    service2 = container2.get(IService)\n\n    assert type(service1) != type(service2)\n</code></pre>"},{"location":"modules/module-composition/#mock-module-composition","title":"Mock Module Composition","text":"<pre><code>class MockInfrastructureModule(Module):\n    def configure(self, binder):\n        binder.bind(IDatabase, MockDatabase())\n        binder.bind(ICache, MockCache())\n\nclass MockExternalModule(Module):\n    def configure(self, binder):\n        binder.bind(IEmailService, MockEmailService())\n        binder.bind(IPaymentAPI, MockPaymentAPI())\n\ndef test_with_mocked_dependencies():\n    \"\"\"Test application with mocked external dependencies\"\"\"\n    container = InjectQ()\n\n    # Real business logic\n    container.install(UserModule())\n    container.install(OrderModule())\n\n    # Mocked infrastructure\n    container.install(MockInfrastructureModule())\n    container.install(MockExternalModule())\n\n    # Test business logic with mocks\n    user_service = container.get(IUserService)\n    order_service = container.get(IOrderService)\n\n    # Create test user\n    user = user_service.create_user(\"test@example.com\", \"password\")\n    assert user.email == \"test@example.com\"\n\n    # Create test order\n    order = order_service.create_order(user.id, [order_item])\n    assert order.user_id == user.id\n</code></pre>"},{"location":"modules/module-composition/#integration-testing","title":"Integration Testing","text":"<pre><code>def test_cross_module_integration():\n    \"\"\"Test integration between multiple modules\"\"\"\n    container = create_test_container()\n\n    # Get services from different modules\n    user_service = container.get(IUserService)      # From UserModule\n    order_service = container.get(IOrderService)    # From OrderModule\n    email_service = container.get(IEmailService)    # From EmailModule\n\n    # Test complete workflow\n    with container.scope() as scope:\n        # Create user\n        user = user_service.create_user(\"test@example.com\", \"password\")\n\n        # Create order\n        order = order_service.create_order(user.id, [order_item])\n\n        # Verify email was sent\n        assert len(email_service.sent_emails) == 1\n        assert \"order\" in email_service.sent_emails[0][\"subject\"].lower()\n\ndef create_test_container() -&gt; InjectQ:\n    \"\"\"Create container for integration testing\"\"\"\n    container = InjectQ()\n\n    # Install test versions of all modules\n    container.install(TestDatabaseModule())\n    container.install(TestCacheModule())\n    container.install(UserModule())\n    container.install(OrderModule())\n    container.install(MockEmailModule())\n\n    return container\n</code></pre>"},{"location":"modules/module-composition/#composition-anti-patterns","title":"\ud83d\udea8 Composition Anti-Patterns","text":""},{"location":"modules/module-composition/#1-monolithic-module","title":"1. Monolithic Module","text":"<pre><code># \u274c Bad: Single massive module\nclass MonolithicModule(Module):\n    def configure(self, binder):\n        # Database bindings\n        binder.bind(IDatabase, PostgresDatabase())\n\n        # Cache bindings\n        binder.bind(ICache, RedisCache())\n\n        # User bindings\n        binder.bind(IUserRepository, SqlUserRepository())\n        binder.bind(IUserService, UserService())\n\n        # Order bindings\n        binder.bind(IOrderRepository, SqlOrderRepository())\n        binder.bind(IOrderService, OrderService())\n\n        # Email bindings\n        binder.bind(IEmailService, SmtpEmailService())\n\n        # Logging bindings\n        binder.bind(ILogger, FileLogger())\n\n        # 50+ more bindings...\n\n# \u2705 Good: Split into focused modules\nclass DatabaseModule(Module): pass\nclass CacheModule(Module): pass\nclass UserModule(Module): pass\nclass OrderModule(Module): pass\nclass EmailModule(Module): pass\nclass LoggingModule(Module): pass\n</code></pre>"},{"location":"modules/module-composition/#2-circular-dependencies","title":"2. Circular Dependencies","text":"<pre><code># \u274c Bad: Circular module dependencies\nclass ModuleA(Module):\n    def configure(self, binder):\n        binder.bind(IServiceA, ServiceA())  # Depends on ServiceB from ModuleB\n\nclass ModuleB(Module):\n    def configure(self, binder):\n        binder.bind(IServiceB, ServiceB())  # Depends on ServiceA from ModuleA\n\n# Installation creates circular dependency\ncontainer.install(ModuleA())  # Needs B\ncontainer.install(ModuleB())  # Needs A - circular!\n\n# \u2705 Good: Break circular dependencies\nclass RefactoredModuleA(Module):\n    def configure(self, binder):\n        binder.bind(IServiceA, ServiceA(binder.get(IServiceB)))\n\nclass RefactoredModuleB(Module):\n    def configure(self, binder):\n        binder.bind(IServiceB, ServiceB())\n\n# Install B first, then A\ncontainer.install(RefactoredModuleB())  # Provides B\ncontainer.install(RefactoredModuleA())  # Uses B\n</code></pre>"},{"location":"modules/module-composition/#3-tight-coupling","title":"3. Tight Coupling","text":"<pre><code># \u274c Bad: Modules know about each other\nclass TightlyCoupledModuleA(Module):\n    def configure(self, binder):\n        # Direct reference to ModuleB\n        module_b = ModuleB()\n        service_from_b = module_b.create_service()\n        binder.bind(IServiceA, ServiceA(service_from_b))\n\n# \u2705 Good: Loose coupling through interfaces\nclass LooselyCoupledModuleA(Module):\n    def configure(self, binder):\n        # Depends on interface, not concrete module\n        binder.bind(IServiceA, ServiceA())\n\nclass ModuleB(Module):\n    def configure(self, binder):\n        binder.bind(IServiceB, ServiceB())\n</code></pre>"},{"location":"modules/module-composition/#4-configuration-scattering","title":"4. Configuration Scattering","text":"<pre><code># \u274c Bad: Configuration scattered across modules\nclass DatabaseModule(Module):\n    def configure(self, binder):\n        binder.bind(IDatabase, PostgresDatabase(\"hardcoded-url\"))\n\nclass CacheModule(Module):\n    def configure(self, binder):\n        binder.bind(ICache, RedisCache(\"hardcoded-url\"))\n\n# \u2705 Good: Centralized configuration\n@dataclass\nclass AppConfig:\n    database_url: str\n    redis_url: str\n    email_host: str\n\nclass ConfigModule(Module):\n    def __init__(self, config: AppConfig):\n        self.config = config\n\n    def configure(self, binder):\n        binder.bind(AppConfig, self.config)\n\nclass DatabaseModule(Module):\n    def configure(self, binder):\n        config = binder.get(AppConfig)\n        binder.bind(IDatabase, PostgresDatabase(config.database_url))\n</code></pre>"},{"location":"modules/module-composition/#best-practices","title":"\ud83c\udfc6 Best Practices","text":""},{"location":"modules/module-composition/#1-clear-module-boundaries","title":"1. Clear Module Boundaries","text":"<pre><code># \u2705 Good: Clear separation of concerns\nclass UserModule(Module):\n    \"\"\"Handles all user-related functionality\"\"\"\n\nclass OrderModule(Module):\n    \"\"\"Handles all order-related functionality\"\"\"\n\nclass InfrastructureModule(Module):\n    \"\"\"Handles all infrastructure concerns\"\"\"\n\n# \u274c Bad: Mixed concerns\nclass MixedModule(Module):\n    \"\"\"Handles users, orders, database, cache, email...\"\"\"\n</code></pre>"},{"location":"modules/module-composition/#2-dependency-documentation","title":"2. Dependency Documentation","text":"<pre><code>class DocumentedModule(Module):\n    \"\"\"\n    User Management Module\n\n    Provides user registration, authentication, and profile management.\n\n    Bindings:\n    - IUserRepository -&gt; SqlUserRepository\n    - IUserService -&gt; UserService\n    - IAuthenticationService -&gt; JWTAuthenticationService\n\n    Dependencies:\n    - InfrastructureModule: For database and cache access\n    - EmailModule: For sending user notifications\n\n    Installation Order:\n    This module must be installed after InfrastructureModule and EmailModule.\n    \"\"\"\n\n    def configure(self, binder):\n        binder.bind(IUserRepository, SqlUserRepository())\n        binder.bind(IUserService, UserService())\n        binder.bind(IAuthenticationService, JWTAuthenticationService())\n</code></pre>"},{"location":"modules/module-composition/#3-environment-specific-composition","title":"3. Environment-Specific Composition","text":"<pre><code>def create_environment_container(env: str) -&gt; InjectQ:\n    \"\"\"Create container for specific environment\"\"\"\n    container = InjectQ()\n\n    # Common modules\n    container.install(CoreModule())\n\n    # Environment-specific composition\n    if env == \"production\":\n        container.install(ProductionInfrastructureModule())\n        container.install(ProductionMonitoringModule())\n    elif env == \"development\":\n        container.install(DevelopmentInfrastructureModule())\n        container.install(DevelopmentToolsModule())\n    elif env == \"testing\":\n        container.install(TestInfrastructureModule())\n        container.install(TestUtilitiesModule())\n\n    return container\n</code></pre>"},{"location":"modules/module-composition/#4-module-health-checks","title":"4. Module Health Checks","text":"<pre><code>class HealthCheckModule(Module):\n    def configure(self, binder):\n        binder.bind(IHealthChecker, ModuleHealthChecker())\n\n    @provider\n    def create_health_checker(self) -&gt; IHealthChecker:\n        \"\"\"Create health checker for all installed modules\"\"\"\n        return ModuleHealthChecker([\n            DatabaseHealthCheck(),\n            CacheHealthCheck(),\n            EmailHealthCheck(),\n            ExternalAPIHealthCheck(),\n        ])\n\n# Usage\ncontainer.install(HealthCheckModule())\nhealth_checker = container.get(IHealthChecker)\nstatus = health_checker.check_all()\n</code></pre>"},{"location":"modules/module-composition/#5-module-versioning","title":"5. Module Versioning","text":"<pre><code>class VersionedModule(Module):\n    \"\"\"Module with version information\"\"\"\n\n    VERSION = \"1.2.0\"\n\n    def __init__(self, config: ModuleConfig):\n        self.config = config\n\n    def configure(self, binder):\n        # Bind with version info\n        binder.bind(ModuleVersion, self.VERSION)\n        binder.bind(IModuleService, ModuleService(self.VERSION))\n\n    @classmethod\n    def is_compatible(cls, container_version: str) -&gt; bool:\n        \"\"\"Check if module is compatible with container version\"\"\"\n        return container_version.startswith(\"1.\")\n</code></pre>"},{"location":"modules/module-composition/#advanced-composition","title":"\u26a1 Advanced Composition","text":""},{"location":"modules/module-composition/#dynamic-module-loading","title":"Dynamic Module Loading","text":"<pre><code>def load_modules_from_config(config_path: str) -&gt; List[Module]:\n    \"\"\"Load modules based on configuration file\"\"\"\n    with open(config_path) as f:\n        config = yaml.safe_load(f)\n\n    modules = []\n\n    # Load enabled modules\n    if config.get(\"database.enabled\"):\n        modules.append(DatabaseModule(config[\"database\"]))\n\n    if config.get(\"cache.enabled\"):\n        modules.append(CacheModule(config[\"cache\"]))\n\n    if config.get(\"features.user_management\"):\n        modules.append(UserModule())\n\n    if config.get(\"features.analytics\"):\n        modules.append(AnalyticsModule())\n\n    return modules\n\n# Usage\nmodules = load_modules_from_config(\"app_config.yaml\")\ncontainer = InjectQ()\n\nfor module in modules:\n    container.install(module)\n</code></pre>"},{"location":"modules/module-composition/#module-registry","title":"Module Registry","text":"<pre><code>class ModuleRegistry:\n    \"\"\"Registry for available modules\"\"\"\n\n    def __init__(self):\n        self._modules = {}\n\n    def register(self, name: str, module_class: Type[Module], config_class: Type = None):\n        \"\"\"Register a module\"\"\"\n        self._modules[name] = {\n            \"class\": module_class,\n            \"config_class\": config_class\n        }\n\n    def create_module(self, name: str, config: dict = None) -&gt; Module:\n        \"\"\"Create module instance\"\"\"\n        module_info = self._modules[name]\n        module_class = module_info[\"class\"]\n        config_class = module_info[\"config_class\"]\n\n        if config_class and config:\n            module_config = config_class(**config)\n            return module_class(module_config)\n        else:\n            return module_class()\n\n# Usage\nregistry = ModuleRegistry()\nregistry.register(\"database\", DatabaseModule, DatabaseConfig)\nregistry.register(\"cache\", CacheModule, CacheConfig)\n\n# Create modules from config\ndb_config = {\"host\": \"localhost\", \"port\": 5432}\ndb_module = registry.create_module(\"database\", db_config)\n\ncontainer.install(db_module)\n</code></pre>"},{"location":"modules/module-composition/#composite-modules","title":"Composite Modules","text":"<pre><code>class CompositeModule(Module):\n    \"\"\"Module that composes other modules\"\"\"\n\n    def __init__(self, submodules: List[Module]):\n        self.submodules = submodules\n\n    def configure(self, binder):\n        # Configure this module\n        binder.bind(CompositeModule, self)\n\n        # Install submodules\n        for module in self.submodules:\n            # Note: In real implementation, this would delegate to container\n            pass\n\n# Usage\nuser_feature = CompositeModule([\n    UserRepositoryModule(),\n    UserServiceModule(),\n    UserControllerModule()\n])\n\ncontainer.install(user_feature)\n</code></pre>"},{"location":"modules/module-composition/#summary","title":"\ud83c\udfaf Summary","text":"<p>Module composition provides:</p> <ul> <li>Flexible assembly - Mix and match modules for different needs</li> <li>Clean separation - Each module has single responsibility</li> <li>Environment support - Different configurations per environment</li> <li>Testability - Easy to replace modules for testing</li> <li>Maintainability - Clear dependencies and boundaries</li> </ul> <p>Key principles: - Install modules in dependency order - Document module dependencies and requirements - Use clear naming and boundaries - Test module assemblies thoroughly - Avoid circular dependencies and tight coupling</p> <p>Common patterns: - Layered architecture (infrastructure \u2192 domain \u2192 application \u2192 presentation) - Environment-specific composition - Feature-toggled modules - Plugin-based architecture - Health checks and monitoring</p> <p>Ready to explore framework integrations?</p>"},{"location":"modules/overview/","title":"Modules &amp; Providers","text":"<p>Modules and providers organize your dependency injection configuration into reusable, composable units that make your application more maintainable and testable.</p>"},{"location":"modules/overview/#what-are-modules","title":"\ud83c\udfaf What are Modules?","text":"<p>Modules are containers for related bindings that group together services with similar responsibilities or from the same domain.</p> <pre><code>from injectq import Module, InjectQ\n\n# Database module - groups all database-related services\nclass DatabaseModule(Module):\n    def configure(self, binder):\n        binder.bind(DatabaseConnection, PostgresConnection())\n        binder.bind(UserRepository, UserRepositoryImpl())\n        binder.bind(OrderRepository, OrderRepositoryImpl())\n\n# Email module - groups email-related services\nclass EmailModule(Module):\n    def configure(self, binder):\n        binder.bind(EmailService, SmtpEmailService())\n        binder.bind(EmailTemplateEngine, JinjaTemplateEngine())\n\n# Application setup\ncontainer = InjectQ()\ncontainer.install(DatabaseModule())\ncontainer.install(EmailModule())\n\n# Services are now available\nuser_repo = container.get(UserRepository)\nemail_svc = container.get(EmailService)\n</code></pre>"},{"location":"modules/overview/#why-use-modules","title":"\ud83c\udfd7\ufe0f Why Use Modules?","text":""},{"location":"modules/overview/#benefits","title":"\u2705 Benefits","text":"<ul> <li>Organization - Group related services together</li> <li>Reusability - Reuse modules across applications</li> <li>Testability - Easy to replace modules in tests</li> <li>Maintainability - Clear separation of concerns</li> <li>Composition - Combine modules for different environments</li> </ul> <pre><code># Production configuration\ncontainer.install(DatabaseModule())\ncontainer.install(EmailModule())\ncontainer.install(CacheModule())\n\n# Test configuration\ncontainer.install(InMemoryDatabaseModule())\ncontainer.install(MockEmailModule())\ncontainer.install(NoOpCacheModule())\n</code></pre>"},{"location":"modules/overview/#without-modules","title":"\u274c Without Modules","text":"<pre><code># \u274c All bindings in one place - hard to maintain\ncontainer = InjectQ()\n\n# Database bindings\ncontainer.bind(DatabaseConnection, PostgresConnection())\ncontainer.bind(UserRepository, UserRepositoryImpl())\n# ... 20 more database bindings\n\n# Email bindings\ncontainer.bind(EmailService, SmtpEmailService())\n# ... 10 more email bindings\n\n# Cache bindings\ncontainer.bind(CacheService, RedisCache())\n# ... 5 more cache bindings\n\n# Total: 35+ scattered bindings\n</code></pre>"},{"location":"modules/overview/#module-types","title":"\ud83d\udd27 Module Types","text":""},{"location":"modules/overview/#configuration-module","title":"Configuration Module","text":"<p>Configuration modules bind interfaces to implementations and configure services.</p> <pre><code>from injectq import Module\n\nclass DatabaseModule(Module):\n    def __init__(self, connection_string: str):\n        self.connection_string = connection_string\n\n    def configure(self, binder):\n        # Bind interfaces to implementations\n        binder.bind(IDatabaseConnection, PostgresConnection(self.connection_string))\n        binder.bind(IUserRepository, UserRepository())\n        binder.bind(IOrderRepository, OrderRepository())\n\n        # Configure with specific settings\n        binder.bind(DatabaseConfig, DatabaseConfig(max_connections=20))\n\n# Usage\ncontainer.install(DatabaseModule(\"postgresql://localhost/mydb\"))\n</code></pre>"},{"location":"modules/overview/#provider-module","title":"Provider Module","text":"<p>Provider modules use factory functions to create complex service instances.</p> <pre><code>from injectq import Module, provider\n\nclass ServiceModule(Module):\n    @provider\n    def create_database_pool(self) -&gt; DatabasePool:\n        \"\"\"Factory for database connection pool\"\"\"\n        return DatabasePool(\n            host=\"localhost\",\n            port=5432,\n            max_connections=20,\n            min_connections=5\n        )\n\n    @provider\n    def create_cache_service(self, pool: DatabasePool) -&gt; ICache:\n        \"\"\"Factory for cache service with dependencies\"\"\"\n        return RedisCache(\n            host=\"redis-server\",\n            db_pool=pool\n        )\n\n# Usage\ncontainer.install(ServiceModule())\ncache = container.get(ICache)  # Gets RedisCache with pool\n</code></pre>"},{"location":"modules/overview/#conditional-module","title":"Conditional Module","text":"<p>Conditional modules configure services based on environment or conditions.</p> <pre><code>class EnvironmentModule(Module):\n    def __init__(self, environment: str):\n        self.environment = environment\n\n    def configure(self, binder):\n        if self.environment == \"production\":\n            binder.bind(IDatabase, PostgresDatabase())\n            binder.bind(ICache, RedisCache())\n        elif self.environment == \"testing\":\n            binder.bind(IDatabase, InMemoryDatabase())\n            binder.bind(ICache, NoOpCache())\n        else:  # development\n            binder.bind(IDatabase, PostgresDatabase())\n            binder.bind(ICache, InMemoryCache())\n\n# Usage\ncontainer.install(EnvironmentModule(os.getenv(\"ENV\", \"development\")))\n</code></pre>"},{"location":"modules/overview/#module-patterns","title":"\ud83c\udfa8 Module Patterns","text":""},{"location":"modules/overview/#domain-module","title":"Domain Module","text":"<p>Group services by business domain.</p> <pre><code># User domain module\nclass UserModule(Module):\n    def configure(self, binder):\n        binder.bind(IUserRepository, UserRepository())\n        binder.bind(IUserService, UserService())\n        binder.bind(IUserValidator, UserValidator())\n\n# Order domain module\nclass OrderModule(Module):\n    def configure(self, binder):\n        binder.bind(IOrderRepository, OrderRepository())\n        binder.bind(IOrderService, OrderService())\n        binder.bind(IOrderValidator, OrderValidator())\n\n# Payment domain module\nclass PaymentModule(Module):\n    def configure(self, binder):\n        binder.bind(IPaymentProcessor, StripeProcessor())\n        binder.bind(IPaymentRepository, PaymentRepository())\n\n# Application assembly\ncontainer.install(UserModule())\ncontainer.install(OrderModule())\ncontainer.install(PaymentModule())\n</code></pre>"},{"location":"modules/overview/#infrastructure-module","title":"Infrastructure Module","text":"<p>Group infrastructure services.</p> <pre><code>class InfrastructureModule(Module):\n    def configure(self, binder):\n        # Database\n        binder.bind(IDatabase, PostgresDatabase())\n\n        # Cache\n        binder.bind(ICache, RedisCache())\n\n        # Message queue\n        binder.bind(IMessageQueue, RabbitMQ())\n\n        # External APIs\n        binder.bind(IPaymentAPI, StripeAPI())\n        binder.bind(IEmailAPI, SendGridAPI())\n</code></pre>"},{"location":"modules/overview/#cross-cutting-module","title":"Cross-Cutting Module","text":"<p>Group cross-cutting concerns.</p> <pre><code>class CrossCuttingModule(Module):\n    def configure(self, binder):\n        # Logging\n        binder.bind(ILogger, StructuredLogger())\n\n        # Metrics\n        binder.bind(IMetrics, PrometheusMetrics())\n\n        # Security\n        binder.bind(IAuthenticator, JWTAuthenticator())\n        binder.bind(IAuthorizer, RBACAuthorizer())\n\n        # Validation\n        binder.bind(IValidator, FluentValidator())\n</code></pre>"},{"location":"modules/overview/#module-composition","title":"\ud83d\udd04 Module Composition","text":""},{"location":"modules/overview/#module-dependencies","title":"Module Dependencies","text":"<p>Modules can depend on services from other modules.</p> <pre><code>class EmailModule(Module):\n    def configure(self, binder):\n        binder.bind(IEmailService, SmtpEmailService())\n        binder.bind(IEmailTemplate, JinjaTemplate())\n\nclass NotificationModule(Module):\n    def configure(self, binder):\n        # Depends on EmailModule's IEmailService\n        binder.bind(INotificationService, EmailNotificationService())\n\n# Installation order matters\ncontainer.install(EmailModule())      # First\ncontainer.install(NotificationModule())  # Second\n</code></pre>"},{"location":"modules/overview/#module-overrides","title":"Module Overrides","text":"<p>Override bindings for testing or different environments.</p> <pre><code>class ProductionModule(Module):\n    def configure(self, binder):\n        binder.bind(IDatabase, PostgresDatabase())\n\nclass TestModule(Module):\n    def configure(self, binder):\n        # Override production database\n        binder.bind(IDatabase, InMemoryDatabase())\n\n# Test setup\ncontainer.install(ProductionModule())\ncontainer.install(TestModule())  # Overrides database binding\n</code></pre>"},{"location":"modules/overview/#module-inheritance","title":"Module Inheritance","text":"<p>Extend modules for specialization.</p> <pre><code>class BaseDatabaseModule(Module):\n    def configure(self, binder):\n        binder.bind(IDatabaseConnection, self.create_connection())\n\n    def create_connection(self):\n        raise NotImplementedError\n\nclass PostgresModule(BaseDatabaseModule):\n    def create_connection(self):\n        return PostgresConnection(\"postgresql://...\")\n\nclass MySQLModule(BaseDatabaseModule):\n    def create_connection(self):\n        return MySQLConnection(\"mysql://...\")\n</code></pre>"},{"location":"modules/overview/#testing-with-modules","title":"\ud83e\uddea Testing with Modules","text":""},{"location":"modules/overview/#module-replacement","title":"Module Replacement","text":"<p>Replace entire modules for testing.</p> <pre><code>class MockEmailModule(Module):\n    def configure(self, binder):\n        binder.bind(IEmailService, MockEmailService())\n\n# Test setup\ndef test_user_registration():\n    container = InjectQ()\n\n    # Use real modules\n    container.install(DatabaseModule())\n    container.install(UserModule())\n\n    # Replace email module with mock\n    container.install(MockEmailModule())\n\n    # Test\n    service = container.get(IUserService)\n    service.register_user(\"test@example.com\", \"password\")\n\n    # Verify email was \"sent\"\n    mock_email = container.get(IEmailService)\n    assert len(mock_email.sent_emails) == 1\n</code></pre>"},{"location":"modules/overview/#partial-overrides","title":"Partial Overrides","text":"<p>Override only specific bindings.</p> <pre><code>class TestOverridesModule(Module):\n    def configure(self, binder):\n        # Only override the repository, keep other services\n        binder.bind(IUserRepository, MockUserRepository())\n\n# Test with partial override\ncontainer.install(ProductionModule())  # All production services\ncontainer.install(TestOverridesModule())  # Override just repository\n</code></pre>"},{"location":"modules/overview/#test-module-composition","title":"Test Module Composition","text":"<pre><code>def create_test_container():\n    \"\"\"Factory for test containers\"\"\"\n    container = InjectQ()\n\n    # Install test versions of all modules\n    container.install(TestDatabaseModule())\n    container.install(TestEmailModule())\n    container.install(TestCacheModule())\n\n    return container\n\ndef test_complete_workflow():\n    container = create_test_container()\n\n    # Test entire workflow with mocked dependencies\n    workflow = container.get(OrderWorkflow)\n    result = workflow.process_order(order_data)\n\n    assert result.success\n</code></pre>"},{"location":"modules/overview/#module-best-practices","title":"\ud83d\udea8 Module Best Practices","text":""},{"location":"modules/overview/#1-single-responsibility","title":"1. Single Responsibility","text":"<pre><code># \u2705 Good: Single responsibility\nclass DatabaseModule(Module):\n    \"\"\"Handles all database-related bindings\"\"\"\n\nclass EmailModule(Module):\n    \"\"\"Handles all email-related bindings\"\"\"\n\n# \u274c Bad: Multiple responsibilities\nclass UtilsModule(Module):\n    \"\"\"Handles database, email, cache, logging... everything!\"\"\"\n</code></pre>"},{"location":"modules/overview/#2-interface-based-binding","title":"2. Interface-Based Binding","text":"<pre><code># \u2705 Good: Bind to interfaces\nclass RepositoryModule(Module):\n    def configure(self, binder):\n        binder.bind(IUserRepository, SqlUserRepository())\n        binder.bind(IOrderRepository, SqlOrderRepository())\n\n# \u274c Bad: Bind to implementations\nclass RepositoryModule(Module):\n    def configure(self, binder):\n        binder.bind(SqlUserRepository, SqlUserRepository())\n        binder.bind(SqlOrderRepository, SqlOrderRepository())\n</code></pre>"},{"location":"modules/overview/#3-configuration-through-parameters","title":"3. Configuration Through Parameters","text":"<pre><code># \u2705 Good: Configurable modules\nclass DatabaseModule(Module):\n    def __init__(self, config: DatabaseConfig):\n        self.config = config\n\n    def configure(self, binder):\n        binder.bind(IDatabase, PostgresDatabase(self.config))\n\n# \u274c Bad: Hard-coded configuration\nclass DatabaseModule(Module):\n    def configure(self, binder):\n        binder.bind(IDatabase, PostgresDatabase(\"hardcoded-connection\"))\n</code></pre>"},{"location":"modules/overview/#4-clear-naming-conventions","title":"4. Clear Naming Conventions","text":"<pre><code># \u2705 Good naming\nclass UserDomainModule(Module): pass\nclass InfrastructureModule(Module): pass\nclass TestOverridesModule(Module): pass\n\n# \u274c Bad naming\nclass Module1(Module): pass\nclass MyModule(Module): pass\nclass StuffModule(Module): pass\n</code></pre>"},{"location":"modules/overview/#5-documentation","title":"5. Documentation","text":"<pre><code>class PaymentProcessingModule(Module):\n    \"\"\"\n    Payment Processing Module\n\n    Provides services for processing payments through various\n    payment gateways. Supports Stripe, PayPal, and bank transfers.\n\n    Bindings:\n    - IPaymentProcessor -&gt; StripeProcessor (primary)\n    - IPaymentRepository -&gt; DatabasePaymentRepository\n    - IPaymentValidator -&gt; PaymentValidator\n\n    Dependencies:\n    - Requires InfrastructureModule for database access\n    - Requires SecurityModule for encryption\n\n    Environment Variables:\n    - STRIPE_API_KEY: Stripe API key\n    - PAYPAL_CLIENT_ID: PayPal client ID\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules/overview/#advanced-module-features","title":"\u26a1 Advanced Module Features","text":""},{"location":"modules/overview/#dynamic-module-loading","title":"Dynamic Module Loading","text":"<pre><code>def load_modules_from_config(config_file: str) -&gt; List[Module]:\n    \"\"\"Load modules based on configuration\"\"\"\n    config = load_config(config_file)\n    modules = []\n\n    if config.get(\"database.enabled\"):\n        modules.append(DatabaseModule(config[\"database\"]))\n\n    if config.get(\"email.enabled\"):\n        modules.append(EmailModule(config[\"email\"]))\n\n    if config.get(\"cache.enabled\"):\n        modules.append(CacheModule(config[\"cache\"]))\n\n    return modules\n\n# Usage\nmodules = load_modules_from_config(\"app_config.yaml\")\nfor module in modules:\n    container.install(module)\n</code></pre>"},{"location":"modules/overview/#module-health-checks","title":"Module Health Checks","text":"<pre><code>class HealthCheckModule(Module):\n    def configure(self, binder):\n        binder.bind(IHealthChecker, CompositeHealthChecker())\n\n    @provider\n    def create_health_checker(self) -&gt; IHealthChecker:\n        checkers = [\n            DatabaseHealthChecker(),\n            CacheHealthChecker(),\n            EmailHealthChecker(),\n        ]\n        return CompositeHealthChecker(checkers)\n\n# Usage\nhealth_checker = container.get(IHealthChecker)\nstatus = health_checker.check_all()\n</code></pre>"},{"location":"modules/overview/#module-metrics","title":"Module Metrics","text":"<pre><code>class MetricsModule(Module):\n    def configure(self, binder):\n        binder.bind(IMetrics, PrometheusMetrics())\n\n    @provider\n    def create_metrics(self) -&gt; IMetrics:\n        metrics = PrometheusMetrics()\n\n        # Add module-specific metrics\n        metrics.gauge(\"modules_loaded\", len(container._modules))\n        metrics.counter(\"bindings_created\", len(container._bindings))\n\n        return metrics\n</code></pre>"},{"location":"modules/overview/#summary","title":"\ud83c\udfaf Summary","text":"<p>Modules provide:</p> <ul> <li>Organization - Group related bindings together</li> <li>Reusability - Reuse across applications and tests</li> <li>Testability - Easy replacement for testing</li> <li>Maintainability - Clear separation of concerns</li> <li>Composition - Flexible combination of modules</li> </ul> <p>Key patterns: - Domain modules for business logic - Infrastructure modules for technical services - Provider modules for factory functions - Conditional modules for environment-specific config</p> <p>Best practices: - Single responsibility per module - Interface-based bindings - Configurable through parameters - Clear naming conventions - Comprehensive documentation</p> <p>Ready to explore framework integrations?</p>"},{"location":"modules/provider-modules/","title":"Provider Modules","text":"<p>Provider modules use factory functions and the <code>@provider</code> decorator to create complex service instances with dependency injection support.</p>"},{"location":"modules/provider-modules/#what-are-providers","title":"\ud83c\udfaf What are Providers?","text":"<p>Providers are factory functions that create service instances, automatically receiving their dependencies through injection.</p> <pre><code>from injectq import Module, provider, InjectQ\n\nclass ServiceModule(Module):\n    @provider\n    def create_database_pool(self) -&gt; DatabasePool:\n        \"\"\"Factory for database connection pool\"\"\"\n        return DatabasePool(\n            host=\"localhost\",\n            port=5432,\n            max_connections=20\n        )\n\n    @provider\n    def create_user_service(self, user_repo: IUserRepository, email_svc: IEmailService) -&gt; IUserService:\n        \"\"\"Factory for user service with dependencies\"\"\"\n        return UserService(user_repo, email_svc)\n\n# Usage\ncontainer = InjectQ()\ncontainer.install(ServiceModule())\n\n# Services are created with dependencies injected\nuser_service = container.get(IUserService)  # Gets UserService with injected dependencies\n</code></pre>"},{"location":"modules/provider-modules/#creating-provider-methods","title":"\ud83d\udd27 Creating Provider Methods","text":""},{"location":"modules/provider-modules/#basic-provider","title":"Basic Provider","text":"<pre><code>from injectq import Module, provider\n\nclass DatabaseModule(Module):\n    @provider\n    def database_connection(self) -&gt; IDatabaseConnection:\n        \"\"\"Create database connection\"\"\"\n        return PostgresConnection(\n            host=\"localhost\",\n            database=\"myapp\"\n        )\n</code></pre>"},{"location":"modules/provider-modules/#provider-with-dependencies","title":"Provider with Dependencies","text":"<pre><code>class ServiceModule(Module):\n    @provider\n    def user_repository(self, db: IDatabaseConnection) -&gt; IUserRepository:\n        \"\"\"Create user repository with database dependency\"\"\"\n        return SqlUserRepository(db)\n\n    @provider\n    def user_service(self, user_repo: IUserRepository, email_svc: IEmailService) -&gt; IUserService:\n        \"\"\"Create user service with its dependencies\"\"\"\n        return UserService(user_repo, email_svc)\n</code></pre>"},{"location":"modules/provider-modules/#provider-with-configuration","title":"Provider with Configuration","text":"<pre><code>class ConfigurableModule(Module):\n    def __init__(self, config: AppConfig):\n        self.config = config\n\n    @provider\n    def database_pool(self) -&gt; IDatabasePool:\n        \"\"\"Create database pool with configuration\"\"\"\n        return DatabasePool(\n            host=self.config.database_host,\n            port=self.config.database_port,\n            max_connections=self.config.max_connections\n        )\n\n    @provider\n    def cache_service(self) -&gt; ICache:\n        \"\"\"Create cache service with configuration\"\"\"\n        if self.config.use_redis:\n            return RedisCache(self.config.redis_url)\n        else:\n            return InMemoryCache()\n</code></pre>"},{"location":"modules/provider-modules/#provider-patterns","title":"\ud83c\udfa8 Provider Patterns","text":""},{"location":"modules/provider-modules/#complex-object-creation","title":"Complex Object Creation","text":"<pre><code>class InfrastructureModule(Module):\n    @provider\n    def message_queue(self) -&gt; IMessageQueue:\n        \"\"\"Create message queue with retry logic\"\"\"\n        queue = RabbitMQConnection(\n            host=\"rabbitmq-server\",\n            port=5672,\n            credentials=self._load_credentials()\n        )\n\n        # Configure retry policy\n        queue.retry_policy = ExponentialBackoffRetry(\n            max_attempts=5,\n            base_delay=1.0\n        )\n\n        return queue\n\n    @provider\n    def payment_processor(self, mq: IMessageQueue, db: IDatabase) -&gt; IPaymentProcessor:\n        \"\"\"Create payment processor with dependencies\"\"\"\n        processor = StripePaymentProcessor(\n            api_key=os.getenv(\"STRIPE_API_KEY\"),\n            message_queue=mq,\n            database=db\n        )\n\n        # Configure webhooks\n        processor.webhook_secret = os.getenv(\"STRIPE_WEBHOOK_SECRET\")\n\n        return processor\n\n    def _load_credentials(self) -&gt; Credentials:\n        \"\"\"Load MQ credentials from secure storage\"\"\"\n        return Credentials(\n            username=os.getenv(\"MQ_USER\"),\n            password=os.getenv(\"MQ_PASS\")\n        )\n</code></pre>"},{"location":"modules/provider-modules/#conditional-provider","title":"Conditional Provider","text":"<pre><code>class EnvironmentModule(Module):\n    def __init__(self, environment: str):\n        self.environment = environment\n\n    @provider\n    def email_service(self) -&gt; IEmailService:\n        \"\"\"Create email service based on environment\"\"\"\n        if self.environment == \"production\":\n            return SmtpEmailService(\n                host=\"smtp.gmail.com\",\n                port=587,\n                credentials=self._load_smtp_credentials()\n            )\n        elif self.environment == \"testing\":\n            return MockEmailService()\n        else:\n            return ConsoleEmailService()  # Development\n\n    @provider\n    def cache_service(self) -&gt; ICache:\n        \"\"\"Create cache service based on environment\"\"\"\n        if self.environment == \"production\":\n            return RedisCache(host=\"redis-cluster\")\n        else:\n            return InMemoryCache()\n</code></pre>"},{"location":"modules/provider-modules/#resource-management-provider","title":"Resource Management Provider","text":"<pre><code>class ResourceModule(Module):\n    @provider\n    def database_connection_pool(self) -&gt; IDatabasePool:\n        \"\"\"Create managed database connection pool\"\"\"\n        pool = DatabasePool(\n            host=\"localhost\",\n            max_connections=20,\n            min_connections=5\n        )\n\n        # Register cleanup\n        import atexit\n        atexit.register(pool.close_all)\n\n        return pool\n\n    @provider\n    def file_manager(self) -&gt; IFileManager:\n        \"\"\"Create file manager with temp directory\"\"\"\n        temp_dir = tempfile.mkdtemp(prefix=\"app_\")\n\n        manager = FileManager(temp_dir)\n\n        # Register cleanup\n        import atexit\n        atexit.register(lambda: shutil.rmtree(temp_dir))\n\n        return manager\n</code></pre>"},{"location":"modules/provider-modules/#provider-dependencies","title":"\ud83d\udd04 Provider Dependencies","text":""},{"location":"modules/provider-modules/#multi-level-dependencies","title":"Multi-Level Dependencies","text":"<pre><code>class ApplicationModule(Module):\n    @provider\n    def database_connection(self) -&gt; IDatabaseConnection:\n        \"\"\"Level 1: Basic connection\"\"\"\n        return PostgresConnection(\"postgresql://...\")\n\n    @provider\n    def user_repository(self, db: IDatabaseConnection) -&gt; IUserRepository:\n        \"\"\"Level 2: Depends on connection\"\"\"\n        return SqlUserRepository(db)\n\n    @provider\n    def order_repository(self, db: IDatabaseConnection) -&gt; IOrderRepository:\n        \"\"\"Level 2: Depends on connection\"\"\"\n        return SqlOrderRepository(db)\n\n    @provider\n    def user_service(self, user_repo: IUserRepository, email_svc: IEmailService) -&gt; IUserService:\n        \"\"\"Level 3: Depends on repository and email\"\"\"\n        return UserService(user_repo, email_svc)\n\n    @provider\n    def order_service(self, order_repo: IOrderRepository, payment_svc: IPaymentService) -&gt; IOrderService:\n        \"\"\"Level 3: Depends on repository and payment\"\"\"\n        return OrderService(order_repo, payment_svc)\n</code></pre>"},{"location":"modules/provider-modules/#circular-dependency-prevention","title":"Circular Dependency Prevention","text":"<pre><code># \u2705 Good: No circular dependencies\nclass GoodModule(Module):\n    @provider\n    def service_a(self, repo: IRepository) -&gt; IServiceA:\n        return ServiceA(repo)\n\n    @provider\n    def service_b(self, service_a: IServiceA) -&gt; IServiceB:\n        return ServiceB(service_a)\n\n# \u274c Bad: Circular dependency\nclass BadModule(Module):\n    @provider\n    def service_a(self, service_b: IServiceB) -&gt; IServiceA:\n        return ServiceA(service_b)  # Depends on B\n\n    @provider\n    def service_b(self, service_a: IServiceA) -&gt; IServiceB:\n        return ServiceB(service_a)  # Depends on A\n</code></pre>"},{"location":"modules/provider-modules/#optional-dependencies","title":"Optional Dependencies","text":"<pre><code>class FlexibleModule(Module):\n    @provider\n    def notification_service(self, email_svc: Optional[IEmailService] = None) -&gt; INotificationService:\n        \"\"\"Create notification service with optional email\"\"\"\n        if email_svc:\n            return EmailNotificationService(email_svc)\n        else:\n            return ConsoleNotificationService()\n\n    @provider\n    def cache_service(self) -&gt; ICache:\n        \"\"\"Create cache service with fallback\"\"\"\n        try:\n            return RedisCache(host=\"redis-server\")\n        except ConnectionError:\n            return InMemoryCache()\n</code></pre>"},{"location":"modules/provider-modules/#testing-with-providers","title":"\ud83e\uddea Testing with Providers","text":""},{"location":"modules/provider-modules/#provider-testing","title":"Provider Testing","text":"<pre><code>def test_provider_creation():\n    \"\"\"Test that providers create correct instances\"\"\"\n    container = InjectQ()\n    container.install(ServiceModule())\n\n    # Test provider-created service\n    user_service = container.get(IUserService)\n    assert isinstance(user_service, UserService)\n\n    # Test dependencies were injected\n    assert user_service.user_repository is not None\n    assert user_service.email_service is not None\n\ndef test_provider_with_mocks():\n    \"\"\"Test provider with mocked dependencies\"\"\"\n    container = InjectQ()\n\n    # Mock dependencies\n    mock_repo = MockUserRepository()\n    mock_email = MockEmailService()\n\n    container.bind(IUserRepository, mock_repo)\n    container.bind(IEmailService, mock_email)\n\n    # Install module with providers\n    container.install(ServiceModule())\n\n    # Get provider-created service\n    user_service = container.get(IUserService)\n\n    # Verify mocks were used\n    assert user_service.user_repository is mock_repo\n    assert user_service.email_service is mock_email\n</code></pre>"},{"location":"modules/provider-modules/#provider-override","title":"Provider Override","text":"<pre><code>class TestProvidersModule(Module):\n    @provider\n    def user_service(self) -&gt; IUserService:\n        \"\"\"Override provider for testing\"\"\"\n        return MockUserService()\n\ndef test_with_provider_override():\n    \"\"\"Test with overridden provider\"\"\"\n    container = InjectQ()\n\n    # Install production module\n    container.install(ServiceModule())\n\n    # Override specific provider\n    container.install(TestProvidersModule())\n\n    # Get service\n    user_service = container.get(IUserService)\n\n    # Should be mock, not real service\n    assert isinstance(user_service, MockUserService)\n</code></pre>"},{"location":"modules/provider-modules/#provider-dependency-testing","title":"Provider Dependency Testing","text":"<pre><code>def test_provider_dependencies():\n    \"\"\"Test that provider dependencies are correctly resolved\"\"\"\n    container = InjectQ()\n    container.install(ComplexModule())\n\n    # Get service with complex dependency chain\n    payment_processor = container.get(IPaymentProcessor)\n\n    # Verify entire dependency chain\n    assert payment_processor.message_queue is not None\n    assert payment_processor.database is not None\n\n    # Verify MQ has its dependencies\n    mq = payment_processor.message_queue\n    assert mq.credentials is not None\n    assert mq.retry_policy is not None\n</code></pre>"},{"location":"modules/provider-modules/#provider-anti-patterns","title":"\ud83d\udea8 Provider Anti-Patterns","text":""},{"location":"modules/provider-modules/#1-complex-logic-in-providers","title":"1. Complex Logic in Providers","text":"<pre><code># \u274c Bad: Too much logic in provider\nclass BadModule(Module):\n    @provider\n    def complex_service(self) -&gt; IService:\n        # Too much setup logic\n        config = self._load_config()\n        credentials = self._decrypt_credentials(config)\n        connection = self._create_connection(credentials)\n        pool = self._create_pool(connection)\n        service = self._create_service(pool)\n\n        # Business logic mixed in\n        if config.environment == \"prod\":\n            service.enable_monitoring()\n        else:\n            service.disable_monitoring()\n\n        return service\n\n# \u2705 Good: Extract logic to separate methods/classes\nclass GoodModule(Module):\n    def __init__(self, config: AppConfig):\n        self.config = config\n\n    @provider\n    def service(self) -&gt; IService:\n        \"\"\"Simple provider using factory\"\"\"\n        return ServiceFactory.create(self.config)\n\nclass ServiceFactory:\n    @staticmethod\n    def create(config: AppConfig) -&gt; IService:\n        credentials = CredentialLoader.load(config)\n        connection = ConnectionFactory.create(credentials)\n        pool = PoolFactory.create(connection, config)\n        service = ServiceFactory._create_service(pool, config)\n\n        if config.environment == \"prod\":\n            service.enable_monitoring()\n\n        return service\n</code></pre>"},{"location":"modules/provider-modules/#2-provider-side-effects","title":"2. Provider Side Effects","text":"<pre><code># \u274c Bad: Side effects in provider\nclass BadModule(Module):\n    @provider\n    def database_service(self) -&gt; IDatabaseService:\n        service = DatabaseService()\n\n        # Side effect: modifies global state\n        global_config.database_initialized = True\n\n        # Side effect: creates files\n        os.makedirs(\"/tmp/app_data\", exist_ok=True)\n\n        return service\n\n# \u2705 Good: Pure providers\nclass GoodModule(Module):\n    @provider\n    def database_service(self) -&gt; IDatabaseService:\n        return DatabaseService()\n\n    def initialize(self):\n        \"\"\"Call this separately for side effects\"\"\"\n        global_config.database_initialized = True\n        os.makedirs(\"/tmp/app_data\", exist_ok=True)\n</code></pre>"},{"location":"modules/provider-modules/#3-provider-tight-coupling","title":"3. Provider Tight Coupling","text":"<pre><code># \u274c Bad: Tight coupling in provider\nclass BadModule(Module):\n    @provider\n    def user_service(self) -&gt; IUserService:\n        # Direct instantiation\n        repo = SqlUserRepository(PostgresConnection())\n        email = SmtpEmailService()\n        return UserService(repo, email)\n\n# \u2705 Good: Loose coupling through dependencies\nclass GoodModule(Module):\n    @provider\n    def user_service(self, user_repo: IUserRepository, email_svc: IEmailService) -&gt; IUserService:\n        return UserService(user_repo, email_svc)\n\n    @provider\n    def user_repository(self, db: IDatabaseConnection) -&gt; IUserRepository:\n        return SqlUserRepository(db)\n\n    @provider\n    def email_service(self) -&gt; IEmailService:\n        return SmtpEmailService()\n</code></pre>"},{"location":"modules/provider-modules/#4-provider-overuse","title":"4. Provider Overuse","text":"<pre><code># \u274c Bad: Provider for everything\nclass OveruseModule(Module):\n    @provider\n    def simple_string(self) -&gt; str:\n        return \"hello\"\n\n    @provider\n    def simple_number(self) -&gt; int:\n        return 42\n\n    @provider\n    def simple_list(self) -&gt; List[str]:\n        return [\"a\", \"b\", \"c\"]\n\n# \u2705 Good: Use providers for complex objects only\nclass GoodModule(Module):\n    @provider\n    def complex_service(self, repo: IRepository, config: AppConfig) -&gt; IService:\n        return ComplexService(repo, config)\n\n    def configure(self, binder):\n        # Simple values can use regular bindings\n        binder.bind(str, \"hello\")\n        binder.bind(int, 42)\n        binder.bind(List[str], [\"a\", \"b\", \"c\"])\n</code></pre>"},{"location":"modules/provider-modules/#best-practices","title":"\ud83c\udfc6 Best Practices","text":""},{"location":"modules/provider-modules/#1-keep-providers-simple","title":"1. Keep Providers Simple","text":"<pre><code># \u2705 Simple provider\nclass SimpleModule(Module):\n    @provider\n    def database_pool(self) -&gt; IDatabasePool:\n        return DatabasePool(host=\"localhost\", max_conn=20)\n\n# \u2705 Extract complex logic\nclass ComplexModule(Module):\n    @provider\n    def payment_processor(self) -&gt; IPaymentProcessor:\n        return PaymentProcessorFactory.create(self.config)\n</code></pre>"},{"location":"modules/provider-modules/#2-use-meaningful-names","title":"2. Use Meaningful Names","text":"<pre><code># \u2705 Good naming\nclass GoodModule(Module):\n    @provider\n    def user_notification_service(self) -&gt; IUserNotificationService:\n        return EmailUserNotificationService()\n\n    @provider\n    def admin_notification_service(self) -&gt; IAdminNotificationService:\n        return SmsAdminNotificationService()\n\n# \u274c Bad naming\nclass BadModule(Module):\n    @provider\n    def service1(self) -&gt; IService1:\n        return Service1Impl()\n\n    @provider\n    def svc2(self) -&gt; IService2:\n        return Service2Impl()\n</code></pre>"},{"location":"modules/provider-modules/#3-document-providers","title":"3. Document Providers","text":"<pre><code>class DocumentedModule(Module):\n    @provider\n    def user_authentication_service(self, user_repo: IUserRepository, jwt_config: JWTConfig) -&gt; IAuthenticationService:\n        \"\"\"\n        Create user authentication service.\n\n        This provider creates an authentication service that handles\n        user login, logout, and token validation.\n\n        Args:\n            user_repo: Repository for user data access\n            jwt_config: Configuration for JWT token handling\n\n        Returns:\n            Configured authentication service instance\n\n        Dependencies:\n            - IUserRepository: For user data access\n            - JWTConfig: For token configuration\n\n        Notes:\n            - Uses bcrypt for password hashing\n            - Tokens expire after 24 hours\n            - Supports refresh token rotation\n        \"\"\"\n        return JWTAuthenticationService(user_repo, jwt_config)\n</code></pre>"},{"location":"modules/provider-modules/#4-handle-errors-gracefully","title":"4. Handle Errors Gracefully","text":"<pre><code>class RobustModule(Module):\n    @provider\n    def external_api_client(self) -&gt; IExternalAPI:\n        \"\"\"Create external API client with error handling\"\"\"\n        try:\n            return HttpExternalAPI(\n                base_url=os.getenv(\"API_BASE_URL\"),\n                api_key=os.getenv(\"API_KEY\"),\n                timeout=30\n            )\n        except (ValueError, ConnectionError) as e:\n            # Fallback to mock in case of configuration errors\n            logger.warning(f\"Failed to create external API client: {e}\")\n            return MockExternalAPI()\n\n    @provider\n    def cache_service(self) -&gt; ICache:\n        \"\"\"Create cache service with fallback\"\"\"\n        cache_configs = [\n            lambda: RedisCache(host=os.getenv(\"REDIS_HOST\")),\n            lambda: MemcachedCache(host=os.getenv(\"MEMCACHED_HOST\")),\n            lambda: InMemoryCache(),  # Always works\n        ]\n\n        for config_func in cache_configs:\n            try:\n                return config_func()\n            except Exception as e:\n                logger.warning(f\"Failed to create cache: {e}\")\n                continue\n\n        raise RuntimeError(\"All cache configurations failed\")\n</code></pre>"},{"location":"modules/provider-modules/#5-test-providers-thoroughly","title":"5. Test Providers Thoroughly","text":"<pre><code>def test_provider_error_handling():\n    \"\"\"Test provider error handling\"\"\"\n    # Test with missing environment variables\n    with patch.dict(os.environ, {}, clear=True):\n        container = InjectQ()\n        container.install(RobustModule())\n\n        # Should get fallback mock\n        api_client = container.get(IExternalAPI)\n        assert isinstance(api_client, MockExternalAPI)\n\ndef test_provider_fallback_chain():\n    \"\"\"Test provider fallback chain\"\"\"\n    container = InjectQ()\n    container.install(RobustModule())\n\n    # Should try Redis first\n    cache = container.get(ICache)\n    # Verify it's the expected type based on configuration\n</code></pre>"},{"location":"modules/provider-modules/#advanced-provider-features","title":"\u26a1 Advanced Provider Features","text":""},{"location":"modules/provider-modules/#async-providers","title":"Async Providers","text":"<pre><code>class AsyncModule(Module):\n    @provider\n    async def async_database_pool(self) -&gt; IAsyncDatabasePool:\n        \"\"\"Create async database pool\"\"\"\n        pool = await AsyncDatabasePool.create(\n            host=\"localhost\",\n            port=5432,\n            database=\"myapp\"\n        )\n        return pool\n\n    @provider\n    async def async_user_service(self, pool: IAsyncDatabasePool) -&gt; IAsyncUserService:\n        \"\"\"Create async user service\"\"\"\n        return AsyncUserService(pool)\n</code></pre>"},{"location":"modules/provider-modules/#provider-scopes","title":"Provider Scopes","text":"<pre><code>class ScopedProvidersModule(Module):\n    @provider(scope=\"singleton\")\n    def application_config(self) -&gt; IAppConfig:\n        \"\"\"Singleton provider\"\"\"\n        return AppConfig.from_env()\n\n    @provider(scope=\"scoped\")\n    def request_context(self) -&gt; IRequestContext:\n        \"\"\"Scoped provider\"\"\"\n        return RequestContext()\n\n    @provider(scope=\"transient\")\n    def validator(self) -&gt; IValidator:\n        \"\"\"Transient provider\"\"\"\n        return DataValidator()\n</code></pre>"},{"location":"modules/provider-modules/#provider-with-lifecycle","title":"Provider with Lifecycle","text":"<pre><code>class LifecycleModule(Module):\n    @provider\n    def managed_service(self) -&gt; IManagedService:\n        \"\"\"Create service with lifecycle management\"\"\"\n        service = ManagedService()\n\n        # Register lifecycle hooks\n        container.on_shutdown(service.cleanup)\n\n        return service\n\n    @provider\n    def health_check_service(self) -&gt; IHealthChecker:\n        \"\"\"Create health checker for all providers\"\"\"\n        return CompositeHealthChecker([\n            DatabaseHealthCheck(),\n            CacheHealthCheck(),\n            ExternalAPIHealthCheck(),\n        ])\n</code></pre>"},{"location":"modules/provider-modules/#summary","title":"\ud83c\udfaf Summary","text":"<p>Provider modules provide:</p> <ul> <li>Factory functions - Create complex service instances</li> <li>Dependency injection - Automatic dependency resolution</li> <li>Flexibility - Handle complex creation logic</li> <li>Testability - Easy to mock and override</li> <li>Clean separation - Separate creation from usage</li> </ul> <p>Key principles: - Keep providers simple and focused - Use meaningful names and documentation - Handle errors gracefully with fallbacks - Test thoroughly including error cases - Avoid side effects and tight coupling</p> <p>Common patterns: - Complex object creation with dependencies - Conditional providers based on environment - Resource management with cleanup - Multi-level dependency chains - Error handling with fallbacks</p> <p>Ready to explore module composition?</p>"},{"location":"scopes/custom-scopes/","title":"Custom Scopes","text":"<p>Custom scopes allow you to define your own lifetime management rules beyond the built-in singleton, transient, and scoped options.</p>"},{"location":"scopes/custom-scopes/#what-are-custom-scopes","title":"\ud83c\udfaf What are Custom Scopes?","text":"<p>Custom scopes let you control exactly when service instances are created and destroyed, based on your application's specific needs.</p> <pre><code>from injectq import InjectQ, Scope, ScopeManager\n\nclass SessionScopeManager(ScopeManager):\n    \"\"\"Manages per-user-session lifetime\"\"\"\n\n    def __init__(self):\n        self._sessions = {}\n\n    def enter_scope(self, session_id: str):\n        if session_id not in self._sessions:\n            self._sessions[session_id] = {}\n        self._current_session = session_id\n\n    def exit_scope(self):\n        self._current_session = None\n\n    def get_current_scope(self):\n        if not hasattr(self, '_current_session'):\n            return None\n        return self._sessions.get(self._current_session)\n\n# Register custom scope\ncontainer = InjectQ()\ncontainer.register_scope_manager(\"session\", SessionScopeManager())\n\n# Use custom scope\n@container.bind(scope=\"session\")\nclass UserPreferences:\n    def __init__(self):\n        self.theme = \"light\"\n        self.language = \"en\"\n\n# Usage\ndef handle_user_request(session_id: str, request):\n    with container.scope(\"session\", session_id) as scope:\n        prefs = scope.get(UserPreferences)\n        return {\"theme\": prefs.theme}\n</code></pre>"},{"location":"scopes/custom-scopes/#when-to-use-custom-scopes","title":"\ud83c\udfd7\ufe0f When to Use Custom Scopes","text":""},{"location":"scopes/custom-scopes/#perfect-for","title":"\u2705 Perfect For","text":"<ul> <li>User sessions - Per-user lifetime</li> <li>Tenant isolation - Per-tenant services</li> <li>Workflow contexts - Per-workflow state</li> <li>Batch operations - Per-batch lifetime</li> <li>Feature flags - Per-feature context</li> </ul> <pre><code># User session scope\nclass UserSessionScope:\n    \"\"\"\u2705 Good - per-user session data\"\"\"\n\n# Tenant scope\nclass TenantScope:\n    \"\"\"\u2705 Good - per-tenant isolation\"\"\"\n\n# Workflow scope\nclass WorkflowScope:\n    \"\"\"\u2705 Good - per-workflow context\"\"\"\n\n# Batch scope\nclass BatchScope:\n    \"\"\"\u2705 Good - per-batch operation\"\"\"\n</code></pre>"},{"location":"scopes/custom-scopes/#avoid-when","title":"\u274c Avoid When","text":"<ul> <li>Simple cases - Use built-in scopes</li> <li>Global state - Use singleton</li> <li>Request state - Use scoped</li> <li>Stateless ops - Use transient</li> </ul> <pre><code># \u274c Overkill for simple request\nclass RequestScope:\n    \"\"\"Use built-in scoped instead\"\"\"\n\n# \u274c Overkill for global config\nclass GlobalScope:\n    \"\"\"Use singleton instead\"\"\"\n</code></pre>"},{"location":"scopes/custom-scopes/#creating-custom-scopes","title":"\ud83d\udd27 Creating Custom Scopes","text":""},{"location":"scopes/custom-scopes/#basic-scope-manager","title":"Basic Scope Manager","text":"<pre><code>from injectq import ScopeManager\nfrom typing import Dict, Any, Optional\n\nclass CustomScopeManager(ScopeManager):\n    \"\"\"Basic custom scope manager\"\"\"\n\n    def __init__(self):\n        self._scopes: Dict[str, Dict[str, Any]] = {}\n        self._current_scope: Optional[str] = None\n\n    def enter_scope(self, scope_id: str):\n        \"\"\"Enter a new scope context\"\"\"\n        if scope_id not in self._scopes:\n            self._scopes[scope_id] = {}\n        self._current_scope = scope_id\n\n    def exit_scope(self):\n        \"\"\"Exit current scope context\"\"\"\n        self._current_scope = None\n\n    def get_current_scope(self) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Get current scope storage\"\"\"\n        if self._current_scope is None:\n            return None\n        return self._scopes.get(self._current_scope)\n\n    def cleanup_scope(self, scope_id: str):\n        \"\"\"Clean up a specific scope\"\"\"\n        if scope_id in self._scopes:\n            del self._scopes[scope_id]\n</code></pre>"},{"location":"scopes/custom-scopes/#registration-and-usage","title":"Registration and Usage","text":"<pre><code># Create and register scope manager\nscope_manager = CustomScopeManager()\ncontainer.register_scope_manager(\"custom\", scope_manager)\n\n# Bind services to custom scope\n@container.bind(scope=\"custom\")\nclass CustomService:\n    def __init__(self):\n        self.instance_id = str(uuid.uuid4())\n        print(f\"Custom service created: {self.instance_id}\")\n\n# Usage\ndef use_custom_scope():\n    with container.scope(\"custom\", \"my_scope_1\") as scope:\n        service1 = scope.get(CustomService)\n        service2 = scope.get(CustomService)\n\n        # Same instance within scope\n        assert service1 is service2\n\n    # Different scope gets different instance\n    with container.scope(\"custom\", \"my_scope_2\") as scope:\n        service3 = scope.get(CustomService)\n        assert service3 is not service1\n</code></pre>"},{"location":"scopes/custom-scopes/#advanced-custom-scopes","title":"\ud83c\udfa8 Advanced Custom Scopes","text":""},{"location":"scopes/custom-scopes/#user-session-scope","title":"User Session Scope","text":"<pre><code>class UserSessionManager(ScopeManager):\n    \"\"\"Manages per-user session services\"\"\"\n\n    def __init__(self, session_timeout: int = 3600):\n        self._sessions: Dict[str, Dict[str, Any]] = {}\n        self._session_times: Dict[str, float] = {}\n        self._timeout = session_timeout\n        self._current_session: Optional[str] = None\n\n    def enter_scope(self, session_id: str):\n        \"\"\"Enter user session context\"\"\"\n        current_time = time.time()\n\n        # Clean up expired sessions\n        self._cleanup_expired_sessions(current_time)\n\n        # Create new session if needed\n        if session_id not in self._sessions:\n            self._sessions[session_id] = {}\n            self._session_times[session_id] = current_time\n\n        self._current_session = session_id\n\n    def exit_scope(self):\n        \"\"\"Exit session context\"\"\"\n        self._current_session = None\n\n    def get_current_scope(self) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Get current session storage\"\"\"\n        if self._current_session is None:\n            return None\n        return self._sessions.get(self._current_session)\n\n    def _cleanup_expired_sessions(self, current_time: float):\n        \"\"\"Remove expired sessions\"\"\"\n        expired = [\n            session_id for session_id, create_time\n            in self._session_times.items()\n            if current_time - create_time &gt; self._timeout\n        ]\n\n        for session_id in expired:\n            if session_id in self._sessions:\n                del self._sessions[session_id]\n            if session_id in self._session_times:\n                del self._session_times[session_id]\n\n# Usage\nsession_manager = UserSessionManager(session_timeout=1800)  # 30 minutes\ncontainer.register_scope_manager(\"session\", session_manager)\n\n@container.bind(scope=\"session\")\nclass UserPreferences:\n    def __init__(self):\n        self.theme = \"light\"\n        self.notifications = True\n\ndef handle_user_request(session_id: str, request):\n    with container.scope(\"session\", session_id) as scope:\n        prefs = scope.get(UserPreferences)\n\n        if request.action == \"update_theme\":\n            prefs.theme = request.theme\n\n        return {\"theme\": prefs.theme}\n</code></pre>"},{"location":"scopes/custom-scopes/#tenant-scope","title":"Tenant Scope","text":"<pre><code>class TenantScopeManager(ScopeManager):\n    \"\"\"Manages per-tenant service isolation\"\"\"\n\n    def __init__(self):\n        self._tenants: Dict[str, Dict[str, Any]] = {}\n        self._current_tenant: Optional[str] = None\n\n    def enter_scope(self, tenant_id: str):\n        \"\"\"Enter tenant context\"\"\"\n        if tenant_id not in self._tenants:\n            self._tenants[tenant_id] = {}\n        self._current_tenant = tenant_id\n\n    def exit_scope(self):\n        \"\"\"Exit tenant context\"\"\"\n        self._current_tenant = None\n\n    def get_current_scope(self) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Get current tenant storage\"\"\"\n        if self._current_tenant is None:\n            return None\n        return self._tenants.get(self._current_tenant)\n\n    def get_tenant_services(self, tenant_id: str) -&gt; Dict[str, Any]:\n        \"\"\"Get all services for a tenant\"\"\"\n        return self._tenants.get(tenant_id, {})\n\n# Usage\ntenant_manager = TenantScopeManager()\ncontainer.register_scope_manager(\"tenant\", tenant_manager)\n\n@container.bind(scope=\"tenant\")\nclass TenantConfig:\n    def __init__(self, tenant_id: str):\n        self.tenant_id = tenant_id\n        self.database_url = f\"postgresql://tenant_{tenant_id}\"\n        self.features = self._load_tenant_features(tenant_id)\n\n    def _load_tenant_features(self, tenant_id: str) -&gt; List[str]:\n        # Load tenant-specific features\n        return [\"basic\", \"premium\"] if tenant_id == \"premium\" else [\"basic\"]\n\ndef process_tenant_request(tenant_id: str, request):\n    with container.scope(\"tenant\", tenant_id) as scope:\n        config = scope.get(TenantConfig)\n        return {\"features\": config.features}\n</code></pre>"},{"location":"scopes/custom-scopes/#workflow-scope","title":"Workflow Scope","text":"<pre><code>class WorkflowScopeManager(ScopeManager):\n    \"\"\"Manages per-workflow execution context\"\"\"\n\n    def __init__(self):\n        self._workflows: Dict[str, Dict[str, Any]] = {}\n        self._current_workflow: Optional[str] = None\n\n    def enter_scope(self, workflow_id: str):\n        \"\"\"Enter workflow context\"\"\"\n        if workflow_id not in self._workflows:\n            self._workflows[workflow_id] = {\n                \"start_time\": time.time(),\n                \"steps\": [],\n                \"status\": \"running\"\n            }\n        self._current_workflow = workflow_id\n\n    def exit_scope(self):\n        \"\"\"Exit workflow context\"\"\"\n        if self._current_workflow:\n            workflow_data = self._workflows.get(self._current_workflow, {})\n            workflow_data[\"end_time\"] = time.time()\n            workflow_data[\"status\"] = \"completed\"\n        self._current_workflow = None\n\n    def get_current_scope(self) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Get current workflow storage\"\"\"\n        if self._current_workflow is None:\n            return None\n        return self._workflows.get(self._current_workflow)\n\n    def record_step(self, step_name: str, result: Any):\n        \"\"\"Record workflow step execution\"\"\"\n        if self._current_workflow:\n            workflow_data = self._workflows.get(self._current_workflow, {})\n            workflow_data[\"steps\"].append({\n                \"name\": step_name,\n                \"result\": result,\n                \"timestamp\": time.time()\n            })\n\n# Usage\nworkflow_manager = WorkflowScopeManager()\ncontainer.register_scope_manager(\"workflow\", workflow_manager)\n\n@container.bind(scope=\"workflow\")\nclass WorkflowContext:\n    def __init__(self):\n        self.data = {}\n        self.errors = []\n\n    def set_data(self, key: str, value: Any):\n        self.data[key] = value\n\n    def add_error(self, error: str):\n        self.errors.append(error)\n\ndef execute_workflow_step(workflow_id: str, step_name: str):\n    with container.scope(\"workflow\", workflow_id) as scope:\n        context = scope.get(WorkflowContext)\n\n        try:\n            result = execute_step_logic(step_name, context.data)\n            context.set_data(f\"{step_name}_result\", result)\n            workflow_manager.record_step(step_name, result)\n            return {\"success\": True, \"result\": result}\n        except Exception as e:\n            context.add_error(str(e))\n            workflow_manager.record_step(step_name, {\"error\": str(e)})\n            return {\"success\": False, \"error\": str(e)}\n</code></pre>"},{"location":"scopes/custom-scopes/#performance-considerations","title":"\u26a1 Performance Considerations","text":""},{"location":"scopes/custom-scopes/#memory-management","title":"Memory Management","text":"<pre><code>class MemoryAwareScopeManager(ScopeManager):\n    \"\"\"Scope manager with memory limits\"\"\"\n\n    def __init__(self, max_scopes: int = 1000, max_memory_mb: int = 100):\n        self._scopes = {}\n        self._max_scopes = max_scopes\n        self._max_memory_mb = max_memory_mb\n        self._current_scope = None\n\n    def enter_scope(self, scope_id: str):\n        # Cleanup old scopes if limit reached\n        if len(self._scopes) &gt;= self._max_scopes:\n            self._cleanup_old_scopes()\n\n        if scope_id not in self._scopes:\n            self._scopes[scope_id] = {}\n        self._current_scope = scope_id\n\n    def _cleanup_old_scopes(self):\n        \"\"\"Remove oldest scopes to free memory\"\"\"\n        # Simple LRU cleanup - remove oldest 10%\n        scope_ids = list(self._scopes.keys())\n        to_remove = scope_ids[:len(scope_ids) // 10]\n\n        for scope_id in to_remove:\n            del self._scopes[scope_id]\n</code></pre>"},{"location":"scopes/custom-scopes/#thread-safety","title":"Thread Safety","text":"<pre><code>import threading\n\nclass ThreadSafeScopeManager(ScopeManager):\n    \"\"\"Thread-safe scope manager\"\"\"\n\n    def __init__(self):\n        self._scopes = {}\n        self._current_scopes = {}  # thread_id -&gt; scope_id\n        self._lock = threading.RLock()\n\n    def enter_scope(self, scope_id: str):\n        with self._lock:\n            thread_id = threading.get_ident()\n\n            if scope_id not in self._scopes:\n                self._scopes[scope_id] = {}\n            self._current_scopes[thread_id] = scope_id\n\n    def exit_scope(self):\n        with self._lock:\n            thread_id = threading.get_ident()\n            if thread_id in self._current_scopes:\n                del self._current_scopes[thread_id]\n\n    def get_current_scope(self):\n        with self._lock:\n            thread_id = threading.get_ident()\n            scope_id = self._current_scopes.get(thread_id)\n\n            if scope_id is None:\n                return None\n            return self._scopes.get(scope_id)\n</code></pre>"},{"location":"scopes/custom-scopes/#async-support","title":"Async Support","text":"<pre><code>import asyncio\nfrom contextvars import ContextVar\n\nclass AsyncScopeManager(ScopeManager):\n    \"\"\"Async-aware scope manager\"\"\"\n\n    def __init__(self):\n        self._scopes = {}\n        self._current_scope: ContextVar[Optional[str]] = ContextVar('current_scope', default=None)\n\n    def enter_scope(self, scope_id: str):\n        if scope_id not in self._scopes:\n            self._scopes[scope_id] = {}\n        self._current_scope.set(scope_id)\n\n    def exit_scope(self):\n        self._current_scope.set(None)\n\n    def get_current_scope(self):\n        scope_id = self._current_scope.get()\n        if scope_id is None:\n            return None\n        return self._scopes.get(scope_id)\n\n# Usage in async context\nasync def async_operation():\n    async with container.scope(\"async_custom\", \"my_scope\") as scope:\n        service = scope.get(MyAsyncService)\n        result = await service.process_async()\n        return result\n</code></pre>"},{"location":"scopes/custom-scopes/#testing-custom-scopes","title":"\ud83e\uddea Testing Custom Scopes","text":""},{"location":"scopes/custom-scopes/#testing-scope-isolation","title":"Testing Scope Isolation","text":"<pre><code>def test_custom_scope_isolation():\n    \"\"\"Test that custom scopes properly isolate instances\"\"\"\n    scope_manager = CustomScopeManager()\n    container.register_scope_manager(\"test\", scope_manager)\n\n    @container.bind(scope=\"test\")\n    class TestService:\n        def __init__(self):\n            self.id = str(uuid.uuid4())\n\n    # Test different scopes get different instances\n    with container.scope(\"test\", \"scope1\") as scope1:\n        service1 = scope1.get(TestService)\n\n    with container.scope(\"test\", \"scope2\") as scope2:\n        service2 = scope2.get(TestService)\n\n    assert service1.id != service2.id\n\ndef test_custom_scope_sharing():\n    \"\"\"Test that same scope shares instances\"\"\"\n    scope_manager = CustomScopeManager()\n    container.register_scope_manager(\"test\", scope_manager)\n\n    @container.bind(scope=\"test\")\n    class TestService:\n        def __init__(self):\n            self.id = str(uuid.uuid4())\n\n    with container.scope(\"test\", \"scope1\") as scope:\n        service1 = scope.get(TestService)\n        service2 = scope.get(TestService)\n\n    assert service1.id == service2.id\n    assert service1 is service2\n</code></pre>"},{"location":"scopes/custom-scopes/#testing-scope-lifecycle","title":"Testing Scope Lifecycle","text":"<pre><code>def test_scope_lifecycle():\n    \"\"\"Test scope creation and cleanup\"\"\"\n    scope_manager = CustomScopeManager()\n    container.register_scope_manager(\"test\", scope_manager)\n\n    @container.bind(scope=\"test\")\n    class LifecycleService:\n        def __init__(self):\n            self.created = True\n\n        def __del__(self):\n            self.destroyed = True\n\n    # Test scope creation\n    with container.scope(\"test\", \"scope1\") as scope:\n        service = scope.get(LifecycleService)\n        assert service.created\n\n    # Test scope cleanup\n    assert \"scope1\" not in scope_manager._scopes\n</code></pre>"},{"location":"scopes/custom-scopes/#testing-concurrent-scopes","title":"Testing Concurrent Scopes","text":"<pre><code>def test_concurrent_scopes():\n    \"\"\"Test custom scopes work correctly with concurrency\"\"\"\n    scope_manager = ThreadSafeScopeManager()\n    container.register_scope_manager(\"thread\", scope_manager)\n\n    @container.bind(scope=\"thread\")\n    class ThreadService:\n        def __init__(self):\n            self.thread_id = threading.get_ident()\n\n    results = []\n\n    def worker(scope_id: str):\n        with container.scope(\"thread\", scope_id) as scope:\n            service = scope.get(ThreadService)\n            results.append((scope_id, service.thread_id))\n\n    # Run multiple threads with different scopes\n    threads = []\n    for i in range(5):\n        t = threading.Thread(target=worker, args=[f\"scope_{i}\"])\n        threads.append(t)\n        t.start()\n\n    for t in threads:\n        t.join()\n\n    # Each scope should have its own service instance\n    scope_ids = set()\n    for scope_id, thread_id in results:\n        scope_ids.add(scope_id)\n\n    assert len(scope_ids) == 5\n</code></pre>"},{"location":"scopes/custom-scopes/#common-custom-scope-mistakes","title":"\ud83d\udea8 Common Custom Scope Mistakes","text":""},{"location":"scopes/custom-scopes/#1-memory-leaks","title":"1. Memory Leaks","text":"<pre><code>class LeakyScopeManager(ScopeManager):\n    \"\"\"\u274c Never cleans up scopes\"\"\"\n\n    def __init__(self):\n        self._scopes = {}\n        self._current_scope = None\n\n    def enter_scope(self, scope_id: str):\n        if scope_id not in self._scopes:\n            self._scopes[scope_id] = {}\n        self._current_scope = scope_id\n\n    # \u274c No cleanup method\n    # Scopes accumulate forever!\n\n# \u2705 Proper cleanup\nclass CleanScopeManager(ScopeManager):\n    def __init__(self):\n        self._scopes = {}\n        self._current_scope = None\n        self._scope_times = {}\n\n    def enter_scope(self, scope_id: str):\n        current_time = time.time()\n        if scope_id not in self._scopes:\n            self._scopes[scope_id] = {}\n            self._scope_times[scope_id] = current_time\n        self._current_scope = scope_id\n\n    def cleanup_expired_scopes(self, max_age: float = 3600):\n        \"\"\"Clean up old scopes\"\"\"\n        current_time = time.time()\n        expired = [\n            scope_id for scope_id, create_time\n            in self._scope_times.items()\n            if current_time - create_time &gt; max_age\n        ]\n\n        for scope_id in expired:\n            if scope_id in self._scopes:\n                del self._scopes[scope_id]\n            if scope_id in self._scope_times:\n                del self._scope_times[scope_id]\n</code></pre>"},{"location":"scopes/custom-scopes/#2-thread-safety-issues","title":"2. Thread Safety Issues","text":"<pre><code>class UnsafeScopeManager(ScopeManager):\n    \"\"\"\u274c Not thread-safe\"\"\"\n\n    def __init__(self):\n        self._scopes = {}\n        self._current_scope = None  # \u274c Shared across threads\n\n    def enter_scope(self, scope_id: str):\n        if scope_id not in self._scopes:\n            self._scopes[scope_id] = {}  # \u274c Race condition\n        self._current_scope = scope_id  # \u274c Overwrites other threads\n\n# \u2705 Thread-safe\nclass SafeScopeManager(ScopeManager):\n    def __init__(self):\n        self._scopes = {}\n        self._current_scopes = {}  # thread_id -&gt; scope_id\n        self._lock = threading.RLock()\n\n    def enter_scope(self, scope_id: str):\n        with self._lock:\n            thread_id = threading.get_ident()\n            if scope_id not in self._scopes:\n                self._scopes[scope_id] = {}\n            self._current_scopes[thread_id] = scope_id\n\n    def get_current_scope(self):\n        with self._lock:\n            thread_id = threading.get_ident()\n            scope_id = self._current_scopes.get(thread_id)\n            if scope_id is None:\n                return None\n            return self._scopes.get(scope_id)\n</code></pre>"},{"location":"scopes/custom-scopes/#3-scope-confusion","title":"3. Scope Confusion","text":"<pre><code># \u274c Confusing scope names\ncontainer.register_scope_manager(\"my_custom_scope\", MyScopeManager())\ncontainer.register_scope_manager(\"another_custom\", AnotherScopeManager())\n\n# Usage is confusing\nwith container.scope(\"my_custom_scope\", \"id\") as scope:\n    service = scope.get(Service)\n\n# \u2705 Clear scope names\ncontainer.register_scope_manager(\"user_session\", UserSessionManager())\ncontainer.register_scope_manager(\"tenant\", TenantScopeManager())\n\n# Usage is clear\nwith container.scope(\"user_session\", user_id) as scope:\n    service = scope.get(Service)\n</code></pre>"},{"location":"scopes/custom-scopes/#best-practices","title":"\ud83c\udfc6 Best Practices","text":""},{"location":"scopes/custom-scopes/#1-clear-naming-conventions","title":"1. Clear Naming Conventions","text":"<pre><code># \u2705 Good naming\ncontainer.register_scope_manager(\"user_session\", UserSessionManager())\ncontainer.register_scope_manager(\"tenant_isolation\", TenantScopeManager())\ncontainer.register_scope_manager(\"request_batch\", BatchScopeManager())\n\n# \u274c Bad naming\ncontainer.register_scope_manager(\"custom1\", MyScopeManager())\ncontainer.register_scope_manager(\"scope2\", AnotherScopeManager())\n</code></pre>"},{"location":"scopes/custom-scopes/#2-implement-proper-cleanup","title":"2. Implement Proper Cleanup","text":"<pre><code>class WellBehavedScopeManager(ScopeManager):\n    def __init__(self):\n        self._scopes = {}\n        self._scope_metadata = {}  # Track creation time, size, etc.\n\n    def cleanup_expired_scopes(self):\n        \"\"\"Regular cleanup of expired scopes\"\"\"\n        current_time = time.time()\n        expired = [\n            scope_id for scope_id, metadata\n            in self._scope_metadata.items()\n            if current_time - metadata[\"created\"] &gt; metadata[\"ttl\"]\n        ]\n\n        for scope_id in expired:\n            self._cleanup_scope(scope_id)\n\n    def _cleanup_scope(self, scope_id: str):\n        \"\"\"Clean up a specific scope and its resources\"\"\"\n        if scope_id in self._scopes:\n            # Clean up any resources in the scope\n            scope_data = self._scopes[scope_id]\n            for key, value in scope_data.items():\n                if hasattr(value, 'cleanup'):\n                    value.cleanup()\n\n            del self._scopes[scope_id]\n\n        if scope_id in self._scope_metadata:\n            del self._scope_metadata[scope_id]\n</code></pre>"},{"location":"scopes/custom-scopes/#3-add-monitoring-and-metrics","title":"3. Add Monitoring and Metrics","text":"<pre><code>class MonitoredScopeManager(ScopeManager):\n    def __init__(self):\n        self._scopes = {}\n        self._metrics = {\n            \"active_scopes\": 0,\n            \"total_scopes_created\": 0,\n            \"scopes_cleaned_up\": 0\n        }\n\n    def enter_scope(self, scope_id: str):\n        if scope_id not in self._scopes:\n            self._scopes[scope_id] = {}\n            self._metrics[\"total_scopes_created\"] += 1\n            self._metrics[\"active_scopes\"] += 1\n\n        self._current_scope = scope_id\n\n    def exit_scope(self):\n        if self._current_scope:\n            self._metrics[\"active_scopes\"] -= 1\n        self._current_scope = None\n\n    def get_metrics(self):\n        \"\"\"Get scope usage metrics\"\"\"\n        return self._metrics.copy()\n</code></pre>"},{"location":"scopes/custom-scopes/#4-document-scope-behavior","title":"4. Document Scope Behavior","text":"<pre><code>class DocumentedScopeManager(ScopeManager):\n    \"\"\"\n    User Session Scope Manager\n\n    Manages service instances per user session. Each session\n    maintains its own set of service instances that are shared\n    within that session but isolated between sessions.\n\n    Features:\n    - Automatic session timeout (30 minutes)\n    - Memory-efficient cleanup of expired sessions\n    - Thread-safe operations\n\n    Usage:\n        with container.scope(\"user_session\", session_id) as scope:\n            service = scope.get(UserService)\n    \"\"\"\n\n    def __init__(self, session_timeout: int = 1800):\n        self.session_timeout = session_timeout\n        # ... implementation\n</code></pre>"},{"location":"scopes/custom-scopes/#5-test-thoroughly","title":"5. Test Thoroughly","text":"<pre><code>def test_custom_scope_comprehensive():\n    \"\"\"Comprehensive test of custom scope behavior\"\"\"\n\n    # Test basic functionality\n    scope_manager = CustomScopeManager()\n    container.register_scope_manager(\"test\", scope_manager)\n\n    @container.bind(scope=\"test\")\n    class TestService:\n        def __init__(self):\n            self.id = str(uuid.uuid4())\n\n    # Test isolation\n    with container.scope(\"test\", \"scope1\") as s1:\n        svc1a = s1.get(TestService)\n        svc1b = s1.get(TestService)\n        assert svc1a is svc1b\n\n    with container.scope(\"test\", \"scope2\") as s2:\n        svc2 = s2.get(TestService)\n        assert svc2 is not svc1a\n\n    # Test cleanup\n    assert \"scope1\" not in scope_manager._scopes\n    assert \"scope2\" not in scope_manager._scopes\n</code></pre>"},{"location":"scopes/custom-scopes/#custom-vs-built-in-scopes","title":"\ud83d\udd04 Custom vs Built-in Scopes","text":""},{"location":"scopes/custom-scopes/#when-to-use-custom-scopes_1","title":"When to Use Custom Scopes","text":"<pre><code># \u2705 Use custom when you need:\n# - Per-user sessions\n# - Tenant isolation\n# - Workflow-specific contexts\n# - Custom lifetime rules\n# - Domain-specific scoping\n\n# \u274c Don't use custom for:\n# - Simple per-request state (use scoped)\n# - Global application state (use singleton)\n# - Stateless operations (use transient)\n</code></pre>"},{"location":"scopes/custom-scopes/#migration-from-built-in","title":"Migration from Built-in","text":"<pre><code># Built-in scoped\n@scoped\nclass RequestService:\n    pass\n\n# Custom equivalent\nclass RequestScopeManager(ScopeManager):\n    def __init__(self):\n        self._current_request = None\n\n    def enter_scope(self, request_id: str):\n        self._current_request = request_id\n        # Custom logic here\n\n    # ... rest of implementation\n\n# Use custom scope\ncontainer.register_scope_manager(\"request\", RequestScopeManager())\n\n@container.bind(scope=\"request\")\nclass RequestService:\n    pass\n</code></pre>"},{"location":"scopes/custom-scopes/#summary","title":"\ud83c\udfaf Summary","text":"<p>Custom scopes provide:</p> <ul> <li>Flexible lifetime management - Define your own rules</li> <li>Domain-specific contexts - User sessions, tenants, workflows</li> <li>Advanced features - Cleanup, monitoring, thread safety</li> <li>Complete control - When instances are created/destroyed</li> </ul> <p>Perfect for: - User session management - Multi-tenant applications - Workflow execution contexts - Batch processing - Feature flag contexts</p> <p>Key principles: - Implement proper cleanup to prevent memory leaks - Ensure thread safety for concurrent access - Add monitoring and metrics - Test thoroughly with isolation and concurrency - Document behavior and usage patterns</p> <p>Ready to explore scope best practices?</p>"},{"location":"scopes/scope-best-practices/","title":"Scope Best Practices","text":"<p>Scope best practices guide you to choose the right scope for each service and avoid common pitfalls in dependency injection.</p>"},{"location":"scopes/scope-best-practices/#choosing-the-right-scope","title":"\ud83c\udfaf Choosing the Right Scope","text":""},{"location":"scopes/scope-best-practices/#decision-framework","title":"Decision Framework","text":"<pre><code>def choose_scope(service_class):\n    \"\"\"\n    Framework for choosing the right scope\n    \"\"\"\n\n    # 1. Is the service stateless?\n    if service_has_no_state(service_class):\n        return \"transient\"  # \u2705 New instance each time\n\n    # 2. Is the service shared across the entire application?\n    if service_is_global(service_class):\n        return \"singleton\"  # \u2705 One instance for all\n\n    # 3. Is the service specific to a request/session/workflow?\n    if service_is_context_specific(service_class):\n        return \"scoped\"  # \u2705 One instance per context\n\n    # 4. Does the service need custom lifetime rules?\n    if service_needs_custom_lifetime(service_class):\n        return \"custom\"  # \u2705 Define your own rules\n\n    # Default to scoped for safety\n    return \"scoped\"\n</code></pre>"},{"location":"scopes/scope-best-practices/#quick-reference","title":"Quick Reference","text":"Service Type State Sharing Lifetime Recommended Scope Validators Stateless Per operation Short Transient Controllers Stateless Per request Short Transient Repositories Stateless Per operation Short Transient Database Connections Stateful Per request Medium Scoped User Sessions Stateful Per user Long Custom (Session) Caches Stateful Per request Medium Scoped Configurations Stateful Global App lifetime Singleton Loggers Stateless Per operation Short Transient Email Services Stateless Per operation Short Transient"},{"location":"scopes/scope-best-practices/#scope-selection-guidelines","title":"\ud83c\udfd7\ufe0f Scope Selection Guidelines","text":""},{"location":"scopes/scope-best-practices/#transient-scope-guidelines","title":"Transient Scope Guidelines","text":"<p>Use transient for: - Stateless services - No instance variables - Lightweight operations - Fast to create - Isolated operations - No shared state needed - Validation logic - Check data without storing - Data transformation - Process without persistence</p> <pre><code># \u2705 Good transient services\n@transient\nclass EmailValidator:\n    def validate(self, email: str) -&gt; bool:\n        return \"@\" in email and \".\" in email\n\n@transient\nclass DataProcessor:\n    def process(self, data: dict) -&gt; dict:\n        return {k: v.upper() for k, v in data.items()}\n\n@transient\nclass PasswordHasher:\n    def hash(self, password: str) -&gt; str:\n        return bcrypt.hashpw(password.encode(), bcrypt.gensalt())\n</code></pre> <p>Avoid transient for: - Expensive resources - Database connections - Shared state - Caches, sessions - Heavy initialization - Loading large datasets</p>"},{"location":"scopes/scope-best-practices/#singleton-scope-guidelines","title":"Singleton Scope Guidelines","text":"<p>Use singleton for: - Global resources - Database connection pools - Application configuration - Settings, constants - Shared caches - Application-wide caching - Heavy objects - Expensive to create - Static data - Reference data, lookup tables</p> <pre><code># \u2705 Good singleton services\n@singleton\nclass DatabasePool:\n    def __init__(self):\n        self.pool = create_connection_pool()\n\n@singleton\nclass AppConfig:\n    def __init__(self):\n        self.database_url = os.getenv(\"DATABASE_URL\")\n        self.redis_url = os.getenv(\"REDIS_URL\")\n\n@singleton\nclass GlobalCache:\n    def __init__(self):\n        self.cache = RedisCache()\n</code></pre> <p>Avoid singleton for: - Request-specific data - User sessions - Mutable state - Per-user preferences - Test isolation - Makes testing harder</p>"},{"location":"scopes/scope-best-practices/#scoped-scope-guidelines","title":"Scoped Scope Guidelines","text":"<p>Use scoped for: - Request context - Per-request data - User sessions - Per-user state - Database transactions - Per-request transactions - Audit trails - Per-request logging - Temporary caches - Request-scoped caching</p> <pre><code># \u2705 Good scoped services\n@scoped\nclass RequestContext:\n    def __init__(self):\n        self.user_id = None\n        self.request_id = str(uuid.uuid4())\n\n@scoped\nclass DatabaseTransaction:\n    def __init__(self, db_pool: DatabasePool):\n        self.transaction = db_pool.begin_transaction()\n\n@scoped\nclass RequestCache:\n    def __init__(self):\n        self.cache = {}\n</code></pre> <p>Avoid scoped for: - Global state - Application-wide data - Stateless operations - No state to share - Long-running contexts - Memory accumulation</p>"},{"location":"scopes/scope-best-practices/#custom-scope-guidelines","title":"Custom Scope Guidelines","text":"<p>Use custom scopes for: - User sessions - Per-user lifetime - Tenant isolation - Per-tenant services - Workflow contexts - Per-workflow state - Batch operations - Per-batch lifetime - Feature contexts - Per-feature state</p> <pre><code># \u2705 Good custom scope usage\nclass UserSessionManager(ScopeManager):\n    \"\"\"Per-user session scope\"\"\"\n\nclass TenantScopeManager(ScopeManager):\n    \"\"\"Per-tenant isolation scope\"\"\"\n\nclass WorkflowScopeManager(ScopeManager):\n    \"\"\"Per-workflow execution scope\"\"\"\n</code></pre> <p>Avoid custom scopes for: - Simple cases - Built-in scopes suffice - Over-engineering - Unnecessary complexity</p>"},{"location":"scopes/scope-best-practices/#common-scope-mistakes","title":"\ud83d\udea8 Common Scope Mistakes","text":""},{"location":"scopes/scope-best-practices/#1-wrong-scope-selection","title":"1. Wrong Scope Selection","text":"<pre><code># \u274c Bad: Singleton for per-request data\n@singleton\nclass UserPreferences:\n    def __init__(self):\n        self.user_id = None  # Only one user globally!\n        self.theme = \"light\"\n\n# \u2705 Good: Scoped for per-request data\n@scoped\nclass UserPreferences:\n    def __init__(self, user_id: int):\n        self.user_id = user_id\n        self.theme = load_user_theme(user_id)\n</code></pre>"},{"location":"scopes/scope-best-practices/#2-memory-leaks-with-scoped","title":"2. Memory Leaks with Scoped","text":"<pre><code># \u274c Bad: Long-lived scoped services\n@scoped\nclass WebSocketConnection:\n    def __init__(self):\n        self.messages = []  # Accumulates forever!\n\n    def handle_message(self, message):\n        self.messages.append(message)  # Memory leak!\n\n# \u2705 Good: Proper cleanup\n@scoped\nclass WebSocketConnection:\n    def __init__(self):\n        self.messages = []\n        self.max_messages = 100\n\n    def handle_message(self, message):\n        self.messages.append(message)\n        if len(self.messages) &gt; self.max_messages:\n            self.messages.pop(0)  # Prevent unbounded growth\n</code></pre>"},{"location":"scopes/scope-best-practices/#3-singleton-state-pollution","title":"3. Singleton State Pollution","text":"<pre><code># \u274c Bad: Mutable singleton state\n@singleton\nclass GlobalCounter:\n    def __init__(self):\n        self.count = 0\n\n    def increment(self):\n        self.count += 1\n\n# Tests interfere with each other!\ndef test_counter():\n    counter = container.get(GlobalCounter)\n    counter.increment()\n    assert counter.count == 1  # Fails if other tests ran first\n\n# \u2705 Good: Immutable or reset-able singleton\n@singleton\nclass GlobalCounter:\n    def __init__(self):\n        self._count = 0\n\n    def increment(self):\n        self._count += 1\n        return self._count\n\n    def get_count(self):\n        return self._count\n\n    # For testing\n    def reset(self):\n        self._count = 0\n</code></pre>"},{"location":"scopes/scope-best-practices/#4-transient-performance-issues","title":"4. Transient Performance Issues","text":"<pre><code># \u274c Bad: Expensive transient\n@transient\nclass DataLoader:\n    def __init__(self):\n        self.data = load_large_dataset()  # 100MB! Created every time\n\n    def get_data(self, key):\n        return self.data.get(key)\n\n# \u2705 Good: Move expensive part to singleton\n@singleton\nclass DataCache:\n    def __init__(self):\n        self.data = load_large_dataset()  # Loaded once\n\n@transient\nclass DataLoader:\n    def __init__(self, cache: DataCache):\n        self.cache = cache\n\n    def get_data(self, key):\n        return self.cache.data.get(key)\n</code></pre>"},{"location":"scopes/scope-best-practices/#5-scope-confusion","title":"5. Scope Confusion","text":"<pre><code># \u274c Bad: Mixed scope usage\n@singleton\nclass UserManager:\n    def __init__(self):\n        self.current_user = None  # \u274c Global state\n\n# \u2705 Good: Clear separation\n@singleton\nclass UserRepository:\n    def get_user(self, user_id: int) -&gt; User:\n        return self.db.get(user_id)\n\n@scoped\nclass UserContext:\n    def __init__(self, user_repo: UserRepository):\n        self.user_repo = user_repo\n        self.current_user = None\n\n    def set_user(self, user_id: int):\n        self.current_user = self.user_repo.get_user(user_id)\n</code></pre>"},{"location":"scopes/scope-best-practices/#best-practices","title":"\ud83c\udfc6 Best Practices","text":""},{"location":"scopes/scope-best-practices/#1-default-to-scoped","title":"1. Default to Scoped","text":"<pre><code># \u2705 Safe default\n@scoped\nclass SafeService:\n    \"\"\"Use scoped unless you have a good reason not to\"\"\"\n    pass\n\n# Only use other scopes when necessary\n@singleton\nclass NecessarySingleton:\n    \"\"\"Only when global sharing is required\"\"\"\n    pass\n</code></pre>"},{"location":"scopes/scope-best-practices/#2-document-scope-decisions","title":"2. Document Scope Decisions","text":"<pre><code>@scoped\nclass UserSession:\n    \"\"\"\n    Scoped: Per-request user session data.\n\n    This service maintains user session state for the duration\n    of a single request. Each request gets its own session\n    instance, ensuring isolation between concurrent requests.\n\n    Dependencies: Requires IUserRepository for user loading.\n    Thread Safety: Safe due to request isolation.\n    \"\"\"\n    pass\n\n@singleton\nclass DatabasePool:\n    \"\"\"\n    Singleton: Application-wide database connection pool.\n\n    This service provides a shared pool of database connections\n    that can be used across the entire application. The pool\n    is created once at startup and reused for all database\n    operations.\n\n    Performance: Reduces connection overhead.\n    Thread Safety: Pool handles concurrent access.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"scopes/scope-best-practices/#3-test-scope-behavior","title":"3. Test Scope Behavior","text":"<pre><code>def test_scope_isolation():\n    \"\"\"Ensure scoped services are properly isolated\"\"\"\n\n    @scoped\n    class TestService:\n        def __init__(self):\n            self.id = str(uuid.uuid4())\n\n    # Test different scopes get different instances\n    with container.scope() as scope1:\n        svc1 = scope1.get(TestService)\n\n    with container.scope() as scope2:\n        svc2 = scope2.get(TestService)\n\n    assert svc1.id != svc2.id\n\ndef test_singleton_sharing():\n    \"\"\"Ensure singletons are shared correctly\"\"\"\n\n    @singleton\n    class TestSingleton:\n        def __init__(self):\n            self.id = str(uuid.uuid4())\n\n    svc1 = container.get(TestSingleton)\n    svc2 = container.get(TestSingleton)\n\n    assert svc1.id == svc2.id\n    assert svc1 is svc2\n</code></pre>"},{"location":"scopes/scope-best-practices/#4-monitor-scope-usage","title":"4. Monitor Scope Usage","text":"<pre><code>class ScopeMonitor:\n    \"\"\"Monitor scope usage and performance\"\"\"\n\n    def __init__(self):\n        self.metrics = {\n            \"transient_created\": 0,\n            \"scoped_active\": 0,\n            \"singleton_count\": 0\n        }\n\n    def track_transient_creation(self, service_class):\n        self.metrics[\"transient_created\"] += 1\n\n    def track_scoped_creation(self, service_class):\n        self.metrics[\"scoped_active\"] += 1\n\n    def track_singleton_access(self, service_class):\n        self.metrics[\"singleton_count\"] += 1\n\n# Integrate with container\nmonitor = ScopeMonitor()\n\n# Track in your services\n@transient\nclass MonitoredTransient:\n    def __init__(self):\n        monitor.track_transient_creation(self.__class__)\n</code></pre>"},{"location":"scopes/scope-best-practices/#5-handle-scope-transitions","title":"5. Handle Scope Transitions","text":"<pre><code># Handle scope transitions gracefully\ndef migrate_from_singleton_to_scoped():\n    \"\"\"\n    Example: Migrating UserPreferences from singleton to scoped\n    \"\"\"\n\n    # Old singleton (problematic)\n    @singleton\n    class OldUserPreferences:\n        def __init__(self):\n            self.preferences = {}  # Global state\n\n    # New scoped (better)\n    @scoped\n    class NewUserPreferences:\n        def __init__(self, user_id: int):\n            self.user_id = user_id\n            self.preferences = load_user_preferences(user_id)\n\n    # Migration wrapper\n    class UserPreferencesAdapter:\n        def __init__(self, old_prefs: OldUserPreferences, new_prefs: NewUserPreferences):\n            self.old = old_prefs\n            self.new = new_prefs\n\n        def get_preference(self, key: str) -&gt; Any:\n            # Try new scoped first, fall back to old singleton\n            if hasattr(self.new, key):\n                return getattr(self.new, key)\n            return self.old.preferences.get(key, None)\n</code></pre>"},{"location":"scopes/scope-best-practices/#performance-optimization","title":"\u26a1 Performance Optimization","text":""},{"location":"scopes/scope-best-practices/#1-scope-aware-caching","title":"1. Scope-Aware Caching","text":"<pre><code># Different caches for different scopes\n@singleton\nclass GlobalCache:\n    \"\"\"Application-wide cache\"\"\"\n    def __init__(self):\n        self.cache = RedisCache()\n\n@scoped\nclass RequestCache:\n    \"\"\"Per-request cache\"\"\"\n    def __init__(self):\n        self.cache = {}\n\n@transient\nclass NoCache:\n    \"\"\"No caching - always fresh\"\"\"\n    pass\n\n# Smart cache service\n@transient\nclass SmartCache:\n    def __init__(self, global_cache: GlobalCache, request_cache: RequestCache):\n        self.global_cache = global_cache\n        self.request_cache = request_cache\n\n    def get(self, key: str):\n        # Try request cache first\n        value = self.request_cache.cache.get(key)\n        if value is not None:\n            return value\n\n        # Try global cache\n        value = self.global_cache.cache.get(key)\n        if value is not None:\n            # Promote to request cache\n            self.request_cache.cache[key] = value\n            return value\n\n        return None\n</code></pre>"},{"location":"scopes/scope-best-practices/#2-lazy-initialization","title":"2. Lazy Initialization","text":"<pre><code># Lazy singleton initialization\nclass LazySingleton:\n    _instance = None\n    _lock = threading.Lock()\n\n    @classmethod\n    def get_instance(cls):\n        if cls._instance is None:\n            with cls._lock:\n                if cls._instance is None:\n                    cls._instance = cls()\n        return cls._instance\n\n# Usage in DI\n@singleton\nclass LazyService:\n    def __init__(self):\n        # Expensive initialization\n        self.data = self._load_expensive_data()\n\n    def _load_expensive_data(self):\n        # Only called when first instance is created\n        time.sleep(5)  # Simulate expensive operation\n        return {\"loaded\": True}\n</code></pre>"},{"location":"scopes/scope-best-practices/#3-scope-pooling","title":"3. Scope Pooling","text":"<pre><code># Pool scoped instances for performance\nclass ScopedPool:\n    def __init__(self, factory, max_size: int = 10):\n        self.factory = factory\n        self.max_size = max_size\n        self.pool = {}\n\n    def get_for_scope(self, scope_id: str):\n        if scope_id not in self.pool:\n            if len(self.pool) &gt;= self.max_size:\n                # Remove oldest\n                oldest = next(iter(self.pool))\n                del self.pool[oldest]\n\n            self.pool[scope_id] = self.factory()\n\n        return self.pool[scope_id]\n\n    def cleanup_scope(self, scope_id: str):\n        if scope_id in self.pool:\n            del self.pool[scope_id]\n</code></pre>"},{"location":"scopes/scope-best-practices/#testing-strategies","title":"\ud83e\uddea Testing Strategies","text":""},{"location":"scopes/scope-best-practices/#1-scope-specific-tests","title":"1. Scope-Specific Tests","text":"<pre><code>def test_transient_isolation():\n    \"\"\"Test transient services are isolated\"\"\"\n\n    @transient\n    class TestTransient:\n        def __init__(self):\n            self.id = str(uuid.uuid4())\n\n    with test_container() as container:\n        svc1 = container.get(TestTransient)\n        svc2 = container.get(TestTransient)\n\n        assert svc1.id != svc2.id\n\ndef test_singleton_sharing():\n    \"\"\"Test singleton services are shared\"\"\"\n\n    @singleton\n    class TestSingleton:\n        def __init__(self):\n            self.id = str(uuid.uuid4())\n\n    with test_container() as container:\n        svc1 = container.get(TestSingleton)\n        svc2 = container.get(TestSingleton)\n\n        assert svc1.id == svc2.id\n        assert svc1 is svc2\n\ndef test_scoped_isolation():\n    \"\"\"Test scoped services are properly isolated\"\"\"\n\n    @scoped\n    class TestScoped:\n        def __init__(self):\n            self.id = str(uuid.uuid4())\n\n    with test_container() as container:\n        with container.scope() as scope1:\n            svc1a = scope1.get(TestScoped)\n            svc1b = scope1.get(TestScoped)\n            assert svc1a.id == svc1b.id  # Same scope\n\n        with container.scope() as scope2:\n            svc2 = scope2.get(TestScoped)\n            assert svc2.id != svc1a.id  # Different scope\n</code></pre>"},{"location":"scopes/scope-best-practices/#2-mocking-strategies","title":"2. Mocking Strategies","text":"<pre><code>def test_with_mocked_scopes():\n    \"\"\"Test with mocked scoped dependencies\"\"\"\n\n    mock_cache = MockRequestCache()\n\n    with override_dependency(RequestCache, mock_cache):\n        with container.scope() as scope:\n            service = scope.get(MyService)\n\n            # Service gets the mock\n            assert service.cache is mock_cache\n\ndef test_scope_lifecycle():\n    \"\"\"Test scope creation and destruction\"\"\"\n\n    creation_count = 0\n    destruction_count = 0\n\n    @scoped\n    class LifecycleService:\n        def __init__(self):\n            nonlocal creation_count\n            creation_count += 1\n\n        def __del__(self):\n            nonlocal destruction_count\n            destruction_count += 1\n\n    with test_container() as container:\n        with container.scope() as scope:\n            service = scope.get(LifecycleService)\n            assert creation_count == 1\n\n        # Scope exited, service should be cleaned up\n        assert destruction_count == 1\n</code></pre>"},{"location":"scopes/scope-best-practices/#3-performance-testing","title":"3. Performance Testing","text":"<pre><code>def test_scope_performance():\n    \"\"\"Test scope creation performance\"\"\"\n\n    @transient\n    class FastService:\n        def __init__(self):\n            pass\n\n    @scoped\n    class ScopedService:\n        def __init__(self):\n            pass\n\n    with test_container() as container:\n        # Test transient creation speed\n        start = time.time()\n        for _ in range(1000):\n            container.get(FastService)\n        transient_time = time.time() - start\n\n        # Test scoped creation speed\n        start = time.time()\n        for _ in range(1000):\n            with container.scope() as scope:\n                scope.get(ScopedService)\n        scoped_time = time.time() - start\n\n        # Scoped should be reasonably fast\n        assert scoped_time &lt; transient_time * 2\n</code></pre>"},{"location":"scopes/scope-best-practices/#summary","title":"\ud83c\udfaf Summary","text":"<p>Scope best practices:</p> <ul> <li>Choose wisely - Match scope to service lifetime needs</li> <li>Default to scoped - Safe choice for most services</li> <li>Document decisions - Explain why you chose each scope</li> <li>Test thoroughly - Verify isolation and sharing behavior</li> <li>Monitor usage - Track performance and memory usage</li> <li>Handle transitions - Migrate scopes when requirements change</li> </ul> <p>Key principles: - Transient for stateless, lightweight operations - Singleton for global, expensive, shared resources - Scoped for request/session-specific state - Custom for domain-specific lifetime rules - Always test scope behavior and performance</p> <p>Remember: Wrong scope choice can cause memory leaks, performance issues, or incorrect behavior. Choose carefully and test thoroughly!</p> <p>Next: Ready to explore modules and providers?</p>"},{"location":"scopes/scoped-services/","title":"Scoped Services","text":"<p>Scoped services live for the duration of a specific context (like a web request or user session), sharing state within that context but isolated between contexts.</p>"},{"location":"scopes/scoped-services/#what-is-scoped-lifetime","title":"\ud83c\udfaf What is Scoped Lifetime?","text":"<p>A scoped service creates one instance per scope, meaning all requests within the same scope get the same instance, but different scopes get different instances.</p> <pre><code>from injectq import InjectQ, scoped\n\ncontainer = InjectQ()\n\n@scoped\nclass RequestContext:\n    def __init__(self):\n        self.request_id = str(uuid.uuid4())\n        self.start_time = time.time()\n        self.user_id = None\n        print(f\"Request context created: {self.request_id}\")\n\n# Within same scope - same instance\nwith container.scope() as scope:\n    ctx1 = scope.get(RequestContext)\n    ctx2 = scope.get(RequestContext)\n    print(f\"Same instance: {ctx1 is ctx2}\")  # True\n\n# Different scopes - different instances\nwith container.scope() as scope_a:\n    ctx_a = scope_a.get(RequestContext)\n\nwith container.scope() as scope_b:\n    ctx_b = scope_b.get(RequestContext)\n\nprint(f\"Different instances: {ctx_a is not ctx_b}\")  # True\n</code></pre>"},{"location":"scopes/scoped-services/#when-to-use-scoped","title":"\ud83c\udfd7\ufe0f When to Use Scoped","text":""},{"location":"scopes/scoped-services/#perfect-for","title":"\u2705 Perfect For","text":"<ul> <li>Web request data - User session, request context</li> <li>Database transactions - Per-request transaction</li> <li>Caching per request - Request-scoped cache</li> <li>User preferences - Per-user settings</li> <li>Audit logging - Per-request audit trail</li> </ul> <pre><code>@scoped\nclass UserSession:\n    \"\"\"\u2705 Good - per-user session data\"\"\"\n    def __init__(self):\n        self.user_id = None\n        self.permissions = []\n        self.login_time = None\n\n@scoped\nclass DatabaseTransaction:\n    \"\"\"\u2705 Good - per-request transaction\"\"\"\n    def __init__(self, db: Database):\n        self.db = db\n        self.transaction = db.begin_transaction()\n\n    def commit(self):\n        self.transaction.commit()\n\n    def rollback(self):\n        self.transaction.rollback()\n\n@scoped\nclass RequestCache:\n    \"\"\"\u2705 Good - cache per request\"\"\"\n    def __init__(self):\n        self.data = {}\n</code></pre>"},{"location":"scopes/scoped-services/#avoid-for","title":"\u274c Avoid For","text":"<ul> <li>Global application state - Use singleton instead</li> <li>Stateless operations - Use transient instead</li> <li>Cross-request data - Use singleton instead</li> <li>Static configuration - Use singleton instead</li> </ul> <pre><code>@scoped\nclass ApplicationConfig:\n    \"\"\"\u274c Bad - config should be global\"\"\"\n    def __init__(self):\n        self.database_url = \"postgresql://...\"\n\n@scoped\nclass EmailValidator:\n    \"\"\"\u274c Bad - validation is stateless\"\"\"\n    def validate(self, email: str) -&gt; bool:\n        return \"@\" in email\n</code></pre>"},{"location":"scopes/scoped-services/#creating-scoped-services","title":"\ud83d\udd27 Creating Scoped Services","text":""},{"location":"scopes/scoped-services/#decorator-approach","title":"Decorator Approach","text":"<pre><code>from injectq import scoped\n\n@scoped\nclass ShoppingCart:\n    def __init__(self):\n        self.items = []\n        self.total = 0.0\n\n    def add_item(self, item: Item, quantity: int = 1):\n        self.items.append({\"item\": item, \"quantity\": quantity})\n        self.total += item.price * quantity\n\n    def get_total(self) -&gt; float:\n        return self.total\n\n# Usage in web request\ndef handle_shopping_request(request):\n    with container.scope() as scope:\n        cart = scope.get(ShoppingCart)\n\n        # Add items to cart\n        cart.add_item(request.item, request.quantity)\n\n        # Cart persists within this request\n        return {\"total\": cart.get_total()}\n</code></pre>"},{"location":"scopes/scoped-services/#explicit-binding","title":"Explicit Binding","text":"<pre><code>from injectq import Scope\n\n# Explicit scoped binding\ncontainer.bind(ShoppingCart, ShoppingCart, scope=Scope.SCOPED)\n\n# Or with string\ncontainer.bind(ShoppingCart, ShoppingCart, scope=\"scoped\")\n</code></pre>"},{"location":"scopes/scoped-services/#factory-function","title":"Factory Function","text":"<pre><code>def create_user_session(user_id: int) -&gt; UserSession:\n    session = UserSession()\n    session.user_id = user_id\n    session.login_time = datetime.now()\n    return session\n\ncontainer.bind_factory(UserSession, create_user_session)\n</code></pre>"},{"location":"scopes/scoped-services/#scoped-patterns","title":"\ud83c\udfa8 Scoped Patterns","text":""},{"location":"scopes/scoped-services/#web-request-context","title":"Web Request Context","text":"<pre><code>@scoped\nclass RequestContext:\n    def __init__(self):\n        self.request_id = str(uuid.uuid4())\n        self.user_id = None\n        self.start_time = time.time()\n        self.metadata = {}\n\n    def set_user(self, user_id: int):\n        self.user_id = user_id\n        self.metadata[\"user_set_at\"] = time.time()\n\n    def add_metadata(self, key: str, value: Any):\n        self.metadata[key] = value\n\n# Middleware usage\ndef auth_middleware(request):\n    with container.scope() as scope:\n        ctx = scope.get(RequestContext)\n        ctx.set_user(request.user_id)\n        ctx.add_metadata(\"user_agent\", request.headers.get(\"User-Agent\"))\n\n        # Continue processing\n        return process_request(scope, request)\n\ndef process_request(scope, request):\n    # Same context instance\n    ctx = scope.get(RequestContext)\n    print(f\"Processing request {ctx.request_id} for user {ctx.user_id}\")\n\n    return {\"request_id\": ctx.request_id}\n</code></pre>"},{"location":"scopes/scoped-services/#database-transaction","title":"Database Transaction","text":"<pre><code>@scoped\nclass UnitOfWork:\n    def __init__(self, db: Database):\n        self.db = db\n        self.transaction = db.begin_transaction()\n        self.repositories = {}\n\n    def get_repository(self, entity_type: Type[T]) -&gt; Repository[T]:\n        if entity_type not in self.repositories:\n            self.repositories[entity_type] = Repository(entity_type, self.transaction)\n        return self.repositories[entity_type]\n\n    def commit(self):\n        self.transaction.commit()\n\n    def rollback(self):\n        self.transaction.rollback()\n\n# Service using transaction\n@transient\nclass OrderService:\n    def __init__(self, uow: UnitOfWork):\n        self.uow = uow\n\n    def create_order(self, order_data: dict) -&gt; Order:\n        order_repo = self.uow.get_repository(Order)\n        item_repo = self.uow.get_repository(OrderItem)\n\n        order = Order(**order_data)\n        order_repo.save(order)\n\n        for item_data in order_data[\"items\"]:\n            item = OrderItem(order_id=order.id, **item_data)\n            item_repo.save(item)\n\n        self.uow.commit()\n        return order\n\n# Usage\ndef create_order_endpoint(order_data):\n    with container.scope() as scope:\n        service = scope.get(OrderService)\n        order = service.create_order(order_data)\n        return {\"order_id\": order.id}\n</code></pre>"},{"location":"scopes/scoped-services/#request-caching","title":"Request Caching","text":"<pre><code>@scoped\nclass RequestCache:\n    def __init__(self):\n        self.cache = {}\n        self.hits = 0\n        self.misses = 0\n\n    def get(self, key: str) -&gt; Any:\n        if key in self.cache:\n            self.hits += 1\n            return self.cache[key]\n        return None\n\n    def set(self, key: str, value: Any):\n        self.misses += 1\n        self.cache[key] = value\n        return value\n\n    def get_or_set(self, key: str, factory: Callable[[], Any]) -&gt; Any:\n        cached = self.get(key)\n        if cached is not None:\n            return cached\n        return self.set(key, factory())\n\n# Service using cache\n@transient\nclass ProductService:\n    def __init__(self, cache: RequestCache, db: ProductRepository):\n        self.cache = cache\n        self.db = db\n\n    def get_product(self, product_id: int) -&gt; Product:\n        return self.cache.get_or_set(\n            f\"product:{product_id}\",\n            lambda: self.db.find_by_id(product_id)\n        )\n\n    def get_products_by_category(self, category_id: int) -&gt; List[Product]:\n        return self.cache.get_or_set(\n            f\"products:category:{category_id}\",\n            lambda: self.db.find_by_category(category_id)\n        )\n</code></pre>"},{"location":"scopes/scoped-services/#framework-integration","title":"\ud83c\udf10 Framework Integration","text":""},{"location":"scopes/scoped-services/#fastapi-request-scope","title":"FastAPI Request Scope","text":"<pre><code>from fastapi import Request, Depends\nfrom injectq import InjectQ, scoped\n\ncontainer = InjectQ()\n\n@scoped\nclass RequestState:\n    def __init__(self):\n        self.user_id = None\n        self.request_id = str(uuid.uuid4())\n        self.start_time = time.time()\n\ndef get_request_state(request: Request) -&gt; RequestState:\n    \"\"\"Get or create request-scoped state\"\"\"\n    # In real implementation, this would be handled by InjectQ's FastAPI integration\n    scope = container.scope()\n    state = scope.get(RequestState)\n    state.user_id = getattr(request.state, 'user_id', None)\n    return state\n\n@app.get(\"/api/data\")\nasync def get_data(state: RequestState = Depends(get_request_state)):\n    # Same state instance for entire request\n    return {\n        \"request_id\": state.request_id,\n        \"user_id\": state.user_id,\n        \"processing_time\": time.time() - state.start_time\n    }\n</code></pre>"},{"location":"scopes/scoped-services/#custom-scope-manager","title":"Custom Scope Manager","text":"<pre><code>from injectq import ScopeManager\n\nclass WebRequestScopeManager(ScopeManager):\n    def __init__(self):\n        self._current_scope = None\n\n    def enter_scope(self):\n        self._current_scope = {}\n\n    def exit_scope(self):\n        self._current_scope = None\n\n    def get_current_scope(self):\n        return self._current_scope\n\n# Register custom scope manager\ncontainer.register_scope_manager(\"web_request\", WebRequestScopeManager())\n\n# Use in web framework\ndef handle_request(request):\n    with container.scope(\"web_request\") as scope:\n        # All scoped services share the same instance\n        service = scope.get(MyScopedService)\n        return service.process(request)\n</code></pre>"},{"location":"scopes/scoped-services/#performance-considerations","title":"\u26a1 Performance Considerations","text":""},{"location":"scopes/scoped-services/#memory-management","title":"Memory Management","text":"<pre><code>@scoped\nclass LargeRequestCache:\n    def __init__(self):\n        # Large data structure per request\n        self.data = {}  # Could be MBs of data\n\n# Each concurrent request gets its own cache\n# Memory usage scales with concurrent requests\n# Good: Isolated per request\n# Bad: High memory usage under load\n</code></pre>"},{"location":"scopes/scoped-services/#scope-lifetime","title":"Scope Lifetime","text":"<pre><code># Short-lived scope - good\ndef handle_api_request(request):\n    with container.scope() as scope:\n        # Scope lives for request duration\n        service = scope.get(RequestService)\n        return service.process(request)\n\n# Long-lived scope - careful!\ndef handle_websocket_connection(ws):\n    with container.scope() as scope:  # \u274c Scope lives for entire connection\n        while ws.connected:\n            message = ws.receive()\n            service = scope.get(MessageService)  # Same instance for hours\n            service.process(message)\n</code></pre>"},{"location":"scopes/scoped-services/#cleanup-and-resources","title":"Cleanup and Resources","text":"<pre><code>@scoped\nclass TempFileManager:\n    def __init__(self):\n        self.temp_files = []\n\n    def create_temp_file(self) -&gt; str:\n        temp_path = tempfile.mktemp()\n        self.temp_files.append(temp_path)\n        return temp_path\n\n    def cleanup(self):\n        for path in self.temp_files:\n            try:\n                os.unlink(path)\n            except FileNotFoundError:\n                pass\n\n# Automatic cleanup when scope exits\ndef process_files():\n    with container.scope() as scope:\n        manager = scope.get(TempFileManager)\n\n        # Create temp files\n        file1 = manager.create_temp_file()\n        file2 = manager.create_temp_file()\n\n        # Process files\n        process_file(file1)\n        process_file(file2)\n\n        # Files automatically cleaned up when scope exits\n</code></pre>"},{"location":"scopes/scoped-services/#testing-scoped-services","title":"\ud83e\uddea Testing Scoped Services","text":""},{"location":"scopes/scoped-services/#testing-scope-isolation","title":"Testing Scope Isolation","text":"<pre><code>def test_scope_isolation():\n    with test_container() as container:\n        container.bind(RequestCache, RequestCache, scope=\"scoped\")\n\n        # Different scopes get different instances\n        with container.scope() as scope1:\n            cache1 = scope1.get(RequestCache)\n            cache1.set(\"key\", \"value1\")\n\n        with container.scope() as scope2:\n            cache2 = scope2.get(RequestCache)\n            cache2.set(\"key\", \"value2\")\n\n        # Values should be isolated\n        with container.scope() as scope1_again:\n            cache1_again = scope1_again.get(RequestCache)\n            assert cache1_again.get(\"key\") is None  # New scope\n\ndef test_same_scope_sharing():\n    with test_container() as container:\n        container.bind(RequestCache, RequestCache, scope=\"scoped\")\n\n        with container.scope() as scope:\n            cache1 = scope.get(RequestCache)\n            cache2 = scope.get(RequestCache)\n\n            # Same instance within scope\n            assert cache1 is cache2\n\n            cache1.set(\"shared\", \"value\")\n            assert cache2.get(\"shared\") == \"value\"\n</code></pre>"},{"location":"scopes/scoped-services/#mocking-scoped-dependencies","title":"Mocking Scoped Dependencies","text":"<pre><code>def test_with_mocked_scoped_service():\n    mock_cache = MockRequestCache()\n\n    with override_dependency(RequestCache, mock_cache):\n        with container.scope() as scope:\n            # All scoped services get the mock\n            service1 = scope.get(MyService)\n            service2 = scope.get(MyService)\n\n            # Both use same mock instance\n            assert service1.cache is mock_cache\n            assert service2.cache is mock_cache\n</code></pre>"},{"location":"scopes/scoped-services/#testing-scope-lifecycle","title":"Testing Scope Lifecycle","text":"<pre><code>def test_scope_lifecycle():\n    events = []\n\n    @scoped\n    class LifecycleService:\n        def __init__(self):\n            events.append(\"created\")\n\n        def __del__(self):\n            events.append(\"destroyed\")\n\n    with test_container() as container:\n        container.bind(LifecycleService, LifecycleService, scope=\"scoped\")\n\n        with container.scope() as scope:\n            service = scope.get(LifecycleService)\n            assert events == [\"created\"]\n\n        # Scope exited, service should be cleaned up\n        # Note: __del__ may not be called immediately due to GC\n        assert len(events) &gt;= 1\n</code></pre>"},{"location":"scopes/scoped-services/#common-scoped-mistakes","title":"\ud83d\udea8 Common Scoped Mistakes","text":""},{"location":"scopes/scoped-services/#1-scope-leakage","title":"1. Scope Leakage","text":"<pre><code># \u274c Scope lives too long\n@scoped\nclass UserPreferences:\n    def __init__(self):\n        self.preferences = load_user_preferences()\n\ndef handle_websocket(ws):\n    with container.scope() as scope:  # \u274c Hours long\n        prefs = scope.get(UserPreferences)\n\n        while ws.connected:\n            # Same preferences instance for entire connection\n            update_prefs(prefs, ws.receive())\n\n# \u2705 Short-lived scopes\ndef handle_websocket_message(ws, message):\n    with container.scope() as scope:  # \u2705 Per message\n        prefs = scope.get(UserPreferences)\n        update_prefs(prefs, message)\n</code></pre>"},{"location":"scopes/scoped-services/#2-cross-scope-sharing","title":"2. Cross-Scope Sharing","text":"<pre><code># \u274c Trying to share across scopes\n@scoped\nclass SharedState:\n    data = {}  # \u274c Class variable shared across scopes!\n\n# Different scopes share the same data\nwith container.scope() as scope1:\n    state1 = scope1.get(SharedState)\n    state1.data[\"key\"] = \"value1\"\n\nwith container.scope() as scope2:\n    state2 = scope2.get(SharedState)\n    print(state2.data[\"key\"])  # \"value1\" - shared!\n\n# \u2705 Use instance variables\n@scoped\nclass IsolatedState:\n    def __init__(self):\n        self.data = {}  # \u2705 Instance variable\n</code></pre>"},{"location":"scopes/scoped-services/#3-resource-accumulation","title":"3. Resource Accumulation","text":"<pre><code>@scoped\nclass FileAccumulator:\n    def __init__(self):\n        self.files = []\n\n    def add_file(self, file_path):\n        self.files.append(open(file_path))  # \u274c Files not closed\n\n# Files accumulate per scope\nwith container.scope() as scope:\n    accumulator = scope.get(FileAccumulator)\n\n    for i in range(100):\n        accumulator.add_file(f\"file_{i}.txt\")\n\n    # 100 open files!\n    # Only closed when scope exits\n\n# \u2705 Proper resource management\n@scoped\nclass FileAccumulator:\n    def __init__(self):\n        self.files = []\n\n    def add_file(self, file_path):\n        file = open(file_path)\n        self.files.append(file)\n        return file\n\n    def __del__(self):\n        for file in self.files:\n            file.close()\n</code></pre>"},{"location":"scopes/scoped-services/#best-practices","title":"\ud83c\udfc6 Best Practices","text":""},{"location":"scopes/scoped-services/#1-keep-scopes-short-lived","title":"1. Keep Scopes Short-Lived","text":"<pre><code># \u2705 Request-scoped\ndef handle_request(request):\n    with container.scope() as scope:\n        service = scope.get(RequestService)\n        return service.process(request)\n\n# \u274c Session-scoped (too long)\ndef handle_session(session):\n    with container.scope() as scope:  # Hours!\n        while session.active:\n            service = scope.get(SessionService)\n            service.process(session.receive())\n</code></pre>"},{"location":"scopes/scoped-services/#2-use-for-request-specific-state","title":"2. Use for Request-Specific State","text":"<pre><code>@scoped\nclass RequestMetrics:\n    \"\"\"\u2705 Good - per-request metrics\"\"\"\n    def __init__(self):\n        self.start_time = time.time()\n        self.operations = []\n\n    def record_operation(self, name: str, duration: float):\n        self.operations.append({\"name\": name, \"duration\": duration})\n\n@scoped\nclass UserPermissions:\n    \"\"\"\u2705 Good - per-request permissions\"\"\"\n    def __init__(self, user_id: int):\n        self.user_id = user_id\n        self.permissions = load_permissions(user_id)\n</code></pre>"},{"location":"scopes/scoped-services/#3-handle-cleanup-properly","title":"3. Handle Cleanup Properly","text":"<pre><code>@scoped\nclass DatabaseConnection:\n    def __init__(self, db_url: str):\n        self.connection = create_connection(db_url)\n\n    def execute(self, query):\n        return self.connection.execute(query)\n\n    def __del__(self):\n        if self.connection:\n            self.connection.close()\n\n# Automatic cleanup when scope exits\ndef process_data():\n    with container.scope() as scope:\n        db = scope.get(DatabaseConnection)\n        result = db.execute(\"SELECT * FROM data\")\n        return process_result(result)\n</code></pre>"},{"location":"scopes/scoped-services/#4-document-scope-requirements","title":"4. Document Scope Requirements","text":"<pre><code>@scoped\nclass TransactionManager:\n    \"\"\"Manages database transactions for a single request.\n\n    This service is scoped to individual requests - each request\n    gets its own transaction that is committed or rolled back\n    when the request completes.\n\n    Dependencies:\n    - Requires active database connection\n    - Should be used within request scope only\n    \"\"\"\n    pass\n</code></pre>"},{"location":"scopes/scoped-services/#5-test-scope-behavior","title":"5. Test Scope Behavior","text":"<pre><code>def test_scoped_service_isolation():\n    \"\"\"Ensure scoped services are properly isolated.\"\"\"\n    with test_container() as container:\n        container.bind(RequestCache, RequestCache, scope=\"scoped\")\n\n        # Test multiple concurrent scopes\n        results = []\n        def test_scope():\n            with container.scope() as scope:\n                cache = scope.get(RequestCache)\n                cache.set(\"key\", f\"value_{id(scope)}\")\n                results.append(cache.get(\"key\"))\n\n        threads = [threading.Thread(target=test_scope) for _ in range(10)]\n        for t in threads:\n            t.start()\n        for t in threads:\n            t.join()\n\n        # All values should be different (different scopes)\n        assert len(set(results)) == 10\n</code></pre>"},{"location":"scopes/scoped-services/#scoped-vs-other-scopes","title":"\ud83d\udd04 Scoped vs Other Scopes","text":""},{"location":"scopes/scoped-services/#scoped-vs-singleton","title":"Scoped vs Singleton","text":"<pre><code># Singleton - Global instance\n@singleton\nclass GlobalConfig:\n    def __init__(self):\n        self.database_url = \"postgresql://...\"\n\n# Scoped - Per-request instance\n@scoped\nclass RequestConfig:\n    def __init__(self, global_config: GlobalConfig):\n        self.database_url = global_config.database_url\n        self.request_timeout = 30  # Per-request setting\n</code></pre>"},{"location":"scopes/scoped-services/#scoped-vs-transient","title":"Scoped vs Transient","text":"<pre><code># Transient - New instance each time\n@transient\nclass Validator:\n    def validate(self, data):\n        return len(data) &gt; 0\n\n# Scoped - Same instance per request\n@scoped\nclass RequestValidator:\n    def __init__(self):\n        self.validations_count = 0\n\n    def validate(self, data):\n        self.validations_count += 1\n        return len(data) &gt; 0\n</code></pre>"},{"location":"scopes/scoped-services/#summary","title":"\ud83c\udfaf Summary","text":"<p>Scoped services provide:</p> <ul> <li>Per-context instances - One per scope</li> <li>Shared state within context - Same instance in scope</li> <li>Isolation between contexts - Different instances across scopes</li> <li>Automatic cleanup - Resources freed when scope exits</li> </ul> <p>Perfect for: - Web request context and data - Database transactions per request - User session data - Request-scoped caching - Audit trails per request</p> <p>Key principles: - Keep scopes short-lived (request duration) - Use for context-specific state - Handle resource cleanup properly - Test scope isolation thoroughly - Document scope requirements</p> <p>Ready to explore custom scopes?</p>"},{"location":"scopes/singleton-scope/","title":"Singleton Scope","text":"<p>The singleton scope creates one instance of a service that lives for the entire application lifetime. It's the default scope in InjectQ and is perfect for shared resources.</p>"},{"location":"scopes/singleton-scope/#what-is-singleton-scope","title":"\ud83c\udfaf What is Singleton Scope?","text":"<p>A singleton service is instantiated once and the same instance is returned for all subsequent requests.</p> <pre><code>from injectq import InjectQ, singleton\n\ncontainer = InjectQ()\n\n@singleton\nclass Database:\n    def __init__(self):\n        self.connection_id = id(self)\n        print(f\"Database created: {self.connection_id}\")\n\n# Register and use\ncontainer.bind(Database, Database)\n\n# First access creates instance\ndb1 = container.get(Database)\nprint(f\"First instance: {db1.connection_id}\")\n\n# Subsequent accesses return same instance\ndb2 = container.get(Database)\nprint(f\"Second instance: {db2.connection_id}\")\nprint(f\"Same instance? {db1 is db2}\")  # True\n</code></pre>"},{"location":"scopes/singleton-scope/#when-to-use-singleton","title":"\ud83c\udfd7\ufe0f When to Use Singleton","text":""},{"location":"scopes/singleton-scope/#perfect-for","title":"\u2705 Perfect For","text":"<ul> <li>Database connections - Share connection pool</li> <li>Configuration objects - App-wide settings</li> <li>Caching services - Shared cache instance</li> <li>Logging services - Centralized logging</li> <li>Expensive resources - Services with high creation cost</li> </ul> <pre><code>@singleton\nclass DatabaseConnection:\n    \"\"\"\u2705 Good - shared connection pool\"\"\"\n    def __init__(self):\n        self.pool = create_connection_pool()\n\n@singleton\nclass AppConfig:\n    \"\"\"\u2705 Good - application configuration\"\"\"\n    def __init__(self):\n        self.database_url = os.getenv(\"DATABASE_URL\")\n        self.redis_url = os.getenv(\"REDIS_URL\")\n\n@singleton\nclass RedisCache:\n    \"\"\"\u2705 Good - shared cache\"\"\"\n    def __init__(self, redis_url: str):\n        self.client = redis.Redis.from_url(redis_url)\n</code></pre>"},{"location":"scopes/singleton-scope/#avoid-for","title":"\u274c Avoid For","text":"<ul> <li>Request-specific data - Use scoped instead</li> <li>User session data - Use scoped instead</li> <li>Temporary state - Use transient instead</li> </ul> <pre><code>@singleton\nclass UserSession:\n    \"\"\"\u274c Bad - user-specific data gets mixed up\"\"\"\n    def __init__(self):\n        self.user_id = None\n        self.permissions = []\n\n@singleton\nclass RequestContext:\n    \"\"\"\u274c Bad - request data gets overwritten\"\"\"\n    def __init__(self):\n        self.request_id = None\n        self.start_time = None\n</code></pre>"},{"location":"scopes/singleton-scope/#creating-singletons","title":"\ud83d\udd27 Creating Singletons","text":""},{"location":"scopes/singleton-scope/#decorator-approach","title":"Decorator Approach","text":"<pre><code>from injectq import singleton\n\n@singleton\nclass Database:\n    def __init__(self, config: DatabaseConfig):\n        self.config = config\n        self.connection = create_connection(config.url)\n\n# Automatic registration with container\ncontainer = InjectQ()\ndb = container.get(Database)  # Works automatically\n</code></pre>"},{"location":"scopes/singleton-scope/#explicit-binding","title":"Explicit Binding","text":"<pre><code>from injectq import Scope\n\n# Explicit binding with scope\ncontainer.bind(Database, Database, scope=Scope.SINGLETON)\n\n# Or with string\ncontainer.bind(Database, Database, scope=\"singleton\")\n</code></pre>"},{"location":"scopes/singleton-scope/#factory-function","title":"Factory Function","text":"<pre><code>def create_database() -&gt; Database:\n    config = load_config()\n    return Database(config)\n\ncontainer.bind_factory(Database, create_database)\n# Result is still singleton (cached after first creation)\n</code></pre>"},{"location":"scopes/singleton-scope/#singleton-patterns","title":"\ud83c\udfa8 Singleton Patterns","text":""},{"location":"scopes/singleton-scope/#lazy-initialization","title":"Lazy Initialization","text":"<p>Singletons are created lazily - only when first requested:</p> <pre><code>@singleton\nclass ExpensiveService:\n    def __init__(self):\n        print(\"Creating expensive service...\")\n        time.sleep(2)  # Simulate expensive initialization\n\nprint(\"Container ready\")\n# Service not created yet\n\nservice = container.get(ExpensiveService)\n# \"Creating expensive service...\" printed here\n\nservice2 = container.get(ExpensiveService)\n# No second creation - same instance returned\n</code></pre>"},{"location":"scopes/singleton-scope/#singleton-with-dependencies","title":"Singleton with Dependencies","text":"<pre><code>@singleton\nclass Database:\n    def __init__(self, config: DatabaseConfig):\n        self.config = config\n\n@singleton\nclass UserRepository:\n    def __init__(self, db: Database):\n        self.db = db\n\n@singleton\nclass UserService:\n    def __init__(self, repo: UserRepository):\n        self.repo = repo\n\n# Dependency chain:\n# UserService -&gt; UserRepository -&gt; Database -&gt; DatabaseConfig\n# All are singletons, so the chain is created once\n</code></pre>"},{"location":"scopes/singleton-scope/#singleton-registry","title":"Singleton Registry","text":"<pre><code>@singleton\nclass ServiceRegistry:\n    def __init__(self):\n        self.services = {}\n\n    def register(self, name: str, service):\n        self.services[name] = service\n\n    def get(self, name: str):\n        return self.services.get(name)\n\n# Usage\nregistry = container.get(ServiceRegistry)\nregistry.register(\"email\", EmailService())\n</code></pre>"},{"location":"scopes/singleton-scope/#performance-benefits","title":"\u26a1 Performance Benefits","text":""},{"location":"scopes/singleton-scope/#memory-efficiency","title":"Memory Efficiency","text":"<pre><code>@singleton\nclass SharedCache:\n    def __init__(self):\n        self.data = {}  # One dictionary for entire app\n\n# vs\n\n@transient\nclass IndividualCache:\n    def __init__(self):\n        self.data = {}  # New dictionary each time\n</code></pre>"},{"location":"scopes/singleton-scope/#creation-cost","title":"Creation Cost","text":"<pre><code>@singleton\nclass DatabaseConnection:\n    def __init__(self):\n        # Expensive operation - done once\n        self.pool = create_connection_pool(max_size=20)\n\n# First access: ~2 seconds\n# Subsequent accesses: ~0.001 seconds\n</code></pre>"},{"location":"scopes/singleton-scope/#reference-equality","title":"Reference Equality","text":"<pre><code>@singleton\nclass AppConfig:\n    pass\n\nconfig1 = container.get(AppConfig)\nconfig2 = container.get(AppConfig)\n\n# Can use identity comparison\nif config1 is config2:\n    print(\"Same config object\")\n</code></pre>"},{"location":"scopes/singleton-scope/#testing-singletons","title":"\ud83e\uddea Testing Singletons","text":""},{"location":"scopes/singleton-scope/#testing-singleton-behavior","title":"Testing Singleton Behavior","text":"<pre><code>def test_singleton_behavior():\n    with test_container() as container:\n        container.bind(Database, Database, scope=\"singleton\")\n\n        # Should be same instance\n        db1 = container.get(Database)\n        db2 = container.get(Database)\n        assert db1 is db2\n\n        # Test the singleton\n        db1.connect()\n        assert db2.is_connected()\n</code></pre>"},{"location":"scopes/singleton-scope/#overriding-singletons","title":"Overriding Singletons","text":"<pre><code>def test_with_mock_singleton():\n    mock_db = MockDatabase()\n\n    with override_dependency(Database, mock_db):\n        # All code sees the mock\n        service = container.get(UserService)\n        result = service.get_user(1)\n        assert result.name == \"Mock User\"\n</code></pre>"},{"location":"scopes/singleton-scope/#resetting-singletons","title":"Resetting Singletons","text":"<pre><code># For testing - reset singleton instances\ncontainer.clear_scope(\"singleton\")\n\n# Or reset entire container\ncontainer.clear()\n</code></pre>"},{"location":"scopes/singleton-scope/#thread-safety","title":"\ud83d\udea8 Thread Safety","text":"<p>Singletons must be thread-safe if used in multi-threaded environments:</p> <pre><code>@singleton\nclass ThreadSafeCache:\n    def __init__(self):\n        self._data = {}\n        self._lock = threading.Lock()\n\n    def get(self, key: str):\n        with self._lock:\n            return self._data.get(key)\n\n    def set(self, key: str, value):\n        with self._lock:\n            self._data[key] = value\n\n# Usage in multi-threaded app\ncache = container.get(ThreadSafeCache)\ncache.set(\"user_123\", user_data)\n</code></pre>"},{"location":"scopes/singleton-scope/#singleton-lifecycle","title":"\ud83d\udd04 Singleton Lifecycle","text":""},{"location":"scopes/singleton-scope/#creation","title":"Creation","text":"<pre><code>print(\"1. Container created\")\ncontainer = InjectQ()\n\nprint(\"2. Service registered\")\ncontainer.bind(Database, Database)\n\nprint(\"3. First access triggers creation\")\ndb = container.get(Database)  # Database.__init__ called here\n\nprint(\"4. Subsequent accesses use cached instance\")\ndb2 = container.get(Database)  # No creation\n</code></pre>"},{"location":"scopes/singleton-scope/#cleanup","title":"Cleanup","text":"<pre><code># Manual cleanup\ncontainer.clear_scope(\"singleton\")\n\n# Or clear all\ncontainer.clear()\n\n# Singletons are garbage collected when container is deleted\ndel container\n</code></pre>"},{"location":"scopes/singleton-scope/#best-practices","title":"\ud83c\udfc6 Best Practices","text":""},{"location":"scopes/singleton-scope/#1-use-for-shared-resources","title":"1. Use for Shared Resources","text":"<pre><code>@singleton\nclass DatabaseConnection:\n    \"\"\"\u2705 Shared database connection\"\"\"\n    pass\n\n@singleton\nclass RedisClient:\n    \"\"\"\u2705 Shared Redis connection\"\"\"\n    pass\n\n@singleton\nclass AppConfig:\n    \"\"\"\u2705 Shared configuration\"\"\"\n    pass\n</code></pre>"},{"location":"scopes/singleton-scope/#2-ensure-thread-safety","title":"2. Ensure Thread Safety","text":"<pre><code>@singleton\nclass SharedService:\n    def __init__(self):\n        self._lock = threading.Lock()\n\n    def do_work(self):\n        with self._lock:\n            # Thread-safe operations\n            pass\n</code></pre>"},{"location":"scopes/singleton-scope/#3-avoid-mutable-state-issues","title":"3. Avoid Mutable State Issues","text":"<pre><code>@singleton\nclass UserManager:\n    def __init__(self):\n        self.current_user = None  # \u274c Mutable state\n\n    def set_current_user(self, user):\n        self.current_user = user  # \u274c Overwrites for all users\n\n# \u2705 Use scoped or transient instead\n@scoped(\"request\")\nclass RequestUser:\n    def __init__(self):\n        self.user = None\n\n    def set_user(self, user):\n        self.user = user  # \u2705 Unique per request\n</code></pre>"},{"location":"scopes/singleton-scope/#4-document-singleton-usage","title":"4. Document Singleton Usage","text":"<pre><code>@singleton\nclass MetricsCollector:\n    \"\"\"Application-wide metrics collection.\n\n    This service collects metrics across all requests.\n    Thread-safe for concurrent access.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"scopes/singleton-scope/#5-use-factories-for-complex-setup","title":"5. Use Factories for Complex Setup","text":"<pre><code>def create_database_pool() -&gt; DatabasePool:\n    \"\"\"Factory for complex database setup.\"\"\"\n    config = load_database_config()\n    pool = create_connection_pool(config)\n    setup_connection_monitoring(pool)\n    return pool\n\ncontainer.bind_factory(DatabasePool, create_database_pool)\n</code></pre>"},{"location":"scopes/singleton-scope/#common-singleton-mistakes","title":"\ud83d\udea8 Common Singleton Mistakes","text":""},{"location":"scopes/singleton-scope/#1-storing-request-data","title":"1. Storing Request Data","text":"<pre><code>@singleton\nclass RequestCache:\n    def __init__(self):\n        self.data = {}  # \u274c Shared across requests\n\n    def set_request_data(self, request_id, data):\n        self.data[request_id] = data  # \u274c Race conditions\n</code></pre>"},{"location":"scopes/singleton-scope/#2-not-handling-thread-safety","title":"2. Not Handling Thread Safety","text":"<pre><code>@singleton\nclass Counter:\n    def __init__(self):\n        self.count = 0  # \u274c Not thread-safe\n\n    def increment(self):\n        self.count += 1  # \u274c Race conditions in multi-threaded apps\n</code></pre>"},{"location":"scopes/singleton-scope/#3-expensive-initialization-in-constructor","title":"3. Expensive Initialization in Constructor","text":"<pre><code>@singleton\nclass Service:\n    def __init__(self):\n        # \u274c Expensive work in constructor blocks app startup\n        self.data = load_large_dataset()\n        self.model = train_ml_model()\n</code></pre>"},{"location":"scopes/singleton-scope/#summary","title":"\ud83c\udfaf Summary","text":"<p>Singleton scope provides:</p> <ul> <li>One instance for the entire application</li> <li>Memory efficient for shared resources</li> <li>Performance optimized with caching</li> <li>Lazy initialization - created only when needed</li> <li>Thread safety concerns must be handled</li> </ul> <p>Perfect for: - Database connections and pools - Configuration objects - Caching services - Logging and monitoring - Expensive shared resources</p> <p>Key principles: - Use for truly shared, application-wide resources - Ensure thread safety in multi-threaded environments - Avoid storing request-specific or user-specific data - Consider lazy initialization for expensive resources - Document thread safety guarantees</p> <p>Ready to explore transient scope?</p>"},{"location":"scopes/transient-scope/","title":"Transient Scope","text":"<p>The transient scope creates a new instance of a service every time it's requested. It's perfect for stateless services and operations that need isolation.</p>"},{"location":"scopes/transient-scope/#what-is-transient-scope","title":"\ud83c\udfaf What is Transient Scope?","text":"<p>A transient service creates a fresh instance for each request, ensuring no shared state between uses.</p> <pre><code>from injectq import InjectQ, transient\n\ncontainer = InjectQ()\n\n@transient\nclass RequestHandler:\n    def __init__(self):\n        self.instance_id = id(self)\n        self.created_at = time.time()\n        print(f\"Handler created: {self.instance_id}\")\n\n# Each access creates new instance\nhandler1 = container.get(RequestHandler)\ntime.sleep(0.1)\nhandler2 = container.get(RequestHandler)\n\nprint(f\"Different instances: {handler1.instance_id != handler2.instance_id}\")\nprint(f\"Creation time difference: {handler2.created_at - handler1.created_at}\")\n</code></pre>"},{"location":"scopes/transient-scope/#when-to-use-transient","title":"\ud83c\udfd7\ufe0f When to Use Transient","text":""},{"location":"scopes/transient-scope/#perfect-for","title":"\u2705 Perfect For","text":"<ul> <li>Request handlers - Process individual requests</li> <li>Validators - Validate data without side effects</li> <li>Command processors - Execute commands</li> <li>Stateless services - No shared state needed</li> <li>Data processors - Transform data without persistence</li> </ul> <pre><code>@transient\nclass EmailValidator:\n    \"\"\"\u2705 Good - stateless validation\"\"\"\n    def validate(self, email: str) -&gt; bool:\n        return \"@\" in email\n\n@transient\nclass DataProcessor:\n    \"\"\"\u2705 Good - processes data without storing state\"\"\"\n    def process(self, data: dict) -&gt; dict:\n        return {\"processed\": True, **data}\n\n@transient\nclass PasswordHasher:\n    \"\"\"\u2705 Good - stateless hashing\"\"\"\n    def hash(self, password: str) -&gt; str:\n        return bcrypt.hashpw(password.encode(), bcrypt.gensalt()).decode()\n</code></pre>"},{"location":"scopes/transient-scope/#avoid-for","title":"\u274c Avoid For","text":"<ul> <li>Database connections - Use singleton instead</li> <li>Caching services - Use singleton instead</li> <li>Shared resources - Use singleton instead</li> <li>Expensive objects - Use singleton instead</li> </ul> <pre><code>@transient\nclass DatabaseConnection:\n    \"\"\"\u274c Bad - expensive to create repeatedly\"\"\"\n    def __init__(self):\n        self.conn = create_connection()  # Expensive!\n\n@transient\nclass SharedCache:\n    \"\"\"\u274c Bad - cache should be shared\"\"\"\n    def __init__(self):\n        self.data = {}  # Lost on each creation\n</code></pre>"},{"location":"scopes/transient-scope/#creating-transients","title":"\ud83d\udd27 Creating Transients","text":""},{"location":"scopes/transient-scope/#decorator-approach","title":"Decorator Approach","text":"<pre><code>from injectq import transient\n\n@transient\nclass EmailSender:\n    def __init__(self, smtp_config: SMTPConfig):\n        self.config = smtp_config\n\n    def send(self, to: str, subject: str, body: str):\n        # Send email logic\n        print(f\"Sending email to {to}\")\n\n# Automatic registration\ncontainer = InjectQ()\nsender = container.get(EmailSender)  # New instance each time\n</code></pre>"},{"location":"scopes/transient-scope/#explicit-binding","title":"Explicit Binding","text":"<pre><code>from injectq import Scope\n\n# Explicit transient binding\ncontainer.bind(EmailSender, EmailSender, scope=Scope.TRANSIENT)\n\n# Or with string\ncontainer.bind(EmailSender, EmailSender, scope=\"transient\")\n</code></pre>"},{"location":"scopes/transient-scope/#factory-function","title":"Factory Function","text":"<pre><code>def create_validator() -&gt; EmailValidator:\n    # Custom creation logic\n    validator = EmailValidator()\n    validator.strict_mode = True\n    return validator\n\ncontainer.bind_factory(EmailValidator, create_validator)\n# Each call to factory creates new instance\n</code></pre>"},{"location":"scopes/transient-scope/#transient-patterns","title":"\ud83c\udfa8 Transient Patterns","text":""},{"location":"scopes/transient-scope/#stateless-operations","title":"Stateless Operations","text":"<pre><code>@transient\nclass UserValidator:\n    def __init__(self, rules: ValidationRules):\n        self.rules = rules\n\n    def validate(self, user: User) -&gt; ValidationResult:\n        errors = []\n\n        if not user.email:\n            errors.append(\"Email is required\")\n\n        if len(user.password) &lt; 8:\n            errors.append(\"Password too short\")\n\n        return ValidationResult(valid=len(errors) == 0, errors=errors)\n\n# Each validation gets fresh validator\nvalidator1 = container.get(UserValidator)\nvalidator2 = container.get(UserValidator)\n\nresult1 = validator1.validate(user1)\nresult2 = validator2.validate(user2)\n</code></pre>"},{"location":"scopes/transient-scope/#command-pattern","title":"Command Pattern","text":"<pre><code>@transient\nclass CreateUserCommand:\n    def __init__(self, user_repo: IUserRepository, event_bus: IEventBus):\n        self.repo = user_repo\n        self.event_bus = event_bus\n\n    def execute(self, user_data: dict) -&gt; User:\n        user = User(**user_data)\n        saved_user = self.repo.save(user)\n\n        # Publish event\n        self.event_bus.publish(UserCreatedEvent(saved_user.id))\n\n        return saved_user\n\n# Each command execution is isolated\ncommand1 = container.get(CreateUserCommand)\ncommand2 = container.get(CreateUserCommand)\n\nuser1 = command1.execute({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\nuser2 = command2.execute({\"name\": \"Bob\", \"email\": \"bob@example.com\"})\n</code></pre>"},{"location":"scopes/transient-scope/#data-processing","title":"Data Processing","text":"<pre><code>@transient\nclass DataTransformer:\n    def __init__(self, config: TransformConfig):\n        self.config = config\n        self.temp_files = []  # Instance-specific\n\n    def transform(self, data: bytes) -&gt; bytes:\n        # Process data with temporary files\n        temp_file = create_temp_file()\n        self.temp_files.append(temp_file)\n\n        # Transform logic\n        result = process_data(data, temp_file, self.config)\n\n        # Cleanup\n        cleanup_temp_files(self.temp_files)\n\n        return result\n\n# Each transformation is isolated\ntransformer1 = container.get(DataTransformer)\ntransformer2 = container.get(DataTransformer)\n\nresult1 = transformer1.transform(data1)\nresult2 = transformer2.transform(data2)\n</code></pre>"},{"location":"scopes/transient-scope/#performance-considerations","title":"\u26a1 Performance Considerations","text":""},{"location":"scopes/transient-scope/#creation-overhead","title":"Creation Overhead","text":"<pre><code>@transient\nclass SimpleProcessor:\n    def __init__(self):\n        pass  # Cheap\n\n@transient\nclass ComplexProcessor:\n    def __init__(self):\n        self.data = load_large_dataset()  # Expensive!\n\n# SimpleProcessor: Fast creation\n# ComplexProcessor: Slow creation every time\n</code></pre>"},{"location":"scopes/transient-scope/#memory-usage","title":"Memory Usage","text":"<pre><code>@transient\nclass LightProcessor:\n    def __init__(self):\n        self.buffer = bytearray(1024)  # Small\n\n@transient\nclass HeavyProcessor:\n    def __init__(self):\n        self.data = bytearray(100 * 1024 * 1024)  # 100MB!\n\n# Each request creates new instances\n# HeavyProcessor: 100MB per request!\n</code></pre>"},{"location":"scopes/transient-scope/#garbage-collection","title":"Garbage Collection","text":"<pre><code>@transient\nclass FileProcessor:\n    def __init__(self):\n        self.temp_file = create_temp_file()\n\n    def process(self):\n        # Use temp file\n        pass\n\n    def cleanup(self):\n        os.unlink(self.temp_file)\n\n# Instances are garbage collected automatically\n# But cleanup() might not be called\n</code></pre>"},{"location":"scopes/transient-scope/#testing-transients","title":"\ud83e\uddea Testing Transients","text":""},{"location":"scopes/transient-scope/#testing-isolation","title":"Testing Isolation","text":"<pre><code>def test_transient_isolation():\n    with test_container() as container:\n        container.bind(RequestHandler, RequestHandler, scope=\"transient\")\n\n        handler1 = container.get(RequestHandler)\n        handler2 = container.get(RequestHandler)\n\n        # Should be different instances\n        assert handler1 is not handler2\n        assert handler1.instance_id != handler2.instance_id\n\n        # Test isolation\n        handler1.state = \"modified\"\n        assert not hasattr(handler2, 'state')\n</code></pre>"},{"location":"scopes/transient-scope/#mocking-dependencies","title":"Mocking Dependencies","text":"<pre><code>def test_with_mocked_dependencies():\n    mock_repo = MockUserRepository()\n\n    with override_dependency(IUserRepository, mock_repo):\n        # Each transient gets the same mock dependency\n        handler1 = container.get(RequestHandler)\n        handler2 = container.get(RequestHandler)\n\n        # Both use the same mock\n        assert handler1.repo is mock_repo\n        assert handler2.repo is mock_repo\n</code></pre>"},{"location":"scopes/transient-scope/#performance-testing","title":"Performance Testing","text":"<pre><code>def test_creation_performance():\n    start_time = time.time()\n\n    # Create many transient instances\n    for i in range(1000):\n        handler = container.get(RequestHandler)\n\n    end_time = time.time()\n    avg_creation_time = (end_time - start_time) / 1000\n\n    # Assert reasonable creation time\n    assert avg_creation_time &lt; 0.001  # Less than 1ms per instance\n</code></pre>"},{"location":"scopes/transient-scope/#common-transient-mistakes","title":"\ud83d\udea8 Common Transient Mistakes","text":""},{"location":"scopes/transient-scope/#1-expensive-initialization","title":"1. Expensive Initialization","text":"<pre><code>@transient\nclass DatabaseProcessor:\n    def __init__(self):\n        # \u274c Expensive operation repeated\n        self.schema = load_database_schema()\n        self.cache = warm_up_cache()\n\n    def process(self, query):\n        # Use schema and cache\n        pass\n\n# \u2705 Move expensive parts to dependencies\n@singleton\nclass DatabaseSchema:\n    def __init__(self):\n        self.schema = load_database_schema()\n\n@transient\nclass DatabaseProcessor:\n    def __init__(self, schema: DatabaseSchema, cache: ICache):\n        self.schema = schema\n        self.cache = cache\n</code></pre>"},{"location":"scopes/transient-scope/#2-shared-state-assumptions","title":"2. Shared State Assumptions","text":"<pre><code>@transient\nclass Counter:\n    count = 0  # \u274c Class variable shared!\n\n    def increment(self):\n        self.count += 1\n        return self.count\n\n# All instances share the same count\ncounter1 = container.get(Counter)\ncounter2 = container.get(Counter)\n\ncounter1.increment()  # count = 1\ncounter2.increment()  # count = 2 (shared!)\n\n# \u2705 Use instance variables\n@transient\nclass Counter:\n    def __init__(self):\n        self.count = 0  # \u2705 Instance variable\n\n    def increment(self):\n        self.count += 1\n        return self.count\n</code></pre>"},{"location":"scopes/transient-scope/#3-resource-leaks","title":"3. Resource Leaks","text":"<pre><code>@transient\nclass FileHandler:\n    def __init__(self):\n        self.file = open(\"temp.txt\", \"w\")  # \u274c File not closed\n\n    def write(self, data):\n        self.file.write(data)\n\n# Files accumulate without cleanup\nfor i in range(100):\n    handler = container.get(FileHandler)\n    handler.write(f\"Data {i}\")\n\n# \u2705 Use context managers or cleanup\n@transient\nclass FileHandler:\n    def __init__(self):\n        self.file_path = create_temp_file()\n\n    def __enter__(self):\n        self.file = open(self.file_path, \"w\")\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self.file:\n            self.file.close()\n            os.unlink(self.file_path)\n</code></pre>"},{"location":"scopes/transient-scope/#best-practices","title":"\ud83c\udfc6 Best Practices","text":""},{"location":"scopes/transient-scope/#1-keep-transients-lightweight","title":"1. Keep Transients Lightweight","text":"<pre><code>@transient\nclass LightweightValidator:\n    def __init__(self, rules: ValidationRules):  # \u2705 Simple dependencies\n        self.rules = rules\n\n    def validate(self, data):\n        # \u2705 Quick validation\n        pass\n</code></pre>"},{"location":"scopes/transient-scope/#2-use-for-stateless-operations","title":"2. Use for Stateless Operations","text":"<pre><code>@transient\nclass PasswordEncoder:\n    \"\"\"\u2705 Stateless - no shared state\"\"\"\n    def encode(self, password: str) -&gt; str:\n        return bcrypt.hashpw(password.encode(), bcrypt.gensalt())\n\n@transient\nclass JWTGenerator:\n    \"\"\"\u2705 Stateless - generates new tokens\"\"\"\n    def generate(self, user_id: int) -&gt; str:\n        return jwt.encode({\"user_id\": user_id}, SECRET_KEY)\n</code></pre>"},{"location":"scopes/transient-scope/#3-handle-resources-properly","title":"3. Handle Resources Properly","text":"<pre><code>@transient\nclass TempFileProcessor:\n    def __init__(self):\n        self.temp_file = None\n\n    def __enter__(self):\n        self.temp_file = tempfile.NamedTemporaryFile(delete=False)\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self.temp_file:\n            self.temp_file.close()\n            os.unlink(self.temp_file.name)\n\n# Usage\nwith container.get(TempFileProcessor) as processor:\n    processor.process_data(data)\n</code></pre>"},{"location":"scopes/transient-scope/#4-document-transient-nature","title":"4. Document Transient Nature","text":"<pre><code>@transient\nclass RequestProcessor:\n    \"\"\"Processes individual requests.\n\n    This service is transient - a new instance is created\n    for each request to ensure isolation and thread safety.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"scopes/transient-scope/#5-test-creation-performance","title":"5. Test Creation Performance","text":"<pre><code>def test_transient_performance():\n    \"\"\"Ensure transient services are fast to create.\"\"\"\n    import time\n\n    start = time.time()\n    instances = [container.get(MyTransient) for _ in range(100)]\n    end = time.time()\n\n    avg_time = (end - start) / 100\n    assert avg_time &lt; 0.01  # Should be fast to create\n</code></pre>"},{"location":"scopes/transient-scope/#transient-vs-singleton","title":"\ud83d\udd04 Transient vs Singleton","text":""},{"location":"scopes/transient-scope/#memory-usage_1","title":"Memory Usage","text":"<pre><code># Singleton - One instance\n@singleton\nclass SharedService:\n    def __init__(self):\n        self.data = [1, 2, 3, 4, 5]  # 5 items\n\n# Transient - New instance each time\n@transient\nclass IsolatedService:\n    def __init__(self):\n        self.data = [1, 2, 3, 4, 5]  # 5 items per instance\n\n# 100 requests:\n# Singleton: 5 items total\n# Transient: 500 items total\n</code></pre>"},{"location":"scopes/transient-scope/#thread-safety","title":"Thread Safety","text":"<pre><code># Singleton - Must be thread-safe\n@singleton\nclass SharedCounter:\n    def __init__(self):\n        self._count = 0\n        self._lock = threading.Lock()\n\n    def increment(self):\n        with self._lock:\n            self._count += 1\n\n# Transient - Automatically thread-safe\n@transient\nclass IsolatedCounter:\n    def __init__(self):\n        self.count = 0  # No sharing\n\n    def increment(self):\n        self.count += 1  # Safe\n</code></pre>"},{"location":"scopes/transient-scope/#state-management","title":"State Management","text":"<pre><code># Singleton - Shared state\n@singleton\nclass GlobalState:\n    def __init__(self):\n        self.current_user = None\n\n# Transient - Isolated state\n@transient\nclass RequestState:\n    def __init__(self):\n        self.current_user = None\n</code></pre>"},{"location":"scopes/transient-scope/#summary","title":"\ud83c\udfaf Summary","text":"<p>Transient scope provides:</p> <ul> <li>New instance for each request</li> <li>Complete isolation between uses</li> <li>Thread safety by default</li> <li>Stateless operations support</li> <li>Resource management challenges</li> </ul> <p>Perfect for: - Request handlers and processors - Validators and data processors - Command execution - Stateless services - Operations needing isolation</p> <p>Key principles: - Keep initialization cheap and fast - Avoid shared state between instances - Handle resource cleanup properly - Use for truly stateless operations - Test creation performance</p> <p>Ready to explore scoped services?</p>"},{"location":"scopes/understanding-scopes/","title":"Understanding Scopes","text":"<p>Scopes in InjectQ control how long service instances live and when they are created. Choosing the right scope is crucial for performance, memory usage, and application correctness.</p>"},{"location":"scopes/understanding-scopes/#what-are-scopes","title":"\ud83c\udfaf What are Scopes?","text":"<p>A scope defines the lifecycle of a service instance:</p> <ul> <li>When it gets created</li> <li>How long it lives</li> <li>When it gets cleaned up</li> <li>Whether instances are shared or unique</li> </ul>"},{"location":"scopes/understanding-scopes/#scope-types","title":"\ud83d\udd04 Scope Types","text":"<p>InjectQ provides several built-in scopes:</p>"},{"location":"scopes/understanding-scopes/#singleton-scope","title":"Singleton Scope","text":"<pre><code>from injectq import singleton\n\n@singleton\nclass Database:\n    def __init__(self):\n        self.connection = create_connection()\n\n# One instance for entire application\ndb1 = container.get(Database)\ndb2 = container.get(Database)\nassert db1 is db2  # True\n</code></pre>"},{"location":"scopes/understanding-scopes/#transient-scope","title":"Transient Scope","text":"<pre><code>from injectq import transient\n\n@transient\nclass RequestHandler:\n    def __init__(self):\n        self.request_id = uuid.uuid4()\n\n# New instance every time\nhandler1 = container.get(RequestHandler)\nhandler2 = container.get(RequestHandler)\nassert handler1 is not handler2  # True\n</code></pre>"},{"location":"scopes/understanding-scopes/#scoped","title":"Scoped","text":"<pre><code>from injectq import scoped\n\n@scoped(\"request\")\nclass UserSession:\n    def __init__(self):\n        self.user_id = None\n\n# One instance per scope\nasync with container.scope(\"request\"):\n    session1 = container.get(UserSession)\n    session2 = container.get(UserSession)\n    assert session1 is session2  # True\n\n# New instance in new scope\nasync with container.scope(\"request\"):\n    session3 = container.get(UserSession)\n    assert session1 is not session3  # True\n</code></pre>"},{"location":"scopes/understanding-scopes/#how-scopes-work","title":"\ud83c\udfd7\ufe0f How Scopes Work","text":""},{"location":"scopes/understanding-scopes/#scope-context","title":"Scope Context","text":"<p>Scopes create a context where service instances are managed:</p> <pre><code># Enter scope\nasync with container.scope(\"request\"):\n    # Services in this scope are available\n    session = container.get(UserSession)\n    # ... use session\n\n# Exit scope - instances are cleaned up\n# session is no longer available\n</code></pre>"},{"location":"scopes/understanding-scopes/#scope-hierarchy","title":"Scope Hierarchy","text":"<p>Scopes can be nested:</p> <pre><code>async with container.scope(\"request\"):\n    request_data = container.get(RequestData)  # Request scope\n\n    async with container.scope(\"transaction\"):\n        tx_data = container.get(TransactionData)  # Transaction scope\n        # Both request and transaction services available\n\n    # tx_data cleaned up, request_data still available\n\n# request_data cleaned up\n</code></pre>"},{"location":"scopes/understanding-scopes/#scope-resolution","title":"Scope Resolution","text":"<p>When resolving a service, InjectQ follows this hierarchy:</p> <ol> <li>Current scope - Check if instance exists in current scope</li> <li>Parent scopes - Check parent scopes if nested</li> <li>Singleton scope - Fall back to application-wide singleton</li> <li>Create new - Create new instance if transient</li> </ol>"},{"location":"scopes/understanding-scopes/#choosing-the-right-scope","title":"\ud83c\udfaf Choosing the Right Scope","text":""},{"location":"scopes/understanding-scopes/#when-to-use-singleton","title":"When to Use Singleton","text":"<p>\u2705 Good for: - Database connections - Configuration objects - Caching services - Logging services - Expensive resources that can be shared</p> <p>\u274c Avoid for: - Request-specific data - User session data - Temporary state</p> <pre><code>@singleton\nclass DatabaseConnection:\n    \"\"\"\u2705 Good - shared connection pool\"\"\"\n    pass\n\n@singleton\nclass UserPreferences:\n    \"\"\"\u274c Bad - user-specific data\"\"\"\n    pass\n</code></pre>"},{"location":"scopes/understanding-scopes/#when-to-use-transient","title":"When to Use Transient","text":"<p>\u2705 Good for: - Request handlers - Validators - Stateless services - Command processors</p> <p>\u274c Avoid for: - Expensive resources - Shared state - Cached data</p> <pre><code>@transient\nclass EmailValidator:\n    \"\"\"\u2705 Good - stateless validation\"\"\"\n    pass\n\n@transient\nclass DatabaseConnection:\n    \"\"\"\u274c Bad - expensive to create\"\"\"\n    pass\n</code></pre>"},{"location":"scopes/understanding-scopes/#when-to-use-scoped","title":"When to Use Scoped","text":"<p>\u2705 Good for: - Request context - User sessions - Transaction data - Per-operation state</p> <p>\u274c Avoid for: - Application-wide data - Stateless operations</p> <pre><code>@scoped(\"request\")\nclass RequestContext:\n    \"\"\"\u2705 Good - request-specific data\"\"\"\n    pass\n\n@scoped(\"request\")\nclass DatabaseConnection:\n    \"\"\"\u274c Bad - should be singleton\"\"\"\n    pass\n</code></pre>"},{"location":"scopes/understanding-scopes/#scope-management","title":"\ud83d\udd27 Scope Management","text":""},{"location":"scopes/understanding-scopes/#manual-scope-control","title":"Manual Scope Control","text":"<pre><code># Enter scope manually\nscope_context = container.scope(\"request\")\nscope_context.__enter__()\n\ntry:\n    # Use scoped services\n    session = container.get(UserSession)\n    # ... do work\nfinally:\n    scope_context.__exit__(None, None, None)\n</code></pre>"},{"location":"scopes/understanding-scopes/#async-scope-control","title":"Async Scope Control","text":"<pre><code>async def handle_request():\n    async with container.scope(\"request\"):\n        # Scoped services available\n        context = container.get(RequestContext)\n        result = await process_request(context)\n    # Automatic cleanup\n    return result\n</code></pre>"},{"location":"scopes/understanding-scopes/#scope-cleanup","title":"Scope Cleanup","text":"<pre><code># Manual cleanup\ncontainer.clear_scope(\"request\")\n\n# Clear all scopes\ncontainer.clear_all_scopes()\n</code></pre>"},{"location":"scopes/understanding-scopes/#testing-with-scopes","title":"\ud83e\uddea Testing with Scopes","text":""},{"location":"scopes/understanding-scopes/#testing-scoped-services","title":"Testing Scoped Services","text":"<pre><code>from injectq.testing import test_container\n\ndef test_request_scope():\n    with test_container() as container:\n        container.bind(RequestContext, RequestContext, scope=\"request\")\n\n        # Outside scope - should fail or return None\n        with pytest.raises(DependencyNotFoundError):\n            container.get(RequestContext)\n\n        # Inside scope\n        with container.scope(\"request\"):\n            ctx1 = container.get(RequestContext)\n            ctx2 = container.get(RequestContext)\n            assert ctx1 is ctx2\n\n        # New scope - new instance\n        with container.scope(\"request\"):\n            ctx3 = container.get(RequestContext)\n            assert ctx1 is not ctx3\n</code></pre>"},{"location":"scopes/understanding-scopes/#mocking-scoped-services","title":"Mocking Scoped Services","text":"<pre><code>def test_with_scoped_mock():\n    mock_context = MockRequestContext()\n\n    with override_dependency(RequestContext, mock_context):\n        with container.scope(\"request\"):\n            context = container.get(RequestContext)\n            assert context is mock_context\n</code></pre>"},{"location":"scopes/understanding-scopes/#performance-implications","title":"\u26a1 Performance Implications","text":""},{"location":"scopes/understanding-scopes/#memory-usage","title":"Memory Usage","text":"<pre><code># Singleton - Low memory\n@singleton\nclass SharedCache:\n    def __init__(self):\n        self.data = {}  # One instance\n\n# Transient - High memory\n@transient\nclass Handler:\n    def __init__(self):\n        self.data = {}  # New instance each time\n\n# Scoped - Controlled memory\n@scoped(\"request\")\nclass RequestCache:\n    def __init__(self):\n        self.data = {}  # One per request\n</code></pre>"},{"location":"scopes/understanding-scopes/#creation-overhead","title":"Creation Overhead","text":"<pre><code># Singleton - Created once\n@singleton\nclass ExpensiveService:\n    def __init__(self):\n        time.sleep(1)  # Expensive\n\n# Transient - Created every time\n@transient\nclass CheapService:\n    def __init__(self):\n        pass  # Cheap\n</code></pre>"},{"location":"scopes/understanding-scopes/#access-speed","title":"Access Speed","text":"<pre><code># Singleton - Fast (cached)\nservice = container.get(SingletonService)  # Instant\n\n# Transient - Slower (new instance)\nservice = container.get(TransientService)  # Creation overhead\n\n# Scoped - Medium (scope lookup + possible creation)\nservice = container.get(ScopedService)    # Scope lookup\n</code></pre>"},{"location":"scopes/understanding-scopes/#common-scope-mistakes","title":"\ud83d\udea8 Common Scope Mistakes","text":""},{"location":"scopes/understanding-scopes/#1-wrong-scope-for-data","title":"1. Wrong Scope for Data","text":"<pre><code># \u274c Singleton with request data\n@singleton\nclass UserContext:\n    def __init__(self):\n        self.user_id = None  # Overwritten by concurrent requests!\n\n# \u2705 Request-scoped\n@scoped(\"request\")\nclass UserContext:\n    def __init__(self):\n        self.user_id = None  # Unique per request\n</code></pre>"},{"location":"scopes/understanding-scopes/#2-expensive-transient-services","title":"2. Expensive Transient Services","text":"<pre><code># \u274c Expensive transient\n@transient\nclass DatabaseConnection:\n    def __init__(self):\n        self.conn = create_connection()  # Expensive!\n\n# \u2705 Singleton connection\n@singleton\nclass DatabaseConnection:\n    def __init__(self):\n        self.conn = create_connection()  # Once only\n</code></pre>"},{"location":"scopes/understanding-scopes/#3-shared-state-in-transient","title":"3. Shared State in Transient","text":"<pre><code># \u274c Transient with shared state\n@transient\nclass Counter:\n    count = 0  # Shared across instances!\n\n    def increment(self):\n        self.count += 1\n\n# \u2705 Instance state\n@transient\nclass Counter:\n    def __init__(self):\n        self.count = 0  # Unique per instance\n\n    def increment(self):\n        self.count += 1\n</code></pre>"},{"location":"scopes/understanding-scopes/#best-practices","title":"\ud83c\udfc6 Best Practices","text":""},{"location":"scopes/understanding-scopes/#1-use-appropriate-scopes","title":"1. Use Appropriate Scopes","text":"<pre><code>@singleton\nclass Database:      # Shared resource\n    pass\n\n@scoped(\"request\")\nclass UserSession:   # Per request\n    pass\n\n@transient\nclass Validator:     # Stateless\n    pass\n</code></pre>"},{"location":"scopes/understanding-scopes/#2-consider-thread-safety","title":"2. Consider Thread Safety","text":"<pre><code>@singleton\nclass SharedService:\n    def __init__(self):\n        self._lock = threading.Lock()\n        self._data = {}\n\n    def get_data(self, key):\n        with self._lock:\n            return self._data.get(key)\n</code></pre>"},{"location":"scopes/understanding-scopes/#3-handle-cleanup","title":"3. Handle Cleanup","text":"<pre><code># Use resource management for cleanup\n@resource\ndef database_connection():\n    conn = create_connection()\n    try:\n        yield conn\n    finally:\n        conn.close()\n</code></pre>"},{"location":"scopes/understanding-scopes/#4-test-scope-behavior","title":"4. Test Scope Behavior","text":"<pre><code>def test_scopes():\n    # Test singleton behavior\n    # Test transient behavior\n    # Test scoped behavior\n    pass\n</code></pre>"},{"location":"scopes/understanding-scopes/#5-document-scope-choices","title":"5. Document Scope Choices","text":"<pre><code>@scoped(\"request\")\nclass RequestCache:\n    \"\"\"Cache for request-scoped data.\n\n    This cache is cleared at the end of each request.\n    Use for temporary data that doesn't need to persist.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"scopes/understanding-scopes/#summary","title":"\ud83c\udfaf Summary","text":"<p>Scopes control service lifecycles:</p> <ul> <li>Singleton: One instance for the entire application</li> <li>Transient: New instance every time</li> <li>Scoped: One instance per scope context</li> </ul> <p>Key considerations: - Choose scopes based on data sharing needs - Consider performance implications - Ensure thread safety for singletons - Test scope behavior thoroughly - Use appropriate cleanup mechanisms</p> <p>Scope selection guide: - Application-wide data \u2192 Singleton - Request-specific data \u2192 Scoped - Stateless operations \u2192 Transient - Expensive resources \u2192 Singleton - Temporary state \u2192 Scoped or Transient</p> <p>Ready to dive deeper into singleton scope?</p>"},{"location":"testing/THREADING_TESTS_SUMMARY/","title":"Comprehensive Threading Test Suite for InjectQ","text":"<p>This document summarizes the comprehensive threading test suite created for InjectQ, covering both synchronous and asynchronous threading scenarios with focus on race conditions, cross-thread injection, and expected failures.</p>"},{"location":"testing/THREADING_TESTS_SUMMARY/#test-coverage-summary","title":"Test Coverage Summary","text":""},{"location":"testing/THREADING_TESTS_SUMMARY/#passing-tests-28-out-of-37","title":"Passing Tests (28 out of 37)","text":""},{"location":"testing/THREADING_TESTS_SUMMARY/#synchronous-threading-tests-16-tests","title":"Synchronous Threading Tests (16 tests)","text":"<ol> <li>test_sync_race_condition_singleton \u2705 - Tests that singleton services return same instance across threads</li> <li>test_sync_race_condition_transient \u2705 - Tests that transient services create unique instances per thread</li> <li>test_sync_concurrent_binding_operations \u2705 - Tests concurrent binding operations from multiple threads</li> <li>test_sync_dependent_service_injection \u2705 - Tests dependency injection across threads with mixed scopes</li> <li>test_sync_scope_clearing_race_condition \u2705 - Tests concurrent scope clearing and resolution</li> <li>test_sync_factory_injection_race \u2705 - Tests concurrent factory-based injection</li> <li>test_sync_circular_dependency_thread_safety \u2705 - Tests circular dependency detection in threaded environment</li> <li>test_sync_thread_safe_counter_increment \u2705 - Tests AsyncSafeCounter under heavy concurrent access</li> <li>test_sync_thread_safe_dict_operations \u2705 - Tests ThreadSafeDict under concurrent access</li> <li>test_sync_hybrid_lock_performance \u2705 - Tests HybridLock performance under contention</li> <li>test_sync_container_thread_local_state \u2705 - Tests container maintains proper thread-local state</li> <li>test_sync_failed_injection_thread_safety \u2705 - Tests failure handling in threaded environment</li> <li>test_sync_memory_cleanup_thread_safety \u2705 - Tests memory cleanup in threaded environment</li> <li>test_sync_concurrent_container_creation \u2705 - Tests creating multiple containers concurrently</li> <li>test_sync_shared_dependency_modification \u2705 - Tests modifying shared dependencies across threads</li> <li>test_sync_performance_under_load \u2705 - Tests container performance under heavy concurrent load</li> </ol>"},{"location":"testing/THREADING_TESTS_SUMMARY/#asynchronous-threading-tests-12-tests","title":"Asynchronous Threading Tests (12 tests)","text":"<ol> <li>test_async_race_condition_singleton \u2705 - Tests async race conditions with singleton scope</li> <li>test_async_cross_event_loop_injection \u2705 - Tests injection across different event loops</li> <li>test_async_dependent_service_injection \u2705 - Tests async dependent service injection</li> <li>test_async_scope_cleanup \u2705 - Tests async scope cleanup operations</li> <li>test_async_error_propagation \u2705 - Tests error propagation in async environment</li> <li>test_async_circular_dependency_detection \u2705 - Tests async circular dependency detection</li> <li>test_async_hybrid_lock_performance \u2705 - Tests HybridLock performance in async environment</li> <li>test_async_thread_safe_dict_operations \u2705 - Tests async ThreadSafeDict operations</li> <li>test_async_memory_pressure \u2705 - Tests async operations under memory pressure</li> <li>test_async_event_loop_integration \u2705 - Tests integration with event loop policies</li> <li>test_async_weakref_cleanup \u2705 - Tests weak reference cleanup in async environment</li> <li>test_async_stress_test \u2705 - Comprehensive async stress test</li> </ol>"},{"location":"testing/THREADING_TESTS_SUMMARY/#currently-failing-tests-9-tests","title":"Currently Failing Tests (9 tests)","text":"<p>These tests have issues that need to be addressed in future iterations:</p> <ol> <li>test_sync_cross_thread_injection - Thread ID comparison issue</li> <li>test_sync_resource_contention - Timeout configuration needs adjustment</li> <li>test_async_concurrent_factory_calls - Async factory handling needs fix</li> <li>test_async_thread_pool_injection - ThreadPoolExecutor integration issue</li> <li>test_async_cascading_dependencies - Race condition in dependency creation</li> <li>test_async_timeout_handling - Timeout mechanism not working as expected</li> <li>test_async_task_cancellation - Task cancellation not being detected</li> <li>test_async_semaphore_integration - Semaphore timing issue</li> <li>test_async_exception_chaining - Exception type propagation issue</li> </ol>"},{"location":"testing/THREADING_TESTS_SUMMARY/#key-testing-scenarios-covered","title":"Key Testing Scenarios Covered","text":""},{"location":"testing/THREADING_TESTS_SUMMARY/#race-condition-testing","title":"Race Condition Testing","text":"<ul> <li>\u2705 Singleton vs Transient scope behavior under concurrent access</li> <li>\u2705 Concurrent binding and resolution operations</li> <li>\u2705 Scope clearing while other threads are resolving</li> <li>\u2705 Factory function calls under high contention</li> </ul>"},{"location":"testing/THREADING_TESTS_SUMMARY/#cross-thread-injection","title":"Cross-Thread Injection","text":"<ul> <li>\u2705 Shared singleton instances across threads</li> <li>\u2705 Thread-local state management</li> <li>\u2705 Data storage and retrieval across threads</li> <li>\u2705 Dependency modification across threads</li> </ul>"},{"location":"testing/THREADING_TESTS_SUMMARY/#thread-safety-components","title":"Thread Safety Components","text":"<ul> <li>\u2705 AsyncSafeCounter - Thread-safe counter with hybrid locking</li> <li>\u2705 ThreadSafeDict - Thread-safe dictionary operations</li> <li>\u2705 HybridLock - Works with both sync and async contexts</li> <li>\u2705 Thread-safe container operations</li> </ul>"},{"location":"testing/THREADING_TESTS_SUMMARY/#error-handling","title":"Error Handling","text":"<ul> <li>\u2705 Circular dependency detection in threaded environment</li> <li>\u2705 Failed injection handling across threads</li> <li>\u2705 Exception propagation in async contexts</li> <li>\u2705 Memory cleanup and resource management</li> </ul>"},{"location":"testing/THREADING_TESTS_SUMMARY/#performance-testing","title":"Performance Testing","text":"<ul> <li>\u2705 Container performance under heavy concurrent load (2000+ operations)</li> <li>\u2705 Lock contention and throughput testing</li> <li>\u2705 Memory pressure testing</li> <li>\u2705 Async operation scalability</li> </ul>"},{"location":"testing/THREADING_TESTS_SUMMARY/#async-specific-testing","title":"Async-Specific Testing","text":"<ul> <li>\u2705 Event loop integration</li> <li>\u2705 Mixed sync/async contexts</li> <li>\u2705 Concurrent coroutine execution</li> <li>\u2705 Resource cleanup in async environments</li> </ul>"},{"location":"testing/THREADING_TESTS_SUMMARY/#test-architecture","title":"Test Architecture","text":""},{"location":"testing/THREADING_TESTS_SUMMARY/#service-classes-used","title":"Service Classes Used","text":"<ul> <li>CounterService - Basic service with thread ID tracking</li> <li>ThreadSafeCounterService - Thread-safe version with internal locking</li> <li>DataService - Service for key-value storage and retrieval</li> <li>DependentService - Service with dependencies for injection testing</li> <li>AsyncDependentService - Async service with async operations</li> <li>FailingService - Service that intentionally fails for error testing</li> </ul>"},{"location":"testing/THREADING_TESTS_SUMMARY/#testing-patterns","title":"Testing Patterns","text":"<ol> <li>Concurrent Execution - Multiple threads/coroutines executing simultaneously</li> <li>Sequential Dependencies - Operations that must happen in order</li> <li>Resource Contention - Limited resources accessed by multiple threads</li> <li>State Sharing - Shared state modification and verification</li> <li>Error Injection - Intentional failures to test error handling</li> </ol>"},{"location":"testing/THREADING_TESTS_SUMMARY/#coverage-statistics","title":"Coverage Statistics","text":"<p>The test suite provides comprehensive coverage of: - Thread safety mechanisms in InjectQ core - Race condition scenarios in dependency injection - Cross-thread communication patterns - Async/await integration with threading - Performance characteristics under load - Error handling in concurrent environments</p>"},{"location":"testing/THREADING_TESTS_SUMMARY/#recommendations","title":"Recommendations","text":"<ol> <li>Fix the 9 failing tests to achieve 100% test coverage</li> <li>Add more edge case scenarios for corner cases</li> <li>Performance benchmarking integration for regression testing</li> <li>Stress testing with higher thread counts and longer durations</li> <li>Memory leak detection with longer-running tests</li> </ol> <p>This test suite serves as a robust foundation for ensuring InjectQ's thread safety and reliability in concurrent applications.</p>"},{"location":"testing/integration-testing/","title":"Integration Testing","text":"<p>Integration testing verifies that different parts of the system work together correctly, testing real implementations with minimal mocking.</p>"},{"location":"testing/integration-testing/#integration-testing-overview","title":"\ud83c\udfaf Integration Testing Overview","text":""},{"location":"testing/integration-testing/#what-is-integration-testing","title":"What is Integration Testing?","text":"<p>Integration testing focuses on testing the interaction between components, using real implementations wherever possible and mocking only external dependencies.</p> <pre><code># Unit Test - Isolated components\ndef test_calculator_unit(container):\n    # Mock all dependencies\n    container.bind_mock(ITaxCalculator)\n    container.bind_mock(IDiscountService)\n\n    calculator = container.get(PriceCalculator)\n    result = calculator.calculate_total(items)\n\n    assert result == expected_total\n\n# Integration Test - Real components working together\ndef test_calculator_integration(container):\n    # Use real implementations\n    container.bind(ITaxCalculator, TaxCalculator())\n    container.bind(IDiscountService, DiscountService())\n\n    # Mock only external services\n    container.bind_mock(IPaymentGateway)  # External API\n\n    calculator = container.get(PriceCalculator)\n    result = calculator.calculate_total(items)\n\n    # Test real business logic integration\n    assert result.total == expected_total\n    assert result.tax_amount == expected_tax\n    assert result.discount_amount == expected_discount\n</code></pre>"},{"location":"testing/integration-testing/#setting-up-integration-tests","title":"\ud83d\udd27 Setting Up Integration Tests","text":""},{"location":"testing/integration-testing/#integration-test-container","title":"Integration Test Container","text":"<pre><code>from injectq.testing import TestContainer\n\n@pytest.fixture\ndef integration_container():\n    \"\"\"Container for integration tests with real implementations.\"\"\"\n    container = TestContainer()\n\n    # Real business logic services\n    container.bind(IUserService, UserService())\n    container.bind(IOrderService, OrderService())\n    container.bind(IPriceCalculator, PriceCalculator())\n\n    # Real infrastructure (but test versions)\n    container.bind(IDatabase, TestDatabase())\n    container.bind(ICache, TestRedisCache())\n\n    # Mock external dependencies\n    container.bind_mock(IEmailService)      # External email API\n    container.bind_mock(IPaymentGateway)    # External payment API\n    container.bind_mock(ISMSService)        # External SMS API\n\n    return container\n\n@pytest.fixture\ndef real_container():\n    \"\"\"Container with completely real implementations.\"\"\"\n    container = InjectQ()\n\n    # All real implementations\n    container.install(DatabaseModule())\n    container.install(CacheModule())\n    container.install(BusinessLogicModule())\n\n    return container\n</code></pre>"},{"location":"testing/integration-testing/#test-database-setup","title":"Test Database Setup","text":"<pre><code>class TestPostgresDatabase(IDatabase):\n    \"\"\"Test database that uses real PostgreSQL but isolated schema.\"\"\"\n    def __init__(self):\n        self.schema_name = f\"test_{uuid.uuid4().hex[:8]}\"\n        self.connection_string = f\"postgresql://test:test@localhost:5432/testdb\"\n\n    async def initialize(self):\n        \"\"\"Create isolated test schema.\"\"\"\n        async with self.get_connection() as conn:\n            await conn.execute(f\"CREATE SCHEMA {self.schema_name}\")\n            await conn.execute(f\"SET search_path TO {self.schema_name}\")\n\n            # Run migrations for test schema\n            await self.run_migrations()\n\n    async def cleanup(self):\n        \"\"\"Drop test schema.\"\"\"\n        async with self.get_connection() as conn:\n            await conn.execute(f\"DROP SCHEMA {self.schema_name} CASCADE\")\n\n    async def get_connection(self):\n        return await asyncpg.connect(self.connection_string)\n\n@pytest.fixture\nasync def test_db():\n    \"\"\"Test database with isolated schema.\"\"\"\n    db = TestPostgresDatabase()\n    await db.initialize()\n\n    try:\n        yield db\n    finally:\n        await db.cleanup()\n</code></pre>"},{"location":"testing/integration-testing/#test-infrastructure","title":"Test Infrastructure","text":"<pre><code>class TestRedisCache(ICache):\n    \"\"\"Test cache using real Redis but isolated namespace.\"\"\"\n    def __init__(self):\n        self.redis = redis.Redis(host=\"localhost\", port=6379, db=1)\n        self.namespace = f\"test:{uuid.uuid4().hex[:8]}\"\n\n    def make_key(self, key: str) -&gt; str:\n        return f\"{self.namespace}:{key}\"\n\n    async def get(self, key: str) -&gt; Any:\n        redis_key = self.make_key(key)\n        value = self.redis.get(redis_key)\n        return json.loads(value) if value else None\n\n    async def set(self, key: str, value: Any, ttl: int = None) -&gt; None:\n        redis_key = self.make_key(key)\n        json_value = json.dumps(value)\n\n        if ttl:\n            self.redis.setex(redis_key, ttl, json_value)\n        else:\n            self.redis.set(redis_key, json_value)\n\n    async def delete(self, key: str) -&gt; bool:\n        redis_key = self.make_key(key)\n        return bool(self.redis.delete(redis_key))\n\n    async def clear(self):\n        \"\"\"Clear all test cache entries.\"\"\"\n        keys = self.redis.keys(f\"{self.namespace}:*\")\n        if keys:\n            self.redis.delete(*keys)\n</code></pre>"},{"location":"testing/integration-testing/#integration-test-patterns","title":"\ud83c\udfa8 Integration Test Patterns","text":""},{"location":"testing/integration-testing/#service-integration-testing","title":"Service Integration Testing","text":"<pre><code>def test_user_registration_integration(integration_container):\n    \"\"\"Test complete user registration workflow.\"\"\"\n    user_service = integration_container.get(IUserService)\n    email_mock = integration_container.get_mock(IEmailService)\n\n    # Register user\n    user = user_service.register_user(\n        email=\"john@example.com\",\n        password=\"secure_password123\"\n    )\n\n    # Verify user was created\n    assert user.id is not None\n    assert user.email == \"john@example.com\"\n    assert user.is_active is True\n    assert user.created_at is not None\n\n    # Verify welcome email was sent\n    assert email_mock.call_count(\"send_welcome_email\") == 1\n    assert email_mock.was_called_with(\"send_welcome_email\", \"john@example.com\")\n\n    # Verify password was hashed\n    assert user.password_hash != \"secure_password123\"\n    assert user.password_hash.startswith(\"$2b$\")  # bcrypt hash\n\ndef test_order_processing_integration(integration_container):\n    \"\"\"Test complete order processing workflow.\"\"\"\n    # Setup test data\n    user_service = integration_container.get(IUserService)\n    order_service = integration_container.get(IOrderService)\n    payment_mock = integration_container.get_mock(IPaymentGateway)\n\n    # Configure payment mock for success\n    payment_mock.configure_return(\"charge_card\", \"txn_12345\")\n\n    # Create user\n    user = user_service.create_user(\"john@example.com\", \"password\")\n\n    # Create order\n    order = order_service.create_order(\n        user_id=user.id,\n        items=[\n            {\"product_id\": 1, \"quantity\": 2, \"price\": 25.00},\n            {\"product_id\": 2, \"quantity\": 1, \"price\": 15.00}\n        ]\n    )\n\n    # Verify order\n    assert order.id is not None\n    assert order.user_id == user.id\n    assert order.total == 65.00  # 2*25 + 1*15\n    assert order.status == \"pending\"\n\n    # Process payment\n    success = order_service.process_payment(order.id, \"tok_visa\")\n\n    # Verify payment processing\n    assert success is True\n    assert payment_mock.call_count(\"charge_card\") == 1\n\n    # Verify order status updated\n    updated_order = order_service.get_order(order.id)\n    assert updated_order.status == \"paid\"\n</code></pre>"},{"location":"testing/integration-testing/#cross-service-integration","title":"Cross-Service Integration","text":"<pre><code>def test_user_order_integration(integration_container):\n    \"\"\"Test integration between user and order services.\"\"\"\n    user_service = integration_container.get(IUserService)\n    order_service = integration_container.get(IOrderService)\n    email_mock = integration_container.get_mock(IEmailService)\n\n    # Create user\n    user = user_service.register_user(\"john@example.com\", \"password\")\n\n    # Create multiple orders\n    order1 = order_service.create_order(user.id, [{\"product_id\": 1, \"quantity\": 1}])\n    order2 = order_service.create_order(user.id, [{\"product_id\": 2, \"quantity\": 2}])\n\n    # Verify user-order relationship\n    user_orders = order_service.get_user_orders(user.id)\n    assert len(user_orders) == 2\n    assert order1.id in [o.id for o in user_orders]\n    assert order2.id in [o.id for o in user_orders]\n\n    # Test order notifications\n    order_service.send_order_notifications(order1.id)\n\n    # Verify notification was sent to correct email\n    assert email_mock.call_count(\"send_order_confirmation\") == 1\n    calls = email_mock.get_calls(\"send_order_confirmation\")\n    assert calls[0][\"args\"][0] == user.email\n</code></pre>"},{"location":"testing/integration-testing/#infrastructure-integration","title":"Infrastructure Integration","text":"<pre><code>def test_cache_database_integration(integration_container, test_db, test_cache):\n    \"\"\"Test integration between cache and database.\"\"\"\n    user_service = integration_container.get(IUserService)\n\n    # Create user (goes to database)\n    user = user_service.create_user(\"john@example.com\", \"password\")\n\n    # First retrieval (from database, then cached)\n    retrieved_user = user_service.get_user(user.id)\n    assert retrieved_user.email == \"john@example.com\"\n\n    # Second retrieval (from cache)\n    cached_user = user_service.get_user(user.id)\n    assert cached_user.email == \"john@example.com\"\n\n    # Verify cache was used\n    cache_key = f\"user:{user.id}\"\n    cached_data = test_cache.get(cache_key)\n    assert cached_data is not None\n    assert cached_data[\"email\"] == \"john@example.com\"\n\n    # Verify database was queried only once\n    # (This would require spy or additional monitoring)\n</code></pre>"},{"location":"testing/integration-testing/#advanced-integration-patterns","title":"\ud83e\uddea Advanced Integration Patterns","text":""},{"location":"testing/integration-testing/#end-to-end-workflow-testing","title":"End-to-End Workflow Testing","text":"<pre><code>def test_complete_user_journey(integration_container):\n    \"\"\"Test complete user journey from registration to order fulfillment.\"\"\"\n    # Services\n    user_service = integration_container.get(IUserService)\n    order_service = integration_container.get(IOrderService)\n    inventory_service = integration_container.get(IInventoryService)\n    shipping_service = integration_container.get(IShippingService)\n\n    # Mocks\n    payment_mock = integration_container.get_mock(IPaymentGateway)\n    email_mock = integration_container.get_mock(IEmailService)\n    shipping_mock = integration_container.get_mock(IShippingProvider)\n\n    # Configure mocks\n    payment_mock.configure_return(\"charge_card\", \"txn_success\")\n    shipping_mock.configure_return(\"create_shipment\", \"ship_123\")\n\n    # Step 1: User registration\n    user = user_service.register_user(\"john@example.com\", \"password\")\n    assert user.is_active is True\n    assert email_mock.call_count(\"send_welcome_email\") == 1\n\n    # Step 2: Browse and add to cart\n    products = inventory_service.get_available_products()\n    assert len(products) &gt; 0\n\n    cart = order_service.create_cart(user.id)\n    order_service.add_to_cart(cart.id, products[0].id, 2)\n\n    # Step 3: Checkout\n    order = order_service.checkout_cart(cart.id, \"tok_visa\")\n\n    # Verify order creation\n    assert order.status == \"pending\"\n    assert order.total &gt; 0\n\n    # Step 4: Payment processing\n    payment_result = order_service.process_payment(order.id, \"tok_visa\")\n    assert payment_result.success is True\n    assert order_service.get_order(order.id).status == \"paid\"\n\n    # Step 5: Inventory update\n    inventory_service.reserve_items(order.id, order.items)\n    for item in order.items:\n        stock = inventory_service.get_stock(item.product_id)\n        assert stock.reserved &gt;= item.quantity\n\n    # Step 6: Shipping\n    shipment = shipping_service.create_shipment(order.id)\n    assert shipment.tracking_number == \"ship_123\"\n    assert order_service.get_order(order.id).status == \"shipped\"\n\n    # Step 7: Order completion\n    order_service.mark_order_delivered(order.id)\n    final_order = order_service.get_order(order.id)\n    assert final_order.status == \"delivered\"\n\n    # Verify all communications sent\n    assert email_mock.call_count(\"send_order_confirmation\") == 1\n    assert email_mock.call_count(\"send_shipping_notification\") == 1\n    assert email_mock.call_count(\"send_delivery_notification\") == 1\n</code></pre>"},{"location":"testing/integration-testing/#data-consistency-testing","title":"Data Consistency Testing","text":"<pre><code>def test_transaction_consistency(integration_container, test_db):\n    \"\"\"Test that operations maintain data consistency.\"\"\"\n    user_service = integration_container.get(IUserService)\n    order_service = integration_container.get(IOrderService)\n\n    # Start transaction\n    async with test_db.transaction():\n        # Create user\n        user = user_service.create_user(\"john@example.com\", \"password\")\n\n        # Create order\n        order = order_service.create_order(user.id, [{\"product_id\": 1, \"quantity\": 1}])\n\n        # Simulate failure after partial operations\n        if random.choice([True, False]):  # Random failure\n            raise Exception(\"Simulated failure\")\n\n    # After transaction, check consistency\n    # Either both operations succeeded or both failed\n    user_exists = user_service.get_user(user.id) is not None\n    order_exists = order_service.get_order(order.id) is not None\n\n    assert user_exists == order_exists, \"Data inconsistency detected!\"\n</code></pre>"},{"location":"testing/integration-testing/#performance-integration-testing","title":"Performance Integration Testing","text":"<pre><code>import time\n\ndef test_operation_performance(integration_container):\n    \"\"\"Test that operations complete within acceptable time.\"\"\"\n    user_service = integration_container.get(IUserService)\n\n    # Test user creation performance\n    start_time = time.time()\n\n    users = []\n    for i in range(100):  # Create 100 users\n        user = user_service.create_user(f\"user{i}@example.com\", \"password\")\n        users.append(user)\n\n    creation_time = time.time() - start_time\n\n    # Verify performance\n    assert creation_time &lt; 5.0, f\"User creation took {creation_time}s, expected &lt; 5.0s\"\n    assert len(users) == 100\n\n    # Test bulk retrieval performance\n    start_time = time.time()\n\n    retrieved_users = user_service.get_users_bulk([u.id for u in users])\n\n    retrieval_time = time.time() - start_time\n\n    # Verify retrieval performance\n    assert retrieval_time &lt; 2.0, f\"User retrieval took {retrieval_time}s, expected &lt; 2.0s\"\n    assert len(retrieved_users) == 100\n</code></pre>"},{"location":"testing/integration-testing/#integration-testing-challenges","title":"\ud83d\udea8 Integration Testing Challenges","text":""},{"location":"testing/integration-testing/#external-dependency-management","title":"External Dependency Management","text":"<pre><code># Challenge: External APIs can be slow/unreliable\ndef test_with_external_api_mocking(integration_container):\n    \"\"\"Test with mocked external dependencies.\"\"\"\n    # Mock slow external API\n    payment_mock = MockPaymentGateway()\n    payment_mock.configure_delay(\"charge_card\", 0.1)  # Fast mock\n\n    container.bind(IPaymentGateway, payment_mock)\n\n    order_service = container.get(IOrderService)\n\n    start_time = time.time()\n    result = order_service.process_payment(order_id, card_token)\n    duration = time.time() - start_time\n\n    # Verify fast execution\n    assert duration &lt; 0.2  # Much faster than real API\n    assert result.success is True\n\n# Challenge: External service failures\ndef test_external_service_failure_handling(integration_container):\n    \"\"\"Test handling of external service failures.\"\"\"\n    # Mock external API failure\n    email_mock = MockEmailService()\n    email_mock.configure_exception(\"send_email\", SMTPError(\"Service unavailable\"))\n\n    container.bind(IEmailService, email_mock)\n\n    notification_service = container.get(INotificationService)\n\n    # Should handle failure gracefully\n    result = notification_service.send_notification(user_id, message)\n\n    # Verify graceful degradation\n    assert result.partial_success is True\n    assert \"email_failed\" in result.errors\n    # But other notifications might have succeeded\n</code></pre>"},{"location":"testing/integration-testing/#test-data-management","title":"Test Data Management","text":"<pre><code>class TestDataManager:\n    \"\"\"Manages test data for integration tests.\"\"\"\n    def __init__(self, db: IDatabase):\n        self.db = db\n        self.created_users = []\n        self.created_orders = []\n\n    async def create_test_user(self, email: str = None) -&gt; User:\n        \"\"\"Create a test user with cleanup tracking.\"\"\"\n        if email is None:\n            email = f\"test_{uuid.uuid4().hex[:8]}@example.com\"\n\n        user = await self.db.create_user(email, \"test_password\")\n        self.created_users.append(user)\n        return user\n\n    async def create_test_order(self, user_id: int, items: List[dict] = None) -&gt; Order:\n        \"\"\"Create a test order with cleanup tracking.\"\"\"\n        if items is None:\n            items = [{\"product_id\": 1, \"quantity\": 1, \"price\": 10.00}]\n\n        order = await self.db.create_order(user_id, items)\n        self.created_orders.append(order)\n        return order\n\n    async def cleanup(self):\n        \"\"\"Clean up all created test data.\"\"\"\n        for order in self.created_orders:\n            await self.db.delete_order(order.id)\n\n        for user in self.created_users:\n            await self.db.delete_user(user.id)\n\n@pytest.fixture\nasync def test_data_manager(integration_container):\n    \"\"\"Test data manager with automatic cleanup.\"\"\"\n    db = integration_container.get(IDatabase)\n    manager = TestDataManager(db)\n\n    try:\n        yield manager\n    finally:\n        await manager.cleanup()\n</code></pre>"},{"location":"testing/integration-testing/#test-isolation","title":"Test Isolation","text":"<pre><code># Challenge: Tests affecting each other through shared state\ndef test_isolation_problem(integration_container):\n    \"\"\"Demonstrates isolation problem.\"\"\"\n    user_service = integration_container.get(IUserService)\n\n    # Test 1 creates user\n    user1 = user_service.create_user(\"shared@example.com\", \"password\")\n\n    # If another test runs here and deletes the user...\n\n    # Test 1 continues and fails\n    retrieved = user_service.get_user(user1.id)\n    assert retrieved is not None  # Might fail due to other test\n\n# Solution: Use unique test data\ndef test_with_isolation(integration_container):\n    \"\"\"Test with proper isolation.\"\"\"\n    user_service = integration_container.get(IUserService)\n\n    # Use unique email for this test\n    email = f\"test_{uuid.uuid4().hex[:8]}@example.com\"\n    user = user_service.create_user(email, \"password\")\n\n    # Test operations\n    retrieved = user_service.get_user(user.id)\n    assert retrieved.email == email\n\n    # Cleanup\n    user_service.delete_user(user.id)\n</code></pre>"},{"location":"testing/integration-testing/#integration-test-metrics","title":"\ud83d\udcca Integration Test Metrics","text":""},{"location":"testing/integration-testing/#test-coverage-metrics","title":"Test Coverage Metrics","text":"<pre><code>def measure_integration_coverage(integration_container):\n    \"\"\"Measure which code paths are covered by integration tests.\"\"\"\n    coverage = {}\n\n    # Track service method calls\n    services_to_track = [\n        (IUserService, \"user_operations\"),\n        (IOrderService, \"order_operations\"),\n        (IPaymentService, \"payment_operations\")\n    ]\n\n    for interface, category in services_to_track:\n        service = integration_container.get(interface)\n\n        # This would require instrumented services\n        coverage[category] = {\n            \"methods_called\": service._called_methods,\n            \"branches_covered\": service._covered_branches\n        }\n\n    return coverage\n</code></pre>"},{"location":"testing/integration-testing/#performance-benchmarks","title":"Performance Benchmarks","text":"<pre><code>def benchmark_integration_performance(integration_container):\n    \"\"\"Benchmark integration test performance.\"\"\"\n    user_service = integration_container.get(IUserService)\n\n    # Benchmark user creation\n    times = []\n    for _ in range(50):\n        start = time.time()\n        user = user_service.create_user(f\"bench_{uuid.uuid4().hex[:8]}@example.com\", \"pass\")\n        times.append(time.time() - start)\n\n    return {\n        \"avg_creation_time\": sum(times) / len(times),\n        \"min_creation_time\": min(times),\n        \"max_creation_time\": max(times),\n        \"p95_creation_time\": sorted(times)[int(len(times) * 0.95)]\n    }\n</code></pre>"},{"location":"testing/integration-testing/#integration-testing-best-practices","title":"\u2705 Integration Testing Best Practices","text":""},{"location":"testing/integration-testing/#1-test-real-integration-points","title":"1. Test Real Integration Points","text":"<pre><code># \u2705 Good: Test real service interactions\ndef test_real_service_integration(integration_container):\n    user_service = integration_container.get(IUserService)\n    order_service = integration_container.get(IOrderService)\n\n    # Create user through real service\n    user = user_service.create_user(\"john@example.com\", \"password\")\n\n    # Create order through real service\n    order = order_service.create_order(user.id, items)\n\n    # Verify real integration\n    assert order.user_id == user.id\n\n# \u274c Bad: Mock everything, no real integration\ndef test_no_real_integration(container):\n    container.bind_mock(IUserService)\n    container.bind_mock(IOrderService)\n\n    # No real integration being tested\n    user_mock = container.get_mock(IUserService)\n    order_mock = container.get_mock(IOrderService)\n\n    # Just testing mocks\n</code></pre>"},{"location":"testing/integration-testing/#2-use-appropriate-test-doubles","title":"2. Use Appropriate Test Doubles","text":"<pre><code># \u2705 Good: Mock external, use real internal\ndef test_mixed_dependencies(integration_container):\n    # Real internal services\n    container.bind(IUserService, UserService())\n    container.bind(IOrderService, OrderService())\n\n    # Mock external dependencies\n    container.bind_mock(IEmailService)      # External API\n    container.bind_mock(IPaymentGateway)    # External service\n\n# \u274c Bad: Mock internal services\ndef test_over_mocking(container):\n    # Mocking internal business logic defeats integration testing\n    container.bind_mock(IUserService)       # Internal service!\n    container.bind_mock(IOrderService)      # Internal service!\n    container.bind_mock(IPriceCalculator)   # Internal logic!\n</code></pre>"},{"location":"testing/integration-testing/#3-ensure-test-isolation","title":"3. Ensure Test Isolation","text":"<pre><code># \u2705 Good: Isolated test data\ndef test_with_unique_data(integration_container):\n    user_service = integration_container.get(IUserService)\n\n    # Unique email for this test\n    email = f\"test_{uuid.uuid4().hex[:8]}@example.com\"\n    user = user_service.create_user(email, \"password\")\n\n    # Test operations\n    assert user.email == email\n\n    # Cleanup\n    user_service.delete_user(user.id)\n\n# \u274c Bad: Shared test data\ndef test_with_shared_data(integration_container):\n    user_service = integration_container.get(IUserService)\n\n    # Same email for all tests - causes conflicts\n    user = user_service.create_user(\"shared@example.com\", \"password\")\n    # Other tests might interfere\n</code></pre>"},{"location":"testing/integration-testing/#4-test-failure-scenarios","title":"4. Test Failure Scenarios","text":"<pre><code># \u2705 Good: Test integration failure handling\ndef test_integration_failure_handling(integration_container):\n    # Setup failure scenario\n    payment_mock = integration_container.get_mock(IPaymentGateway)\n    payment_mock.configure_exception(\"charge_card\", PaymentError(\"Card declined\"))\n\n    order_service = integration_container.get(IOrderService)\n\n    # Test failure handling\n    with pytest.raises(OrderProcessingError):\n        order_service.process_payment(order_id, card_token)\n\n    # Verify failure handling\n    order = order_service.get_order(order_id)\n    assert order.status == \"payment_failed\"\n\n# \u2705 Test partial failures\ndef test_partial_failure_handling(integration_container):\n    # Setup partial failure\n    email_mock = integration_container.get_mock(IEmailService)\n    email_mock.configure_exception(\"send_email\", SMTPError(\"Temporary failure\"))\n\n    notification_service = integration_container.get(INotificationService)\n\n    # Should handle partial failure gracefully\n    result = notification_service.send_multiple_notifications(notifications)\n\n    assert result.total == len(notifications)\n    assert result.successful == len(notifications) - 1  # One failed\n    assert result.failed == 1\n</code></pre>"},{"location":"testing/integration-testing/#summary","title":"\ud83c\udfaf Summary","text":"<p>Integration testing verifies that system components work together correctly:</p> <ul> <li>Service integration - Test real service interactions</li> <li>Cross-service workflows - Test complete user journeys</li> <li>Infrastructure integration - Test with real databases and caches</li> <li>External dependency handling - Test with mocked external services</li> <li>Failure scenario testing - Test error handling and recovery</li> </ul> <p>Key principles: - Use real implementations for internal services - Mock only external dependencies - Ensure proper test isolation - Test complete workflows, not just individual methods - Include failure scenarios and error handling - Monitor performance and consistency</p> <p>Best practices: - Create dedicated integration test containers - Use test-specific databases and infrastructure - Implement proper test data management - Test both success and failure scenarios - Monitor test performance and coverage - Ensure tests are isolated and repeatable</p> <p>Ready to explore test scopes?</p>"},{"location":"testing/mocking-strategies/","title":"Mocking Strategies","text":"<p>Mocking strategies define different approaches to replacing real dependencies with test doubles during testing.</p>"},{"location":"testing/mocking-strategies/#mock-categories","title":"\ud83c\udfaf Mock Categories","text":""},{"location":"testing/mocking-strategies/#dummy-objects","title":"Dummy Objects","text":"<p>Dummy objects are passed around but never actually used. They are typically used to satisfy parameter requirements.</p> <pre><code>class DummyEmailService:\n    \"\"\"Dummy implementation that does nothing.\"\"\"\n    def send_welcome_email(self, email: str) -&gt; None:\n        pass\n\n    def send_password_reset(self, email: str, token: str) -&gt; None:\n        pass\n\ndef test_user_creation_with_dummy(container):\n    \"\"\"Test using dummy objects for unused dependencies.\"\"\"\n    # Bind dummy for dependency we don't care about\n    container.bind(IEmailService, DummyEmailService())\n\n    # Focus test on user creation logic\n    user_service = container.get(IUserService)\n    user = user_service.create_user(\"john@example.com\", \"password\")\n\n    # Only verify user creation\n    assert user.email == \"john@example.com\"\n    assert user.is_active is True\n</code></pre>"},{"location":"testing/mocking-strategies/#stubs","title":"Stubs","text":"<p>Stubs provide canned answers to calls made during the test, usually not responding at all to anything outside what's programmed in for the test.</p> <pre><code>class StubUserRepository:\n    \"\"\"Stub that returns predefined data.\"\"\"\n    def __init__(self):\n        self.users = {\n            1: User(id=1, email=\"existing@example.com\", is_active=True)\n        }\n\n    def get_user(self, user_id: int) -&gt; Optional[User]:\n        return self.users.get(user_id)\n\n    def save_user(self, user: User) -&gt; User:\n        # Always succeed for stub\n        user.id = len(self.users) + 1\n        self.users[user.id] = user\n        return user\n\n    def get_user_by_email(self, email: str) -&gt; Optional[User]:\n        return next((u for u in self.users.values() if u.email == email), None)\n\ndef test_email_uniqueness_check(container):\n    \"\"\"Test email uniqueness validation using stub.\"\"\"\n    stub_repo = StubUserRepository()\n    container.bind(IUserRepository, stub_repo)\n\n    user_service = container.get(IUserService)\n\n    # Test with existing email\n    with pytest.raises(EmailAlreadyExistsError):\n        user_service.create_user(\"existing@example.com\", \"password\")\n\n    # Test with new email\n    user = user_service.create_user(\"new@example.com\", \"password\")\n    assert user.email == \"new@example.com\"\n</code></pre>"},{"location":"testing/mocking-strategies/#mocks","title":"Mocks","text":"<p>Mocks are pre-programmed with expectations which form a specification of the calls they are expected to receive.</p> <pre><code>from injectq.testing import Mock\n\nclass MockEmailService(Mock[IEmailService]):\n    def __init__(self):\n        super().__init__()\n        self.sent_emails = []\n\n    def send_welcome_email(self, email: str) -&gt; None:\n        self.record_call(\"send_welcome_email\", email)\n        self.sent_emails.append({\n            \"type\": \"welcome\",\n            \"email\": email,\n            \"timestamp\": time.time()\n        })\n\n    def send_password_reset(self, email: str, token: str) -&gt; None:\n        self.record_call(\"send_password_reset\", email, token)\n        self.sent_emails.append({\n            \"type\": \"password_reset\",\n            \"email\": email,\n            \"token\": token,\n            \"timestamp\": time.time()\n        })\n\ndef test_registration_sends_welcome_email(container):\n    \"\"\"Test that registration sends welcome email.\"\"\"\n    mock_email = MockEmailService()\n    container.bind(IEmailService, mock_email)\n\n    user_service = container.get(IUserService)\n    user = user_service.register_user(\"john@example.com\", \"password\")\n\n    # Verify the behavior we care about\n    assert mock_email.call_count(\"send_welcome_email\") == 1\n    assert mock_email.was_called_with(\"send_welcome_email\", \"john@example.com\")\n    assert user.email == \"john@example.com\"\n</code></pre>"},{"location":"testing/mocking-strategies/#spies","title":"Spies","text":"<p>Spies are stubs that also record some information based on how they were called.</p> <pre><code>class SpyUserRepository(Mock[IUserRepository]):\n    \"\"\"Spy that records calls while delegating to real implementation.\"\"\"\n    def __init__(self, real_repo: IUserRepository):\n        super().__init__()\n        self.real_repo = real_repo\n        self.created_users = []\n        self.queried_users = []\n\n    def save_user(self, user: User) -&gt; User:\n        self.record_call(\"save_user\", user)\n\n        # Delegate to real implementation\n        saved_user = self.real_repo.save_user(user)\n        self.created_users.append(saved_user)\n\n        return saved_user\n\n    def get_user(self, user_id: int) -&gt; Optional[User]:\n        self.record_call(\"get_user\", user_id)\n\n        # Delegate to real implementation\n        user = self.real_repo.get_user(user_id)\n        if user:\n            self.queried_users.append(user)\n\n        return user\n\ndef test_user_operations_with_spy(container, test_db):\n    \"\"\"Test user operations using spy pattern.\"\"\"\n    real_repo = UserRepository(test_db)\n    spy_repo = SpyUserRepository(real_repo)\n    container.bind(IUserRepository, spy_repo)\n\n    user_service = container.get(IUserService)\n\n    # Create user\n    user = user_service.create_user(\"john@example.com\", \"password\")\n\n    # Retrieve user\n    retrieved_user = user_service.get_user(user.id)\n\n    # Verify spy recorded interactions\n    assert spy_repo.call_count(\"save_user\") == 1\n    assert spy_repo.call_count(\"get_user\") == 1\n    assert len(spy_repo.created_users) == 1\n    assert len(spy_repo.queried_users) == 1\n    assert spy_repo.created_users[0].id == user.id\n</code></pre>"},{"location":"testing/mocking-strategies/#fakes","title":"Fakes","text":"<p>Fakes are working implementations with simplified functionality, not suitable for production use.</p> <pre><code>class FakeDatabase:\n    \"\"\"Fake database using in-memory storage.\"\"\"\n    def __init__(self):\n        self.users = {}\n        self.orders = {}\n        self._next_user_id = 1\n        self._next_order_id = 1\n\n    def save_user(self, user: User) -&gt; User:\n        if user.id is None:\n            user.id = self._next_user_id\n            self._next_user_id += 1\n        self.users[user.id] = user\n        return user\n\n    def get_user(self, user_id: int) -&gt; Optional[User]:\n        return self.users.get(user_id)\n\n    def get_user_by_email(self, email: str) -&gt; Optional[User]:\n        return next((u for u in self.users.values() if u.email == email), None)\n\n    def save_order(self, order: Order) -&gt; Order:\n        if order.id is None:\n            order.id = self._next_order_id\n            self._next_order_id += 1\n        self.orders[order.id] = order\n        return order\n\n    def get_order(self, order_id: int) -&gt; Optional[Order]:\n        return self.orders.get(order_id)\n\n    def clear(self):\n        \"\"\"Clear all data for test isolation.\"\"\"\n        self.users.clear()\n        self.orders.clear()\n        self._next_user_id = 1\n        self._next_order_id = 1\n\ndef test_complete_workflow_with_fake(container):\n    \"\"\"Test complete workflow using fake database.\"\"\"\n    fake_db = FakeDatabase()\n    container.bind(IDatabase, fake_db)\n\n    # Test complete user journey\n    user_service = container.get(IUserService)\n    order_service = container.get(IOrderService)\n\n    # Create user\n    user = user_service.create_user(\"john@example.com\", \"password\")\n    assert user.id == 1\n\n    # Create order\n    order = order_service.create_order(user.id, [\"item1\", \"item2\"])\n    assert order.id == 1\n    assert order.user_id == user.id\n\n    # Verify data persistence\n    saved_user = fake_db.get_user(user.id)\n    saved_order = fake_db.get_order(order.id)\n    assert saved_user.email == \"john@example.com\"\n    assert saved_order.user_id == user.id\n</code></pre>"},{"location":"testing/mocking-strategies/#choosing-the-right-strategy","title":"\ud83c\udfa8 Choosing the Right Strategy","text":""},{"location":"testing/mocking-strategies/#when-to-use-each-type","title":"When to Use Each Type","text":""},{"location":"testing/mocking-strategies/#use-dummies-when","title":"Use Dummies When:","text":"<ul> <li>You need to satisfy constructor parameters</li> <li>The dependency won't be used in the test</li> <li>You want to keep the test focused</li> </ul> <pre><code>def test_business_logic_only(container):\n    \"\"\"Test focuses only on business logic.\"\"\"\n    # Dummy for unused dependency\n    container.bind(IExternalAPI, DummyExternalAPI())\n\n    calculator = container.get(PriceCalculator)\n    result = calculator.calculate(items)\n\n    assert result.total == expected_total\n</code></pre>"},{"location":"testing/mocking-strategies/#use-stubs-when","title":"Use Stubs When:","text":"<ul> <li>You need predictable responses</li> <li>You want to test specific scenarios</li> <li>The test doesn't care about side effects</li> </ul> <pre><code>def test_validation_with_stub(container):\n    \"\"\"Test validation with predictable data.\"\"\"\n    stub_repo = StubUserRepository()\n    container.bind(IUserRepository, stub_repo)\n\n    validator = container.get(EmailValidator)\n\n    # Test existing email\n    assert not validator.is_unique(\"existing@example.com\")\n\n    # Test new email\n    assert validator.is_unique(\"new@example.com\")\n</code></pre>"},{"location":"testing/mocking-strategies/#use-mocks-when","title":"Use Mocks When:","text":"<ul> <li>You need to verify interactions</li> <li>You want to ensure certain methods are called</li> <li>You need to check call arguments</li> </ul> <pre><code>def test_notification_sent_on_registration(container):\n    \"\"\"Test that notification is sent during registration.\"\"\"\n    mock_email = MockEmailService()\n    container.bind(IEmailService, mock_email)\n\n    user_service = container.get(IUserService)\n    user = user_service.register_user(\"john@example.com\", \"password\")\n\n    # Verify notification was sent\n    assert mock_email.call_count(\"send_welcome_email\") == 1\n    assert mock_email.was_called_with(\"send_welcome_email\", \"john@example.com\")\n</code></pre>"},{"location":"testing/mocking-strategies/#use-spies-when","title":"Use Spies When:","text":"<ul> <li>You want to verify interactions with real implementations</li> <li>You need both real behavior and call verification</li> <li>You're testing integration between components</li> </ul> <pre><code>def test_service_integration_with_spy(container, real_db):\n    \"\"\"Test service integration with spy verification.\"\"\"\n    real_repo = UserRepository(real_db)\n    spy_repo = SpyUserRepository(real_repo)\n    container.bind(IUserRepository, spy_repo)\n\n    user_service = container.get(IUserService)\n    user = user_service.create_user(\"john@example.com\", \"password\")\n\n    # Verify real database operation occurred\n    assert user.id is not None\n\n    # Verify spy recorded the interaction\n    assert spy_repo.call_count(\"save_user\") == 1\n</code></pre>"},{"location":"testing/mocking-strategies/#use-fakes-when","title":"Use Fakes When:","text":"<ul> <li>You need realistic behavior for integration tests</li> <li>You want to test against a real interface</li> <li>Performance is important for test execution</li> </ul> <pre><code>def test_workflow_integration(container):\n    \"\"\"Test complete workflow with fake implementations.\"\"\"\n    container.bind(IDatabase, FakeDatabase())\n    container.bind(ICache, FakeCache())\n\n    # Test complete user journey\n    workflow = container.get(UserRegistrationWorkflow)\n    result = workflow.register_and_setup_user(\"john@example.com\", \"password\")\n\n    assert result.success is True\n    assert result.user.email == \"john@example.com\"\n    assert result.setup_complete is True\n</code></pre>"},{"location":"testing/mocking-strategies/#advanced-mocking-patterns","title":"\ud83d\udd27 Advanced Mocking Patterns","text":""},{"location":"testing/mocking-strategies/#partial-mocks","title":"Partial Mocks","text":"<pre><code>class PartialMockEmailService(Mock[IEmailService]):\n    \"\"\"Mock that delegates some calls to real implementation.\"\"\"\n    def __init__(self, real_service: IEmailService):\n        super().__init__()\n        self.real_service = real_service\n\n    def send_welcome_email(self, email: str) -&gt; None:\n        # Use real implementation for this method\n        self.real_service.send_welcome_email(email)\n\n    def send_password_reset(self, email: str, token: str) -&gt; None:\n        # Mock this method\n        self.record_call(\"send_password_reset\", email, token)\n\ndef test_partial_mock_usage(container):\n    \"\"\"Test using partial mock for selective mocking.\"\"\"\n    real_email = RealEmailService()\n    partial_mock = PartialMockEmailService(real_email)\n    container.bind(IEmailService, partial_mock)\n\n    user_service = container.get(IUserService)\n\n    # Welcome email uses real service\n    user_service.register_user(\"john@example.com\", \"password\")\n\n    # Password reset uses mock\n    user_service.reset_password(\"john@example.com\")\n\n    # Verify only password reset was mocked\n    assert partial_mock.call_count(\"send_password_reset\") == 1\n    assert partial_mock.call_count(\"send_welcome_email\") == 0\n</code></pre>"},{"location":"testing/mocking-strategies/#chain-of-mocks","title":"Chain of Mocks","text":"<pre><code>class MockPaymentService(Mock[IPaymentService]):\n    def __init__(self):\n        super().__init__()\n        self.authorized_payments = set()\n\n    def authorize_payment(self, amount: float, card: str) -&gt; str:\n        self.record_call(\"authorize_payment\", amount, card)\n\n        # Generate mock authorization code\n        auth_code = f\"auth_{len(self.authorized_payments)}\"\n        self.authorized_payments.add(auth_code)\n\n        return auth_code\n\n    def capture_payment(self, auth_code: str, amount: float) -&gt; bool:\n        self.record_call(\"capture_payment\", auth_code, amount)\n\n        if auth_code in self.authorized_payments:\n            self.authorized_payments.remove(auth_code)\n            return True\n        return False\n\ndef test_payment_workflow(container):\n    \"\"\"Test payment workflow with chained operations.\"\"\"\n    mock_payment = MockPaymentService()\n    container.bind(IPaymentService, mock_payment)\n\n    payment_service = container.get(IPaymentService)\n\n    # Authorize payment\n    auth_code = payment_service.authorize_payment(100.0, \"4111111111111111\")\n    assert auth_code.startswith(\"auth_\")\n\n    # Capture payment\n    success = payment_service.capture_payment(auth_code, 100.0)\n    assert success is True\n\n    # Verify call chain\n    assert mock_payment.call_count(\"authorize_payment\") == 1\n    assert mock_payment.call_count(\"capture_payment\") == 1\n</code></pre>"},{"location":"testing/mocking-strategies/#mock-factories","title":"Mock Factories","text":"<pre><code>class MockFactory:\n    \"\"\"Factory for creating configured mocks.\"\"\"\n    @staticmethod\n    def create_email_service(fail_on_send: bool = False) -&gt; MockEmailService:\n        mock = MockEmailService()\n        if fail_on_send:\n            mock.configure_exception(\"send_welcome_email\", SMTPError(\"Connection failed\"))\n        return mock\n\n    @staticmethod\n    def create_user_repository(users: List[User] = None) -&gt; StubUserRepository:\n        stub = StubUserRepository()\n        if users:\n            for user in users:\n                stub.users[user.id] = user\n        return stub\n\n    @staticmethod\n    def create_database(initial_data: dict = None) -&gt; FakeDatabase:\n        fake = FakeDatabase()\n        if initial_data:\n            fake.users.update(initial_data.get(\"users\", {}))\n            fake.orders.update(initial_data.get(\"orders\", {}))\n        return fake\n\ndef test_with_factory_mocks(container):\n    \"\"\"Test using mock factory for consistent setup.\"\"\"\n    # Create configured mocks\n    email_mock = MockFactory.create_email_service()\n    user_repo = MockFactory.create_user_repository([\n        User(id=1, email=\"existing@example.com\", is_active=True)\n    ])\n\n    container.bind(IEmailService, email_mock)\n    container.bind(IUserRepository, user_repo)\n\n    user_service = container.get(IUserService)\n\n    # Test with pre-configured state\n    with pytest.raises(EmailAlreadyExistsError):\n        user_service.create_user(\"existing@example.com\", \"password\")\n</code></pre>"},{"location":"testing/mocking-strategies/#common-mocking-mistakes","title":"\ud83d\udea8 Common Mocking Mistakes","text":""},{"location":"testing/mocking-strategies/#over-mocking","title":"\u274c Over-Mocking","text":"<pre><code># Bad: Mocking everything\ndef test_with_too_many_mocks(container):\n    container.bind_mock(IUserService)\n    container.bind_mock(IEmailService)\n    container.bind_mock(IValidator)\n    container.bind_mock(IPasswordHasher)\n    container.bind_mock(ILogger)\n    # Test becomes meaningless\n\n# Good: Mock only external dependencies\ndef test_focused_test(container):\n    # Mock external services only\n    container.bind_mock(IEmailService)  # External API\n    container.bind_mock(IPaymentService)  # External payment\n\n    # Use real implementations for business logic\n    # Test focuses on actual behavior\n</code></pre>"},{"location":"testing/mocking-strategies/#mocking-internal-logic","title":"\u274c Mocking Internal Logic","text":"<pre><code># Bad: Mocking internal business logic\ndef test_internal_logic_mock(container):\n    mock_calculator = MockPriceCalculator()\n    mock_calculator.configure_return(\"calculate_tax\", 10.0)\n    container.bind(IPriceCalculator, mock_calculator)\n\n    service = container.get(OrderService)\n    total = service.calculate_total(order)\n\n    # Test is testing the mock, not real logic\n    assert total == 110.0  # Based on mock return\n\n# Good: Test real business logic\ndef test_real_business_logic(container):\n    # Use real calculator\n    container.bind(IPriceCalculator, PriceCalculator())\n\n    # Mock only external dependencies\n    container.bind_mock(ITaxService)  # External tax API\n\n    service = container.get(OrderService)\n    total = service.calculate_total(order)\n\n    # Test is testing real calculation logic\n    assert total == expected_total\n</code></pre>"},{"location":"testing/mocking-strategies/#ignoring-mock-configuration","title":"\u274c Ignoring Mock Configuration","text":"<pre><code># Bad: Mock not configured for test scenario\ndef test_unconfigured_mock(container):\n    mock_repo = MockUserRepository()\n    # Forgot to configure for \"user not found\" scenario\n    container.bind(IUserRepository, mock_repo)\n\n    service = container.get(UserService)\n\n    # Test expects user not found, but mock returns None by default\n    user = service.get_user(999)\n    assert user is None  # This might fail if mock not configured\n\n# Good: Properly configure mock for scenario\ndef test_configured_mock(container):\n    mock_repo = MockUserRepository()\n    mock_repo.configure_return(\"get_user\", None)  # Explicitly configure\n    container.bind(IUserRepository, mock_repo)\n\n    service = container.get(UserService)\n    user = service.get_user(999)\n    assert user is None\n</code></pre>"},{"location":"testing/mocking-strategies/#mocking-best-practices","title":"\ud83d\udcca Mocking Best Practices","text":""},{"location":"testing/mocking-strategies/#1-mock-external-dependencies-only","title":"1. Mock External Dependencies Only","text":"<pre><code># \u2705 Good: Mock external services\ncontainer.bind_mock(IEmailService)      # External API\ncontainer.bind_mock(IPaymentGateway)    # External payment\ncontainer.bind_mock(ISMSService)        # External SMS\n\n# \u2705 Use real implementations for business logic\ncontainer.bind(IPriceCalculator, PriceCalculator())  # Real business logic\ncontainer.bind(IOrderValidator, OrderValidator())    # Real validation\n</code></pre>"},{"location":"testing/mocking-strategies/#2-use-appropriate-mock-types","title":"2. Use Appropriate Mock Types","text":"<pre><code># \u2705 Use stubs for predictable data\ncontainer.bind(IUserRepository, StubUserRepository())\n\n# \u2705 Use mocks for interaction verification\ncontainer.bind(IEmailService, MockEmailService())\n\n# \u2705 Use fakes for realistic behavior\ncontainer.bind(IDatabase, FakeDatabase())\n\n# \u2705 Use spies for integration testing\ncontainer.bind(IUserRepository, SpyUserRepository(real_repo))\n</code></pre>"},{"location":"testing/mocking-strategies/#3-configure-mocks-explicitly","title":"3. Configure Mocks Explicitly","text":"<pre><code># \u2705 Explicit mock configuration\nmock_email = MockEmailService()\nmock_email.configure_return(\"send_welcome_email\", None)\nmock_email.configure_exception(\"send_password_reset\", SMTPError())\ncontainer.bind(IEmailService, mock_email)\n\n# \u2705 Clear mock configuration between tests\n@pytest.fixture\ndef configured_mock():\n    mock = MockEmailService()\n    mock.configure_return(\"send_welcome_email\", None)\n    return mock\n</code></pre>"},{"location":"testing/mocking-strategies/#4-verify-important-interactions","title":"4. Verify Important Interactions","text":"<pre><code># \u2705 Verify critical interactions\ndef test_payment_processing(container):\n    mock_payment = MockPaymentService()\n    container.bind(IPaymentService, mock_payment)\n\n    order_service = container.get(IOrderService)\n    order_service.process_payment(order)\n\n    # Verify payment was processed\n    assert mock_payment.call_count(\"charge_card\") == 1\n    assert mock_payment.was_called_with(\"charge_card\", order.total, order.card_token)\n\n# \u2705 Don't verify unimportant details\ndef test_user_creation(container):\n    mock_email = MockEmailService()\n    container.bind(IEmailService, mock_email)\n\n    user_service = container.get(IUserService)\n    user = user_service.create_user(\"john@example.com\", \"password\")\n\n    # Verify result, not email sending details\n    assert user.email == \"john@example.com\"\n    # Don't check email template or exact timing\n</code></pre>"},{"location":"testing/mocking-strategies/#5-keep-mocks-simple","title":"5. Keep Mocks Simple","text":"<pre><code># \u2705 Simple, focused mock\nclass SimpleMockEmailService(Mock[IEmailService]):\n    def send_welcome_email(self, email: str) -&gt; None:\n        self.record_call(\"send_welcome_email\", email)\n\n# \u274c Complex mock with too much logic\nclass ComplexMockEmailService(Mock[IEmailService]):\n    def __init__(self):\n        self.templates = {}\n        self.queue = []\n        self.retry_count = 3\n        self.timeout = 30\n        # ... lots of configuration\n\n    def send_welcome_email(self, email: str) -&gt; None:\n        # Complex logic that might have bugs\n        if self.should_retry:\n            for i in range(self.retry_count):\n                try:\n                    self._send_with_template(email, \"welcome\")\n                    break\n                except Exception:\n                    if i == self.retry_count - 1:\n                        raise\n        # ... more complex logic\n</code></pre>"},{"location":"testing/mocking-strategies/#summary","title":"\ud83c\udfaf Summary","text":"<p>Mocking strategies provide different ways to replace dependencies:</p> <ul> <li>Dummies - Satisfy parameters, never used</li> <li>Stubs - Provide canned responses</li> <li>Mocks - Verify interactions and expectations</li> <li>Spies - Record calls while using real implementations</li> <li>Fakes - Working implementations with simplified behavior</li> </ul> <p>Key principles: - Choose the right strategy for each test scenario - Mock external dependencies, use real business logic - Configure mocks explicitly for test scenarios - Verify important interactions, not implementation details - Keep mocks simple and focused - Use factories for consistent mock creation</p> <p>Best practices: - Use dummies for unused dependencies - Use stubs for predictable test data - Use mocks for interaction verification - Use spies for integration testing - Use fakes for realistic behavior - Avoid over-mocking and complex mock logic</p> <p>Ready to explore override patterns?</p>"},{"location":"testing/override-patterns/","title":"Override Patterns","text":"<p>Override patterns provide ways to temporarily replace service implementations during testing or runtime configuration.</p>"},{"location":"testing/override-patterns/#basic-override","title":"\ud83c\udfaf Basic Override","text":""},{"location":"testing/override-patterns/#simple-override","title":"Simple Override","text":"<pre><code>def test_with_simple_override(container):\n    \"\"\"Test with simple service override.\"\"\"\n    # Setup original service\n    container.bind(IEmailService, RealEmailService())\n\n    # Verify original\n    service = container.get(IEmailService)\n    assert isinstance(service, RealEmailService)\n\n    # Override with mock\n    container.bind(IEmailService, MockEmailService())\n\n    # Verify override\n    service = container.get(IEmailService)\n    assert isinstance(service, MockEmailService)\n\n    # Override is permanent for this container\n    service2 = container.get(IEmailService)\n    assert isinstance(service2, MockEmailService)\n</code></pre>"},{"location":"testing/override-patterns/#context-manager-override","title":"Context Manager Override","text":"<pre><code>def test_with_context_override(container):\n    \"\"\"Test with temporary override using context manager.\"\"\"\n    # Setup original service\n    container.bind(IEmailService, RealEmailService())\n\n    # Verify original\n    service = container.get(IEmailService)\n    assert isinstance(service, RealEmailService)\n\n    # Temporary override\n    with container.override(IEmailService, MockEmailService()) as mock:\n        # Inside context: mock is active\n        service = container.get(IEmailService)\n        assert isinstance(service, MockEmailService)\n\n        # Use the mock\n        user_service = container.get(IUserService)\n        user_service.register_user(\"john@example.com\", \"password\")\n\n        # Verify mock was used\n        assert mock.call_count(\"send_welcome_email\") == 1\n\n    # Outside context: back to original\n    service = container.get(IEmailService)\n    assert isinstance(service, RealEmailService)\n</code></pre>"},{"location":"testing/override-patterns/#advanced-override-patterns","title":"\ud83d\udd27 Advanced Override Patterns","text":""},{"location":"testing/override-patterns/#nested-overrides","title":"Nested Overrides","text":"<pre><code>def test_nested_overrides(container):\n    \"\"\"Test multiple levels of overrides.\"\"\"\n    container.bind(IEmailService, RealEmailService())\n    container.bind(IUserService, RealUserService())\n\n    # First level override\n    with container.override(IEmailService, MockEmailService()) as email_mock:\n        assert isinstance(container.get(IEmailService), MockEmailService)\n        assert isinstance(container.get(IUserService), RealUserService)\n\n        # Second level override\n        with container.override(IUserService, MockUserService()) as user_mock:\n            assert isinstance(container.get(IEmailService), MockEmailService)\n            assert isinstance(container.get(IUserService), MockUserService)\n\n            # Both services are mocked\n            notification_svc = container.get(INotificationService)\n            notification_svc.send_user_notification(123)\n\n            # Verify both mocks were called\n            assert email_mock.call_count(\"send_email\") == 1\n            assert user_mock.call_count(\"get_user\") == 1\n\n        # Back to first level\n        assert isinstance(container.get(IEmailService), MockEmailService)\n        assert isinstance(container.get(IUserService), RealUserService)\n\n    # Back to original\n    assert isinstance(container.get(IEmailService), RealEmailService)\n    assert isinstance(container.get(IUserService), RealUserService)\n</code></pre>"},{"location":"testing/override-patterns/#conditional-overrides","title":"Conditional Overrides","text":"<pre><code>def test_conditional_override(container):\n    \"\"\"Override services based on conditions.\"\"\"\n    container.bind(IEmailService, RealEmailService())\n\n    # Override based on environment\n    if os.getenv(\"USE_MOCK_EMAIL\", \"false\").lower() == \"true\":\n        container.bind(IEmailService, MockEmailService())\n\n    # Override based on test scenario\n    test_scenario = os.getenv(\"TEST_SCENARIO\", \"normal\")\n\n    if test_scenario == \"email_failure\":\n        container.bind(IEmailService, FailingEmailService())\n    elif test_scenario == \"slow_email\":\n        container.bind(IEmailService, SlowEmailService())\n\n    # Test runs with appropriate service\n    email_service = container.get(IEmailService)\n\n    if test_scenario == \"email_failure\":\n        assert isinstance(email_service, FailingEmailService)\n    elif test_scenario == \"slow_email\":\n        assert isinstance(email_service, SlowEmailService)\n    else:\n        assert isinstance(email_service, RealEmailService)\n</code></pre>"},{"location":"testing/override-patterns/#partial-overrides","title":"Partial Overrides","text":"<pre><code>class PartialOverrideEmailService(RealEmailService):\n    \"\"\"Service that overrides only specific methods.\"\"\"\n    def __init__(self, real_service: RealEmailService):\n        self.real_service = real_service\n        self.mocked_calls = []\n\n    def send_welcome_email(self, email: str) -&gt; None:\n        # Override this method\n        self.mocked_calls.append((\"send_welcome_email\", email))\n\n    def send_password_reset(self, email: str, token: str) -&gt; None:\n        # Use real implementation for this method\n        self.real_service.send_password_reset(email, token)\n\ndef test_partial_override(container):\n    \"\"\"Test with partial service override.\"\"\"\n    real_email = RealEmailService()\n    partial_override = PartialOverrideEmailService(real_email)\n    container.bind(IEmailService, partial_override)\n\n    user_service = container.get(IUserService)\n\n    # Welcome email uses override\n    user_service.register_user(\"john@example.com\", \"password\")\n\n    # Password reset uses real implementation\n    user_service.reset_password(\"john@example.com\")\n\n    # Verify partial override\n    assert len(partial_override.mocked_calls) == 1\n    assert partial_override.mocked_calls[0][0] == \"send_welcome_email\"\n</code></pre>"},{"location":"testing/override-patterns/#override-scenarios","title":"\ud83c\udfa8 Override Scenarios","text":""},{"location":"testing/override-patterns/#test-specific-overrides","title":"Test-Specific Overrides","text":"<pre><code>@pytest.fixture\ndef container():\n    return TestContainer()\n\ndef test_registration_success(container):\n    \"\"\"Test successful registration.\"\"\"\n    # Override with successful email service\n    container.bind(IEmailService, MockEmailService())\n\n    user_service = container.get(IUserService)\n    user = user_service.register_user(\"john@example.com\", \"password\")\n\n    assert user.email == \"john@example.com\"\n    assert user.is_active is True\n\ndef test_registration_email_failure(container):\n    \"\"\"Test registration with email failure.\"\"\"\n    # Override with failing email service\n    failing_email = MockEmailService()\n    failing_email.configure_exception(\"send_welcome_email\", SMTPError(\"Connection failed\"))\n    container.bind(IEmailService, failing_email)\n\n    user_service = container.get(IUserService)\n\n    # Should handle email failure gracefully\n    user = user_service.register_user(\"john@example.com\", \"password\")\n    assert user.email == \"john@example.com\"\n    # User should still be created even if email fails\n    assert user.is_active is True\n\ndef test_registration_duplicate_email(container):\n    \"\"\"Test registration with duplicate email.\"\"\"\n    # Override repository to return existing user\n    mock_repo = MockUserRepository()\n    mock_repo.configure_return(\"get_user_by_email\", User(id=1, email=\"john@example.com\"))\n    container.bind(IUserRepository, mock_repo)\n\n    user_service = container.get(IUserService)\n\n    with pytest.raises(EmailAlreadyExistsError):\n        user_service.register_user(\"john@example.com\", \"password\")\n</code></pre>"},{"location":"testing/override-patterns/#environment-based-overrides","title":"Environment-Based Overrides","text":"<pre><code>def create_container_for_environment(env: str) -&gt; InjectQ:\n    \"\"\"Create container with environment-specific overrides.\"\"\"\n    container = InjectQ()\n\n    # Base services\n    container.bind(IUserService, UserService())\n    container.bind(IOrderService, OrderService())\n\n    # Environment-specific overrides\n    if env == \"test\":\n        container.bind(IEmailService, MockEmailService())\n        container.bind(IPaymentService, MockPaymentService())\n        container.bind(IDatabase, FakeDatabase())\n\n    elif env == \"development\":\n        container.bind(IEmailService, ConsoleEmailService())  # Log to console\n        container.bind(IPaymentService, StripePaymentService())\n        container.bind(IDatabase, PostgresDatabase())\n\n    elif env == \"production\":\n        container.bind(IEmailService, SendGridEmailService())\n        container.bind(IPaymentService, StripePaymentService())\n        container.bind(IDatabase, PostgresDatabase())\n\n    return container\n\ndef test_environment_overrides():\n    \"\"\"Test different environments use correct services.\"\"\"\n    # Test environment\n    test_container = create_container_for_environment(\"test\")\n    assert isinstance(test_container.get(IEmailService), MockEmailService)\n    assert isinstance(test_container.get(IPaymentService), MockPaymentService)\n\n    # Development environment\n    dev_container = create_container_for_environment(\"development\")\n    assert isinstance(dev_container.get(IEmailService), ConsoleEmailService)\n    assert isinstance(dev_container.get(IPaymentService), StripePaymentService)\n</code></pre>"},{"location":"testing/override-patterns/#feature-flag-overrides","title":"Feature Flag Overrides","text":"<pre><code>class FeatureFlagContainer(InjectQ):\n    \"\"\"Container that supports feature flags.\"\"\"\n    def __init__(self):\n        super().__init__()\n        self.feature_flags = {}\n\n    def set_feature_flag(self, flag: str, enabled: bool):\n        self.feature_flags[flag] = enabled\n\n    def is_feature_enabled(self, flag: str) -&gt; bool:\n        return self.feature_flags.get(flag, False)\n\n    def bind_with_feature_flag(self, interface, implementation, feature_flag: str):\n        \"\"\"Bind service that may be overridden by feature flag.\"\"\"\n        if self.is_feature_enabled(feature_flag):\n            self.bind(interface, implementation)\n\ndef test_feature_flag_overrides():\n    \"\"\"Test feature flag-based service overrides.\"\"\"\n    container = FeatureFlagContainer()\n\n    # Base binding\n    container.bind(IEmailService, BasicEmailService())\n\n    # Feature flag override\n    container.set_feature_flag(\"advanced_email\", True)\n    container.bind_with_feature_flag(\n        IEmailService,\n        AdvancedEmailService(),\n        \"advanced_email\"\n    )\n\n    # Service should use advanced implementation\n    email_service = container.get(IEmailService)\n    assert isinstance(email_service, AdvancedEmailService)\n\n    # Disable feature flag\n    container.set_feature_flag(\"advanced_email\", False)\n    container.bind_with_feature_flag(\n        IEmailService,\n        BasicEmailService(),\n        \"advanced_email\"\n    )\n\n    # Service should use basic implementation\n    email_service = container.get(IEmailService)\n    assert isinstance(email_service, BasicEmailService)\n</code></pre>"},{"location":"testing/override-patterns/#dynamic-overrides","title":"\ud83d\udd04 Dynamic Overrides","text":""},{"location":"testing/override-patterns/#runtime-service-switching","title":"Runtime Service Switching","text":"<pre><code>class DynamicContainer(InjectQ):\n    \"\"\"Container that allows runtime service switching.\"\"\"\n    def __init__(self):\n        super().__init__()\n        self.service_versions = {}\n\n    def register_service_version(self, interface, implementation, version: str):\n        \"\"\"Register a version of a service.\"\"\"\n        if interface not in self.service_versions:\n            self.service_versions[interface] = {}\n        self.service_versions[interface][version] = implementation\n\n    def switch_service_version(self, interface, version: str):\n        \"\"\"Switch to a different version of a service.\"\"\"\n        if interface in self.service_versions and version in self.service_versions[interface]:\n            self.bind(interface, self.service_versions[interface][version])\n\ndef test_dynamic_service_switching():\n    \"\"\"Test runtime service version switching.\"\"\"\n    container = DynamicContainer()\n\n    # Register service versions\n    container.register_service_version(IEmailService, BasicEmailService(), \"v1\")\n    container.register_service_version(IEmailService, AdvancedEmailService(), \"v2\")\n\n    # Start with v1\n    container.switch_service_version(IEmailService, \"v1\")\n    service = container.get(IEmailService)\n    assert isinstance(service, BasicEmailService)\n\n    # Switch to v2\n    container.switch_service_version(IEmailService, \"v2\")\n    service = container.get(IEmailService)\n    assert isinstance(service, AdvancedEmailService)\n</code></pre>"},{"location":"testing/override-patterns/#ab-testing-overrides","title":"A/B Testing Overrides","text":"<pre><code>class ABTestContainer(InjectQ):\n    \"\"\"Container that supports A/B testing.\"\"\"\n    def __init__(self):\n        super().__init__()\n        self.ab_tests = {}\n\n    def setup_ab_test(self, test_name: str, interface, variant_a, variant_b):\n        \"\"\"Setup A/B test for a service.\"\"\"\n        self.ab_tests[test_name] = {\n            \"interface\": interface,\n            \"variant_a\": variant_a,\n            \"variant_b\": variant_b\n        }\n\n    def assign_variant(self, test_name: str, user_id: int) -&gt; str:\n        \"\"\"Assign user to A/B test variant.\"\"\"\n        # Simple hash-based assignment\n        variant = \"A\" if hash(f\"{test_name}_{user_id}\") % 2 == 0 else \"B\"\n        return variant\n\n    def get_service_for_user(self, interface, user_id: int):\n        \"\"\"Get service variant for specific user.\"\"\"\n        for test_name, test_config in self.ab_tests.items():\n            if test_config[\"interface\"] == interface:\n                variant = self.assign_variant(test_name, user_id)\n                if variant == \"A\":\n                    return test_config[\"variant_a\"]\n                else:\n                    return test_config[\"variant_b\"]\n\n        # No A/B test, return default\n        return self.get(interface)\n\ndef test_ab_testing_overrides():\n    \"\"\"Test A/B testing service overrides.\"\"\"\n    container = ABTestContainer()\n\n    # Setup A/B test for email service\n    container.setup_ab_test(\n        \"email_template_test\",\n        IEmailService,\n        BasicEmailService(),\n        FancyEmailService()\n    )\n\n    # User 1 gets variant A\n    service1 = container.get_service_for_user(IEmailService, 1)\n    assert isinstance(service1, BasicEmailService)\n\n    # User 2 gets variant B\n    service2 = container.get_service_for_user(IEmailService, 2)\n    assert isinstance(service2, FancyEmailService)\n</code></pre>"},{"location":"testing/override-patterns/#override-best-practices","title":"\ud83d\udea8 Override Best Practices","text":""},{"location":"testing/override-patterns/#good-patterns","title":"\u2705 Good Patterns","text":""},{"location":"testing/override-patterns/#1-clear-override-scope","title":"1. Clear Override Scope","text":"<pre><code># \u2705 Good: Clear context manager scope\ndef test_with_clear_scope(container):\n    with container.override(IService, MockService()) as mock:\n        # Override is clearly scoped\n        service = container.get(IService)\n        assert isinstance(service, MockService)\n\n        # Use service\n        result = service.do_work()\n\n        # Verify\n        assert mock.call_count(\"do_work\") == 1\n\n    # Outside scope: back to original\n    service = container.get(IService)\n    assert isinstance(service, RealService)\n</code></pre>"},{"location":"testing/override-patterns/#2-descriptive-override-names","title":"2. Descriptive Override Names","text":"<pre><code># \u2705 Good: Descriptive override names\ndef test_payment_processing_with_failed_payment():\n    failing_payment = MockPaymentService()\n    failing_payment.configure_exception(\"charge_card\", PaymentError(\"Card declined\"))\n\n    with container.override(IPaymentService, failing_payment):\n        # Clear intent of the override\n        pass\n\ndef test_email_sending_with_slow_service():\n    slow_email = SlowEmailService(delay=5.0)\n\n    with container.override(IEmailService, slow_email):\n        # Clear intent of the override\n        pass\n</code></pre>"},{"location":"testing/override-patterns/#3-override-cleanup","title":"3. Override Cleanup","text":"<pre><code># \u2705 Good: Explicit cleanup\ndef test_with_cleanup(container):\n    original_service = container.get(IService)\n\n    # Override\n    container.bind(IService, MockService())\n\n    try:\n        # Test logic\n        service = container.get(IService)\n        assert isinstance(service, MockService)\n\n    finally:\n        # Explicit cleanup\n        container.bind(IService, original_service)\n</code></pre>"},{"location":"testing/override-patterns/#bad-patterns","title":"\u274c Bad Patterns","text":""},{"location":"testing/override-patterns/#1-global-overrides","title":"1. Global Overrides","text":"<pre><code># \u274c Bad: Global override affects all tests\n@pytest.fixture(scope=\"session\")\ndef override_container():\n    container = TestContainer()\n    container.bind(IEmailService, MockEmailService())  # Affects all tests!\n    return container\n\n# \u274c Bad: Override in fixture without clear scope\n@pytest.fixture\ndef container_with_override():\n    container = TestContainer()\n    container.bind(IEmailService, MockEmailService())  # Permanent override\n    return container\n</code></pre>"},{"location":"testing/override-patterns/#2-nested-override-confusion","title":"2. Nested Override Confusion","text":"<pre><code># \u274c Bad: Confusing nested overrides\ndef test_confusing_nesting(container):\n    with container.override(IService, MockServiceA()):\n        with container.override(IService, MockServiceB()):  # Overrides the override!\n            service = container.get(IService)\n            # Which mock is active? Confusing!\n\n# \u2705 Good: Clear nested overrides\ndef test_clear_nesting(container):\n    with container.override(IService, MockServiceA()) as mock_a:\n        # First override active\n        assert isinstance(container.get(IService), MockServiceA)\n\n        with container.override(IOtherService, MockServiceB()) as mock_b:\n            # Both overrides active\n            assert isinstance(container.get(IService), MockServiceA)\n            assert isinstance(container.get(IOtherService), MockServiceB)\n\n        # Back to first override only\n        assert isinstance(container.get(IService), MockServiceA)\n</code></pre>"},{"location":"testing/override-patterns/#3-override-without-verification","title":"3. Override Without Verification","text":"<pre><code># \u274c Bad: Override without testing its effect\ndef test_without_verification(container):\n    with container.override(IEmailService, MockEmailService()):\n        user_service = container.get(IUserService)\n        user_service.register_user(\"john@example.com\", \"password\")\n\n        # No verification that mock was actually used!\n\n# \u2705 Good: Verify override was used\ndef test_with_verification(container):\n    with container.override(IEmailService, MockEmailService()) as mock:\n        user_service = container.get(IUserService)\n        user_service.register_user(\"john@example.com\", \"password\")\n\n        # Verify mock was used\n        assert mock.call_count(\"send_welcome_email\") == 1\n</code></pre>"},{"location":"testing/override-patterns/#override-metrics-and-monitoring","title":"\ud83d\udcca Override Metrics and Monitoring","text":""},{"location":"testing/override-patterns/#override-usage-tracking","title":"Override Usage Tracking","text":"<pre><code>class MonitoredContainer(InjectQ):\n    \"\"\"Container that tracks override usage.\"\"\"\n    def __init__(self):\n        super().__init__()\n        self.override_history = []\n\n    def override(self, interface, implementation):\n        # Record override\n        self.override_history.append({\n            \"interface\": interface,\n            \"implementation\": implementation,\n            \"timestamp\": time.time()\n        })\n\n        return super().override(interface, implementation)\n\n    def get_override_stats(self):\n        \"\"\"Get statistics about override usage.\"\"\"\n        stats = {}\n        for entry in self.override_history:\n            interface_name = entry[\"interface\"].__name__\n            if interface_name not in stats:\n                stats[interface_name] = 0\n            stats[interface_name] += 1\n        return stats\n\ndef test_with_monitoring():\n    \"\"\"Test with override monitoring.\"\"\"\n    container = MonitoredContainer()\n\n    # Use overrides\n    with container.override(IEmailService, MockEmailService()):\n        pass\n\n    with container.override(IUserService, MockUserService()):\n        pass\n\n    with container.override(IEmailService, FailingEmailService()):\n        pass\n\n    # Check override statistics\n    stats = container.get_override_stats()\n    assert stats[\"IEmailService\"] == 2  # Overridden twice\n    assert stats[\"IUserService\"] == 1   # Overridden once\n</code></pre>"},{"location":"testing/override-patterns/#override-performance-monitoring","title":"Override Performance Monitoring","text":"<pre><code>class PerformanceMonitoredContainer(InjectQ):\n    \"\"\"Container that monitors override performance.\"\"\"\n    def __init__(self):\n        super().__init__()\n        self.performance_stats = {}\n\n    def override(self, interface, implementation):\n        start_time = time.time()\n\n        try:\n            return super().override(interface, implementation)\n        finally:\n            duration = time.time() - start_time\n            interface_name = interface.__name__\n\n            if interface_name not in self.performance_stats:\n                self.performance_stats[interface_name] = []\n\n            self.performance_stats[interface_name].append(duration)\n\n    def get_performance_stats(self):\n        \"\"\"Get performance statistics for overrides.\"\"\"\n        return {\n            interface: {\n                \"count\": len(durations),\n                \"avg_duration\": sum(durations) / len(durations),\n                \"max_duration\": max(durations),\n                \"min_duration\": min(durations)\n            }\n            for interface, durations in self.performance_stats.items()\n        }\n</code></pre>"},{"location":"testing/override-patterns/#summary","title":"\ud83c\udfaf Summary","text":"<p>Override patterns provide flexible ways to replace services:</p> <ul> <li>Simple overrides - Permanent service replacement</li> <li>Context overrides - Temporary service replacement</li> <li>Nested overrides - Multiple levels of replacement</li> <li>Conditional overrides - Environment or condition-based replacement</li> <li>Dynamic overrides - Runtime service switching</li> </ul> <p>Key features: - Temporary service replacement with context managers - Nested override support - Environment and condition-based overrides - Feature flag integration - A/B testing support - Performance and usage monitoring</p> <p>Best practices: - Use context managers for clear override scope - Give overrides descriptive names - Verify that overrides are actually used - Clean up overrides explicitly when needed - Avoid global overrides that affect multiple tests - Monitor override usage and performance</p> <p>Common patterns: - Test-specific overrides for different scenarios - Environment-based service selection - Feature flag-driven service switching - A/B testing with service variants - Runtime service version switching</p> <p>Ready to explore integration testing?</p>"},{"location":"testing/overview/","title":"Testing","text":"<p>Testing is a critical aspect of dependency injection systems. InjectQ provides comprehensive testing utilities that make it easy to test your dependency-injected code with proper isolation, mocking, and verification.</p>"},{"location":"testing/overview/#overview","title":"\ud83c\udfaf Overview","text":"<p>InjectQ's testing utilities help you:</p> <ul> <li>Isolate dependencies - Replace real services with test doubles</li> <li>Mock external services - Simulate external API calls and database operations</li> <li>Override bindings - Temporarily change service implementations for testing</li> <li>Verify interactions - Ensure services are called correctly</li> <li>Test scopes - Verify scoped behavior in tests</li> <li>Integration testing - Test with real dependencies when needed</li> </ul>"},{"location":"testing/overview/#testing-philosophy","title":"Testing Philosophy","text":"<pre><code># Traditional testing - manual setup\ndef test_user_service():\n    # Manual dependency setup\n    db = MockDatabase()\n    cache = MockCache()\n    service = UserService(db, cache)\n\n    # Test logic\n    result = service.get_user(123)\n    assert result.id == 123\n\n# InjectQ testing - automatic resolution\ndef test_user_service(container):\n    # Override dependencies\n    container.bind(IDatabase, MockDatabase())\n    container.bind(ICache, MockCache())\n\n    # InjectQ handles resolution\n    service = container.get(IUserService)\n    result = service.get_user(123)\n    assert result.id == 123\n</code></pre>"},{"location":"testing/overview/#testing-section-structure","title":"\ud83d\udcc1 Testing Section Structure","text":"<p>This section covers:</p> <ul> <li>Testing Utilities - Core testing tools and setup</li> <li>Mocking Strategies - Different approaches to mocking dependencies</li> <li>Override Patterns - Temporarily changing service implementations</li> <li>Integration Testing - Testing with real dependencies</li> <li>Test Scopes - Testing scoped services and lifecycle</li> <li>Best Practices - Testing patterns and anti-patterns</li> </ul>"},{"location":"testing/overview/#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"testing/overview/#basic-test-setup","title":"Basic Test Setup","text":"<pre><code>import pytest\nfrom injectq import InjectQ\nfrom injectq.testing import TestContainer\n\n@pytest.fixture\ndef container():\n    \"\"\"Create test container with mocked dependencies.\"\"\"\n    container = TestContainer()\n\n    # Bind mock services\n    container.bind(IUserService, MockUserService())\n    container.bind(IEmailService, MockEmailService())\n\n    return container\n\ndef test_user_registration(container):\n    \"\"\"Test user registration with mocked dependencies.\"\"\"\n    # Get service from container\n    user_service = container.get(IUserService)\n\n    # Test the service\n    user = user_service.register_user(\"john@example.com\", \"password\")\n\n    # Verify result\n    assert user.email == \"john@example.com\"\n    assert user.is_active is True\n\n    # Verify interactions\n    email_service = container.get(IEmailService)\n    assert email_service.welcome_email_sent is True\n</code></pre>"},{"location":"testing/overview/#mock-classes","title":"Mock Classes","text":"<pre><code>from injectq.testing import Mock\n\nclass MockUserService(Mock[IUserService]):\n    def __init__(self):\n        super().__init__()\n        self.users = {}\n        self.next_id = 1\n\n    def get_user(self, user_id: int) -&gt; User:\n        return self.users.get(user_id)\n\n    def create_user(self, email: str, password: str) -&gt; User:\n        user = User(\n            id=self.next_id,\n            email=email,\n            password_hash=hash_password(password),\n            is_active=True\n        )\n        self.users[self.next_id] = user\n        self.next_id += 1\n        return user\n\n    def register_user(self, email: str, password: str) -&gt; User:\n        # Record the call\n        self.record_call(\"register_user\", email, password)\n\n        # Create and return user\n        return self.create_user(email, password)\n\nclass MockEmailService(Mock[IEmailService]):\n    def __init__(self):\n        super().__init__()\n        self.welcome_email_sent = False\n        self.sent_emails = []\n\n    def send_welcome_email(self, email: str) -&gt; None:\n        self.record_call(\"send_welcome_email\", email)\n        self.welcome_email_sent = True\n        self.sent_emails.append({\n            \"type\": \"welcome\",\n            \"email\": email,\n            \"timestamp\": time.time()\n        })\n</code></pre>"},{"location":"testing/overview/#testing-patterns","title":"\ud83c\udfa8 Testing Patterns","text":""},{"location":"testing/overview/#unit-testing-pattern","title":"Unit Testing Pattern","text":"<pre><code>def test_service_with_mocks(container):\n    \"\"\"Test service with mocked dependencies.\"\"\"\n    # Arrange\n    container.bind(IDependency, MockDependency())\n\n    # Act\n    service = container.get(IService)\n    result = service.do_something()\n\n    # Assert\n    assert result is not None\n    mock_dep = container.get(IDependency)\n    assert mock_dep.method_called(\"do_something\")\n</code></pre>"},{"location":"testing/overview/#integration-testing-pattern","title":"Integration Testing Pattern","text":"<pre><code>def test_service_integration(real_container):\n    \"\"\"Test service with real dependencies.\"\"\"\n    # Use real implementations\n    service = real_container.get(IService)\n    result = service.do_something()\n\n    # Verify with real data\n    assert result.status == \"success\"\n</code></pre>"},{"location":"testing/overview/#override-testing-pattern","title":"Override Testing Pattern","text":"<pre><code>def test_with_override(container):\n    \"\"\"Test with temporary service override.\"\"\"\n    # Original binding\n    container.bind(IService, RealService())\n\n    # Override for test\n    with container.override(IService, MockService()):\n        service = container.get(IService)\n        result = service.do_something()\n\n        # Service is mocked during override\n        assert isinstance(service, MockService)\n\n    # Override ends, back to real service\n    service = container.get(IService)\n    assert isinstance(service, RealService)\n</code></pre>"},{"location":"testing/overview/#test-categories","title":"\ud83e\uddea Test Categories","text":""},{"location":"testing/overview/#1-unit-tests","title":"1. Unit Tests","text":"<pre><code>def test_business_logic(container):\n    \"\"\"Test business logic in isolation.\"\"\"\n    # Mock all external dependencies\n    container.bind(IExternalAPI, MockExternalAPI())\n    container.bind(IDatabase, MockDatabase())\n\n    # Test the unit\n    calculator = container.get(PriceCalculator)\n    price = calculator.calculate_total(items)\n\n    assert price == expected_total\n</code></pre>"},{"location":"testing/overview/#2-integration-tests","title":"2. Integration Tests","text":"<pre><code>def test_service_integration(integration_container):\n    \"\"\"Test service with real database.\"\"\"\n    # Use real database, mock external APIs\n    container.bind(IExternalAPI, MockExternalAPI())\n\n    # Test integration\n    order_service = container.get(IOrderService)\n    order = order_service.create_order(items)\n\n    # Verify database state\n    db_order = container.get(IDatabase).get_order(order.id)\n    assert db_order.status == \"created\"\n</code></pre>"},{"location":"testing/overview/#3-end-to-end-tests","title":"3. End-to-End Tests","text":"<pre><code>def test_full_workflow(e2e_container):\n    \"\"\"Test complete user workflow.\"\"\"\n    # Minimal mocking - mostly real services\n    user_service = e2e_container.get(IUserService)\n    order_service = e2e_container.get(IOrderService)\n\n    # Create user\n    user = user_service.register_user(\"test@example.com\", \"password\")\n\n    # Create order\n    order = order_service.create_order(user.id, items)\n\n    # Verify complete flow\n    assert order.user_id == user.id\n    assert order.status == \"confirmed\"\n</code></pre>"},{"location":"testing/overview/#testing-utilities","title":"\ud83d\udd27 Testing Utilities","text":""},{"location":"testing/overview/#testcontainer","title":"TestContainer","text":"<pre><code>from injectq.testing import TestContainer\n\ndef test_with_test_container():\n    \"\"\"TestContainer provides testing-specific features.\"\"\"\n    container = TestContainer()\n\n    # Bind mocks easily\n    container.bind_mock(IUserService)\n    container.bind_mock(IEmailService)\n\n    # Get services\n    user_service = container.get(IUserService)\n    email_service = container.get(IEmailService)\n\n    # Both are automatically mocked\n    assert isinstance(user_service, Mock)\n    assert isinstance(email_service, Mock)\n</code></pre>"},{"location":"testing/overview/#mock-base-class","title":"Mock Base Class","text":"<pre><code>from injectq.testing import Mock\n\nclass CustomMock(Mock[IService]):\n    def __init__(self):\n        super().__init__()\n        self.call_history = []\n\n    def some_method(self, arg: str) -&gt; str:\n        # Record the call\n        self.record_call(\"some_method\", arg)\n\n        # Custom mock behavior\n        return f\"mocked_{arg}\"\n\n    def verify_called_with(self, method: str, *args):\n        \"\"\"Verify method was called with specific args.\"\"\"\n        calls = [call for call in self.call_history if call[\"method\"] == method]\n        return any(call[\"args\"] == args for call in calls)\n</code></pre>"},{"location":"testing/overview/#override-context-manager","title":"Override Context Manager","text":"<pre><code>def test_with_temporary_override(container):\n    \"\"\"Temporarily override a service.\"\"\"\n    # Setup original service\n    container.bind(IService, RealService())\n\n    # Test with override\n    with container.override(IService, MockService()) as mock:\n        service = container.get(IService)\n        result = service.do_work()\n\n        # Verify mock was used\n        assert isinstance(service, MockService)\n        assert mock.call_count(\"do_work\") == 1\n\n    # Override ends automatically\n    service = container.get(IService)\n    assert isinstance(service, RealService)\n</code></pre>"},{"location":"testing/overview/#common-testing-mistakes","title":"\ud83d\udea8 Common Testing Mistakes","text":""},{"location":"testing/overview/#bad-testing-implementation-details","title":"\u274c Bad: Testing Implementation Details","text":"<pre><code># Bad: Testing private methods\ndef test_private_method(container):\n    service = container.get(IService)\n    # Don't test private methods directly\n    result = service._private_method()  # \u274c\n\n# Good: Test public interface\ndef test_public_interface(container):\n    service = container.get(IService)\n    result = service.public_method()  # \u2705\n</code></pre>"},{"location":"testing/overview/#bad-over-mocking","title":"\u274c Bad: Over-Mocking","text":"<pre><code># Bad: Mocking everything\ndef test_with_too_many_mocks(container):\n    container.bind_mock(IUserService)\n    container.bind_mock(IEmailService)\n    container.bind_mock(IDatabase)\n    container.bind_mock(ICache)\n    container.bind_mock(ILogger)\n    # ... 10 more mocks\n\n    service = container.get(IService)\n    # Test becomes meaningless\n\n# Good: Mock only external dependencies\ndef test_with_appropriate_mocks(container):\n    # Mock external services only\n    container.bind_mock(IEmailService)  # External API\n    container.bind_mock(IPaymentService)  # External payment\n\n    # Use real implementations for internal services\n    # Test focuses on business logic\n</code></pre>"},{"location":"testing/overview/#bad-no-interaction-verification","title":"\u274c Bad: No Interaction Verification","text":"<pre><code># Bad: No verification of interactions\ndef test_without_verification(container):\n    container.bind_mock(IEmailService)\n    service = container.get(IUserService)\n\n    service.register_user(\"test@example.com\", \"password\")\n\n    # No verification that email was sent! \u274c\n\n# Good: Verify important interactions\ndef test_with_verification(container):\n    mock_email = container.bind_mock(IEmailService)\n    service = container.get(IUserService)\n\n    service.register_user(\"test@example.com\", \"password\")\n\n    # Verify email was sent \u2705\n    assert mock_email.call_count(\"send_welcome_email\") == 1\n</code></pre>"},{"location":"testing/overview/#testing-best-practices","title":"\u2705 Testing Best Practices","text":""},{"location":"testing/overview/#1-test-behavior-not-implementation","title":"1. Test Behavior, Not Implementation","text":"<pre><code># \u2705 Good: Test what the service does\ndef test_user_registration_sends_email(container):\n    mock_email = container.bind_mock(IEmailService)\n    service = container.get(IUserService)\n\n    service.register_user(\"test@example.com\", \"password\")\n\n    # Verify behavior: email is sent\n    assert mock_email.call_count(\"send_welcome_email\") == 1\n\n# \u274c Bad: Test how the service does it\ndef test_user_registration_calls_internal_method(container):\n    service = container.get(IUserService)\n\n    service.register_user(\"test@example.com\", \"password\")\n\n    # Testing implementation detail\n    assert service._hash_password_called is True\n</code></pre>"},{"location":"testing/overview/#2-use-appropriate-test-doubles","title":"2. Use Appropriate Test Doubles","text":"<pre><code># \u2705 Use mocks for external dependencies\ncontainer.bind_mock(IEmailService)  # External service\ncontainer.bind_mock(IPaymentAPI)    # External API\n\n# \u2705 Use stubs for data providers\ncontainer.bind(IUserRepository, StubUserRepository())\n\n# \u2705 Use spies for verification\nspy_service = SpyService()\ncontainer.bind(IService, spy_service)\n\n# \u2705 Use fakes for complex dependencies\ncontainer.bind(IDatabase, FakeDatabase())\n</code></pre>"},{"location":"testing/overview/#3-test-error-conditions","title":"3. Test Error Conditions","text":"<pre><code># \u2705 Test happy path\ndef test_successful_registration(container):\n    service = container.get(IUserService)\n    user = service.register_user(\"test@example.com\", \"password\")\n    assert user.is_active\n\n# \u2705 Test error conditions\ndef test_registration_with_existing_email(container):\n    mock_repo = container.bind_mock(IUserRepository)\n    mock_repo.get_user_by_email.return_value = existing_user()\n\n    service = container.get(IUserService)\n\n    with pytest.raises(UserAlreadyExistsError):\n        service.register_user(\"existing@example.com\", \"password\")\n</code></pre>"},{"location":"testing/overview/#4-keep-tests-fast-and-isolated","title":"4. Keep Tests Fast and Isolated","text":"<pre><code># \u2705 Fast: Use in-memory fakes\ncontainer.bind(IDatabase, FakeDatabase())\n\n# \u2705 Isolated: Each test gets fresh container\n@pytest.fixture\ndef container():\n    return TestContainer()  # Fresh container each test\n\n# \u2705 Independent: No shared state between tests\ndef test_independent_operation(container):\n    # Each test starts with clean slate\n    pass\n</code></pre>"},{"location":"testing/overview/#testing-metrics","title":"\ud83d\udcca Testing Metrics","text":""},{"location":"testing/overview/#test-coverage-goals","title":"Test Coverage Goals","text":"<ul> <li>Unit Tests: 80%+ coverage of business logic</li> <li>Integration Tests: Cover critical user journeys</li> <li>End-to-End Tests: Cover complete workflows</li> </ul>"},{"location":"testing/overview/#test-types-distribution","title":"Test Types Distribution","text":"<ul> <li>Unit Tests: 70% - Test individual components</li> <li>Integration Tests: 20% - Test component interactions</li> <li>End-to-End Tests: 10% - Test complete system</li> </ul>"},{"location":"testing/overview/#summary","title":"\ud83c\udfaf Summary","text":"<p>Effective testing with InjectQ requires:</p> <ul> <li>Proper isolation - Mock external dependencies</li> <li>Appropriate test doubles - Use right tool for each scenario</li> <li>Behavior verification - Test what matters, not implementation</li> <li>Fast execution - Keep tests running quickly</li> <li>Clear organization - Separate unit, integration, and e2e tests</li> </ul> <p>Key principles: - Test behavior over implementation - Mock external dependencies, use real internal services - Verify important interactions - Keep tests fast and isolated - Use appropriate test doubles (mocks, stubs, fakes, spies)</p> <p>Ready to dive into testing utilities?</p>"},{"location":"testing/test-scopes/","title":"Test Scopes","text":"<p>Test scopes handle testing of scoped services, ensuring proper lifecycle management and isolation in tests.</p>"},{"location":"testing/test-scopes/#understanding-scopes-in-testing","title":"\ud83c\udfaf Understanding Scopes in Testing","text":""},{"location":"testing/test-scopes/#scope-lifecycle-in-tests","title":"Scope Lifecycle in Tests","text":"<pre><code>from injectq import scoped, singleton, transient\n\n# Scoped service - New instance per scope\n@scoped\nclass RequestContext:\n    def __init__(self):\n        self.request_id = str(uuid.uuid4())\n        self.user_id = None\n        self.metadata = {}\n\n# Singleton service - Same instance for entire container\n@singleton\nclass ApplicationConfig:\n    def __init__(self):\n        self.settings = {}\n        self.initialized_at = time.time()\n\n# Transient service - New instance every time\n@transient\nclass DataProcessor:\n    def __init__(self):\n        self.created_at = time.time()\n\ndef test_scope_lifecycle(container):\n    \"\"\"Test how different scopes behave in tests.\"\"\"\n    # Scoped service\n    context1 = container.get(RequestContext)\n    context2 = container.get(RequestContext)\n\n    # In same scope: same instance\n    assert context1 is context2\n    assert context1.request_id == context2.request_id\n\n    # Singleton service\n    config1 = container.get(ApplicationConfig)\n    config2 = container.get(ApplicationConfig)\n\n    # Always same instance\n    assert config1 is config2\n    assert config1.initialized_at == config2.initialized_at\n\n    # Transient service\n    processor1 = container.get(DataProcessor)\n    processor2 = container.get(DataProcessor)\n\n    # Always different instances\n    assert processor1 is not processor2\n    assert processor1.created_at != processor2.created_at\n</code></pre>"},{"location":"testing/test-scopes/#testing-scoped-services","title":"\ud83d\udd27 Testing Scoped Services","text":""},{"location":"testing/test-scopes/#request-scope-testing","title":"Request Scope Testing","text":"<pre><code>@scoped\nclass RequestContext:\n    def __init__(self):\n        self.request_id = str(uuid.uuid4())\n        self.user = None\n        self.start_time = time.time()\n        self.metadata = {}\n\n    def set_user(self, user: User):\n        self.user = user\n\n    def add_metadata(self, key: str, value: Any):\n        self.metadata[key] = value\n\ndef test_request_scoped_service(container):\n    \"\"\"Test request-scoped service behavior.\"\"\"\n    # Get service in current scope\n    context1 = container.get(RequestContext)\n    context1.set_user(User(id=1, name=\"John\"))\n    context1.add_metadata(\"source\", \"test\")\n\n    # Same scope: same instance\n    context2 = container.get(RequestContext)\n    assert context1 is context2\n    assert context2.user.name == \"John\"\n    assert context2.metadata[\"source\"] == \"test\"\n\n    # Verify scope isolation\n    assert context1.request_id == context2.request_id\n</code></pre>"},{"location":"testing/test-scopes/#scope-boundary-testing","title":"Scope Boundary Testing","text":"<pre><code>def test_scope_boundaries(container):\n    \"\"\"Test behavior at scope boundaries.\"\"\"\n    # Start with one scope\n    context1 = container.get(RequestContext)\n    context1.set_user(User(id=1, name=\"John\"))\n\n    # Simulate scope end (in real app, this would be automatic)\n    container.end_scope()\n\n    # New scope: new instance\n    context2 = container.get(RequestContext)\n    assert context1 is not context2\n    assert context1.request_id != context2.request_id\n    assert context2.user is None  # Fresh instance\n\n    # Set data in new scope\n    context2.set_user(User(id=2, name=\"Jane\"))\n    assert context2.user.name == \"Jane\"\n\n    # Original scope unchanged\n    assert context1.user.name == \"John\"\n</code></pre>"},{"location":"testing/test-scopes/#nested-scope-testing","title":"Nested Scope Testing","text":"<pre><code>def test_nested_scopes(container):\n    \"\"\"Test nested scope behavior.\"\"\"\n    # Outer scope\n    outer_context = container.get(RequestContext)\n    outer_context.set_user(User(id=1, name=\"John\"))\n    outer_context.add_metadata(\"level\", \"outer\")\n\n    # Start nested scope\n    container.begin_nested_scope()\n\n    # Inner scope\n    inner_context = container.get(RequestContext)\n    assert inner_context is not outer_context  # Different instances\n    assert inner_context.request_id != outer_context.request_id\n\n    # Inner scope inherits some data (depending on implementation)\n    inner_context.set_user(User(id=2, name=\"Jane\"))\n    inner_context.add_metadata(\"level\", \"inner\")\n\n    # Verify isolation\n    assert outer_context.user.name == \"John\"\n    assert inner_context.user.name == \"Jane\"\n\n    # End nested scope\n    container.end_scope()\n\n    # Back to outer scope\n    current_context = container.get(RequestContext)\n    assert current_context is outer_context\n    assert current_context.user.name == \"John\"\n    assert current_context.metadata[\"level\"] == \"outer\"\n</code></pre>"},{"location":"testing/test-scopes/#scope-testing-patterns","title":"\ud83c\udfa8 Scope Testing Patterns","text":""},{"location":"testing/test-scopes/#scope-aware-test-fixtures","title":"Scope-Aware Test Fixtures","text":"<pre><code>@pytest.fixture\ndef scoped_container():\n    \"\"\"Container with proper scope management.\"\"\"\n    container = TestContainer()\n\n    # Bind scoped services\n    container.bind(RequestContext, RequestContext())\n    container.bind(UserSession, UserSession())\n\n    # Start test scope\n    container.begin_scope()\n\n    try:\n        yield container\n    finally:\n        # Clean up scope\n        container.end_scope()\n\ndef test_with_scoped_fixture(scoped_container):\n    \"\"\"Test using scoped fixture.\"\"\"\n    # Services are in test scope\n    context = scoped_container.get(RequestContext)\n    session = scoped_container.get(UserSession)\n\n    # Use services\n    context.set_user(User(id=1, name=\"Test User\"))\n    session.set_data(\"key\", \"value\")\n\n    # Verify in same scope\n    assert context.user.name == \"Test User\"\n    assert session.get_data(\"key\") == \"value\"\n</code></pre>"},{"location":"testing/test-scopes/#scope-isolation-testing","title":"Scope Isolation Testing","text":"<pre><code>def test_scope_isolation(container):\n    \"\"\"Test that scopes are properly isolated.\"\"\"\n    users = []\n\n    # Create multiple \"requests\" (scopes)\n    for i in range(3):\n        # Start new scope for each \"request\"\n        container.begin_scope()\n\n        context = container.get(RequestContext)\n        context.set_user(User(id=i+1, name=f\"User {i+1}\"))\n\n        # Simulate request processing\n        user = context.user\n        users.append(user)\n\n        # End scope\n        container.end_scope()\n\n    # Verify isolation\n    assert len(users) == 3\n    assert users[0].name == \"User 1\"\n    assert users[1].name == \"User 2\"\n    assert users[2].name == \"User 3\"\n\n    # Verify different request IDs\n    request_ids = [u.id for u in users]\n    assert len(set(request_ids)) == 3  # All unique\n</code></pre>"},{"location":"testing/test-scopes/#scope-lifecycle-testing","title":"Scope Lifecycle Testing","text":"<pre><code>@scoped\nclass ScopedService:\n    def __init__(self):\n        self.created_at = time.time()\n        self.operations = []\n        self.disposed = False\n\n    def do_operation(self, name: str):\n        self.operations.append({\n            \"name\": name,\n            \"timestamp\": time.time()\n        })\n\n    def dispose(self):\n        self.disposed = True\n\ndef test_scope_lifecycle(container):\n    \"\"\"Test scoped service lifecycle.\"\"\"\n    # Start scope\n    container.begin_scope()\n\n    # Get service\n    service1 = container.get(ScopedService)\n    service1.do_operation(\"init\")\n\n    # Same scope: same instance\n    service2 = container.get(ScopedService)\n    assert service1 is service2\n    assert len(service1.operations) == 1\n\n    # Do more operations\n    service2.do_operation(\"process\")\n    assert len(service1.operations) == 2\n\n    # End scope\n    container.end_scope()\n\n    # Verify disposal\n    assert service1.disposed is True\n\n    # New scope: new instance\n    container.begin_scope()\n    service3 = container.get(ScopedService)\n    assert service3 is not service1\n    assert service3.disposed is False\n    assert len(service3.operations) == 0\n    container.end_scope()\n</code></pre>"},{"location":"testing/test-scopes/#advanced-scope-testing","title":"\ud83e\uddea Advanced Scope Testing","text":""},{"location":"testing/test-scopes/#concurrent-scope-testing","title":"Concurrent Scope Testing","text":"<pre><code>import asyncio\n\nasync def test_concurrent_scopes(container):\n    \"\"\"Test scopes in concurrent scenarios.\"\"\"\n    results = []\n\n    async def process_request(request_id: int):\n        # Each \"request\" gets its own scope\n        container.begin_scope()\n\n        try:\n            context = container.get(RequestContext)\n            context.set_user(User(id=request_id, name=f\"User {request_id}\"))\n\n            # Simulate async processing\n            await asyncio.sleep(0.01)\n\n            # Verify isolation\n            result = {\n                \"request_id\": request_id,\n                \"user_name\": context.user.name,\n                \"context_id\": id(context)\n            }\n            results.append(result)\n\n        finally:\n            container.end_scope()\n\n    # Process multiple concurrent requests\n    tasks = [process_request(i) for i in range(5)]\n    await asyncio.gather(*tasks)\n\n    # Verify all requests were isolated\n    assert len(results) == 5\n\n    # All should have different context instances\n    context_ids = [r[\"context_id\"] for r in results]\n    assert len(set(context_ids)) == 5\n\n    # Each should have correct user\n    for i, result in enumerate(results):\n        assert result[\"user_name\"] == f\"User {i}\"\n\n@pytest.mark.asyncio\nasync def test_async_scope_isolation(container):\n    \"\"\"Test async scope isolation.\"\"\"\n    await test_concurrent_scopes(container)\n</code></pre>"},{"location":"testing/test-scopes/#scope-context-manager-testing","title":"Scope Context Manager Testing","text":"<pre><code>class ScopeContext:\n    \"\"\"Context manager for scope testing.\"\"\"\n    def __init__(self, container):\n        self.container = container\n\n    def __enter__(self):\n        self.container.begin_scope()\n        return self.container\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.container.end_scope()\n\ndef test_scope_context_manager(container):\n    \"\"\"Test scope management with context manager.\"\"\"\n    results = []\n\n    for i in range(3):\n        with ScopeContext(container) as scoped_container:\n            context = scoped_container.get(RequestContext)\n            context.set_user(User(id=i+1, name=f\"User {i+1}\"))\n\n            results.append({\n                \"user_name\": context.user.name,\n                \"context_id\": id(context)\n            })\n\n    # Verify results\n    assert len(results) == 3\n    assert results[0][\"user_name\"] == \"User 1\"\n    assert results[1][\"user_name\"] == \"User 2\"\n    assert results[2][\"user_name\"] == \"User 3\"\n\n    # Verify different contexts\n    context_ids = [r[\"context_id\"] for r in results]\n    assert len(set(context_ids)) == 3\n</code></pre>"},{"location":"testing/test-scopes/#scope-inheritance-testing","title":"Scope Inheritance Testing","text":"<pre><code>@scoped\nclass ParentScope:\n    def __init__(self):\n        self.data = {\"level\": \"parent\"}\n\n@scoped\nclass ChildScope:\n    def __init__(self, parent: ParentScope):\n        self.parent = parent\n        self.data = {\"level\": \"child\"}\n\ndef test_scope_inheritance(container):\n    \"\"\"Test scope inheritance behavior.\"\"\"\n    # Parent scope\n    container.begin_scope()\n\n    parent = container.get(ParentScope)\n    parent.data[\"parent_value\"] = \"inherited\"\n\n    # Child scope\n    container.begin_nested_scope()\n\n    child = container.get(ChildScope)\n    assert child.parent is parent  # Should inherit parent\n    assert child.parent.data[\"parent_value\"] == \"inherited\"\n\n    # Child can have its own data\n    child.data[\"child_value\"] = \"unique\"\n\n    # Parent unchanged\n    assert parent.data[\"level\"] == \"parent\"\n    assert \"child_value\" not in parent.data\n\n    # End child scope\n    container.end_scope()\n\n    # Back to parent scope\n    current_parent = container.get(ParentScope)\n    assert current_parent is parent\n    assert current_parent.data[\"parent_value\"] == \"inherited\"\n\n    # End parent scope\n    container.end_scope()\n</code></pre>"},{"location":"testing/test-scopes/#scope-testing-challenges","title":"\ud83d\udea8 Scope Testing Challenges","text":""},{"location":"testing/test-scopes/#scope-leakage","title":"Scope Leakage","text":"<pre><code># \u274c Bad: Scope leakage between tests\ndef test_scope_leakage_problem(container):\n    # Test 1\n    context1 = container.get(RequestContext)\n    context1.set_user(User(id=1, name=\"User 1\"))\n\n    # Test runs, but scope not cleaned up\n    # Next test will see User 1's data!\n\ndef test_scope_leakage_problem2(container):\n    # Test 2 - sees data from test 1!\n    context2 = container.get(RequestContext)\n    assert context2.user.name == \"User 1\"  # Unexpected!\n\n# \u2705 Good: Proper scope cleanup\n@pytest.fixture\ndef clean_scoped_container():\n    container = TestContainer()\n    container.begin_scope()\n\n    try:\n        yield container\n    finally:\n        container.end_scope()\n\ndef test_with_proper_cleanup(clean_scoped_container):\n    context = clean_scoped_container.get(RequestContext)\n    context.set_user(User(id=1, name=\"User 1\"))\n\n    assert context.user.name == \"User 1\"\n\ndef test_isolated_with_proper_cleanup(clean_scoped_container):\n    context = clean_scoped_container.get(RequestContext)\n\n    # Fresh scope, no data from previous test\n    assert context.user is None\n</code></pre>"},{"location":"testing/test-scopes/#async-scope-issues","title":"Async Scope Issues","text":"<pre><code># \u274c Bad: Async scope issues\nasync def test_async_scope_problem(container):\n    # Start scope in async function\n    container.begin_scope()\n\n    context = container.get(RequestContext)\n    context.set_user(User(id=1, name=\"User 1\"))\n\n    # Async operation\n    await some_async_operation()\n\n    # Forget to end scope - memory leak!\n    # container.end_scope()  # Missing!\n\n# \u2705 Good: Proper async scope management\n@pytest.fixture\nasync def async_scoped_container():\n    container = TestContainer()\n    container.begin_scope()\n\n    try:\n        yield container\n    finally:\n        container.end_scope()\n\nasync def test_proper_async_scope(async_scoped_container):\n    context = async_scoped_container.get(RequestContext)\n    context.set_user(User(id=1, name=\"User 1\"))\n\n    await some_async_operation()\n\n    # Scope automatically cleaned up by fixture\n</code></pre>"},{"location":"testing/test-scopes/#threading-scope-issues","title":"Threading Scope Issues","text":"<pre><code>import threading\n\n# \u274c Bad: Threading scope issues\ndef test_threading_scope_problem(container):\n    results = []\n\n    def worker_thread(thread_id):\n        # Each thread should have its own scope\n        container.begin_scope()  # Wrong! Shared container\n\n        context = container.get(RequestContext)\n        context.set_user(User(id=thread_id, name=f\"Thread {thread_id}\"))\n\n        results.append(context.user.name)\n\n        # container.end_scope()  # Missing cleanup\n\n    threads = [threading.Thread(target=worker_thread, args=(i,)) for i in range(3)]\n    for t in threads:\n        t.start()\n    for t in threads:\n        t.join()\n\n    # Results unpredictable due to shared scopes\n\n# \u2705 Good: Thread-local scopes\ndef test_threading_scope_solution():\n    results = []\n\n    def worker_thread(thread_id):\n        # Each thread gets its own container\n        container = TestContainer()\n        container.begin_scope()\n\n        try:\n            context = container.get(RequestContext)\n            context.set_user(User(id=thread_id, name=f\"Thread {thread_id}\"))\n\n            results.append((thread_id, context.user.name))\n        finally:\n            container.end_scope()\n\n    threads = [threading.Thread(target=worker_thread, args=(i,)) for i in range(3)]\n    for t in threads:\n        t.start()\n    for t in threads:\n        t.join()\n\n    # Each thread has isolated scope\n    assert len(results) == 3\n    for thread_id, user_name in results:\n        assert user_name == f\"Thread {thread_id}\"\n</code></pre>"},{"location":"testing/test-scopes/#scope-testing-metrics","title":"\ud83d\udcca Scope Testing Metrics","text":""},{"location":"testing/test-scopes/#scope-usage-tracking","title":"Scope Usage Tracking","text":"<pre><code>class ScopeTrackingContainer(TestContainer):\n    \"\"\"Container that tracks scope usage for testing.\"\"\"\n    def __init__(self):\n        super().__init__()\n        self.scope_stack = []\n        self.scope_metrics = {\n            \"created_scopes\": 0,\n            \"active_scopes\": 0,\n            \"max_nested_depth\": 0,\n            \"scope_lifetimes\": []\n        }\n\n    def begin_scope(self):\n        super().begin_scope()\n        self.scope_stack.append(time.time())\n        self.scope_metrics[\"created_scopes\"] += 1\n        self.scope_metrics[\"active_scopes\"] += 1\n        self.scope_metrics[\"max_nested_depth\"] = max(\n            self.scope_metrics[\"max_nested_depth\"],\n            len(self.scope_stack)\n        )\n\n    def end_scope(self):\n        if self.scope_stack:\n            start_time = self.scope_stack.pop()\n            lifetime = time.time() - start_time\n            self.scope_metrics[\"scope_lifetimes\"].append(lifetime)\n            self.scope_metrics[\"active_scopes\"] -= 1\n\n        super().end_scope()\n\n    def get_scope_metrics(self):\n        return self.scope_metrics.copy()\n\ndef test_scope_metrics_tracking():\n    \"\"\"Test scope usage tracking.\"\"\"\n    container = ScopeTrackingContainer()\n\n    # Create some scopes\n    container.begin_scope()\n    time.sleep(0.01)  # Simulate work\n    container.end_scope()\n\n    container.begin_scope()\n    container.begin_nested_scope()\n    time.sleep(0.005)\n    container.end_scope()\n    time.sleep(0.01)\n    container.end_scope()\n\n    # Check metrics\n    metrics = container.get_scope_metrics()\n    assert metrics[\"created_scopes\"] == 3  # 2 regular + 1 nested\n    assert metrics[\"max_nested_depth\"] == 2\n    assert len(metrics[\"scope_lifetimes\"]) == 3\n    assert all(lifetime &gt; 0 for lifetime in metrics[\"scope_lifetimes\"])\n</code></pre>"},{"location":"testing/test-scopes/#scope-performance-testing","title":"Scope Performance Testing","text":"<pre><code>def test_scope_performance(container):\n    \"\"\"Test scope creation and destruction performance.\"\"\"\n    import time\n\n    # Test scope creation performance\n    creation_times = []\n    for _ in range(100):\n        start = time.time()\n        container.begin_scope()\n        creation_times.append(time.time() - start)\n\n        container.end_scope()\n\n    avg_creation_time = sum(creation_times) / len(creation_times)\n\n    # Should be very fast\n    assert avg_creation_time &lt; 0.001  # Less than 1ms\n\n    # Test nested scope performance\n    nested_times = []\n    for _ in range(50):\n        container.begin_scope()\n\n        start = time.time()\n        for _ in range(5):  # 5 levels of nesting\n            container.begin_nested_scope()\n        nested_creation_time = time.time() - start\n        nested_times.append(nested_creation_time)\n\n        # Clean up nested scopes\n        for _ in range(5):\n            container.end_scope()\n        container.end_scope()\n\n    avg_nested_time = sum(nested_times) / len(nested_times)\n    assert avg_nested_time &lt; 0.005  # Less than 5ms for 5 nested scopes\n</code></pre>"},{"location":"testing/test-scopes/#scope-testing-best-practices","title":"\u2705 Scope Testing Best Practices","text":""},{"location":"testing/test-scopes/#1-use-proper-scope-management","title":"1. Use Proper Scope Management","text":"<pre><code># \u2705 Good: Fixture with automatic cleanup\n@pytest.fixture\ndef scoped_container():\n    container = TestContainer()\n    container.begin_scope()\n\n    try:\n        yield container\n    finally:\n        container.end_scope()\n\ndef test_with_proper_scope_management(scoped_container):\n    # Scope automatically managed\n    context = scoped_container.get(RequestContext)\n    # Test logic\n    pass  # Scope cleaned up automatically\n\n# \u274c Bad: Manual scope management\ndef test_manual_scope_management(container):\n    container.begin_scope()\n    try:\n        # Test logic\n        context = container.get(RequestContext)\n        # ...\n    finally:\n        container.end_scope()  # Easy to forget\n</code></pre>"},{"location":"testing/test-scopes/#2-test-scope-isolation","title":"2. Test Scope Isolation","text":"<pre><code># \u2705 Good: Test scope isolation\ndef test_scope_isolation(scoped_container):\n    # Each test gets fresh scope\n    context1 = scoped_container.get(RequestContext)\n    context1.set_user(User(id=1, name=\"User 1\"))\n\n    # Modify in this test\n    assert context1.user.name == \"User 1\"\n\ndef test_scope_isolation2(scoped_container):\n    # Different test, fresh scope\n    context2 = scoped_container.get(RequestContext)\n\n    # No data from previous test\n    assert context2.user is None\n\n# \u274c Bad: Shared scope between tests\ndef test_shared_scope_problem(container):\n    # No scope management - shared state\n    context = container.get(RequestContext)\n    # Tests interfere with each other\n</code></pre>"},{"location":"testing/test-scopes/#3-test-scope-boundaries","title":"3. Test Scope Boundaries","text":"<pre><code># \u2705 Good: Test scope boundaries\ndef test_scope_boundaries(container):\n    # Test scope start\n    container.begin_scope()\n    context = container.get(RequestContext)\n    context.set_user(User(id=1, name=\"Test\"))\n\n    # Verify in scope\n    assert context.user.name == \"Test\"\n\n    # Test scope end\n    container.end_scope()\n\n    # Verify after scope end\n    container.begin_scope()\n    new_context = container.get(RequestContext)\n    assert new_context.user is None  # Fresh scope\n    container.end_scope()\n\n# \u2705 Test nested scopes\ndef test_nested_scope_behavior(container):\n    container.begin_scope()\n\n    outer = container.get(RequestContext)\n    outer.set_user(User(id=1, name=\"Outer\"))\n\n    container.begin_nested_scope()\n    inner = container.get(RequestContext)\n\n    # Different instances\n    assert inner is not outer\n    assert inner.user is None  # No inheritance by default\n\n    container.end_scope()  # End nested\n    container.end_scope()  # End outer\n</code></pre>"},{"location":"testing/test-scopes/#4-handle-async-scopes-properly","title":"4. Handle Async Scopes Properly","text":"<pre><code># \u2705 Good: Async scope management\n@pytest.fixture\nasync def async_scoped_container():\n    container = TestContainer()\n    container.begin_scope()\n\n    try:\n        yield container\n    finally:\n        container.end_scope()\n\n@pytest.mark.asyncio\nasync def test_async_scopes(async_scoped_container):\n    context = async_scoped_container.get(RequestContext)\n    context.set_user(User(id=1, name=\"Async User\"))\n\n    # Async operations\n    await asyncio.sleep(0.01)\n\n    # Verify scope maintained\n    assert context.user.name == \"Async User\"\n\n# \u2705 Test concurrent scopes\n@pytest.mark.asyncio\nasync def test_concurrent_scopes():\n    async def scoped_operation(container_factory, operation_id):\n        container = container_factory()\n        container.begin_scope()\n\n        try:\n            context = container.get(RequestContext)\n            context.set_user(User(id=operation_id, name=f\"User {operation_id}\"))\n            await asyncio.sleep(0.01)  # Simulate work\n            return context.user.name\n        finally:\n            container.end_scope()\n\n    # Run concurrent operations\n    tasks = [scoped_operation(TestContainer, i) for i in range(5)]\n    results = await asyncio.gather(*tasks)\n\n    # Verify isolation\n    assert len(set(results)) == 5  # All different\n    assert all(f\"User {i}\" in results for i in range(5))\n</code></pre>"},{"location":"testing/test-scopes/#summary","title":"\ud83c\udfaf Summary","text":"<p>Scope testing ensures proper lifecycle management and isolation:</p> <ul> <li>Scope lifecycle - Test creation, usage, and cleanup</li> <li>Scope isolation - Ensure scopes don't interfere</li> <li>Nested scopes - Test hierarchical scope behavior</li> <li>Async scopes - Handle concurrent and async scenarios</li> <li>Scope boundaries - Test transitions between scopes</li> </ul> <p>Key principles: - Use fixtures for automatic scope management - Test scope isolation between tests - Verify proper cleanup and disposal - Handle async and concurrent scenarios - Monitor scope performance and usage</p> <p>Best practices: - Use context managers for scope management - Ensure proper test isolation - Test both success and failure scenarios - Monitor scope metrics and performance - Handle threading and async scope issues - Test scope inheritance and nesting</p> <p>Common patterns: - Scope-aware test fixtures - Scope context managers - Concurrent scope testing - Scope usage tracking - Performance monitoring</p> <p>Ready to explore testing best practices?</p>"},{"location":"testing/testing-best-practices/","title":"Testing Best Practices","text":"<p>Testing best practices provide guidelines and patterns for effective testing with dependency injection.</p>"},{"location":"testing/testing-best-practices/#testing-principles","title":"\ud83c\udfaf Testing Principles","text":""},{"location":"testing/testing-best-practices/#test-behavior-not-implementation","title":"Test Behavior, Not Implementation","text":"<pre><code># \u2705 Good: Test what the service does\ndef test_user_registration_sends_welcome_email(container):\n    \"\"\"Test that user registration sends welcome email.\"\"\"\n    mock_email = MockEmailService()\n    container.bind(IEmailService, mock_email)\n\n    user_service = container.get(IUserService)\n    user = user_service.register_user(\"john@example.com\", \"password\")\n\n    # Verify behavior: email is sent\n    assert mock_email.call_count(\"send_welcome_email\") == 1\n    assert user.email == \"john@example.com\"\n\n# \u274c Bad: Test how the service does it\ndef test_user_registration_calls_internal_methods(container):\n    \"\"\"Test internal implementation details.\"\"\"\n    user_service = container.get(IUserService)\n\n    user_service.register_user(\"john@example.com\", \"password\")\n\n    # Testing implementation: private method calls\n    assert user_service._validate_email_called\n    assert user_service._hash_password_called\n    assert user_service._save_user_called\n</code></pre>"},{"location":"testing/testing-best-practices/#test-public-interfaces","title":"Test Public Interfaces","text":"<pre><code># \u2705 Good: Test public API\ndef test_price_calculation_public_api(container):\n    \"\"\"Test price calculation through public interface.\"\"\"\n    calculator = container.get(IPriceCalculator)\n\n    order = Order(items=[Item(price=10, quantity=2), Item(price=5, quantity=1)])\n    total = calculator.calculate_total(order)\n\n    assert total == 25  # (10*2) + (5*1)\n\n# \u274c Bad: Test private methods\ndef test_price_calculation_private_methods(container):\n    \"\"\"Test private implementation details.\"\"\"\n    calculator = container.get(IPriceCalculator)\n\n    # Don't test private methods\n    tax = calculator._calculate_tax(100)\n    discount = calculator._apply_discount(100, 10)\n\n    assert tax == 8.0\n    assert discount == 90.0\n</code></pre>"},{"location":"testing/testing-best-practices/#test-organization","title":"\ud83d\udd27 Test Organization","text":""},{"location":"testing/testing-best-practices/#test-file-structure","title":"Test File Structure","text":"<pre><code># tests/\n# \u251c\u2500\u2500 unit/\n# \u2502   \u251c\u2500\u2500 test_user_service.py\n# \u2502   \u251c\u2500\u2500 test_order_service.py\n# \u2502   \u2514\u2500\u2500 test_price_calculator.py\n# \u251c\u2500\u2500 integration/\n# \u2502   \u251c\u2500\u2500 test_user_registration_flow.py\n# \u2502   \u251c\u2500\u2500 test_order_processing_flow.py\n# \u2502   \u2514\u2500\u2500 test_payment_flow.py\n# \u251c\u2500\u2500 e2e/\n# \u2502   \u251c\u2500\u2500 test_complete_user_journey.py\n# \u2502   \u2514\u2500\u2500 test_admin_workflow.py\n# \u2514\u2500\u2500 fixtures/\n#     \u251c\u2500\u2500 conftest.py\n#     \u251c\u2500\u2500 test_data.py\n#     \u2514\u2500\u2500 mock_services.py\n</code></pre>"},{"location":"testing/testing-best-practices/#test-naming-conventions","title":"Test Naming Conventions","text":"<pre><code># \u2705 Good: Descriptive test names\ndef test_user_registration_with_valid_email_sends_welcome_email():\n    pass\n\ndef test_order_calculation_applies_tax_correctly():\n    pass\n\ndef test_payment_processing_handles_card_decline_gracefully():\n    pass\n\n# \u274c Bad: Vague test names\ndef test_user():\n    pass\n\ndef test_calculation():\n    pass\n\ndef test_payment():\n    pass\n\n# \u2705 Good: Test method naming patterns\ndef test_[unit_of_work]_[scenario]_[expected_result]():\n    pass\n\n# Examples:\ndef test_user_registration_valid_email_creates_account():\n    pass\n\ndef test_order_total_calculation_includes_tax_and_discount():\n    pass\n\ndef test_payment_gateway_timeout_retries_automatically():\n    pass\n</code></pre>"},{"location":"testing/testing-best-practices/#test-class-organization","title":"Test Class Organization","text":"<pre><code>class TestUserService:\n    \"\"\"Test cases for UserService.\"\"\"\n\n    def setup_method(self):\n        \"\"\"Setup for each test method.\"\"\"\n        self.container = TestContainer()\n        # Setup common test data\n\n    def test_successful_registration(self):\n        \"\"\"Test successful user registration.\"\"\"\n        pass\n\n    def test_registration_with_duplicate_email_fails(self):\n        \"\"\"Test registration fails with duplicate email.\"\"\"\n        pass\n\n    def test_password_reset_sends_email(self):\n        \"\"\"Test password reset sends email.\"\"\"\n        pass\n\nclass TestUserServiceIntegration:\n    \"\"\"Integration tests for UserService.\"\"\"\n\n    def test_registration_creates_user_in_database(self):\n        \"\"\"Test that registration persists user to database.\"\"\"\n        pass\n\n    def test_registration_sends_welcome_email_via_real_service(self):\n        \"\"\"Test email sending with real email service.\"\"\"\n        pass\n</code></pre>"},{"location":"testing/testing-best-practices/#test-setup-patterns","title":"\ud83c\udfa8 Test Setup Patterns","text":""},{"location":"testing/testing-best-practices/#fixture-best-practices","title":"Fixture Best Practices","text":"<pre><code># \u2705 Good: Descriptive fixture names\n@pytest.fixture\ndef user_service_with_mocked_dependencies():\n    \"\"\"User service with mocked email and database.\"\"\"\n    container = TestContainer()\n    container.bind_mock(IEmailService)\n    container.bind_mock(IUserRepository)\n\n    service = container.get(IUserService)\n    return service\n\n@pytest.fixture\ndef integration_container():\n    \"\"\"Container for integration tests.\"\"\"\n    container = TestContainer()\n    container.install(TestDatabaseModule())\n    container.install(BusinessLogicModule())\n    container.bind_mock(IExternalAPI)  # Only mock externals\n\n    return container\n\n# \u274c Bad: Generic fixture names\n@pytest.fixture\ndef container():\n    \"\"\"Too generic, unclear purpose.\"\"\"\n    return TestContainer()\n\n@pytest.fixture\ndef service():\n    \"\"\"Unclear which service.\"\"\"\n    container = TestContainer()\n    return container.get(IService)\n</code></pre>"},{"location":"testing/testing-best-practices/#test-data-management","title":"Test Data Management","text":"<pre><code># \u2705 Good: Factory pattern for test data\nclass TestDataFactory:\n    @staticmethod\n    def create_user(email=None, name=None):\n        return User(\n            id=None,  # Will be set by database\n            email=email or f\"test_{uuid.uuid4().hex[:8]}@example.com\",\n            name=name or \"Test User\",\n            created_at=datetime.now()\n        )\n\n    @staticmethod\n    def create_order(user_id, items=None):\n        if items is None:\n            items = [TestDataFactory.create_order_item()]\n\n        return Order(\n            id=None,\n            user_id=user_id,\n            items=items,\n            total=sum(item.price * item.quantity for item in items),\n            status=\"pending\"\n        )\n\ndef test_order_creation_with_factory(container):\n    \"\"\"Test order creation using test data factory.\"\"\"\n    user = TestDataFactory.create_user()\n    order = TestDataFactory.create_order(user.id)\n\n    order_service = container.get(IOrderService)\n    created_order = order_service.create_order(order)\n\n    assert created_order.user_id == user.id\n    assert created_order.status == \"pending\"\n\n# \u2705 Good: Builder pattern for complex objects\nclass UserBuilder:\n    def __init__(self):\n        self.email = f\"test_{uuid.uuid4().hex[:8]}@example.com\"\n        self.name = \"Test User\"\n        self.is_active = True\n        self.roles = []\n\n    def with_email(self, email):\n        self.email = email\n        return self\n\n    def with_name(self, name):\n        self.name = name\n        return self\n\n    def inactive(self):\n        self.is_active = False\n        return self\n\n    def with_roles(self, *roles):\n        self.roles.extend(roles)\n        return self\n\n    def build(self):\n        return User(\n            id=None,\n            email=self.email,\n            name=self.name,\n            is_active=self.is_active,\n            roles=self.roles,\n            created_at=datetime.now()\n        )\n\ndef test_user_with_builder(container):\n    \"\"\"Test user creation using builder pattern.\"\"\"\n    user = (UserBuilder()\n            .with_email(\"john@example.com\")\n            .with_name(\"John Doe\")\n            .with_roles(\"admin\", \"user\")\n            .build())\n\n    user_service = container.get(IUserService)\n    created_user = user_service.create_user(user)\n\n    assert created_user.email == \"john@example.com\"\n    assert \"admin\" in created_user.roles\n</code></pre>"},{"location":"testing/testing-best-practices/#mock-and-stub-patterns","title":"\ud83e\uddea Mock and Stub Patterns","text":""},{"location":"testing/testing-best-practices/#appropriate-mock-usage","title":"Appropriate Mock Usage","text":"<pre><code># \u2705 Good: Mock external dependencies\ndef test_user_service_with_mocked_email(container):\n    \"\"\"Mock external email service.\"\"\"\n    mock_email = container.bind_mock(IEmailService)\n\n    user_service = container.get(IUserService)\n    user = user_service.register_user(\"john@example.com\", \"password\")\n\n    # Verify external service was called\n    assert mock_email.call_count(\"send_welcome_email\") == 1\n\n# \u2705 Good: Mock slow or unreliable services\ndef test_payment_with_mocked_gateway(container):\n    \"\"\"Mock external payment gateway.\"\"\"\n    mock_payment = container.bind_mock(IPaymentGateway)\n    mock_payment.configure_return(\"charge_card\", \"txn_123\")\n\n    payment_service = container.get(IPaymentService)\n    result = payment_service.process_payment(100, \"card_token\")\n\n    assert result.success is True\n    assert result.transaction_id == \"txn_123\"\n\n# \u274c Bad: Mock business logic\ndef test_business_logic_with_mocked_calculator(container):\n    \"\"\"Don't mock business logic you want to test.\"\"\"\n    mock_calculator = container.bind_mock(IPriceCalculator)\n    mock_calculator.configure_return(\"calculate_total\", 100)\n\n    # This test is meaningless - just testing the mock\n    order_service = container.get(IOrderService)\n    total = order_service.calculate_order_total(order)\n\n    assert total == 100  # Just verifying mock behavior\n</code></pre>"},{"location":"testing/testing-best-practices/#stub-vs-mock-distinction","title":"Stub vs Mock Distinction","text":"<pre><code># \u2705 Use stubs for data provision\ndef test_with_stub_data(container):\n    \"\"\"Use stub for predictable test data.\"\"\"\n    stub_repo = StubUserRepository()\n    stub_repo.save_user(TestDataFactory.create_user(\"existing@example.com\"))\n\n    container.bind(IUserRepository, stub_repo)\n\n    user_service = container.get(IUserService)\n\n    # Test with predictable existing data\n    with pytest.raises(EmailExistsError):\n        user_service.register_user(\"existing@example.com\", \"password\")\n\n# \u2705 Use mocks for interaction verification\ndef test_with_mock_verification(container):\n    \"\"\"Use mock to verify interactions.\"\"\"\n    mock_email = MockEmailService()\n    container.bind(IEmailService, mock_email)\n\n    user_service = container.get(IUserService)\n    user_service.register_user(\"john@example.com\", \"password\")\n\n    # Verify the interaction occurred\n    assert mock_email.call_count(\"send_welcome_email\") == 1\n    assert mock_email.was_called_with(\"send_welcome_email\", \"john@example.com\")\n</code></pre>"},{"location":"testing/testing-best-practices/#common-testing-mistakes","title":"\ud83d\udea8 Common Testing Mistakes","text":""},{"location":"testing/testing-best-practices/#1-testing-implementation-details","title":"1. Testing Implementation Details","text":"<pre><code># \u274c Bad: Testing private methods\ndef test_private_method(container):\n    service = container.get(IService)\n    result = service._private_method()  # Don't test private methods\n    assert result == expected\n\n# \u274c Bad: Testing internal state\ndef test_internal_state(container):\n    service = container.get(IService)\n    service.do_something()\n\n    # Don't test internal state\n    assert service._internal_counter == 1\n    assert len(service._internal_list) == 5\n\n# \u2705 Good: Test observable behavior\ndef test_observable_behavior(container):\n    service = container.get(IService)\n    result = service.do_something()\n\n    # Test what the service does, not how\n    assert result.success is True\n    assert result.data is not None\n</code></pre>"},{"location":"testing/testing-best-practices/#2-over-mocking","title":"2. Over-Mocking","text":"<pre><code># \u274c Bad: Mocking everything\ndef test_with_too_many_mocks(container):\n    container.bind_mock(IUserService)\n    container.bind_mock(IEmailService)\n    container.bind_mock(IValidator)\n    container.bind_mock(IPasswordHasher)\n    container.bind_mock(ILogger)\n\n    # Test becomes meaningless\n    service = container.get(IService)\n    result = service.do_work()\n    assert result is not None\n\n# \u2705 Good: Mock only what's necessary\ndef test_with_appropriate_mocking(container):\n    # Mock external dependencies\n    container.bind_mock(IEmailService)      # External API\n    container.bind_mock(IPaymentGateway)    # External service\n\n    # Use real implementations for business logic\n    container.bind(IUserService, UserService())\n    container.bind(IValidator, EmailValidator())\n\n    # Test focuses on real business logic\n    service = container.get(IService)\n    result = service.do_work()\n    assert result.success is True\n</code></pre>"},{"location":"testing/testing-best-practices/#3-no-test-isolation","title":"3. No Test Isolation","text":"<pre><code># \u274c Bad: Shared state between tests\nclass TestWithSharedState:\n    container = TestContainer()  # Shared instance!\n\n    def test1(self):\n        user = self.container.get(IUserService).create_user(\"test@example.com\")\n        assert user.email == \"test@example.com\"\n\n    def test2(self):\n        # Sees user from test1!\n        users = self.container.get(IUserService).get_all_users()\n        assert len(users) == 1  # Unexpected!\n\n# \u2705 Good: Isolated tests\nclass TestWithIsolation:\n    def setup_method(self):\n        self.container = TestContainer()  # Fresh instance per test\n\n    def test1(self):\n        user = self.container.get(IUserService).create_user(\"test@example.com\")\n        assert user.email == \"test@example.com\"\n\n    def test2(self):\n        # Fresh container, no data from test1\n        users = self.container.get(IUserService).get_all_users()\n        assert len(users) == 0  # Expected\n</code></pre>"},{"location":"testing/testing-best-practices/#4-ignoring-test-performance","title":"4. Ignoring Test Performance","text":"<pre><code># \u274c Bad: Slow tests\ndef test_slow_operation(container):\n    # No timeout or performance consideration\n    service = container.get(IService)\n    result = service.slow_operation()  # Takes 30 seconds\n    assert result is not None\n\n# \u2705 Good: Performance-aware tests\ndef test_operation_within_timeout(container):\n    service = container.get(IService)\n\n    import time\n    start = time.time()\n    result = service.do_operation()\n    duration = time.time() - start\n\n    assert result is not None\n    assert duration &lt; 5.0  # Should complete within 5 seconds\n</code></pre>"},{"location":"testing/testing-best-practices/#5-inconsistent-test-data","title":"5. Inconsistent Test Data","text":"<pre><code># \u274c Bad: Hardcoded test data\ndef test_with_hardcoded_data(container):\n    user_service = container.get(IUserService)\n\n    # Hardcoded data causes conflicts\n    user = user_service.create_user(\"test@example.com\", \"password\")\n    assert user.email == \"test@example.com\"\n\ndef test_another_with_hardcoded_data(container):\n    user_service = container.get(IUserService)\n\n    # Same hardcoded data causes conflicts\n    user = user_service.create_user(\"test@example.com\", \"password\")\n    # This test might fail if previous test ran\n\n# \u2705 Good: Unique test data\ndef test_with_unique_data(container):\n    user_service = container.get(IUserService)\n\n    # Unique data per test\n    email = f\"test_{uuid.uuid4().hex[:8]}@example.com\"\n    user = user_service.create_user(email, \"password\")\n    assert user.email == email\n</code></pre>"},{"location":"testing/testing-best-practices/#test-quality-metrics","title":"\ud83d\udcca Test Quality Metrics","text":""},{"location":"testing/testing-best-practices/#test-coverage-guidelines","title":"Test Coverage Guidelines","text":"<pre><code># pytest configuration for coverage\n# pyproject.toml\n[tool.coverage.run]\nsource = [\"injectq\"]\nomit = [\n    \"*/tests/*\",\n    \"*/migrations/*\",\n    \"*/venv/*\"\n]\n\n[tool.coverage.report]\nexclude_lines = [\n    \"pragma: no cover\",\n    \"def __repr__\",\n    \"raise AssertionError\",\n    \"raise NotImplementedError\"\n]\n</code></pre>"},{"location":"testing/testing-best-practices/#coverage-targets","title":"Coverage Targets","text":"<ul> <li>Unit Tests: 80%+ coverage of business logic</li> <li>Integration Tests: Cover critical user journeys</li> <li>Branches: 75%+ branch coverage</li> <li>Lines: 85%+ line coverage</li> </ul>"},{"location":"testing/testing-best-practices/#test-performance-benchmarks","title":"Test Performance Benchmarks","text":"<pre><code># conftest.py\ndef pytest_configure(config):\n    config.addinivalue_line(\n        \"markers\", \"slow: marks tests as slow (deselect with '-m \\\"not slow\\\"')\"\n    )\n    config.addinivalue_line(\n        \"markers\", \"integration: marks tests as integration tests\"\n    )\n\n# Test with performance markers\n@pytest.mark.slow\ndef test_slow_integration():\n    \"\"\"Mark slow tests.\"\"\"\n    pass\n\n@pytest.mark.integration\ndef test_integration_test():\n    \"\"\"Mark integration tests.\"\"\"\n    pass\n</code></pre>"},{"location":"testing/testing-best-practices/#testing-best-practices-checklist","title":"\u2705 Testing Best Practices Checklist","text":""},{"location":"testing/testing-best-practices/#test-structure","title":"Test Structure","text":"<ul> <li> Tests are organized by type (unit, integration, e2e)</li> <li> Test names are descriptive and follow naming conventions</li> <li> Tests use appropriate fixtures for setup</li> <li> Test data is unique and isolated</li> <li> Tests clean up after themselves</li> </ul>"},{"location":"testing/testing-best-practices/#test-quality","title":"Test Quality","text":"<ul> <li> Tests focus on behavior, not implementation</li> <li> Tests use appropriate mocking strategies</li> <li> Tests cover both success and failure scenarios</li> <li> Tests are fast and reliable</li> <li> Tests provide clear failure messages</li> </ul>"},{"location":"testing/testing-best-practices/#test-maintenance","title":"Test Maintenance","text":"<ul> <li> Tests are easy to understand and modify</li> <li> Tests use factories/builders for complex data</li> <li> Tests avoid shared state</li> <li> Tests have appropriate performance expectations</li> <li> Tests are regularly reviewed and updated</li> </ul>"},{"location":"testing/testing-best-practices/#cicd-integration","title":"CI/CD Integration","text":"<ul> <li> Tests run in CI pipeline</li> <li> Test coverage is tracked and reported</li> <li> Performance regressions are caught</li> <li> Tests run in parallel where possible</li> <li> Test results are easily accessible</li> </ul>"},{"location":"testing/testing-best-practices/#summary","title":"\ud83c\udfaf Summary","text":"<p>Effective testing with dependency injection requires:</p> <ul> <li>Clear test organization - Separate unit, integration, and e2e tests</li> <li>Appropriate mocking - Mock externals, test real business logic</li> <li>Proper isolation - Each test gets fresh, unique data</li> <li>Behavior focus - Test what services do, not implementation details</li> <li>Performance awareness - Keep tests fast and monitor performance</li> </ul> <p>Key principles: - Test public interfaces and observable behavior - Use fixtures for consistent test setup - Mock external dependencies, use real business logic - Ensure test isolation and cleanup - Write descriptive test names and clear assertions - Monitor test coverage and performance</p> <p>Common patterns: - Factory pattern for test data creation - Builder pattern for complex objects - Fixture-based test setup - Appropriate mock vs stub usage - Performance benchmarking in tests</p> <p>Quality checklist: - Tests are fast, isolated, and reliable - Test names are descriptive - Coverage meets targets - Tests focus on behavior over implementation - CI/CD integration is solid</p> <p>This completes the testing section! Ready to explore advanced features?</p>"},{"location":"testing/testing-utilities/","title":"Testing Utilities","text":"<p>Testing utilities provide the core tools and infrastructure for testing dependency-injected applications with InjectQ.</p>"},{"location":"testing/testing-utilities/#core-testing-classes","title":"\ud83c\udfaf Core Testing Classes","text":""},{"location":"testing/testing-utilities/#testcontainer","title":"TestContainer","text":"<p><code>TestContainer</code> extends the regular <code>InjectQ</code> container with testing-specific features.</p> <pre><code>from injectq.testing import TestContainer\n\ndef test_with_test_container():\n    \"\"\"TestContainer provides testing-focused features.\"\"\"\n    container = TestContainer()\n\n    # Bind services normally\n    container.bind(IUserService, UserService())\n\n    # Or bind mocks easily\n    container.bind_mock(IEmailService)\n\n    # Get services\n    user_service = container.get(IUserService)\n    email_service = container.get(IEmailService)\n\n    # Email service is automatically mocked\n    assert isinstance(email_service, Mock)\n</code></pre>"},{"location":"testing/testing-utilities/#testcontainer-features","title":"TestContainer Features","text":"<pre><code>container = TestContainer()\n\n# 1. Automatic mock binding\ncontainer.bind_mock(IService)  # Creates and binds Mock[IService]\n\n# 2. Easy mock access\nmock_service = container.get_mock(IService)\n\n# 3. Override context manager\nwith container.override(IService, MockService()):\n    # Temporary override\n    pass\n\n# 4. Reset between tests\ncontainer.reset()  # Clear all bindings and mocks\n\n# 5. Verification helpers\nassert container.get_mock(IService).call_count(\"method\") == 1\n</code></pre>"},{"location":"testing/testing-utilities/#mock-base-class","title":"Mock Base Class","text":"<p>The <code>Mock</code> class provides the foundation for creating test doubles.</p> <pre><code>from injectq.testing import Mock\n\nclass MockUserService(Mock[IUserService]):\n    def __init__(self):\n        super().__init__()\n        self.users = {}\n        self.next_id = 1\n\n    def get_user(self, user_id: int) -&gt; User:\n        # Record the call\n        self.record_call(\"get_user\", user_id)\n\n        # Return mock data\n        return self.users.get(user_id)\n\n    def create_user(self, email: str, password: str) -&gt; User:\n        # Record the call\n        self.record_call(\"create_user\", email, password)\n\n        # Create mock user\n        user = User(\n            id=self.next_id,\n            email=email,\n            password_hash=f\"hash_{password}\",\n            is_active=True\n        )\n        self.users[self.next_id] = user\n        self.next_id += 1\n        return user\n</code></pre>"},{"location":"testing/testing-utilities/#mock-features","title":"Mock Features","text":"<pre><code>mock = MockUserService()\n\n# 1. Call recording\nmock.get_user(123)\nassert mock.call_count(\"get_user\") == 1\n\n# 2. Call arguments verification\ncalls = mock.get_calls(\"get_user\")\nassert calls[0][\"args\"] == (123,)\n\n# 3. Return value configuration\nmock.configure_return(\"get_user\", mock_user)\n\n# 4. Exception simulation\nmock.configure_exception(\"get_user\", ValueError(\"User not found\"))\n\n# 5. Call verification\nassert mock.was_called_with(\"get_user\", 123)\n</code></pre>"},{"location":"testing/testing-utilities/#setup-and-configuration","title":"\ud83d\udd27 Setup and Configuration","text":""},{"location":"testing/testing-utilities/#basic-test-setup","title":"Basic Test Setup","text":"<pre><code>import pytest\nfrom injectq.testing import TestContainer\n\n@pytest.fixture\ndef container():\n    \"\"\"Create test container with common test setup.\"\"\"\n    container = TestContainer()\n\n    # Bind real services that are fast/cheap\n    container.bind(IValidator, EmailValidator())\n    container.bind(IPasswordHasher, BcryptHasher())\n\n    # Bind mocks for external dependencies\n    container.bind_mock(IEmailService)\n    container.bind_mock(IUserRepository)\n\n    return container\n\n@pytest.fixture\ndef mock_email_service(container):\n    \"\"\"Get mock email service for verification.\"\"\"\n    return container.get_mock(IEmailService)\n\n@pytest.fixture\ndef mock_user_repo(container):\n    \"\"\"Get mock user repository for setup.\"\"\"\n    return container.get_mock(IUserRepository)\n</code></pre>"},{"location":"testing/testing-utilities/#module-based-test-setup","title":"Module-Based Test Setup","text":"<pre><code>from injectq import Module\n\nclass TestInfrastructureModule(Module):\n    def configure(self, binder):\n        # Real infrastructure for tests\n        binder.bind(IDatabase, TestDatabase())\n        binder.bind(ICache, TestCache())\n\nclass TestServicesModule(Module):\n    def configure(self, binder):\n        # Real services\n        binder.bind(IUserService, UserService())\n        binder.bind(IAuthService, AuthService())\n\n        # Mock external services\n        binder.bind(IEmailService, MockEmailService())\n        binder.bind(IPaymentService, MockPaymentService())\n\n@pytest.fixture\ndef test_container():\n    \"\"\"Create container with test modules.\"\"\"\n    container = TestContainer()\n    container.install(TestInfrastructureModule())\n    container.install(TestServicesModule())\n    return container\n</code></pre>"},{"location":"testing/testing-utilities/#test-database-setup","title":"Test Database Setup","text":"<pre><code>class TestDatabase(IDatabase):\n    def __init__(self):\n        self.users = {}\n        self.orders = {}\n        self._next_user_id = 1\n        self._next_order_id = 1\n\n    def save_user(self, user: User) -&gt; User:\n        user.id = self._next_user_id\n        self.users[self._next_user_id] = user\n        self._next_user_id += 1\n        return user\n\n    def get_user(self, user_id: int) -&gt; Optional[User]:\n        return self.users.get(user_id)\n\n    def save_order(self, order: Order) -&gt; Order:\n        order.id = self._next_order_id\n        self.orders[self._next_order_id] = order\n        self._next_order_id += 1\n        return order\n\n    def get_order(self, order_id: int) -&gt; Optional[Order]:\n        return self.orders.get(order_id)\n\n    def clear(self):\n        \"\"\"Clear all test data.\"\"\"\n        self.users.clear()\n        self.orders.clear()\n        self._next_user_id = 1\n        self._next_order_id = 1\n\n@pytest.fixture\ndef test_db():\n    \"\"\"Create test database.\"\"\"\n    return TestDatabase()\n\n@pytest.fixture\ndef clean_db(test_db):\n    \"\"\"Ensure clean database for each test.\"\"\"\n    test_db.clear()\n    return test_db\n</code></pre>"},{"location":"testing/testing-utilities/#mocking-patterns","title":"\ud83c\udfa8 Mocking Patterns","text":""},{"location":"testing/testing-utilities/#simple-mock-implementation","title":"Simple Mock Implementation","text":"<pre><code>class MockEmailService(Mock[IEmailService]):\n    def __init__(self):\n        super().__init__()\n        self.sent_emails = []\n\n    def send_welcome_email(self, email: str) -&gt; None:\n        self.record_call(\"send_welcome_email\", email)\n        self.sent_emails.append({\n            \"type\": \"welcome\",\n            \"email\": email,\n            \"timestamp\": time.time()\n        })\n\n    def send_password_reset(self, email: str, token: str) -&gt; None:\n        self.record_call(\"send_password_reset\", email, token)\n        self.sent_emails.append({\n            \"type\": \"password_reset\",\n            \"email\": email,\n            \"token\": token,\n            \"timestamp\": time.time()\n        })\n\ndef test_user_registration_sends_welcome_email(container):\n    # Setup\n    mock_email = MockEmailService()\n    container.bind(IEmailService, mock_email)\n\n    # Act\n    user_service = container.get(IUserService)\n    user = user_service.register_user(\"john@example.com\", \"password\")\n\n    # Assert\n    assert mock_email.call_count(\"send_welcome_email\") == 1\n    assert len(mock_email.sent_emails) == 1\n    assert mock_email.sent_emails[0][\"email\"] == \"john@example.com\"\n</code></pre>"},{"location":"testing/testing-utilities/#configurable-mock","title":"Configurable Mock","text":"<pre><code>class ConfigurableMockEmailService(Mock[IEmailService]):\n    def __init__(self):\n        super().__init__()\n        self.should_fail = False\n        self.fail_with = None\n\n    def send_welcome_email(self, email: str) -&gt; None:\n        if self.should_fail:\n            raise self.fail_with or Exception(\"Mock email failure\")\n\n        self.record_call(\"send_welcome_email\", email)\n\n    def configure_failure(self, exception: Exception = None):\n        \"\"\"Configure mock to fail on next call.\"\"\"\n        self.should_fail = True\n        self.fail_with = exception\n\n    def reset_failure(self):\n        \"\"\"Reset failure configuration.\"\"\"\n        self.should_fail = False\n        self.fail_with = None\n\ndef test_email_failure_handling(container):\n    # Setup\n    mock_email = ConfigurableMockEmailService()\n    mock_email.configure_failure(ValueError(\"SMTP error\"))\n    container.bind(IEmailService, mock_email)\n\n    # Act &amp; Assert\n    user_service = container.get(IUserService)\n\n    with pytest.raises(ValueError, match=\"SMTP error\"):\n        user_service.register_user(\"john@example.com\", \"password\")\n</code></pre>"},{"location":"testing/testing-utilities/#spy-pattern","title":"Spy Pattern","text":"<pre><code>class SpyUserRepository(Mock[IUserRepository]):\n    def __init__(self, real_repo: IUserRepository):\n        super().__init__()\n        self.real_repo = real_repo\n        self.created_users = []\n\n    def save_user(self, user: User) -&gt; User:\n        # Spy on the call\n        self.record_call(\"save_user\", user)\n\n        # Delegate to real implementation\n        saved_user = self.real_repo.save_user(user)\n        self.created_users.append(saved_user)\n\n        return saved_user\n\n    def get_user(self, user_id: int) -&gt; Optional[User]:\n        self.record_call(\"get_user\", user_id)\n        return self.real_repo.get_user(user_id)\n\ndef test_user_creation_with_spy(container, test_db):\n    # Setup\n    real_repo = UserRepository(test_db)\n    spy_repo = SpyUserRepository(real_repo)\n    container.bind(IUserRepository, spy_repo)\n\n    # Act\n    user_service = container.get(IUserService)\n    user = user_service.create_user(\"john@example.com\", \"password\")\n\n    # Assert\n    assert user.email == \"john@example.com\"\n    assert spy_repo.call_count(\"save_user\") == 1\n    assert len(spy_repo.created_users) == 1\n</code></pre>"},{"location":"testing/testing-utilities/#override-patterns","title":"\ud83d\udd04 Override Patterns","text":""},{"location":"testing/testing-utilities/#temporary-override","title":"Temporary Override","text":"<pre><code>def test_with_temporary_override(container):\n    \"\"\"Test with temporary service override.\"\"\"\n    # Setup original service\n    container.bind(IEmailService, RealEmailService())\n\n    # Verify original\n    service = container.get(IEmailService)\n    assert isinstance(service, RealEmailService)\n\n    # Temporary override\n    with container.override(IEmailService, MockEmailService()) as mock:\n        service = container.get(IEmailService)\n        assert isinstance(service, MockEmailService)\n\n        # Use the mock\n        user_service = container.get(IUserService)\n        user_service.send_notification(\"test@example.com\")\n\n        # Verify mock was called\n        assert mock.call_count(\"send_notification\") == 1\n\n    # Override ends, back to original\n    service = container.get(IEmailService)\n    assert isinstance(service, RealEmailService)\n</code></pre>"},{"location":"testing/testing-utilities/#nested-overrides","title":"Nested Overrides","text":"<pre><code>def test_nested_overrides(container):\n    \"\"\"Test multiple levels of overrides.\"\"\"\n    container.bind(IEmailService, RealEmailService())\n    container.bind(IUserService, RealUserService())\n\n    with container.override(IEmailService, MockEmailService()) as email_mock:\n        # First level override\n        assert isinstance(container.get(IEmailService), MockEmailService)\n\n        with container.override(IUserService, MockUserService()) as user_mock:\n            # Second level override\n            assert isinstance(container.get(IEmailService), MockEmailService)\n            assert isinstance(container.get(IUserService), MockUserService)\n\n            # Use both mocks\n            notification_service = container.get(INotificationService)\n            notification_service.send_user_notification(123)\n\n            # Verify both mocks were called\n            assert email_mock.call_count(\"send_email\") == 1\n            assert user_mock.call_count(\"get_user\") == 1\n\n        # Back to first level\n        assert isinstance(container.get(IEmailService), MockEmailService)\n        assert isinstance(container.get(IUserService), RealUserService)\n\n    # Back to original\n    assert isinstance(container.get(IEmailService), RealEmailService)\n    assert isinstance(container.get(IUserService), RealUserService)\n</code></pre>"},{"location":"testing/testing-utilities/#conditional-override","title":"Conditional Override","text":"<pre><code>def test_conditional_override(container):\n    \"\"\"Override service based on test conditions.\"\"\"\n    container.bind(IEmailService, RealEmailService())\n\n    # Override only for certain conditions\n    use_mock = os.getenv(\"USE_MOCK_EMAIL\", \"false\").lower() == \"true\"\n\n    if use_mock:\n        container.bind(IEmailService, MockEmailService())\n\n    # Test runs with either real or mock service\n    email_service = container.get(IEmailService)\n\n    if use_mock:\n        assert isinstance(email_service, MockEmailService)\n    else:\n        assert isinstance(email_service, RealEmailService)\n</code></pre>"},{"location":"testing/testing-utilities/#test-verification","title":"\ud83e\uddea Test Verification","text":""},{"location":"testing/testing-utilities/#call-verification","title":"Call Verification","text":"<pre><code>def test_call_verification(container):\n    \"\"\"Verify method calls on mock services.\"\"\"\n    mock_email = MockEmailService()\n    container.bind(IEmailService, mock_email)\n\n    user_service = container.get(IUserService)\n\n    # Perform action\n    user_service.register_user(\"john@example.com\", \"password\")\n\n    # Verify calls\n    assert mock_email.call_count(\"send_welcome_email\") == 1\n\n    # Verify call arguments\n    calls = mock_email.get_calls(\"send_welcome_email\")\n    assert calls[0][\"args\"] == (\"john@example.com\",)\n\n    # Verify call was made\n    assert mock_email.was_called_with(\"send_welcome_email\", \"john@example.com\")\n</code></pre>"},{"location":"testing/testing-utilities/#interaction-verification","title":"Interaction Verification","text":"<pre><code>def test_service_interactions(container):\n    \"\"\"Verify interactions between services.\"\"\"\n    mock_repo = MockUserRepository()\n    mock_email = MockEmailService()\n\n    container.bind(IUserRepository, mock_repo)\n    container.bind(IEmailService, mock_email)\n\n    user_service = container.get(IUserService)\n\n    # Perform complex operation\n    user = user_service.register_user(\"john@example.com\", \"password\")\n\n    # Verify repository interaction\n    assert mock_repo.call_count(\"save_user\") == 1\n    saved_user_calls = mock_repo.get_calls(\"save_user\")\n    assert saved_user_calls[0][\"args\"][0].email == \"john@example.com\"\n\n    # Verify email interaction\n    assert mock_email.call_count(\"send_welcome_email\") == 1\n    assert mock_email.was_called_with(\"send_welcome_email\", \"john@example.com\")\n\n    # Verify user creation\n    assert user.email == \"john@example.com\"\n    assert user.is_active is True\n</code></pre>"},{"location":"testing/testing-utilities/#state-verification","title":"State Verification","text":"<pre><code>def test_state_verification(container):\n    \"\"\"Verify service state changes.\"\"\"\n    mock_repo = MockUserRepository()\n    container.bind(IUserRepository, mock_repo)\n\n    user_service = container.get(IUserService)\n\n    # Initial state\n    assert len(mock_repo.users) == 0\n\n    # Perform operations\n    user1 = user_service.create_user(\"john@example.com\", \"pass1\")\n    user2 = user_service.create_user(\"jane@example.com\", \"pass2\")\n\n    # Verify final state\n    assert len(mock_repo.users) == 2\n    assert mock_repo.users[1].email == \"john@example.com\"\n    assert mock_repo.users[2].email == \"jane@example.com\"\n\n    # Verify user properties\n    assert user1.id == 1\n    assert user2.id == 2\n    assert user1.is_active is True\n    assert user2.is_active is True\n</code></pre>"},{"location":"testing/testing-utilities/#error-testing","title":"\ud83d\udea8 Error Testing","text":""},{"location":"testing/testing-utilities/#exception-testing","title":"Exception Testing","text":"<pre><code>def test_exception_handling(container):\n    \"\"\"Test how services handle exceptions.\"\"\"\n    mock_repo = MockUserRepository()\n    mock_repo.configure_exception(\"save_user\", DatabaseError(\"Connection failed\"))\n    container.bind(IUserRepository, mock_repo)\n\n    user_service = container.get(IUserService)\n\n    # Test exception handling\n    with pytest.raises(DatabaseError, match=\"Connection failed\"):\n        user_service.create_user(\"john@example.com\", \"password\")\n\n    # Verify call was attempted\n    assert mock_repo.call_count(\"save_user\") == 1\n</code></pre>"},{"location":"testing/testing-utilities/#timeout-testing","title":"Timeout Testing","text":"<pre><code>class SlowMockEmailService(Mock[IEmailService]):\n    def __init__(self, delay: float = 0.1):\n        super().__init__()\n        self.delay = delay\n\n    async def send_welcome_email(self, email: str) -&gt; None:\n        self.record_call(\"send_welcome_email\", email)\n        await asyncio.sleep(self.delay)  # Simulate slow operation\n\n@pytest.mark.asyncio\nasync def test_timeout_handling(container):\n    \"\"\"Test timeout handling with slow services.\"\"\"\n    slow_email = SlowMockEmailService(delay=2.0)  # 2 second delay\n    container.bind(IEmailService, slow_email)\n\n    user_service = container.get(IUserService)\n\n    # Test with timeout\n    with pytest.raises(asyncio.TimeoutError):\n        await asyncio.wait_for(\n            user_service.register_user_async(\"john@example.com\", \"password\"),\n            timeout=1.0  # 1 second timeout\n        )\n</code></pre>"},{"location":"testing/testing-utilities/#test-metrics-and-reporting","title":"\ud83d\udcca Test Metrics and Reporting","text":""},{"location":"testing/testing-utilities/#test-coverage","title":"Test Coverage","text":"<pre><code># pytest configuration for coverage\n# pytest.ini or pyproject.toml\n[tool:pytest]\naddopts =\n    --cov=injectq\n    --cov-report=html\n    --cov-report=term-missing\n    --cov-fail-under=80\n\n# Run coverage\n# pytest --cov=injectq --cov-report=html\n</code></pre>"},{"location":"testing/testing-utilities/#mock-usage-metrics","title":"Mock Usage Metrics","text":"<pre><code>class MetricsMock(Mock[IService]):\n    def __init__(self):\n        super().__init__()\n        self.metrics = {\n            \"calls\": 0,\n            \"errors\": 0,\n            \"avg_response_time\": 0\n        }\n\n    def record_call(self, method: str, *args, **kwargs):\n        super().record_call(method, *args, **kwargs)\n        self.metrics[\"calls\"] += 1\n\n    def get_metrics(self):\n        return self.metrics.copy()\n\ndef test_with_metrics(container):\n    \"\"\"Test with mock metrics collection.\"\"\"\n    metrics_mock = MetricsMock()\n    container.bind(IService, metrics_mock)\n\n    # Use service\n    service = container.get(IService)\n    service.do_work()\n    service.do_work()\n\n    # Check metrics\n    metrics = metrics_mock.get_metrics()\n    assert metrics[\"calls\"] == 2\n</code></pre>"},{"location":"testing/testing-utilities/#summary","title":"\ud83c\udfaf Summary","text":"<p>Testing utilities provide:</p> <ul> <li>TestContainer - Testing-focused container with mock support</li> <li>Mock base class - Foundation for creating test doubles</li> <li>Override patterns - Temporary service replacement</li> <li>Call verification - Ensure correct service interactions</li> <li>State verification - Check service state changes</li> <li>Error testing - Verify exception handling</li> </ul> <p>Key features: - Automatic mock creation and binding - Call recording and verification - Temporary service overrides - Configurable mock behavior - Integration with pytest fixtures - Comprehensive verification methods</p> <p>Best practices: - Use TestContainer for testing setup - Create specific mock implementations - Verify important interactions - Test error conditions - Keep tests fast and isolated - Use appropriate mock patterns (mocks, stubs, spies, fakes)</p> <p>Ready to explore mocking strategies?</p>"}]}